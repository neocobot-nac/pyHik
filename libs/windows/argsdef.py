import os
import platform

from ctypes import c_void_p, c_uint, c_int, c_char_p, cast, c_bool, c_char, c_ushort, c_long, c_ubyte, c_double, c_uint64
from ctypes import byref, pointer, POINTER, WINFUNCTYPE, Structure, Union
from ctypes.wintypes import DWORD, LPDWORD

sysstr = platform.system()
sysbit = platform.architecture()[0]

####################################################
### Data types define                            ###
####################################################
BOOL = c_bool
INT = c_int
DOUBLE = c_double
LONG = c_long
BYTE = c_ubyte
WORD = c_ushort
CHAR = c_char
UINT64 = c_uint64
HWND = c_uint
CHARP = c_char_p
VOIDP = c_void_p


fRealDataCallBack_V30 = WINFUNCTYPE(None, LONG, DWORD, BYTE, DWORD, VOIDP)

####################################################
### Global variables                             ###
####################################################
MAX_NAMELEN                         = 16    # DVR本地登陆名
MAX_RIGHT                           = 32    # 设备支持的权限（1-12表示本地权限，13-32表示远程权限）
NAME_LEN                            = 32    # 用户名长度
MIN_PASSWD_LEN                      = 8     # 最小密码长度
PASSWD_LEN                          = 16    # 密码长度
STREAM_PASSWD_LEN                   = 12    # 码流加密密钥最大长度
MAX_PASSWD_LEN_EX                   = 64    # 密码长度64位
GUID_LEN                            = 16    # GUID长度
DEV_TYPE_NAME_LEN                   = 24    # 设备类型名称长度
SERIALNO_LEN                        = 48    # 序列号长度
MACADDR_LEN                         = 6     # mac地址长度
MAC_ADDRESS_NUM                     = 48    # Mac地址长度
MAX_SENCE_NUM                       = 16    # 场景数
RULE_REGION_MAX                     = 128   # 最大区域
MAX_ETHERNET                        = 2     # 设备可配以太网络
MAX_NETWORK_CARD                    = 4     # 设备可配最大网卡数目
MAX_NETWORK_CARD_EX                 = 12    # 设备可配最大网卡数目扩展
PATHNAME_LEN                        = 128   # 路径长度
MAX_PRESET_V13                      = 16    # 预置点
MAX_TEST_COMMAND_NUM                = 32    # 产线测试保留字段长度
MAX_NUMBER_LEN                      = 32    # 号码最大长度
MAX_NAME_LEN                        = 128   # 设备名称最大长度
MAX_INDEX_LED                       = 8     # LED索引最大值 2013-11-19
MAX_CUSTOM_DIR                      = 64    # 自定义目录最大长度
URL_LEN_V40                         = 256   # 最大URL长度
CLOUD_NAME_LEN                      = 48    # 云存储服务器用户名长度
CLOUD_PASSWD_LEN                    = 48    # 云存储服务器密码长度
MAX_SENSORNAME_LEN                  = 64    # 传感器名称长度
MAX_SENSORCHAN_LEN                  = 32    # 传感器通道长度
MAX_DESCRIPTION_LEN                 = 32    # 传感器描述长度
MAX_DEVNAME_LEN_EX                  = 64    # 设备名称长度扩展
NET_SDK_MAX_FILE_PATH               = 256   # 文件路径长度
MAX_TMEVOICE_LEN                    = 64    # TME语音播报内容长度
ISO_8601_LEN                        = 32    # ISO_8601时间长度
MODULE_INFO_LEN                     = 32    # 模块信息长度
VERSION_INFO_LEN                    = 32    # 版本信息长度

MAX_NUM_INPUT_BOARD                 = 512   # 输入板最大个数
MAX_SHIPSDETE_REGION_NUM            = 8     # 船只检测区域列表最大数目

MAX_RES_NUM_ONE_VS_INPUT_CHAN       = 8     # 一个虚拟屏输入通道支持的分辨率的最大数量
MAX_VS_INPUT_CHAN_NUM               = 16    # 虚拟屏输入通道最大数量

NET_SDK_MAX_FDID_LEN                = 256   # 人脸库ID最大长度
NET_SDK_MAX_PICID_LEN               = 256   # 人脸ID最大长度
NET_SDK_FDPIC_CUSTOM_INFO_LEN       = 96    # 人脸库图片自定义信息长度
NET_DVR_MAX_FACE_ANALYSIS_NUM       = 32    # 最大支持单张图片识别出的人脸区域个数
NET_DVR_MAX_FACE_SEARCH_NUM         = 5     # 最大支持搜索人脸区域个数
NET_SDK_SECRETKEY_LEN               = 128   # 配置文件密钥长度
NET_SDK_CUSTOM_LEN                  = 512   # 自定义信息最大长度
NET_SDK_CHECK_CODE_LEN              = 128   # 校验码长度
RELATIVE_CHANNEL_LEN                = 2     # 报警关联的通道号的数量
NET_SDK_MAX_CALLEDTARGET_NAME       = 32    # 呗呼叫目标的用户名
#小间距LED控制器
MAX_LEN_TEXT_CONTENT                = 128   # 字符内容长度
MAX_NUM_INPUT_SOURCE_TEXT           = 32    # 信号源可叠加的文本数量
MAX_NUM_OUTPUT_CHANNEL              = 512   # LED区域包含的输出口个数

#子窗口解码OSD
MAX_LEN_OSD_CONTENT                 = 256   # OSD信息最大长度
MAX_NUM_OSD_ONE_SUBWND              = 8     # 单个子窗口支持的最大OSD数量
MAX_NUM_SPLIT_WND                   = 64    # 单个窗口支持的最大分屏窗口数量（即子窗口数量）
MAX_NUM_OSD                         = 8

#2013-11-19
MAX_DEVNAME_LEN                     = 32    # 设备名称最大长度
MAX_LED_INFO                        = 256   # 屏幕字体显示信息最大长度
MAX_TIME_LEN                        = 32    # 时间最大长度
MAX_CARD_LEN                        = 24    # 卡号最大长度
MAX_OPERATORNAME_LEN                = 32    # 操作人员名称最大长度

THERMOMETRY_ALARMRULE_NUM           = 40    # 热成像报警规则数
MAX_THERMOMETRY_REGION_NUM          = 40    # 热度图检测区域最大支持数
MAX_THERMOMETRY_DIFFCOMPARISON_NUM  = 40    # 热成像温差报警规则数
MAX_SHIPS_NUM                       = 20    # 船只检测最大船只数
KEY_WORD_NUM                        = 3     # 关键字个数
KEY_WORD_LEN                        = 128   # 关键字长度
#异步登录回调状态宏定义
ASYN_LOGIN_SUCC                     = 1     # 异步登录成功
ASYN_LOGIN_FAILED                   = 0     # 异步登录失败

NET_SDK_MAX_VERIFICATION_CODE_LEN   = 32    # 萤石云验证码长度
NET_SDK_MAX_OPERATE_CODE_LEN        = 64    # 萤石云操作码长度
MAX_TIMESEGMENT_V30                 = 8     # 9000设备最大时间段数
MAX_TIMESEGMENT                     = 4     # 8000设备最大时间段数
MAX_ICR_NUM                         = 8     # 抓拍机红外滤光片预置点数2013-07-09
MAX_VEHICLEFLOW_INFO                = 24    # 车流量信息最大个数
MAX_SHELTERNUM                      = 4     # 8000设备最大遮挡区域数
MAX_DAYS                            = 7     # 每周天数
PHONENUMBER_LEN                     = 32    # pppoe拨号号码最大长度
MAX_ACCESSORY_CARD                  = 256   # 配件板信息最大长度
MAX_DISKNUM_V30                     = 33    # 9000设备最大硬盘数# 最多33个硬盘(包括16个内置SATA硬盘、1个eSATA硬盘和16个NFS盘)

NET_SDK_DISK_LOCATION_LEN           = 16    # 硬盘位置长度
NET_SDK_SUPPLIER_NAME_LEN           = 32    # 供应商名称长度
NET_SDK_DISK_MODEL_LEN              = 64    # 硬盘型号长度
NET_SDK_MAX_DISK_VOLUME             = 33    # 最大硬盘卷个数
NET_SDK_DISK_VOLUME_LEN             = 36    # 硬盘卷名称长度

MAX_DISKNUM                         = 16    # 8000设备最大硬盘数
MAX_DISKNUM_V10                     = 8     # 1.2版本之前版本
CARD_READER_DESCRIPTION             = 32    # 读卡器描述
MAX_FACE_NUM                        = 2     # 最大人脸数

MAX_WINDOW_V30                      = 32    # 9000设备本地显示最大播放窗口数
MAX_WINDOW_V40                      = 64    # Netra 2.3.1扩展
MAX_WINDOW                          = 16    # 8000设备最大硬盘数
MAX_VGA_V30                         = 4     # 9000设备最大可接VGA数
MAX_VGA                             = 1     # 8000设备最大可接VGA数

MAX_USERNUM_V30                     = 32    # 9000设备最大用户数
MAX_USERNUM                         = 16    # 8000设备最大用户数
MAX_EXCEPTIONNUM_V30                = 32    # 9000设备最大异常处理数
MAX_EXCEPTIONNUM                    = 16    # 8000设备最大异常处理数
MAX_LINK                            = 6     # 8000设备单通道最大视频流连接数
MAX_ITC_EXCEPTIONOUT                = 32    # 抓拍机最大报警输出
MAX_SCREEN_DISPLAY_LEN              = 512   # 屏幕显示字符长度

MAX_DECPOOLNUM                      = 4     # 单路解码器每个解码通道最大可循环解码数
MAX_DECNUM                          = 4     # 单路解码器的最大解码通道数（实际只有一个，其他三个保留）
MAX_TRANSPARENTNUM                  = 2     # 单路解码器可配置最大透明通道数
MAX_CYCLE_CHAN                      = 16    # 单路解码器最大轮巡通道数
MAX_CYCLE_CHAN_V30                  = 64    # 最大轮巡通道数（扩展）
MAX_DIRNAME_LENGTH                  = 80    # 最大目录长度
MAX_WINDOWS                         = 16    # 最大窗口数


MAX_STRINGNUM_V30                   = 8     # 9000设备最大OSD字符行数数
MAX_STRINGNUM                       = 4     # 8000设备最大OSD字符行数数
MAX_STRINGNUM_EX                    = 8     # 8000定制扩展
MAX_AUXOUT_V30                      = 16    # 9000设备最大辅助输出数
MAX_AUXOUT                          = 4     # 8000设备最大辅助输出数
MAX_HD_GROUP                        = 16    # 9000设备最大硬盘组数
MAX_HD_GROUP_V40                    = 32    # 设备最大硬盘组数
MAX_NFS_DISK                        = 8     # 8000设备最大NFS硬盘数
NET_SDK_VERSION_LIST_LEN            = 64    # 算法库版本最大值
IW_ESSID_MAX_SIZE                   = 32    # WIFI的SSID号长度
IW_ENCODING_TOKEN_MAX               = 32    # WIFI密锁最大字节数
MAX_SERIAL_NUM                      = 64    # 最多支持的透明通道路数
MAX_DDNS_NUMS                       = 10    # 9000设备最大可配ddns数
MAX_DOMAIN_NAME                     = 64    # 最大域名长度
MAX_EMAIL_ADDR_LEN                  = 48    # 最大email地址长度
MAX_EMAIL_PWD_LEN                   = 32    # 最大email密码长度
MAX_SLAVECAMERA_NUM                 = 8     # 从摄像机个数
MAX_CALIB_NUM                       = 6     # 标定点的个数
MAX_CALIB_NUM_EX                    = 20    # 扩展标定点的个数
MAX_LEDDISPLAYINFO_LEN              = 1024  # 最大LED屏显示长度
MAX_PEOPLE_DETECTION_NUM            = 8     # 最大人员检测区域数
MAXPROGRESS                         = 100   # 回放时的最大百分率
MAX_SERIALNUM                       = 2     # 8000设备支持的串口数 1-232， 2-485
CARDNUM_LEN                         = 20    # 卡号长度
PATIENTID_LEN                       = 64
CARDNUM_LEN_OUT                     = 32    # 外部结构体卡号长度
MAX_VIDEOOUT_V30                    = 4     # 9000设备的视频输出数
MAX_VIDEOOUT                        = 2     # 8000设备的视频输出数

MAX_PRESET_V30                      = 256   # 9000设备支持的云台预置点数
MAX_TRACK_V30                       = 256   # 9000设备支持的云台轨迹数
MAX_CRUISE_V30                      = 256   # 9000设备支持的云台巡航数
MAX_PRESET                          = 128   # 8000设备支持的云台预置点数
MAX_TRACK                           = 128   # 8000设备支持的云台轨迹数
MAX_CRUISE                          = 128   # 8000设备支持的云台巡航数

MAX_PRESET_V40                      = 300   # 云台支持的最大预置点数
MAX_CRUISE_POINT_NUM                = 128   # 最大支持的巡航点的个数
MAX_CRUISEPOINT_NUM_V50             = 256   # 最大支持的巡航点的个数扩展

CRUISE_MAX_PRESET_NUMS              = 32    # 一条巡航最多的巡航点
MAX_FACE_PIC_NUM                    = 30    # 人脸子图个数
LOCKGATE_TIME_NUM                   = 4     # 锁闸时间段个数

MAX_SERIAL_PORT                     = 8     # 9000设备支持232串口数
MAX_PREVIEW_MODE                    = 8     # 设备支持最大预览模式数目 1画面,4画面,9画面,16画面....
MAX_MATRIXOUT                       = 16    # 最大模拟矩阵输出个数
LOG_INFO_LEN                        = 11840 # 日志附加信息
DESC_LEN                            = 16    # 云台描述字符串长度
PTZ_PROTOCOL_NUM                    = 200   # 9000最大支持的云台协议数
IPC_PROTOCOL_NUM                    = 50    # ipc 协议最大个数

MAX_AUDIO                           = 1     # 8000语音对讲通道数
MAX_AUDIO_V30                       = 2     # 9000语音对讲通道数
MAX_CHANNUM                         = 16    # 8000设备最大通道数
MAX_ALARMIN                         = 16    # 8000设备最大报警输入数
MAX_ALARMOUT                        = 4     # 8000设备最大报警输出数
#9000 IPC接入
MAX_ANALOG_CHANNUM                  = 32    # 最大32个模拟通道
MAX_ANALOG_ALARMOUT                 = 32    # 最大32路模拟报警输出
MAX_ANALOG_ALARMIN                  = 32    # 最大32路模拟报警输入

MAX_IP_DEVICE                       = 32    # 允许接入的最大IP设备数
MAX_IP_DEVICE_V40                   = 64    # 允许接入的最大IP设备数 最多可添加64个 IVMS 2000等新设备
MAX_IP_CHANNEL                      = 32    # 允许加入的最多IP通道数
MAX_IP_ALARMIN                      = 128   # 允许加入的最多报警输入数
MAX_IP_ALARMOUT                     = 64    # 允许加入的最多报警输出数
MAX_IP_ALARMIN_V40                  = 4096  # 允许加入的最多报警输入数
MAX_IP_ALARMOUT_V40                 = 4096  # 允许加入的最多报警输出数

MAX_RECORD_FILE_NUM                 = 20    # 每次删除或者刻录的最大文件数
#SDK_V31 ATM
MAX_ACTION_TYPE                     = 12    # 自定义协议叠加交易行为最大行为个数
MAX_ATM_PROTOCOL_NUM                = 256   # 每种输入方式对应的ATM最大协议数
ATM_CUSTOM_PROTO                    = 1025  # 自定义协议 值为1025
ATM_PROTOCOL_SORT                   = 4     # ATM协议段数
ATM_DESC_LEN                        = 32    # ATM描述字符串长度
# SDK_V31 ATM

MAX_IPV6_LEN                        = 64    # IPv6地址最大长度
MAX_EVENTID_LEN                     = 64    # 事件ID长度

INVALID_VALUE_UINT32                = 0xffffffff # 无效值
MAX_CHANNUM_V40                     = 512
MAX_MULTI_AREA_NUM                  = 24

#SDK 录播主机
COURSE_NAME_LEN                     = 32    # 课程名称
INSTRUCTOR_NAME_LEN                 = 16    # 授课教师
COURSE_DESCRIPTION_LEN              = 256   # 课程信息

MAX_TIMESEGMENT_V40                 = 16    # 每节课信息


MAX_MIX_CHAN_NUM                    = 16    # 目前支持的最大混音通道数，背景通道 + MIC + LINE IN + 最多4个小画面
MAX_LINE_IN_CHAN_NUM                = 16    # 最大line in通道数
MAX_MIC_CHAN_NUM                    = 16    # 最大MIC通道数
INQUEST_CASE_NO_LEN                 = 64    # 审讯案件编号长度
INQUEST_CASE_NAME_LEN               = 64    # 审讯案件名称长度
CUSTOM_INFO_LEN                     = 64    # 自定义信息长度
INQUEST_CASE_LEN                    = 64    # 审讯信息长度


MAX_FILE_ID_LEN                     = 128   # 视图库项目中文件ID的最大长度
MAX_PIC_NAME_LEN                    = 128   # 图片名称长度

# 最大支持的通道数 最大模拟加上最大IP支持
MAX_CHANNUM_V30                     = (MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL)         # 64
MAX_ALARMOUT_V40                    = (MAX_IP_ALARMOUT_V40 +MAX_ANALOG_ALARMOUT)    # 4128
MAX_ALARMOUT_V30                    = (MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT)       # 96
MAX_ALARMIN_V30                     = (MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN)         # 160
MAX_ALARMIN_V40                     = (MAX_IP_ALARMIN_V40 +MAX_ANALOG_ALARMOUT)     # 4128
MAX_ANALOG_ALARM_WITH_VOLT_LIMIT    = 16    # 受电压限定的模拟报警最大输入数

MAX_ROIDETECT_NUM                   = 8     # 支持的ROI区域数
MAX_LANERECT_NUM                    = 5     # 最大车牌识别区域数
MAX_FORTIFY_NUM                     = 10    # 最大布防个数
MAX_INTERVAL_NUM                    = 4     # 最大时间间隔个数
MAX_CHJC_NUM                        = 3     # 最大车辆省份简称字符个数
MAX_VL_NUM                          = 5     # 最大虚拟线圈个数
MAX_DRIVECHAN_NUM                   = 16    # 最大车道数
MAX_COIL_NUM                        = 3     # 最大线圈个数
MAX_SIGNALLIGHT_NUM                 = 6     # 最大信号灯个数
LEN_16                              = 16
LEN_32                              = 32
LEN_64                              = 64
LEN_31                              = 31
MAX_LINKAGE_CHAN_NUM                = 16    # 报警联动的通道的最大数量
MAX_CABINET_COUNT                   = 8     # 最大支持机柜数量
MAX_ID_LEN                          = 48
MAX_PARKNO_LEN                      = 16
MAX_ALARMREASON_LEN                 = 32
MAX_UPGRADE_INFO_LEN                = 48    # 获取升级文件匹配信息(模糊升级)
MAX_CUSTOMDIR_LEN                   = 32    # 自定义目录长度
MAX_LED_INFO_LEN                    = 512   # LED内容长度
MAX_VOICE_INFO_LEN                  = 128   # 语音播报内容长度
MAX_LITLE_INFO_LEN                  = 64    # 纸票标题内容长度
MAX_CUSTOM_INFO_LEN                 = 64    # 纸票自定义信息内容长度
MAX_PHONE_NUM_LEN                   = 16    # 联系电话内容长度
MAX_APP_SERIALNUM_LEN               = 32    # 应用序列号长度

AUDIOTALKTYPE_G722                  = 0
AUDIOTALKTYPE_G711_MU               = 1
AUDIOTALKTYPE_G711_A                = 2
AUDIOTALKTYPE_MP2L2                 = 5
AUDIOTALKTYPE_G726                  = 6
AUDIOTALKTYPE_AAC                   = 7
AUDIOTALKTYPE_PCM                   = 8
AUDIOTALKTYPE_G722C                 = 9
AUDIOTALKTYPE_MP3                   = 15

#packet type
FILE_HEAD                           = 0     # file head
VIDEO_I_FRAME                       = 1     # video I frame
VIDEO_B_FRAME                       = 2     # video B frame
VIDEO_P_FRAME                       = 3     # video P frame
AUDIO_PACKET                        = 10    # audio packet
PRIVT_PACKET                        = 11    # private packet
#E frame
HIK_H264_E_FRAME                    = (1 << 6) # 以前E帧不用了,深P帧也没用到
MAX_TRANSPARENT_CHAN_NUM            = 4     # 每个串口允许建立的最大透明通道数
MAX_TRANSPARENT_ACCESS_NUM          = 4     # 每个监听端口允许接入的最大主机数

#ITS
MAX_PARKING_STATUS                  = 8     # 车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
MAX_PARKING_NUM                     = 4     # 一个通道最大4个车位 (从左到右车位 数组0～3)

MAX_ITS_SCENE_NUM                   = 16    # 最大场景数量
MAX_SCENE_TIMESEG_NUM               = 16    # 最大场景时间段数量
MAX_IVMS_IP_CHANNEL                 = 128   # 最大IP通道数
DEVICE_ID_LEN                       = 48    # 设备编号长度
MONITORSITE_ID_LEN                  = 48    # 监测点编号长度
MAX_AUXAREA_NUM                     = 16    # 辅助区域最大数目
MAX_SLAVE_CHANNEL_NUM               = 16    # 最大从通道数量
MAX_DEVDESC_LEN                     = 64    # 设备描述信息最大长度
ILLEGAL_LEN                         = 32    # 违法代码长度
MAX_TRUCK_AXLE_NUM                  = 10    # 货车轴最大数
MAX_CATEGORY_LEN                    = 8     # 车牌附加信息最大字符
SERIAL_NO_LEN                       = 16    # 泊车位编号


MAX_SECRETKEY_LEN                   = 512   # 最大秘钥长度
MAX_INDEX_CODE_LEN                  = 64    # 最大序号长度
MAX_ILLEGAL_LEN                     = 64    # 违法代码最大字符长度
CODE_LEN                            = 64    # 授权码
ALIAS_LEN                           = 32    # 别名，只读
MAX_SCH_TASKS_NUM                   = 10

MAX_SERVERID_LEN                    = 64    # 最大服务器ID的长度
MAX_SERVERDOMAIN_LEN                = 128   # 服务器域名最大长度
MAX_AUTHENTICATEID_LEN              = 64    # 认证ID最大长度
MAX_AUTHENTICATEPASSWD_LEN          = 32    # 认证密码最大长度
MAX_SERVERNAME_LEN                  = 64    # 最大服务器用户名
MAX_COMPRESSIONID_LEN               = 64    # 编码ID的最大长度
MAX_SIPSERVER_ADDRESS_LEN           = 128   # SIP服务器地址支持域名和IP地址
#压线报警
MAX_PlATE_NO_LEN                    = 32    # 车牌号码最大长度 2013-09-27
UPNP_PORT_NUM                       = 12    # upnp端口映射端口数目

# MAX_PEOPLE_DETECTION_NUM            = 8   # 最大人员检测区域数 (exist)

MAX_NOTICE_NUMBER_LEN               = 32    # 公告编号最大长度
MAX_NOTICE_THEME_LEN                = 64    # 公 告主题最大长度
MAX_NOTICE_DETAIL_LEN               = 1024  # 公告详情最大长度
MAX_NOTICE_PIC_NUM                  = 6     # 公告信息最大图片数量
MAX_DEV_NUMBER_LEN                  = 32    # 设备编号最大长度
LOCK_NAME_LEN                       = 32    # 锁名称


HOLIDAY_GROUP_NAME_LEN              = 32    # 假日组名称长度
MAX_HOLIDAY_PLAN_NUM                = 16    # 假日组最大假日计划数
TEMPLATE_NAME_LEN                   = 32    # 计划模板名称长度
MAX_HOLIDAY_GROUP_NUM               = 16    # 计划模板最大假日组数
DOOR_NAME_LEN                       = 32    # 门名称
STRESS_PASSWORD_LEN                 = 8     # 胁迫密码长度
SUPER_PASSWORD_LEN                  = 8     # 胁迫密码长度
GROUP_NAME_LEN                      = 32    # 群组名称长度
GROUP_COMBINATION_NUM               = 8     # 群组组合数
MULTI_CARD_GROUP_NUM                = 4     # 单门最大多重卡组数
ACS_CARD_NO_LEN                     = 32    # 门禁卡号长度
NET_SDK_EMPLOYEE_NO_LEN             = 32    # 工号长度
NET_SDK_UUID_LEN                    = 36    # UUID长度
NET_SDK_EHOME_KEY_LEN               = 32    # EHome Key长度
CARD_PASSWORD_LEN                   = 8     # 卡密码长度
MAX_DOOR_NUM                        = 32    # 最大门数
MAX_CARD_RIGHT_PLAN_NUM             = 4     # 卡权限最大计划个数
MAX_GROUP_NUM_128                   = 128   # 最大群组数
MAX_CARD_READER_NUM                 = 64    # 最大读卡器数
MAX_SNEAK_PATH_NODE                 = 8     # 最大后续读卡器数
MAX_MULTI_DOOR_INTERLOCK_GROUP      = 8     # 最大多门互锁组数
MAX_INTER_LOCK_DOOR_NUM             = 8     # 一个多门互锁组中最大互锁门数
MAX_CASE_SENSOR_NUM                 = 8     # 最大case sensor触发器数
MAX_DOOR_NUM_256                    = 256   # 最大门数
MAX_READER_ROUTE_NUM                = 16    # 最大刷卡循序路径
MAX_FINGER_PRINT_NUM                = 10    # 最大指纹个数
MAX_CARD_READER_NUM_512             = 512   # 最大读卡器数
NET_SDK_MULTI_CARD_GROUP_NUM_20     = 20    # 单门最大多重卡组数

ERROR_MSG_LEN                       = 32    # 下发错误信息
MAX_DOOR_CODE_LEN                   = 8     # 房间代码长度
MAX_LOCK_CODE_LEN                   = 8     # 锁代码长度
PER_RING_PORT_NUM                   = 2     # 每个环的端口数
SENSORNAME_LEN                      = 32    # 传感器名称长度
MAX_SENSORDESCR_LEN                 = 64    # 传感器描述长度
MAX_DNS_SERVER_NUM                  = 2     # 最大DNS个数
SENSORUNIT_LEN                      = 32    # 最大单位长度

WEP_KEY_MAX_SIZE                    = 32    # 最大WEP加密密钥长度
WEP_KEY_MAX_NUM                     = 4     # 最大WEP加密密钥个数
WPA_KEY_MAX_SIZE                    = 64    # 最大WPA共享密钥长度

MAX_SINGLE_FTPPICNAME_LEN           = 20    # 最大单个FTP通道名称
MAX_CAMNAME_LEN                     = 32    # 最大通道名称
MAX_FTPNAME_NUM                     = 12    # TFP名称数


MAX_IDCODE_LEN                      = 128   # 识别码最大长度
MAX_VERSIIN_LEN                     = 64    # 版本最大长度
MAX_IDCODE_NUM                      = 32    # 识别码个数
SDK_LEN_2048                        = 2048
SDK_MAX_IP_LEN                      = 48

RECT_POINT_NUM                      = 4     # 矩形角数

MAX_PUBLIC_KEY_LEN                  = 512   # 最大公钥长度
CHIP_SERIALNO_LEN                   = 32    # 加密芯片序列号长度
ENCRYPT_DEV_ID_LEN                  = 20    # 设备ID长度

#MCU相关的
MAX_SEARCH_ID_LEN                   = 36    # 搜索标识符最大长度
TERMINAL_NAME_LEN                   = 64    # 终端名称长度
MAX_URL_LEN                         = 512   # URL长度
REGISTER_NAME_LEN                   = 64    # 终端注册GK名称最大长度

#光纤
MAX_PORT_NUM                        = 64    # 最大端口数
MAX_SINGLE_CARD_PORT_NO             = 4     # 光纤收发器单卡最大端口数
MAX_FUNC_CARD_NUM                   = 32    # 光纤收发器最大功能卡数
MAX_FC_CARD_NUM                     = 33    # 光纤收发器最大卡数
MAX_REMARKS_LEN                     = 128   # 注释最大长度
MAX_OUTPUT_PORT_NUM                 = 32    # 单路输出包含的最大输出端口数
MAX_SINGLE_PORT_RECVCARD_NUM        = 64    # 单个端口连接的最大接收卡数
MAX_GAMMA_X_VALUE                   = 256   # GAMMA表X轴取值个数
NET_DEV_NAME_LEN                    = 64    # 设备名称长度
NET_DEV_TYPE_NAME_LEN               = 64    # 设备类型名称长度
ABNORMAL_INFO_NUM                   = 4     # 异常时间段个数

PLAYLIST_NAME_LEN                   = 64    # 播放表名称长度
PLAYLIST_ITEM_NUM                   = 64    # 播放项数目

#后端相关
NET_SDK_MAX_LOGIN_PASSWORD_LEN      = 128   # 用户登录密码最大长度
NET_SDK_MAX_ANSWER_LEN              = 256   # 安全问题答案最大长度
NET_SDK_MAX_QUESTION_LIST_LEN       = 32    # 安全问题列表最大长度

MAX_SCREEN_AREA_NUM                 = 128   # 屏幕区域最大数量
NET_SDK_MAX_THERMOMETRYALGNAME      = 128   # 测温算法库版本最大长度
NET_SDK_MAX_SHIPSALGNAME            = 128   # 船只算法库版本最大长度
NET_SDK_MAX_FIRESALGNAME            = 128   # 火点算法库版本最大长度

MAX_PASSPORT_NUM_LEN                = 16    # 最大护照证件号长度
MAX_PASSPORT_INFO_LEN               = 128   # 最大护照通用信息长度
MAX_PASSPORT_NAME_LEN               = 64    # 最大护照姓名长度
MAX_PASSPORT_MONITOR_LEN            = 1024  # 最大护照监护信息长度
MAX_NATIONALITY_LEN                 = 16    # 最大护照国籍长度
MAX_PASSPORT_TYPE_LEN               = 4     # 最大护照证件类型长度

####################################################
### Error codes                                  ###
####################################################
NET_DVR_UNKNOW = -1  # DLL加载错误
NET_DVR_NOERROR = 0  # 没有错误
NET_DVR_PASSWORD_ERROR = 1  # 用户名密码错误
NET_DVR_NOENOUGHPRI = 2  # 权限不足
NET_DVR_NOINIT = 3  # 没有初始化
NET_DVR_CHANNEL_ERROR = 4  # 通道号错误
NET_DVR_OVER_MAXLINK = 5  # 连接到DVR的客户端个数超过最大
NET_DVR_VERSIONNOMATCH = 6  # 版本不匹配
NET_DVR_NETWORK_FAIL_CONNECT = 7  # 连接服务器失败
NET_DVR_NETWORK_SEND_ERROR = 8  # 向服务器发送失败
NET_DVR_NETWORK_RECV_ERROR = 9  # 从服务器接收数据失败
NET_DVR_NETWORK_RECV_TIMEOUT = 10  # 从服务器接收数据超时
NET_DVR_NETWORK_ERRORDATA = 11  # 传送的数据有误
NET_DVR_ORDER_ERROR = 12  # 调用次序错误
NET_DVR_OPERNOPERMIT = 13  # 无此权限
NET_DVR_COMMANDTIMEOUT = 14  # DVR命令执行超时
NET_DVR_ERRORSERIALPORT = 15  # 串口号错误
NET_DVR_ERRORALARMPORT = 16  # 报警端口错误
NET_DVR_PARAMETER_ERROR = 17  # 参数错误
NET_DVR_CHAN_EXCEPTION = 18  # 服务器通道处于错误状态
NET_DVR_NODISK = 19  # 没有硬盘
NET_DVR_ERRORDISKNUM = 20  # 硬盘号错误
NET_DVR_DISK_FULL = 21  # 服务器硬盘满
NET_DVR_DISK_ERROR = 22  # 服务器硬盘出错
NET_DVR_NOSUPPORT = 23  # 服务器不支持
NET_DVR_BUSY = 24  # 服务器忙
NET_DVR_MODIFY_FAIL = 25  # 服务器修改不成功
NET_DVR_PASSWORD_FORMAT_ERROR = 26  # 密码输入格式不正确
NET_DVR_DISK_FORMATING = 27  # 硬盘正在格式化，不能启动操作
NET_DVR_DVRNORESOURCE = 28  # DVR资源不足
NET_DVR_DVROPRATEFAILED = 29  # DVR操作失败
NET_DVR_OPENHOSTSOUND_FAIL = 30  # 打开PC声音失败
NET_DVR_DVRVOICEOPENED = 31  # 服务器语音对讲被占用
NET_DVR_TIMEINPUTERROR = 32  # 时间输入不正确
NET_DVR_NOSPECFILE = 33  # 回放时服务器没有指定的文件
NET_DVR_CREATEFILE_ERROR = 34  # 创建文件出错
NET_DVR_FILEOPENFAIL = 35  # 打开文件出错
NET_DVR_OPERNOTFINISH = 36  # 上次的操作还没有完成
NET_DVR_GETPLAYTIMEFAIL = 37  # 获取当前播放的时间出错
NET_DVR_PLAYFAIL = 38  # 播放出错
NET_DVR_FILEFORMAT_ERROR = 39  # 文件格式不正确
NET_DVR_DIR_ERROR = 40  # 路径错误
NET_DVR_ALLOC_RESOURCE_ERROR = 41  # 资源分配错误
NET_DVR_AUDIO_MODE_ERROR = 42  # 声卡模式错误
NET_DVR_NOENOUGH_BUF = 43  # 缓冲区太小
NET_DVR_CREATESOCKET_ERROR = 44  # 创建SOCKET出错
NET_DVR_SETSOCKET_ERROR = 45  # 设置SOCKET出错
NET_DVR_MAX_NUM = 46  # 个数达到最大
NET_DVR_USERNOTEXIST = 47  # 用户不存在
NET_DVR_WRITEFLASHERROR = 48  # 写FLASH出错
NET_DVR_UPGRADEFAIL = 49  # DVR升级失败
NET_DVR_CARDHAVEINIT = 50  # 解码卡已经初始化过
NET_DVR_PLAYERFAILED = 51  # 调用播放库中某个函数失败
NET_DVR_MAX_USERNUM = 52  # 设备端用户数达到最大
NET_DVR_GETLOCALIPANDMACFAIL = 53  # 获得客户端的IP地址或物理地址失败
NET_DVR_NOENCODEING = 54  # 该通道没有编码
NET_DVR_IPMISMATCH = 55  # IP地址不匹配
NET_DVR_MACMISMATCH = 56  # MAC地址不匹配
NET_DVR_UPGRADELANGMISMATCH = 57  # 升级文件语言不匹配
NET_DVR_MAX_PLAYERPORT = 58  # 播放器路数达到最大
NET_DVR_NOSPACEBACKUP = 59  # 备份设备中没有足够空间进行备份
NET_DVR_NODEVICEBACKUP = 60  # 没有找到指定的备份设备
NET_DVR_PICTURE_BITS_ERROR = 61  # 图像素位数不符，限24色
NET_DVR_PICTURE_DIMENSION_ERROR = 62  # 图片高*宽超限， 限128*256
NET_DVR_PICTURE_SIZ_ERROR = 63  # 图片大小超限，限100K
NET_DVR_LOADPLAYERSDKFAILED = 64  # 载入当前目录下Player Sdk出错
NET_DVR_LOADPLAYERSDKPROC_ERROR = 65  # 找不到Player Sdk中某个函数入口
NET_DVR_LOADDSSDKFAILED = 66  # 载入当前目录下DSsdk出错
NET_DVR_LOADDSSDKPROC_ERROR = 67  # 找不到DsSdk中某个函数入口
NET_DVR_DSSDK_ERROR = 68  # 调用硬解码库DsSdk中某个函数失败
NET_DVR_VOICEMONOPOLIZE = 69  # 声卡被独占
NET_DVR_JOINMULTICASTFAILED = 70  # 加入多播组失败
NET_DVR_CREATEDIR_ERROR = 71  # 建立日志文件目录失败
NET_DVR_BINDSOCKET_ERROR = 72  # 绑定套接字失败
NET_DVR_SOCKETCLOSE_ERROR = 73  # socket连接中断，此错误通常是由于连接中断或目的地不可达
NET_DVR_USERID_ISUSING = 74  # 注销时用户ID正在进行某操作
NET_DVR_SOCKETLISTEN_ERROR = 75  # 监听失败
NET_DVR_PROGRAM_EXCEPTION = 76  # 程序异常
NET_DVR_WRITEFILE_FAILED = 77  # 写文件失败
NET_DVR_FORMAT_READONLY = 78  # 禁止格式化只读硬盘
NET_DVR_WITHSAMEUSERNAME = 79  # 用户配置结构中存在相同的用户名
NET_DVR_DEVICETYPE_ERROR = 80  # 导入参数时设备型号不匹配
NET_DVR_LANGUAGE_ERROR = 81  # 导入参数时语言不匹配
NET_DVR_PARAVERSION_ERROR = 82  # 导入参数时软件版本不匹配
NET_DVR_IPCHAN_NOTALIVE = 83  # 预览时外接IP通道不在线
NET_DVR_RTSP_SDK_ERROR = 84  # 加载高清IPC通讯库StreamTransClient.dll失败
NET_DVR_CONVERT_SDK_ERROR = 85  # 加载转码库失败
NET_DVR_IPC_COUNT_OVERFLOW = 86  # 超出最大的ip接入通道数
NET_DVR_MAX_ADD_NUM = 87  # 添加标签(一个文件片段64)等个数达到最大
NET_DVR_PARAMMODE_ERROR = 88  # 图像增强仪，参数模式错误（用于硬件设置时，客户端进行软件设置时错误值）
NET_DVR_CODESPITTER_OFFLINE = 89  # 视频综合平台，码分器不在线
NET_DVR_BACKUP_COPYING = 90  # 设备正在备份
NET_DVR_CHAN_NOTSUPPORT = 91  # 通道不支持该操作
NET_DVR_CALLINEINVALID = 92  # 高度线位置太集中或长度线不够倾斜
NET_DVR_CALCANCELCONFLICT = 93  # 取消标定冲突，如果设置了规则及全局的实际大小尺寸过滤
NET_DVR_CALPOINTOUTRANGE = 94  # 标定点超出范围
NET_DVR_FILTERRECTINVALID = 95  # 尺寸过滤器不符合要求
NET_DVR_DDNS_DEVOFFLINE = 96  # 设备没有注册到ddns上
NET_DVR_DDNS_INTER_ERROR = 97  # DDNS 服务器内部错误
NET_DVR_FUNCTION_NOT_SUPPORT_OS = 98  # 此功能不支持该操作系统
NET_DVR_DEC_CHAN_REBIND = 99  # 解码通道绑定显示输出次数受限
NET_DVR_INTERCOM_SDK_ERROR = 100  # 加载当前目录下的语音对讲库失败
NET_DVR_NO_CURRENT_UPDATEFILE = 101  # 没有正确的升级包
NET_DVR_USER_NOT_SUCC_LOGIN = 102  # 用户还没登陆成功
NET_DVR_USE_LOG_SWITCH_FILE = 103  # 正在使用日志开关文件
NET_DVR_POOL_PORT_EXHAUST = 104  # 端口池中用于绑定的端口已耗尽
NET_DVR_PACKET_TYPE_NOT_SUPPORT = 105  # 码流封装格式错误
NET_DVR_IPPARA_IPID_ERROR = 106  # IP接入配置时IPID有误

NET_DVR_LOAD_HCPREVIEW_SDK_ERROR = 107 # 预览组件加载失败
NET_DVR_LOAD_HCVOICETALK_SDK_ERROR = 108 # 语音组件加载失败
NET_DVR_LOAD_HCALARM_SDK_ERROR = 109 # 报警组件加载失败
NET_DVR_LOAD_HCPLAYBACK_SDK_ERROR = 110 # 回放组件加载失败
NET_DVR_LOAD_HCDISPLAY_SDK_ERROR = 111 # 显示组件加载失败
NET_DVR_LOAD_HCINDUSTRY_SDK_ERROR = 112 # 行业应用组件加载失败
NET_DVR_LOAD_HCGENERALCFGMGR_SDK_ERROR = 113 # 通用配置管理组件加载失败
NET_DVR_LOAD_HCCOREDEVCFG_SDK_ERROR = 114 # 设备配置核心组件加载失败
NET_DVR_LOAD_HCNETUTILS_SDK_ERROR = 115 # HCNetUtils加载失败

NET_DVR_CORE_VER_MISMATCH = 121 # 单独加载组件时，组件与core版本不匹配
NET_DVR_CORE_VER_MISMATCH_HCPREVIEW = 122 # 预览组件与core版本不匹配
NET_DVR_CORE_VER_MISMATCH_HCVOICETALK = 123 # 语音组件与core版本不匹配
NET_DVR_CORE_VER_MISMATCH_HCALARM = 124 # 报警组件与core版本不匹配
NET_DVR_CORE_VER_MISMATCH_HCPLAYBACK = 125 # 回放组件与core版本不匹配
NET_DVR_CORE_VER_MISMATCH_HCDISPLAY = 126 # 显示组件与core版本不匹配
NET_DVR_CORE_VER_MISMATCH_HCINDUSTRY = 127 # 行业应用组件与core版本不匹配
NET_DVR_CORE_VER_MISMATCH_HCGENERALCFGMGR = 128 # 通用配置管理组件与core版本不匹配

NET_DVR_COM_VER_MISMATCH_HCPREVIEW = 136 # 预览组件与HCNetSDK版本不匹配
NET_DVR_COM_VER_MISMATCH_HCVOICETALK = 137 # 语音组件与HCNetSDK版本不匹配
NET_DVR_COM_VER_MISMATCH_HCALARM = 138 # 报警组件与HCNetSDK版本不匹配
NET_DVR_COM_VER_MISMATCH_HCPLAYBACK = 139 # 回放组件与HCNetSDK版本不匹配
NET_DVR_COM_VER_MISMATCH_HCDISPLAY = 140 # 显示组件与HCNetSDK版本不匹配
NET_DVR_COM_VER_MISMATCH_HCINDUSTRY = 141 # 行业应用组件与HCNetSDK版本不匹配
NET_DVR_COM_VER_MISMATCH_HCGENERALCFGMGR = 142 # 通用配置管理组件与HCNetSDK版本不匹配

NET_ERR_CONFIG_FILE_IMPORT_FAILED = 145 # 配置文件导入失败
NET_ERR_CONFIG_FILE_EXPORT_FAILED = 146 # 配置文件导出失败
NET_DVR_CERTIFICATE_FILE_ERROR = 147 # 证书错误
NET_DVR_LOAD_SSL_LIB_ERROR = 148 # 加载SSL库失败（可能是版本不匹配，也可能是不存在）
NET_DVR_SSL_VERSION_NOT_MATCH = 149 # SSL库版本不匹配

NET_DVR_ALIAS_DUPLICATE = 150 # 别名重复  # 2011-08-31 通过别名或者序列号来访问设备的新版本ddns的配置
NET_DVR_INVALID_COMMUNICATION = 151 # 无效通信
NET_DVR_USERNAME_NOT_EXIST = 152 # 用户名不存在（用户名不存在，IPC5.1.7中发布出去了，所以删不掉。后续的产品这个错误码用不上）
NET_DVR_USER_LOCKED = 153 # 用户被锁定
NET_DVR_INVALID_USERID = 154 # 无效用户ID
NET_DVR_LOW_LOGIN_VERSION = 155 # 登录版本低
NET_DVR_LOAD_LIBEAY32_DLL_ERROR = 156 # 加载libeay32.dll库失败
NET_DVR_LOAD_SSLEAY32_DLL_ERROR = 157 # 加载ssleay32.dll库失败
NET_ERR_LOAD_LIBICONV = 158 # 加载libiconv库失败
NET_ERR_SSL_CONNECT_FAILED = 159 # SSL连接失败
NET_ERR_MCAST_ADDRESS_ERROR = 160 # 获取多播地址错误
NET_ERR_LOAD_ZLIB = 161 # 加载zlib.dll库失败
NET_ERR_OPENSSL_NO_INIT = 162 # Openssl库未初始化

NET_DVR_SERVER_NOT_EXIST = 164 # 对应的服务器找不到,查找时输入的国家编号或者服务器类型错误
NET_DVR_TEST_SERVER_FAIL_CONNECT = 165 # 连接测试服务器失败
NET_DVR_NAS_SERVER_INVALID_DIR = 166 # NAS服务器挂载目录失败，目录无效
NET_DVR_NAS_SERVER_NOENOUGH_PRI = 167 # NAS服务器挂载目录失败，没有权限
NET_DVR_EMAIL_SERVER_NOT_CONFIG_DNS = 168 # 服务器使用域名，但是没有配置DNS，可能造成域名无效。
NET_DVR_EMAIL_SERVER_NOT_CONFIG_GATEWAY = 169 # 没有配置网关，可能造成发送邮件失败。
NET_DVR_TEST_SERVER_PASSWORD_ERROR = 170 # 用户名密码不正确，测试服务器的用户名或密码错误
NET_DVR_EMAIL_SERVER_CONNECT_EXCEPTION_WITH_SMTP = 171 # 设备和smtp服务器交互异常
NET_DVR_FTP_SERVER_FAIL_CREATE_DIR = 172 # FTP服务器创建目录失败
NET_DVR_FTP_SERVER_NO_WRITE_PIR = 173 # FTP服务器没有写入权限
NET_DVR_IP_CONFLICT = 174 # IP冲突
NET_DVR_INSUFFICIENT_STORAGEPOOL_SPACE = 175 # 存储池空间已满
NET_DVR_STORAGEPOOL_INVALID = 176 # 云服务器存储池无效,没有配置存储池或者存储池ID错误
NET_DVR_EFFECTIVENESS_REBOOT = 177 # 生效需要重启
NET_ERR_ANR_ARMING_EXIST = 178 # 断网续传布防连接已经存在(该错误码是在HIK私有布防连接建立的情况下，重复布防的断网续传功能时，返回。)
NET_ERR_UPLOADLINK_EXIST = 179 # 断网续传上传连接已经存在(EHOME协议和HIK SDK协议是不能同时支持断网续传的，当一个协议存在的时候，另外一个连接建立话，报错这个错误码。)
NET_ERR_INCORRECT_FILE_FORMAT = 180 # 导入文件格式不正确
NET_ERR_INCORRECT_FILE_CONTENT = 181 # 导入文件内容不正确
NET_ERR_MAX_HRUDP_LINK = 182 # HRUDP 连接数 超过设备限制
NET_SDK_ERR_ACCESSKEY_SECRETKEY = 183 #  接入秘钥或加密秘钥不正确
NET_SDK_ERR_CREATE_PORT_MULTIPLEX = 184 # 创建端口复用失败
NET_DVR_NONBLOCKING_CAPTURE_NOTSUPPORT = 185 # 不支持无阻塞抓图
NET_SDK_ERR_FUNCTION_INVALID = 186 # 已开启异步，该功能无效
NET_SDK_ERR_MAX_PORT_MULTIPLEX = 187 # 已达到端口复用最大数目
#  2010-5-28
#  阵列错误码
RAID_ERROR_INDEX = 200
NET_DVR_NAME_NOT_ONLY = (RAID_ERROR_INDEX + 0) #  名称已存在
NET_DVR_OVER_MAX_ARRAY = (RAID_ERROR_INDEX + 1) #  阵列达到上限
NET_DVR_OVER_MAX_VD = (RAID_ERROR_INDEX + 2) #  虚拟磁盘达到上限
NET_DVR_VD_SLOT_EXCEED = (RAID_ERROR_INDEX + 3) #  虚拟磁盘槽位已满
NET_DVR_PD_STATUS_INVALID = (RAID_ERROR_INDEX + 4) #  重建阵列所需物理磁盘状态错误
NET_DVR_PD_BE_DEDICATE_SPARE = (RAID_ERROR_INDEX + 5) #  重建阵列所需物理磁盘为指定热备
NET_DVR_PD_NOT_FREE = (RAID_ERROR_INDEX + 6) #  重建阵列所需物理磁盘非空闲
NET_DVR_CANNOT_MIG2NEWMODE = (RAID_ERROR_INDEX + 7) #  不能从当前的阵列类型迁移到新的阵列类型
NET_DVR_MIG_PAUSE = (RAID_ERROR_INDEX + 8) #  迁移操作已暂停
NET_DVR_MIG_CANCEL = (RAID_ERROR_INDEX + 9) #  正在执行的迁移操作已取消
NET_DVR_EXIST_VD = (RAID_ERROR_INDEX + 10) #  阵列上阵列上存在虚拟磁盘，无法删除阵列
NET_DVR_TARGET_IN_LD_FUNCTIONAL = (RAID_ERROR_INDEX + 11) #  对象物理磁盘为虚拟磁盘组成部分且工作正常
NET_DVR_HD_IS_ASSIGNED_ALREADY = (RAID_ERROR_INDEX + 12) #  指定的物理磁盘被分配为虚拟磁盘
NET_DVR_INVALID_HD_COUNT = (RAID_ERROR_INDEX + 13) #  物理磁盘数量与指定的RAID等级不匹配
NET_DVR_LD_IS_FUNCTIONAL = (RAID_ERROR_INDEX + 14) #  阵列正常，无法重建
NET_DVR_BGA_RUNNING = (RAID_ERROR_INDEX + 15) #  存在正在执行的后台任务
NET_DVR_LD_NO_ATAPI = (RAID_ERROR_INDEX + 16) #  无法用ATAPI盘创建虚拟磁盘
NET_DVR_MIGRATION_NOT_NEED = (RAID_ERROR_INDEX + 17) #  阵列无需迁移
NET_DVR_HD_TYPE_MISMATCH = (RAID_ERROR_INDEX + 18) #  物理磁盘不属于同意类型
NET_DVR_NO_LD_IN_DG = (RAID_ERROR_INDEX + 19) #  无虚拟磁盘，无法进行此项操作
NET_DVR_NO_ROOM_FOR_SPARE = (RAID_ERROR_INDEX + 20) #  磁盘空间过小，无法被指定为热备盘
NET_DVR_SPARE_IS_IN_MULTI_DG = (RAID_ERROR_INDEX + 21) #  磁盘已被分配为某阵列热备盘
NET_DVR_DG_HAS_MISSING_PD = (RAID_ERROR_INDEX + 22) #  阵列缺少盘

#  x86 64bit nvr新增 2012-02-04
NET_DVR_NAME_EMPTY = (RAID_ERROR_INDEX + 23) # 名称为空
NET_DVR_INPUT_PARAM = (RAID_ERROR_INDEX + 24) # 输入参数有误
NET_DVR_PD_NOT_AVAILABLE = (RAID_ERROR_INDEX + 25) # 物理磁盘不可用
NET_DVR_ARRAY_NOT_AVAILABLE = (RAID_ERROR_INDEX + 26) # 阵列不可用
NET_DVR_PD_COUNT = (RAID_ERROR_INDEX + 27) # 物理磁盘数不正确
NET_DVR_VD_SMALL = (RAID_ERROR_INDEX + 28) # 虚拟磁盘太小
NET_DVR_NO_EXIST = (RAID_ERROR_INDEX + 29) # 不存在
NET_DVR_NOT_SUPPORT = (RAID_ERROR_INDEX + 30) # 不支持该操作
NET_DVR_NOT_FUNCTIONAL = (RAID_ERROR_INDEX + 31) # 阵列状态不是正常状态
NET_DVR_DEV_NODE_NOT_FOUND = (RAID_ERROR_INDEX + 32) # 虚拟磁盘设备节点不存在
NET_DVR_SLOT_EXCEED = (RAID_ERROR_INDEX + 33) # 槽位达到上限
NET_DVR_NO_VD_IN_ARRAY = (RAID_ERROR_INDEX + 34) # 阵列上不存在虚拟磁盘
NET_DVR_VD_SLOT_INVALID = (RAID_ERROR_INDEX + 35) # 虚拟磁盘槽位无效
NET_DVR_PD_NO_ENOUGH_SPACE = (RAID_ERROR_INDEX + 36) # 所需物理磁盘空间不足
NET_DVR_ARRAY_NONFUNCTION = (RAID_ERROR_INDEX + 37) # 只有处于正常状态的阵列才能进行迁移
NET_DVR_ARRAY_NO_ENOUGH_SPACE = (RAID_ERROR_INDEX + 38) # 阵列空间不足
NET_DVR_STOPPING_SCANNING_ARRAY = (RAID_ERROR_INDEX + 39) # 正在执行安全拔盘或重新扫描
NET_DVR_NOT_SUPPORT_16T = (RAID_ERROR_INDEX + 40) # 不支持创建大于16T的阵列
NET_DVR_ARRAY_FORMATING = (RAID_ERROR_INDEX + 41) # 正在执行格式化的阵列无法删除
NET_DVR_QUICK_SETUP_PD_COUNT = (RAID_ERROR_INDEX + 42) # 一键配置至少需要三块空闲盘

# 设备未激活时，登录失败，返回错误码
NET_DVR_ERROR_DEVICE_NOT_ACTIVATED = 250 # 设备未激活
# 老SDK接新设备，设置用户密码或者激活的时候为风险密码时，错误码
NET_DVR_ERROR_RISK_PASSWORD = 251 # 有风险的密码
# 已激活的设备，再次激活时返回错误码
NET_DVR_ERROR_DEVICE_HAS_ACTIVATED = 252 # 设备已激活


#  智能错误码
VCA_ERROR_INDEX = 300 #  智能错误码索引
NET_DVR_ID_ERROR = (VCA_ERROR_INDEX + 0) #  配置ID不合理
NET_DVR_POLYGON_ERROR = (VCA_ERROR_INDEX + 1) #  多边形不符合要求
NET_DVR_RULE_PARAM_ERROR = (VCA_ERROR_INDEX + 2) #  规则参数不合理
NET_DVR_RULE_CFG_CONFLICT = (VCA_ERROR_INDEX + 3) #  配置信息冲突
NET_DVR_CALIBRATE_NOT_READY = (VCA_ERROR_INDEX + 4) #  当前没有标定信息
NET_DVR_CAMERA_DATA_ERROR = (VCA_ERROR_INDEX + 5) #  摄像机参数不合理
NET_DVR_CALIBRATE_DATA_UNFIT = (VCA_ERROR_INDEX + 6) #  长度不够倾斜，不利于标定
NET_DVR_CALIBRATE_DATA_CONFLICT = (VCA_ERROR_INDEX + 7) #  标定出错，以为所有点共线或者位置太集中
NET_DVR_CALIBRATE_CALC_FAIL = (VCA_ERROR_INDEX + 8) #  摄像机标定参数值计算失败
NET_DVR_CALIBRATE_LINE_OUT_RECT = (VCA_ERROR_INDEX + 9) #  输入的样本标定线超出了样本外接矩形框
NET_DVR_ENTER_RULE_NOT_READY = (VCA_ERROR_INDEX + 10) #  没有设置进入区域
NET_DVR_AID_RULE_NO_INCLUDE_LANE = (VCA_ERROR_INDEX + 11) #  交通事件规则中没有包括车道（特值拥堵和逆行）
NET_DVR_LANE_NOT_READY = (VCA_ERROR_INDEX + 12) #  当前没有设置车道
NET_DVR_RULE_INCLUDE_TWO_WAY = (VCA_ERROR_INDEX + 13) #  事件规则中包含2种不同方向
NET_DVR_LANE_TPS_RULE_CONFLICT = (VCA_ERROR_INDEX + 14) #  车道和数据规则冲突
NET_DVR_NOT_SUPPORT_EVENT_TYPE = (VCA_ERROR_INDEX + 15) #  不支持的事件类型
NET_DVR_LANE_NO_WAY = (VCA_ERROR_INDEX + 16) #  车道没有方向
NET_DVR_SIZE_FILTER_ERROR = (VCA_ERROR_INDEX + 17) #  尺寸过滤框不合理
NET_DVR_LIB_FFL_NO_FACE = (VCA_ERROR_INDEX + 18) #  特征点定位时输入的图像没有人脸
NET_DVR_LIB_FFL_IMG_TOO_SMALL = (VCA_ERROR_INDEX + 19) #  特征点定位时输入的图像太小
NET_DVR_LIB_FD_IMG_NO_FACE = (VCA_ERROR_INDEX + 20) #  单张图像人脸检测时输入的图像没有人脸
NET_DVR_LIB_FACE_TOO_SMALL = (VCA_ERROR_INDEX + 21) #  建模时人脸太小
NET_DVR_LIB_FACE_QUALITY_TOO_BAD = (VCA_ERROR_INDEX + 22) #  建模时人脸图像质量太差
NET_DVR_KEY_PARAM_ERR = (VCA_ERROR_INDEX + 23) # 高级参数设置错误
NET_DVR_CALIBRATE_DATA_ERR = (VCA_ERROR_INDEX + 24) # 标定样本数目错误，或数据值错误，或样本点超出地平线
NET_DVR_CALIBRATE_DISABLE_FAIL = (VCA_ERROR_INDEX + 25) # 所配置规则不允许取消标定
NET_DVR_VCA_LIB_FD_SCALE_OUTRANGE = (VCA_ERROR_INDEX + 26) # 最大过滤框的宽高最小值超过最小过滤框的宽高最大值两倍以上
NET_DVR_LIB_FD_REGION_TOO_LARGE = (VCA_ERROR_INDEX + 27) # 当前检测区域范围过大。检测区最大为图像的2/3
NET_DVR_TRIAL_OVERDUE = (VCA_ERROR_INDEX + 28) # 试用版评估期已结束
NET_DVR_CONFIG_FILE_CONFLICT = (VCA_ERROR_INDEX + 29) # 设备类型与配置文件冲突（加密狗类型与现有分析仪配置不符错误码提示）
# 算法库相关错误码
NET_DVR_FR_FPL_FAIL = (VCA_ERROR_INDEX + 30) #  人脸特征点定位失败
NET_DVR_FR_IQA_FAIL = (VCA_ERROR_INDEX + 31) #  人脸评分失败
NET_DVR_FR_FEM_FAIL = (VCA_ERROR_INDEX + 32) #  人脸特征提取失败
NET_DVR_FPL_DT_CONF_TOO_LOW = (VCA_ERROR_INDEX + 33) #  特征点定位时人脸检测置信度过低
NET_DVR_FPL_CONF_TOO_LOW = (VCA_ERROR_INDEX + 34) #  特征点定位置信度过低
NET_DVR_E_DATA_SIZE = (VCA_ERROR_INDEX + 35) #  数据长度不匹配
NET_DVR_FR_MODEL_VERSION_ERR = (VCA_ERROR_INDEX + 36) #  人脸模型数据中的模型版本错误
NET_DVR_FR_FD_FAIL = (VCA_ERROR_INDEX + 37) #  识别库中人脸检测失败
NET_DVR_FA_NORMALIZE_ERR = (VCA_ERROR_INDEX + 38) #  人脸归一化出错
# 其他错误码
NET_DVR_DOG_PUSTREAM_NOT_MATCH = (VCA_ERROR_INDEX + 39) #  加密狗与前端取流设备类型不匹配
NET_DVR_DEV_PUSTREAM_NOT_MATCH = (VCA_ERROR_INDEX + 40) #  前端取流设备版本不匹配
NET_DVR_PUSTREAM_ALREADY_EXISTS = (VCA_ERROR_INDEX + 41) #  设备的其他通道已经添加过该前端设备
NET_DVR_SEARCH_CONNECT_FAILED = (VCA_ERROR_INDEX + 42) #  连接检索服务器失败
NET_DVR_INSUFFICIENT_DISK_SPACE = (VCA_ERROR_INDEX + 43) #  可存储的硬盘空间不足
NET_DVR_DATABASE_CONNECTION_FAILED = (VCA_ERROR_INDEX + 44) #  数据库连接失败
NET_DVR_DATABASE_ADM_PW_ERROR = (VCA_ERROR_INDEX + 45) #  数据库用户名、密码错误
NET_DVR_DECODE_YUV = (VCA_ERROR_INDEX + 46) #  解码失败
NET_DVR_IMAGE_RESOLUTION_ERROR = (VCA_ERROR_INDEX + 47) #
NET_DVR_CHAN_WORKMODE_ERROR = (VCA_ERROR_INDEX + 48) #

NET_DVR_RTSP_ERROR_NOENOUGHPRI = 401 # 无权限：服务器返回401时，转成这个错误码
NET_DVR_RTSP_ERROR_ALLOC_RESOURCE = 402 # 分配资源失败
NET_DVR_RTSP_ERROR_PARAMETER = 403 # 参数错误
NET_DVR_RTSP_ERROR_NO_URL = 404 # 指定的URL地址不存在：服务器返回404时，转成这个错误码
NET_DVR_RTSP_ERROR_FORCE_STOP = 406 # 用户中途强行退出

NET_DVR_RTSP_GETPORTFAILED = 407 # rtsp 得到端口错误
NET_DVR_RTSP_DESCRIBERROR = 410 # rtsp decribe 交互错误
NET_DVR_RTSP_DESCRIBESENDTIMEOUT = 411 # rtsp decribe 发送超时
NET_DVR_RTSP_DESCRIBESENDERROR = 412 # rtsp decribe 发送失败
NET_DVR_RTSP_DESCRIBERECVTIMEOUT = 413 # rtsp decribe 接收超时
NET_DVR_RTSP_DESCRIBERECVDATALOST = 414 # rtsp decribe 接收数据错误
NET_DVR_RTSP_DESCRIBERECVERROR = 415 # rtsp decribe 接收失败
NET_DVR_RTSP_DESCRIBESERVERERR = 416 # rtsp decribe 服务器返回错误状态

NET_DVR_RTSP_SETUPERROR = 420 # rtsp setup 交互错误
NET_DVR_RTSP_SETUPSENDTIMEOUT = 421 # rtsp setup 发送超时
NET_DVR_RTSP_SETUPSENDERROR = 422 # rtsp setup 发送错误
NET_DVR_RTSP_SETUPRECVTIMEOUT = 423 # rtsp setup 接收超时
NET_DVR_RTSP_SETUPRECVDATALOST = 424 # rtsp setup 接收数据错误
NET_DVR_RTSP_SETUPRECVERROR = 425 # rtsp setup 接收失败
NET_DVR_RTSP_OVER_MAX_CHAN = 426 # 超过服务器最大连接数，或者服务器资源不足，服务器返回453时，转成这个错误码。
NET_DVR_RTSP_SETUPSERVERERR = 427 # rtsp setup 服务器返回错误状态

NET_DVR_RTSP_PLAYERROR = 430 # rtsp play 交互错误
NET_DVR_RTSP_PLAYSENDTIMEOUT = 431 # rtsp play 发送超时
NET_DVR_RTSP_PLAYSENDERROR = 432 # rtsp play 发送错误
NET_DVR_RTSP_PLAYRECVTIMEOUT = 433 # rtsp play 接收超时
NET_DVR_RTSP_PLAYRECVDATALOST = 434 # rtsp play 接收数据错误
NET_DVR_RTSP_PLAYRECVERROR = 435 # rtsp play 接收失败
NET_DVR_RTSP_PLAYSERVERERR = 436 # rtsp play 服务器返回错误状态

NET_DVR_RTSP_TEARDOWNERROR = 440 # rtsp teardown 交互错误
NET_DVR_RTSP_TEARDOWNSENDTIMEOUT = 441 # rtsp teardown 发送超时
NET_DVR_RTSP_TEARDOWNSENDERROR = 442 # rtsp teardown 发送错误
NET_DVR_RTSP_TEARDOWNRECVTIMEOUT = 443 # rtsp teardown 接收超时
NET_DVR_RTSP_TEARDOWNRECVDATALOST = 444 # rtsp teardown 接收数据错误
NET_DVR_RTSP_TEARDOWNRECVERROR = 445 # rtsp teardown 接收失败
NET_DVR_RTSP_TEARDOWNSERVERERR = 446 # rtsp teardown 服务器返回错误状态

NET_PLAYM4_NOERROR = 500 # no error
NET_PLAYM4_PARA_OVER = 501 # input parameter is invalid;
NET_PLAYM4_ORDER_ERROR = 502 # The order of the function to be called is error.
NET_PLAYM4_TIMER_ERROR = 503 # Create multimedia clock failed;
NET_PLAYM4_DEC_VIDEO_ERROR = 504 # Decode video data failed.
NET_PLAYM4_DEC_AUDIO_ERROR = 505 # Decode audio data failed.
NET_PLAYM4_ALLOC_MEMORY_ERROR = 506 # Allocate memory failed.
NET_PLAYM4_OPEN_FILE_ERROR = 507 # Open the file failed.
NET_PLAYM4_CREATE_OBJ_ERROR = 508 # Create thread or event failed
NET_PLAYM4_CREATE_DDRAW_ERROR = 509 # Create DirectDraw object failed.
NET_PLAYM4_CREATE_OFFSCREEN_ERROR = 510 # failed when creating off-screen surface.
NET_PLAYM4_BUF_OVER = 511 # buffer is overflow
NET_PLAYM4_CREATE_SOUND_ERROR = 512 # failed when creating audio device.
NET_PLAYM4_SET_VOLUME_ERROR = 513 # Set volume failed
NET_PLAYM4_SUPPORT_FILE_ONLY = 514 # The function only support play file.
NET_PLAYM4_SUPPORT_STREAM_ONLY = 515 # The function only support play stream.
NET_PLAYM4_SYS_NOT_SUPPORT = 516 # System not support.
NET_PLAYM4_FILEHEADER_UNKNOWN = 517 # No file header.
NET_PLAYM4_VERSION_INCORRECT = 518 # The version of decoder and encoder is not adapted.
NET_PALYM4_INIT_DECODER_ERROR = 519 # Initialize decoder failed.
NET_PLAYM4_CHECK_FILE_ERROR = 520 # The file data is unknown.
NET_PLAYM4_INIT_TIMER_ERROR = 521 # Initialize multimedia clock failed.
NET_PLAYM4_BLT_ERROR = 522 # Blt failed.
NET_PLAYM4_UPDATE_ERROR = 523 # Update failed.
NET_PLAYM4_OPEN_FILE_ERROR_MULTI = 524 # openfile error, streamtype is multi
NET_PLAYM4_OPEN_FILE_ERROR_VIDEO = 525 # openfile error, streamtype is video
NET_PLAYM4_JPEG_COMPRESS_ERROR = 526 # JPEG compress error
NET_PLAYM4_EXTRACT_NOT_SUPPORT = 527 # Don't support the version of this file.
NET_PLAYM4_EXTRACT_DATA_ERROR = 528 # extract video data failed.

# 转封装库错误码
NET_CONVERT_ERROR_NOT_SUPPORT = 581 # convert not support

# 语音对讲库错误码
NET_AUDIOINTERCOM_OK = 600 # 无错误
NET_AUDIOINTECOM_ERR_NOTSUPORT = 601 # 不支持
NET_AUDIOINTECOM_ERR_ALLOC_MEMERY = 602 # 内存申请错误
NET_AUDIOINTECOM_ERR_PARAMETER = 603 # 参数错误
NET_AUDIOINTECOM_ERR_CALL_ORDER = 604 # 调用次序错误
NET_AUDIOINTECOM_ERR_FIND_DEVICE = 605 # 未发现设备
NET_AUDIOINTECOM_ERR_OPEN_DEVICE = 606 # 不能打开设备诶
NET_AUDIOINTECOM_ERR_NO_CONTEXT = 607 # 设备上下文出错
NET_AUDIOINTECOM_ERR_NO_WAVFILE = 608 # WAV文件出错
NET_AUDIOINTECOM_ERR_INVALID_TYPE = 609 # 无效的WAV参数类型
NET_AUDIOINTECOM_ERR_ENCODE_FAIL = 610 # 编码失败
NET_AUDIOINTECOM_ERR_DECODE_FAIL = 611 # 解码失败
NET_AUDIOINTECOM_ERR_NO_PLAYBACK = 612 # 播放失败
NET_AUDIOINTECOM_ERR_DENOISE_FAIL = 613 # 降噪失败
NET_AUDIOINTECOM_ERR_UNKOWN = 619 # 未知错误

NET_QOS_OK = 700 # no error
NET_QOS_ERROR = (NET_QOS_OK - 1) # qos error
NET_QOS_ERR_INVALID_ARGUMENTS = (NET_QOS_OK - 2) # invalid arguments
NET_QOS_ERR_SESSION_NOT_FOUND = (NET_QOS_OK - 3) # session net found
NET_QOS_ERR_LIB_NOT_INITIALIZED = (NET_QOS_OK - 4) # lib not initialized
NET_QOS_ERR_OUTOFMEM = (NET_QOS_OK - 5) # outtofmem
NET_QOS_ERR_PACKET_UNKNOW = (NET_QOS_OK - 10) # packet unknow
NET_QOS_ERR_PACKET_VERSION = (NET_QOS_OK - 11) # packet version error
NET_QOS_ERR_PACKET_LENGTH = (NET_QOS_OK - 12) # packet length error
NET_QOS_ERR_PACKET_TOO_BIG = (NET_QOS_OK - 13) # packet too big
NET_QOS_ERR_SCHEDPARAMS_INVALID_BANDWIDTH = (NET_QOS_OK - 20) # schedparams invalid bandwidth
NET_QOS_ERR_SCHEDPARAMS_BAD_FRACTION = (NET_QOS_OK - 21) # schedparams bad fraction
NET_QOS_ERR_SCHEDPARAMS_BAD_MINIMUM_INTERVAL = (NET_QOS_OK - 22) # schedparams bad minimum interval

NET_ERROR_TRUNK_LINE = 711 # 子系统已被配成干线
NET_ERROR_MIXED_JOINT = 712 # 不能进行混合拼接
NET_ERROR_DISPLAY_SWITCH = 713 # 不能进行显示通道切换
NET_ERROR_USED_BY_BIG_SCREEN = 714 # 解码资源被大屏占用
NET_ERROR_USE_OTHER_DEC_RESOURCE = 715 # 不能使用其他解码子系统资源
NET_ERROR_DISP_MODE_SWITCH = 716 # 显示通道显示状态切换中
NET_ERROR_SCENE_USING = 717 # 场景正在使用
NET_ERR_NO_ENOUGH_DEC_RESOURCE = 718 # 解码资源不足
NET_ERR_NO_ENOUGH_FREE_SHOW_RESOURCE = 719 # 畅显资源不足
NET_ERR_NO_ENOUGH_VIDEO_MEMORY = 720 # 显存资源不足
NET_ERR_MAX_VIDEO_NUM = 721 # 一拖多资源不足
NET_ERR_WIN_COVER_FREE_SHOW_AND_NORMAL = 722 # 窗口跨越了畅显输出口和非畅显输出口
NET_ERR_FREE_SHOW_WIN_SPLIT = 723 # 畅显窗口不支持分屏
NET_ERR_INAPPROPRIATE_WIN_FREE_SHOW = 724 # 不是输出口整数倍的窗口不支持开启畅显
NET_DVR_TRANSPARENT_WIN_NOT_SUPPORT_SPLIT = 725 # 开启透明度的窗口不支持分屏
NET_DVR_SPLIT_WIN_NOT_SUPPORT_TRANSPARENT = 726 # 开启多分屏的窗口不支持透明度设置
NET_ERR_MAX_LOGO_NUM = 727 # logo数达到上限
NET_ERR_MAX_WIN_LOOP_NUM = 728 # 轮巡窗口数达到上限
NET_ERR_VIRTUAL_LED_VERTICAL_CROSS = 729 # 虚拟LED不能纵向跨屏
NET_ERR_MAX_VIRTUAL_LED_HEIGHT = 730 # 虚拟LED高度超限
NET_ERR_VIRTUAL_LED_ILLEGAL_CHARACTER = 731 # 虚拟LED内容包含非法字符
NET_ERR_BASEMAP_NOT_EXIST = 732 # 底图图片不存在
NET_ERR_LED_NOT_SUPPORT_VIRTUAL_LED = 733 # LED屏幕不支持虚拟LED
NET_ERR_LED_RESOLUTION_NOT_SUPPORT = 734 # LED分辨率不支持
NET_ERR_PLAN_OVERDUE = 735 # 预案超期，不能再调用
NET_ERR_PROCESSER_MAX_SCREEN_BLK = 736 # 单个处理器接入的信号跨越的屏幕个数超限
NET_ERR_WND_SIZE_TOO_SMALL = 737 # 开窗窗口宽高太小
NET_ERR_WND_SPLIT_NOT_SUPPORT_ROAM = 738 # 分屏窗口不支持漫游
NET_ERR_OUTPUT_ONE_BOARD_ONE_WALL = 739 # 同一个子板的输出口只能绑定到同一面墙上
NET_ERR_WND_CANNOT_LCD_AND_LED_OUTPUT = 740 # 窗口不能同时跨LCD和LED输出口
NET_ERR_MAX_OSD_NUM = 741 # OSD数量达到最大

NET_SDK_CANCEL_WND_TOPKEEP_ATTR_FIRST = 751 # 先取消置顶保持窗口的置顶保持属性才能进行置底操作
NET_SDK_ERR_LED_SCREEN_CHECKING = 752 # 正在校正LED屏幕
NET_SDK_ERR_NOT_SUPPORT_SINGLE_RESOLUTION = 753 # LCD/LED输出口绑定之后不支持单个输出口的分辨率配置
NET_SDK_ERR_LED_RESOLUTION_MISMATCHED = 754 # 该输出口的LED分辨率和其他输出口的LED分辨率不匹配，需要满足同行等高、同列等宽


NET_SDK_ERR_MAX_VIRTUAL_LED_WIDTH = 755 # 虚拟LED宽度超限，包括最大值和最小值
NET_SDK_ERR_MAX_VIRTUAL_LED_IN_SCREEN = 756 # 单屏虚拟LED数量超限
NET_SDK_ERR_MAX_VIRTUAL_LED_IN_WALL = 757 # 单墙虚拟LED数量超限
NET_SDK_ERR_VIRTUAL_LED_OVERLAP = 758 # 虚拟LED重叠错误
NET_SDK_ERR_VIRTUAL_LED_TYPE = 759 # 类型错误
NET_SDK_ERR_VIRTUAL_LED_COLOUR = 760 # 颜色错误
NET_SDK_ERR_VIRTUAL_LED_MOVE_DIRECTION = 761 # 移动方向错误
NET_SDK_ERR_VIRTUAL_LED_MOVE_MODE = 762 # 移动模式错误
NET_SDK_ERR_VIRTUAL_LED_MOVE_SPEED = 763 # 移动速度错误
NET_SDK_ERR_VIRTUAL_LED_DISP_MODE = 764 # 显示模式有误
NET_SDK_ERR_VIRTUAL_LED_NO = 765 # 虚拟LED序号错误
NET_SDK_ERR_VIRTUAL_LED_PARA = 766 # 虚拟LED参数配置错误，包括结构体内其他参数
NET_SDK_ERR_BASEMAP_POSITION = 767 # 底图窗口宽高参数错误
NET_SDK_ERR_BASEMAP_PICTURE_LEN = 768 # 底图图片长度超限
NET_SDK_ERR_BASEMAP_PICTURE_RESOLUTION = 769 # 底图图片分辨率错误
NET_SDK_ERR_BASEMAP_PICTURE_FORMAT = 770 # 底图图片格式错误
NET_SDK_ERR_MAX_VIRTUAL_LED_NUM = 771 # 设备支持的虚拟LED数量超限
NET_SDK_ERR_MAX_TIME_VIRTUAL_LED_IN_WALL = 772 # 单面电视墙支持的时间虚拟LED的数量超限

NET_ERR_TERMINAL_BUSY = 780 # 终端忙，终端处于会议中

NET_ERR_DATA_RETURNED_ILLEGAL = 790 # 设备返回的数据不合法
NET_DVR_FUNCTION_RESOURCE_USAGE_ERROR = 791 # 设备其它功能占用资源，导致该功能无法开启

NET_DVR_ERR_IMPORT_EMPTY_FILE = 792 # 导入文件为空
NET_DVR_ERR_IMPORT_TOO_LARGE_FILE = 793 # 导入文件过大
NET_DVR_ERR_BAD_IPV4_ADDRESS = 794 # IPV4地址无效
NET_DVR_ERR_BAD_NET_MASK = 795 # 子网掩码地址无效
NET_DVR_ERR_INVALID_NET_GATE_ADDRESS = 796 # 网关地址无效
NET_DVR_ERR_BAD_DNS = 797 # DNS地址无效
NET_DVR_ERR_ILLEGAL_PASSWORD = 798 # 密码不能包含用户名

NET_DVR_DEV_NET_OVERFLOW = 800 # 网络流量超过设备能力上限
NET_DVR_STATUS_RECORDFILE_WRITING_NOT_LOCK = 801 # 录像文件在录像，无法被锁定
NET_DVR_STATUS_CANT_FORMAT_LITTLE_DISK = 802 # 由于硬盘太小无法格式化

# N+1错误码
NET_SDK_ERR_REMOTE_DISCONNECT = 803 # 远端无法连接
NET_SDK_ERR_RD_ADD_RD = 804 # 备机不能添加备机
NET_SDK_ERR_BACKUP_DISK_EXCEPT = 805 # 备份盘异常
NET_SDK_ERR_RD_LIMIT = 806 # 备机数已达上限
NET_SDK_ERR_ADDED_RD_IS_WD = 807 # 添加的备机是工作机
NET_SDK_ERR_ADD_ORDER_WRONG = 808 # 添加顺序出错，比如没有被工作机添加为备机，就添加工作机
NET_SDK_ERR_WD_ADD_WD = 809 # 工作机不能添加工作机
NET_SDK_ERR_WD_SERVICE_EXCETP = 810 # 工作机CVR服务异常
NET_SDK_ERR_RD_SERVICE_EXCETP = 811 # 备机CVR服务异常
NET_SDK_ERR_ADDED_WD_IS_RD = 812 # 添加的工作机是备机
NET_SDK_ERR_PERFORMANCE_LIMIT = 813 # 性能达到上限
NET_SDK_ERR_ADDED_DEVICE_EXIST = 814 # 添加的设备已经存在

# 审讯机错误码
NET_SDK_ERR_INQUEST_RESUMING = 815 # 审讯恢复中
NET_SDK_ERR_RECORD_BACKUPING = 816 # 审讯备份中
NET_SDK_ERR_DISK_PLAYING = 817 # 光盘回放中
NET_SDK_ERR_INQUEST_STARTED = 818 # 审讯已开启
NET_SDK_ERR_LOCAL_OPERATING = 819 # 本地操作进行中
NET_SDK_ERR_INQUEST_NOT_START = 820 # 审讯未开启
# Netra3.1.0错误码
NET_SDK_ERR_CHAN_AUDIO_BIND = 821 # 通道未绑定或绑定语音对讲失败
# 云存储错误码
NET_DVR_N_PLUS_ONE_MODE = 822 # 设备当前处于N+1模式
NET_DVR_CLOUD_STORAGE_OPENED = 823 # 云存储模式已开启

NET_DVR_ERR_OPER_NOT_ALLOWED = 824 # 设备处于N+0被接管状态，不允许该操作
NET_DVR_ERR_NEED_RELOCATE = 825 # 设备处于N+0被接管状态，需要获取重定向信息，再重新操作

# 庭审主机错误码
NET_SDK_ERR_IR_PORT_ERROR = 830 # 红外输出口错误
NET_SDK_ERR_IR_CMD_ERROR = 831 # 红外输出口的命令号错误
NET_SDK_ERR_NOT_INQUESTING = 832 # 设备处于非审讯状态
NET_SDK_ERR_INQUEST_NOT_PAUSED = 833 # 设备处于非暂停状态
NET_DVR_CHECK_PASSWORD_MISTAKE_ERROR = 834 # 校验密码错误
NET_DVR_CHECK_PASSWORD_NULL_ERROR = 835 # 校验密码不能为空
NET_DVR_UNABLE_CALIB_ERROR = 836 #  当前无法标定
NET_DVR_PLEASE_CALIB_ERROR = 837 # 请先完成标定
NET_DVR_ERR_PANORAMIC_CAL_EMPTY = 838 # Flash中全景标定为空
NET_DVR_ERR_CALIB_FAIL_PLEASEAGAIN = 839 # 标定失败，请重新标定(Calibration failed. Please calibrate again.)
NET_DVR_ERR_DETECTION_LINE = 840 # 规则线配置错误，请重新配置规则线，确保规则线位于红色区域内(Please set detection line again. The detection line should be within the red count area.)
NET_DVR_ERR_TURN_OFF_IMAGE_PARA = 841 # 请先关闭图像参数切换功能(Please turn off the image parameters switch first.)
NET_DVR_EXCEED_FACE_IMAGES_ERROR = 843 # 超过人脸图片最大张数
NET_DVR_ANALYSIS_FACE_IMAGES_ERROR = 844 # 图片数据识别失败
NET_ERR_ALARM_INPUT_OCCUPIED = 845 # A<-1报警号已用于触发车辆抓拍Alarm Input No. A<-1 is used to trigger vehicle capture.
NET_DVR_FACELIB_DATABASE_ERROR = 846 # 人脸库中数据库版本不匹配
NET_DVR_FACELIB_DATA_ERROR = 847 # 人脸库数据错误
NET_DVR_FACE_DATA_ID_ERROR = 848 # 人脸数据PID无效
NET_DVR_FACELIB_ID_ERROR = 849 # 人脸库ID无效
NET_DVR_EXCEED_FACE_LIBARY_ERROR = 850 # 超过人脸库最大个数
NET_DVR_PIC_ANALYSIS_NO_TARGET_ERROR = 851 # 图片未识别到目标
NET_DVR_SUBPIC_ANALYSIS_MODELING_ERROR = 852 # 子图建模失败
NET_DVR_PIC_ANALYSIS_NO_RESOURCE_ERROR = 853 # 无对应智能分析引擎支持图片二次识别
NET_DVR_ANALYSIS_ENGINES_NO_RESOURCE_ERROR = 854 # 无分析引擎资源
NET_DVR_ANALYSIS_ENGINES_USAGE_EXCEED_ERROR = 855 # 引擎使用率超负荷，已达100%
NET_DVR_EXCEED_HUMANMISINFO_FILTER_ENABLED_ERROR = 856 # 超过开启人体去误报最大通道个数
NET_DVR_NAME_ERROR = 857 # 名称错误
NET_DVR_NAME_EXIST_ERROR = 858 # 名称已存在
NET_DVR_FACELIB_PIC_IMPORTING_ERROR = 859 # 人脸库导入图片中
NET_DVR_ERR_CALIB_POSITION = 860 # 标定位置超出摄像机运动范围
NET_DVR_ERR_DELETE = 861 # 无法删除
NET_DVR_ERR_SCENE_ID = 862 # 场景ID无效
NET_DVR_ERR_CALIBING = 863 # 标定中
NET_DVR_PIC_FORMAT_ERROR = 864 # 图片格式错误
NET_DVR_PIC_RESOLUTION_INVALID_ERROR = 865 # 图片分辨率无效错误
NET_DVR_PIC_SIZE_EXCEED_ERROR = 866 # 图片过大
NET_DVR_PIC_ANALYSIS_TARGRT_NUM_EXCEED_ERROR = 867 # 图片目标个数超过上限
NET_DVR_ANALYSIS_ENGINES_LOADING_ERROR = 868 # 分析引擎初始化中
NET_DVR_ANALYSIS_ENGINES_ABNORMA_ERROR = 869 # 分析引擎异常
NET_DVR_ANALYSIS_ENGINES_FACELIB_IMPORTING = 870 # 分析引擎正在导入人脸库
NET_DVR_NO_DATA_FOR_MODELING_ERROR = 871 # 无待建模数据
NET_DVR_FACE_DATA_MODELING_ERROR = 872 # 设备正在进行图片建模操作，不支持并发处理
NET_ERR_FACELIBDATA_OVERLIMIT = 873 # 超过设备中支持导入人脸数最大个数限制（导入的人脸库中数据）
NET_DVR_ANALYSIS_ENGINES_ASSOCIATED_CHANNEL = 874 # 分析引擎已关联通道
NET_DVR_ERR_CUSTOMID_LEN = 875 # 上层自定义ID的长度最小32字符长度
NET_DVR_ERR_CUSTOMFACELIBID_REPEAT = 876 # 上层下发重复的自定义人脸库ID
NET_DVR_ERR_CUSTOMHUMANID_REPEAT = 877 # 上层下发重复的自定义人员ID
NET_DVR_ERR_URL_DOWNLOAD_FAIL = 878 # url下载失败
NET_DVR_ERR_URL_DOWNLOAD_NOTSTART = 879 # url未开始下载

NET_DVR_CFG_FILE_SECRETKEY_ERROR = 880 # 配置文件安全校验密钥错误
NET_DVR_WDR_NOTDISABLE_ERROR = 881 # 请先关闭所有通道当前日夜参数转换模式下的宽动态
NET_DVR_HLC_NOTDISABLE_ERROR = 882 # 请先关闭所有通道当前日夜参数转换模式下的强光抑制

NET_DVR_THERMOMETRY_REGION_OVERSTEP_ERROR = 883 # 测温区域越界


NET_DVR_ERR_MODELING_DEVICEINTERNAL = 884 # 建模失败，设备内部错误
NET_DVR_ERR_MODELING_FACE = 885 # 建模失败，人脸建模错误
NET_DVR_ERR_MODELING_FACEGRADING = 886 # 建模失败，人脸质量评分错误
NET_DVR_ERR_MODELING_FACEGFEATURE = 887 # 建模失败，特征点提取错误
NET_DVR_ERR_MODELING_FACEGANALYZING = 888 # 建模失败，属性提取错误

NET_DVR_ERR_STREAM_LIMIT = 889 # 码流性能超过上限，请减少取流路数
NET_DVR_ERR_STREAM_DESCRIPTION = 890 # 请输入码流描述
NET_DVR_ERR_STREAM_DELETE = 891 # 码流正在使用无法删除
NET_DVR_ERR_CUSTOMSTREAM_NAME = 892 # 自定义码流名称为空或不合法
NET_DVR_ERR_CUSTOMSTREAM_NOTEXISTED = 893 # 该自定义码流不存在

NET_DVR_ERR_TOO_SHORT_CALIBRATING_TIME = 894 # 标定时间太短
NET_DVR_ERR_AUTO_CALIBRATE_FAILED = 895 # 自动标定失败
NET_DVR_ERR_VERIFICATION_FAILED = 896 # 校验失败

NET_DVR_NO_TEMP_SENSOR_ERROR = 897 # 无温度传感器
NET_DVR_PUPIL_DISTANCE_OVERSIZE_ERROR = 898 # 瞳距过大
NET_DVR_ERR_UNOPENED_FACE_SNAP = 899 # 操作无效，请先开启人脸抓拍
# 2011-10-25多屏控制器错误码（900-950）
NET_ERR_CUT_INPUTSTREAM_OVERLIMIT = 900 # 信号源裁剪数值超限
NET_ERR_WINCHAN_IDX = 901 #  开窗通道号错误
NET_ERR_WIN_LAYER = 902 #  窗口层数错误，单个屏幕上最多覆盖的窗口层数
NET_ERR_WIN_BLK_NUM = 903 #  窗口的块数错误，单个窗口可覆盖的屏幕个数
NET_ERR_OUTPUT_RESOLUTION = 904 #  输出分辨率错误
NET_ERR_LAYOUT = 905 #  布局号错误
NET_ERR_INPUT_RESOLUTION = 906 #  输入分辨率不支持
NET_ERR_SUBDEVICE_OFFLINE = 907 #  子设备不在线
NET_ERR_NO_DECODE_CHAN = 908 #  没有空闲解码通道
NET_ERR_MAX_WINDOW_ABILITY = 909 #  开窗能力上限, 分布式多屏控制器中解码子设备能力上限或者显示处理器能力上限导致
NET_ERR_ORDER_ERROR = 910 #  调用顺序有误
NET_ERR_PLAYING_PLAN = 911 #  正在执行预案
NET_ERR_DECODER_USED = 912 #  解码板正在使用
NET_ERR_OUTPUT_BOARD_DATA_OVERFLOW = 913 #  输出板数据量超限
NET_ERR_SAME_USER_NAME = 914 #  用户名相同
NET_ERR_INVALID_USER_NAME = 915 #  无效用户名
NET_ERR_MATRIX_USING = 916 #  输入矩阵正在使用
NET_ERR_DIFFERENT_CHAN_TYPE = 917 #  通道类型不同（矩阵输出通道和控制器的输入为不同的类型）
NET_ERR_INPUT_CHAN_BINDED = 918 #  输入通道已经被其他矩阵绑定
NET_ERR_BINDED_OUTPUT_CHAN_OVERFLOW = 919 #  正在使用的矩阵输出通道个数超过矩阵与控制器绑定的通道个数
NET_ERR_MAX_SIGNAL_NUM = 920 #  输入信号源个数达到上限
NET_ERR_INPUT_CHAN_USING = 921 #  输入通道正在使用
NET_ERR_MANAGER_LOGON = 922 #  管理员已经登陆，操作失败
NET_ERR_USERALREADY_LOGON = 923 #  该用户已经登陆，操作失败
NET_ERR_LAYOUT_INIT = 924 #  布局正在初始化，操作失败
NET_ERR_BASEMAP_SIZE_NOT_MATCH = 925 #  底图大小不符
NET_ERR_WINDOW_OPERATING = 926 #  窗口正在执行其他操作，本次操作失败
NET_ERR_SIGNAL_UPLIMIT = 927 #  信号源开窗个数达到上限
NET_ERR_SIGNAL_MAX_ENLARGE_TIMES = 928 #  信号源放大倍数超限
NET_ERR_ONE_SIGNAL_MULTI_CROSS = 929 #  单个信号源不能多次跨屏
NET_ERR_ULTRA_HD_SIGNAL_MULTI_WIN = 930 #  超高清信号源不能重复开窗
NET_ERR_MAX_VIRTUAL_LED_WIDTH = 931 # 虚拟LED宽度大于限制值
NET_ERR_MAX_VIRTUAL_LED_WORD_LEN = 932 # 虚拟LED字符数大于限制值
NET_ERR_SINGLE_OUTPUTPARAM_CONFIG = 933 # 不支持单个显示输出参数设置
NET_ERR_MULTI_WIN_BE_COVER = 934 # 多分屏窗口被覆盖
NET_ERR_WIN_NOT_EXIST = 935 # 窗口不存在
NET_ERR_WIN_MAX_SIGNALSOURCE = 936 # 窗口信号源数超过限制值
NET_ERR_MULTI_WIN_MOVE = 937 # 对多分屏窗口移动
NET_ERR_MULTI_WIN_YPBPR_SDI = 938 #  YPBPR 和SDI信号源不支持9/16分屏
NET_ERR_DIFF_TYPE_OUTPUT_MIXUSE = 939 # 不同类型输出板混插
NET_ERR_SPLIT_WIN_CROSS = 940 # 对跨屏窗口分屏
NET_ERR_SPLIT_WIN_NOT_FULL_SCREEN = 941 # 对未满屏窗口分屏
NET_ERR_SPLIT_WIN_MANY_WIN = 942 # 对单个输出口上有多个窗口的窗口分屏
NET_ERR_WINDOW_SIZE_OVERLIMIT = 943 # 窗口大小超限
NET_ERR_INPUTSTREAM_ALREADY_JOINT = 944 # 信号源已加入拼接
NET_ERR_JOINT_INPUTSTREAM_OVERLIMIT = 945 # 拼接信号源个数超限

NET_ERR_LED_RESOLUTION = 946 # LED 分辨率大于输出分辨率
NET_ERR_JOINT_SCALE_OVERLIMIT = 947 # 拼接信号源的规模超限
NET_ERR_INPUTSTREAM_ALREADY_DECODE = 948 # 信号源已上墙
NET_ERR_INPUTSTREAM_NOTSUPPORT_CAPTURE = 949 # 信号源不支持抓图
NET_ERR_JOINT_NOTSUPPORT_SPLITWIN = 950 # 拼接信号源不支持分屏

# 解码器错误码（951-999）
NET_ERR_MAX_WIN_OVERLAP = 951 # 达到最大窗口重叠数
NET_ERR_STREAMID_CHAN_BOTH_VALID = 952 # stream ID和通道号同时有效
NET_ERR_NO_ZERO_CHAN = 953 # 设备无零通道
NEED_RECONNECT = 955 # 需要重定向（转码子系统使用）
NET_ERR_NO_STREAM_ID = 956 # 流ID不存在
NET_DVR_TRANS_NOT_START = 957 # 转码未启动
NET_ERR_MAXNUM_STREAM_ID = 958 # 流ID数达到上限
NET_ERR_WORKMODE_MISMATCH = 959 # 工作模式不匹配
NET_ERR_MODE_IS_USING = 960 # 已工作在当前模式
NET_ERR_DEV_PROGRESSING = 961 # 设备正在处理中
NET_ERR_PASSIVE_TRANSCODING = 962 # 正在被动转码

NET_ERR_RING_NOT_CONFIGURE = 964 # 环网未配置

NET_ERR_CLOSE_WINDOW_FIRST = 971 # 切换全帧率畅显时必须先关闭对应的已上墙的窗口
NET_ERR_SPLIT_WINDOW_NUM_NOT_SUPPORT = 972 # VGA/DVI/DP/HDMI/HDBase_T输入源在全帧率畅显下不支持9/16画面
NET_ERR_REACH_ONE_SIGNAL_PREVIEW_MAX_LINK = 973 # 单信号源回显连接数量超限
NET_ERR_ONLY_SPLITWND_SUPPORT_AMPLIFICATION = 974 # 只有分屏窗口支持子窗口放大
NET_DVR_ERR_WINDOW_SIZE_PLACE = 975 # 窗口位置错误
NET_DVR_ERR_RGIONAL_RESTRICTIONS = 976 # 屏幕距离超限
NET_ERR_WNDZOOM_NOT_SUPPORT = 977 # 单窗口不支持子窗口全屏功能
NET_ERR_LED_SCREEN_SIZE = 978 # LED屏宽高不正确
NET_ERR_OPEN_WIN_IN_ERROR_AREA = 979 # 在非法区域开窗(包括跨LCD/LED屏)
NET_ERR_TITLE_WIN_NOT_SUPPORT_MOVE = 980 # 平铺模式不支持漫游
NET_ERR_TITLE_WIN_NOT_SUPPORT_COVER = 981 # 平铺模式不支持图层覆盖
NET_ERR_TITLE_WIN_NOT_SUPPORT_SPLIT = 982 # 平铺模式不支持分屏
NET_DVR_LED_WINDOWS_ALREADY_CLOSED = 983 # LED区域内输出口的分辨率发生变化，设备已关闭该区域内的所有LED窗口
NET_DVR_ERR_CLOSE_WINDOWS = 984 # 操作失败，请先关闭窗口
NET_DVR_ERR_MATRIX_LOOP_ABILITY = 985 # 超出轮巡解码能力限制
NET_DVR_ERR_MATRIX_LOOP_TIME = 986 # 轮巡解码时间不支持
NET_DVR_ERR_LINKED_OUT_ABILITY = 987 # 联动通道数超过上限
NET_ERR_REACH_SCENE_MAX_NUM = 988 # 场景数量达到上限
NET_ERR_SCENE_MEM_NOT_ENOUGH = 989 # 内存不足，无法新建场景
NET_ERR_RESOLUTION_NOT_SUPPORT_ODD_VOUT = 990 # 奇口不支持该分辨率
NET_ERR_RESOLUTION_NOT_SUPPORT_EVEN_VOUT = 991 # 偶口不支持该分辨率

NET_DVR_CANCEL_WND_OPENKEEP_ATTR_FIRST = 992 # 常开窗口需要先取消常开属性才能被关闭
NET_SDK_LED_MODE_NOT_SUPPORT_SPLIT = 993 # LED模式下不支持窗口分屏
NET_ERR_VOICETALK_ONLY_SUPPORT_ONE_TALK = 994 # 同时只支持一路语音对讲
NET_ERR_WND_POSITION_ADJUSTED = 995 # 窗口位置被设备调整，上层需要重新获取下窗口位置
NET_SDK_ERR_STARTTIME_CANNOT_LESSTHAN_CURTIME = 996 # 开始时间不能小于当前时间
NET_SDK_ERR_NEED_ADJUST_PLAN = 997 # 场景已被预案关联，请先将该场景从预案中删除
NET_ERR_UnitConfig_Failed = 998 # 当“启用单位统一”勾选时，测温下配置的单位与系统设置下的单位不同返回单位配置错误

# 能力集解析库错误码
XML_ABILITY_NOTSUPPORT = 1000 # 不支持能力节点获取
XML_ANALYZE_NOENOUGH_BUF = 1001 # 输出内存不足
XML_ANALYZE_FIND_LOCALXML_ERROR = 1002 # 无法找到对应的本地xml
XML_ANALYZE_LOAD_LOCALXML_ERROR = 1003 # 加载本地xml出错
XML_NANLYZE_DVR_DATA_FORMAT_ERROR = 1004 # 设备能力数据格式错误
XML_ANALYZE_TYPE_ERROR = 1005 # 能力集类型错误
XML_ANALYZE_XML_NODE_ERROR = 1006 # XML能力节点格式错误
XML_INPUT_PARAM_ERROR = 1007 # 输入的能力XML节点值错误

NET_DVR_ERR_RETURNED_XML_DATA = 1008 # 设备返回的XML数据有误

# 传显错误码
NET_ERR_LEDAREA_EXIST_WINDOW = 1051 # LED区域有窗口存在(如果LED区域上已经有窗口存在，不允许修改LED区域）
NET_ERR_AUDIO_EXIST = 1052 # 输出口上存在音频输出，不允许解除绑定
NET_ERR_MATERIAL_NAME_EXIST = 1053 # 素材名称已存在
NET_ERR_MATERIAL_APPROVE_STATE = 1054 # 素材审核状态错误
NET_ERR_DATAHD_SIGNAL_FORMAT = 1055 # 已使用的硬盘不允许单个格式化

NET_ERR_SCENE_SWITCHING = 1056 # 场景正在切换
NER_ERR_DATA_TRANSFER = 1057 # 设备正在数据转移中
NET_ERR_DATA_RESTORE = 1058 # 设备正在数据还原中
NET_ERR_CHECK_NOT_ENABLE = 1059 # 校正使能未开启
NET_ERR_AREA_OFFLINE = 1060 # 区域不在线
NET_ERR_SCREEN_TYPE = 1061 # 屏幕类型不匹配
NET_ERR_MIN_OPERATE_UNIT = 1062 # 最小操作单元不匹配
NET_ERR_MAINHD_NOT_BACKUP = 1063 # 第一槽位上的普通盘（主盘）禁止设置成备份盘
NET_ERR_ONE_BACKUP_HD = 1064 # 设置备份盘时，设备至少有一块普通盘
NET_ERR_CONNECT_SUB_SYSTEM_ABNORMAL = 1065 # 连接子系统异常
NET_ERR_SERIAL_PORT_VEST = 1066 # 错误的串口归属
NET_ERR_WHITE_LIST_FULL = 1067 # 白名单列表数量已满
NET_ERR_NOT_MATCH_SOURCE = 1068 # 不匹配的信号源类型
NET_ERR_CLOCK_VIRTUAL_LED_FULL = 1069 # 开启时钟功能的虚拟LED达上限
NET_ERR_MAX_WIN_SIGNAL_LOOP_NUM = 1070 # 窗口轮巡信号源个数已达上限
NET_ERR_RESOLUTION_NO_MATCH_FRAME = 1071 # 分辨率与当前帧数不匹配
NET_ERR_NOT_UPDATE_LOW_VERSION = 1072 # 不支持向低版本升级
NET_ERR_NO_CUSTOM_TO_UPDATE = 1073 # 非定制程序无法升级
NET_ERR_CHAN_RESOLUTION_NOT_SUPPORT_SPLIT = 1074 # 该输出口分辨率不支持分屏
NET_ERR_HIGH_DEFINITION_NOT_SUPPORT_SPLIT = 1075 # 超高清不支持9/16画面分割
NET_ERR_MIRROR_IMAGE_BY_VIDEO_WALL = 1076 # 电视墙镜像出错
NET_ERR_MAX_OSD_FONT_SIZE = 1077 # 超过OSD最大支持字符数
NET_ERR_HIGH_DEFINITION_NOT_SUPPORT_VIDEO_SET = 1078 # 超清不支持视频参数设置
NET_ERR_TILE_MODE_NOT_SUPPORT_JOINT = 1079 # 平铺模式不支持拼接窗口
NET_ERR_ADD_AUDIO_MATRIX_FAILED = 1080 # 创建音频矩阵失败
NET_ERR_ONE_VIRTUAL_LED_AREA_BIND_ONE_AUDIO_AREA = 1081 # 一个虚拟LED区域只能绑定一个音频区域
NET_ERR_NAT_NOT_MODIFY_SERVER_NETWORK_PARAM = 1082 # NAT下无法修改服务器网络参数
NET_ERR_ORIGINAL_CHECH_DATA_ERROR = 1083 # 原始校正数据错误
NET_ERR_INPUT_BOARD_SPLICED_IN_DIFFERENT_NETWORKAREAS = 1084 # 不同网络区域的输入板不能拼接
NET_ERR_SPLICINGSOURCE_ONWALL_IN_DIFFERENT_NETWORKAREAS = 1085 # 不同网络区域的拼接源不能上墙
NET_ERR_ONWALL_OUTPUTBOARD_MODIFY_NETWORKAREAS = 1086 # 已绑定在电视墙上的输出板不能修改网络区域
NET_ERR_LAN_AND_WAN_CANNOT_SAME_NET_SEGMENT = 1087 # LAN口IP和WAN口IP不能处于同一网段
NET_ERR_USERNAME_REPETITIVE = 1088 # 用户名重复
NET_ERR_ASSOCIATED_SAMEWALL_IN_DIFFERENT_NETWORKAREAS = 1089 # 不同数据网络区域的输出口不能关联到同一电视墙
NET_ERR_BASEMAP_ROAM_IN_LED_AREA = 1090 # LED区域不允许底图漫游
NET_ERR_VIRTUAL_LED_NOT_SUPPORT_4K_OUTPUT = 1091 # 虚拟LED不支持4K输出口显示
NET_ERR_BASEMAP_NOT_SUPPORT_4K_OUTPUT = 1092 # 底图不支持4K输出口显示
NET_ERR_MIN_BLOCK_IN_VIRTUAL_LED_AND_OUTPUT = 1093 # 虚拟LED与输出口相交出现最小块
NET_ERR_485FIlE_VERSION_INVALID = 1094 # 485文件版本无效
NET_ERR_485FIlE_CHECK_ERROR = 1095 # 485文件校验错误
NET_ERR_485FIlE_ABNORMAL_SIZE = 1096 # 485文件大小异常效
NET_ERR_MODIFY_SUBBOARD_NETCFG_IN_NAT = 1097 # NAT下无法修改子板网络参
NET_ERR_OSD_CONTENT_WITH_ILLEGAL_CHARACTERS = 1098 # OSD内容包含非法字符
NET_ERR_NON_SLAVE_DEVICE_INSERT_SYNC_LINE = 1099 # 非从设备禁止插入同步线
# 民用错误码（1100～1200）
NET_ERR_PLT_USERID = 1100 # 验证平台userid错误
NET_ERR_TRANS_CHAN_START = 1101 # 透明通道已打开，当前操作无法完成
NET_ERR_DEV_UPGRADING = 1102 # 设备正在升级
NET_ERR_MISMATCH_UPGRADE_PACK_TYPE = 1103 # 升级包类型不匹配
NET_ERR_DEV_FORMATTING = 1104 # 设备正在格式化
NET_ERR_MISMATCH_UPGRADE_PACK_VERSION = 1105 # 升级包版本不匹配
NET_ERR_PT_LOCKED = 1106 # PT锁定功能

NET_DVR_LOGO_OVERLAY_WITHOUT_UPLOAD_PIC = 1110 # logo叠加失败，没有上传logo图片
NET_DVR_ERR_ILLEGAL_VERIFICATION_CODE = 1111 # 不合法验证码
NET_DVR_ERR_LACK_VERIFICATION_CODE = 1112 # 缺少验证码
NET_DVR_ERR_FORBIDDEN_IP = 1113 # 该IP地址已被禁止，不允许配置(设备支持的IP地址过滤功能)
NET_DVR_ERR_UNLOCKPTZ = 1114 # 操作无效，请先锁定云台
NET_DVR_ERR_COUNTAREA_LARGE = 1116 # 计数区域绘制错误，区域面积大于设备允许值
NET_DVR_ERR_LABEL_ID_EXCEED = 1117 # 标签ID超限
NET_DVR_ERR_LABEL_TYPE = 1118 # 标签类型错误
NET_DVR_ERR_LABEL_FULL = 1119 # 标签满
NET_DVR_ERR_LABEL_DISABLED = 1120 # 标签未使能
NET_DVR_ERR_DOME_PT_TRANS_TO_DOME_XY = 1121 # 球机PT转球机XY失败
NET_DVR_ERR_DOME_PT_TRANS_TO_PANORAMA_XY = 1122 # 球机PT转全景XY失败
NET_DVR_ERR_PANORAMA_XY_TRANS_TO_DOME_PT = 1123 # 全景XY坐标转球机PT错误
NET_DVR_ERR_SCENE_DUR_TIME_LESS_THAN_INTERV_TIME = 1124 # 场景停留时间要大于检测周期
NET_DVR_ERR_HTTP_BKN_EXCEED_ONE = 1125 # 断网续传布防只支持一路
NET_DVR_ERR_DELETING_FAILED_TURN_OFF_HTTPS_ESDK_WEBSOCKETS_FIRST = 1126 # 删除失败，请先关闭HTTPS和网络服务中的增强型SDK服务及WebSockets服务。
NET_DVR_ERR_DELETING_FAILED_TURN_OFF_HTTPS_ESDK_FIRST = 1127 # 删除失败，请先关闭HTTPS和网络服务中的增强型SDK服务
NET_DVR_ERR_PTZ_OCCUPIED_PRIORITY = 1128 #  有高优先级云台控制权限用户操作
NET_DVR_ERR_INCORRECT_VIDEOAUDIO_ID = 1129 #  视频通道编码ID或语音输出通道编码ID错误
NET_DVR_ERR_REPETITIONTIME_OVER_MAXIMUM = 1130 #  去重时间最大不超过最大值
NET_DVR_ERR_FORMATTING_FAILED = 1131 #  格式化错误，请重新
NET_DVR_ERR_ENCRYPTED_FORMATTING_FAILED = 1132 #  加密格式化失败，请重试
NET_DVR_ERR_WRONG_PASSWORD = 1133 #  密码错误,请输入正确的密码（SD卡 密码校验失败）
NET_DVR_ERR_EXPOSURE_SYNC = 1134 #  镜头间曝光同步已开启，不允许配置手动RGB

# 2012-10-16 报警设备错误码（1200~1300）
NET_ERR_SEARCHING_MODULE = 1201 #  正在搜索外接模块
NET_ERR_REGISTERING_MODULE = 1202 #  正在注册外接模块
NET_ERR_GETTING_ZONES = 1203 #  正在获取防区参数
NET_ERR_GETTING_TRIGGERS = 1204 #  正在获取触发器
NET_ERR_ARMED_STATUS = 1205 #  系统处于布防状态
NET_ERR_PROGRAM_MODE_STATUS = 1206 #  系统处于编程模式
NET_ERR_WALK_TEST_MODE_STATUS = 1207 #  系统处于步测模式
NET_ERR_BYPASS_STATUS = 1208 #  旁路状态
NET_ERR_DISABLED_MODULE_STATUS = 1209 #  功能未使能
NET_ERR_NOT_SUPPORT_OPERATE_ZONE = 1210 #  防区不支持该操作
NET_ERR_NOT_SUPPORT_MOD_MODULE_ADDR = 1211 #  模块地址不能被修改
NET_ERR_UNREGISTERED_MODULE = 1212 #  模块未注册
NET_ERR_PUBLIC_SUBSYSTEM_ASSOCIATE_SELF = 1213 #  公共子系统关联自身
NET_ERR_EXCEEDS_ASSOCIATE_SUBSYSTEM_NUM = 1214 #  超过公共子系统最大关联个数
NET_ERR_BE_ASSOCIATED_BY_PUBLIC_SUBSYSTEM = 1215 #  子系统被其他公共子系统关联
NET_ERR_ZONE_FAULT_STATUS = 1216 #  防区处于故障状态
NET_ERR_SAME_EVENT_TYPE = 1217 #  事件触发报警输出开启和事件触发报警输出关闭中有相同事件类型
NET_ERR_ZONE_ALARM_STATUS = 1218 #  防区处于报警状态
NET_ERR_EXPANSION_BUS_SHORT_CIRCUIT = 1219 # 扩展总线短路
NET_ERR_PWD_CONFLICT = 1220 # 密码冲突
NET_ERR_DETECTOR_GISTERED_BY_OTHER_ZONE = 1221 # 探测器已被其他防区注册
NET_ERR_DETECTOR_GISTERED_BY_OTHER_PU = 1222 # 探测器已被其他主机注册
NET_ERR_DETECTOR_DISCONNECT = 1223 # 探测器不在线
NET_ERR_CALL_BUSY = 1224 # 设备正在通话中
NET_DVR_ERR_ZONE_TAMPER_STAUS = 1225 # 防区处于防拆状态
NET_DVR_ERR_WIRELESS_DEV_REGISTER = 1226 # 无线外设已被其他主机注册
NET_DVR_ERR_WIRELESS_DEV_ADDED = 1227 # 无线外设已被添加
NET_DVR_ERR_WIRELESS_DEV_OFFLINE = 1228 # 无线外设不在线
NET_DVR_ERR_WIRELESS_DEV_TAMPER_STATUS = 1229 # 无线外设处于防拆状态
NET_DVR_ERR_GPRS_PHONE_CONFLICT = 1230 # 电话报警与无线报警中心冲突
# 信息发布主机
NET_ERR_GET_ALL_RETURN_OVER = 1300 # 获取所有返回数目超限
NET_ERR_RESOURCE_USING = 1301 # 信息发布资源正在使用，不能修改
NET_ERR_FILE_SIZE_OVERLIMIT = 1302 # 文件大小超限

# 信息发布服务器错误码
NET_ERR_MATERIAL_NAME = 1303 # 素材名称非法
NET_ERR_MATERIAL_NAME_LEN = 1304 # 素材名称长度非法
NET_ERR_MATERIAL_REMARK = 1305 # 素材描述非法
NET_ERR_MATERIAL_REMARK_LEN = 1306 # 素材描述长度非法
NET_ERR_MATERIAL_SHARE_PROPERTY = 1307 # 素材共享属性非法
NET_ERR_UNSUPPORT_MATERIAL_TYPE = 1308 # 素材类型不支持
NET_ERR_MATERIAL_NOT_EXIST = 1309 # 素材不存在
NET_ERR_READ_FROM_DISK = 1310 # 从硬盘读取素材文件失败
NET_ERR_WRITE_TO_DISK = 1311 # 向硬盘写素材文件失败
NET_ERR_WRITE_DATA_BASE = 1312 # 素材写数据库失败
NET_ERR_NO_APPROVED_NOT_EXPORT = 1313 # 未审核内容禁止发布
NET_ERR_MATERIAL_EXCEPTION = 1314 # 素材异常
NET_ERR_NO_MISINFO = 1315 # 无误报信息
NET_ERR_LAN_NOT_SUP_DHCP_CLIENT_CONFIGURATION = 1316 # 网桥在路由模式下，配置DHCP客户端返回错误
NET_ERR_VIDEOWALL_OPTPORT_RESOLUTION_INCONSISTENT = 1317 # 电视墙上各输出口分辨率不一致(主要用于设置输出分辨率为4K出现异常时报错)
NET_ERR_VIDEOWALL_OPTPORT_RESOLUTION_INCONSISTENT_UNBIND_OPTPORT_FIRST = 1318 # 电视墙上各输出口分辨率不一致，请先解绑定输出口(主要用于绑定输出口出现异常时报错)
NET_ERR_FOUR_K_OUTPUT_RESOLUTION_UNSUPPORT_NINE_TO_SIXTEEN_SPLIT_SCREEN = 1319 # 4K输出分辨率不支持9/16分屏
NET_ERR_SIGNAL_SOURCE_UNSUPPORT_CUSTOM_RESOLUTION = 1320 # 信号源不支持该自定义分辨率
NET_ERR_DVI_UNSUPPORT_FOURK_OUTPUT_RESOLUTION = 1321 # DVI不支持4K输出分辨率
NET_ERR_BNC_UNSUPPORT_SOURCE_CROPPING = 1322 # BNC不支持信号源裁剪

# 多屏互动错误码
NET_ERR_MAX_SCREEN_CTRL_NUM = 1351 # 屏幕控制连接数达到上限
NET_ERR_FILE_NOT_EXIST = 1352 # 文件不存在
NET_ERR_THUMBNAIL_NOT_EXIST = 1353 # 缩略图不存在
NET_ERR_DEV_OPEN_FILE_FAIL = 1354 # 设备端打开文件失败
NET_ERR_SERVER_READ_FILE_FAIL = 1355 # 设备端读取文件失败
NET_ERR_FILE_SIZE = 1356 # 文件大小错误
NET_ERR_FILE_NAME = 1357 # 文件名称错误，为空或不合法

# 分段错误码（1351-1400）
NET_ERR_BROADCAST_BUSY = 1358 # 设备正在广播中

# 2012-12-20抓拍机错误码（1400-1499）
NET_DVR_ERR_LANENUM_EXCEED = 1400 # 车道数超出能力
NET_DVR_ERR_PRAREA_EXCEED = 1401 # 牌识区域过大
NET_DVR_ERR_LIGHT_PARAM = 1402 # 信号灯接入参数错误
NET_DVR_ERR_LANE_LINE_INVALID = 1403 # 车道线配置错误
NET_DVR_ERR_STOP_LINE_INVALID = 1404 # 停止线配置错误
NET_DVR_ERR_LEFTORRIGHT_LINE_INVALID = 1405 # 左/右转分界线配置错误
NET_DVR_ERR_LANE_NO_REPEAT = 1406 # 叠加车道号重复
NET_DVR_ERR_PRAREA_INVALID = 1407 # 牌识多边形不符合要求
NET_DVR_ERR_LIGHT_NUM_EXCEED = 1408 # 视频检测交通灯信号灯数目超出最大值
NET_DVR_ERR_SUBLIGHT_NUM_INVALID = 1409 # 视频检测交通灯信号灯子灯数目不合法
NET_DVR_ERR_LIGHT_AREASIZE_INVALID = 1410 # 视频检测交通灯输入信号灯框大小不合法
NET_DVR_ERR_LIGHT_COLOR_INVALID = 1411 # 视频检测交通灯输入信号灯颜色不合法
NET_DVR_ERR_LIGHT_DIRECTION_INVALID = 1412 # 视频检测交通灯输入灯方向属性不合法
NET_DVR_ERR_LACK_IOABLITY = 1413 # IO口实际支持的能力不足

NET_DVR_ERR_FTP_PORT = 1414 # FTP端口号非法（端口号重复或者异常）
NET_DVR_ERR_FTP_CATALOGUE = 1415 # FTP目录名非法（启用多级目录，多级目录传值为空）
NET_DVR_ERR_FTP_UPLOAD_TYPE = 1416 # FTP上传类型非法（单ftp只支持全部/双ftp只支持卡口和违章）
NET_DVR_ERR_FLASH_PARAM_WRITE = 1417 # 配置参数时写FLASH失败
NET_DVR_ERR_FLASH_PARAM_READ = 1418 # 配置参数时读FLASH失败
NET_DVR_ERR_PICNAME_DELIMITER = 1419 # FTP图片命名分隔符非法
NET_DVR_ERR_PICNAME_ITEM = 1420 # FTP图片命名项非法（例如 分隔符）
NET_DVR_ERR_PLATE_RECOGNIZE_TYPE = 1421 # 牌识区域类型非法 （矩形和多边形有效性校验）
NET_DVR_ERR_CAPTURE_TIMES = 1422 # 抓拍次数非法 （有效值是0～5）
NET_DVR_ERR_LOOP_DISTANCE = 1423 # 线圈距离非法 （有效值是0～2000ms）
NET_DVR_ERR_LOOP_INPUT_STATUS = 1424 # 线圈输入状态非法 （有效值）
NET_DVR_ERR_RELATE_IO_CONFLICT = 1425 # 测速组IO关联冲突
NET_DVR_ERR_INTERVAL_TIME = 1426 # 连拍间隔时间非法 （0～6000ms）
NET_DVR_ERR_SIGN_SPEED = 1427 # 标志限速值非法（大车标志限速不能大于小车标志限速 ）
NET_DVR_ERR_PIC_FLIP = 1428 # 图像配置翻转 （配置交互影响）
NET_DVR_ERR_RELATE_LANE_NUMBER = 1429 # 关联车道数错误 (重复 有效值校验1～99)
NET_DVR_ERR_TRIGGER_MODE = 1430 # 配置抓拍机触发模式非法
NET_DVR_ERR_DELAY_TIME = 1431 # 触发延时时间错误(2000ms)
NET_DVR_ERR_EXCEED_RS485_COUNT = 1432 # 超过最大485个数限制
NET_DVR_ERR_RADAR_TYPE = 1433 # 雷达类型错误
NET_DVR_ERR_RADAR_ANGLE = 1434 # 雷达角度错误
NET_DVR_ERR_RADAR_SPEED_VALID_TIME = 1435 # 雷达有效时间错误
NET_DVR_ERR_RADAR_LINE_CORRECT = 1436 # 雷达线性矫正参数错误
NET_DVR_ERR_RADAR_CONST_CORRECT = 1437 # 雷达常量矫正参数错误
NET_DVR_ERR_RECORD_PARAM = 1438 # 录像参数无效（预录时间不超过10s）
NET_DVR_ERR_LIGHT_WITHOUT_COLOR_AND_DIRECTION = 1439 # 视频检测信号灯配置信号灯个数，但是没有勾选信号灯方向和颜色的
NET_DVR_ERR_LIGHT_WITHOUT_DETECTION_REGION = 1440 # 视频检测信号灯配置信号灯个数，但是没有画检测区域
NET_DVR_ERR_RECOGNIZE_PROVINCE_PARAM = 1441 # 牌识参数省份参数的合法性

NET_DVR_ERR_SPEED_TIMEOUT = 1442 # IO测速超时时间非法（有效值大于0）
NET_DVR_ERR_NTP_TIMEZONE = 1443 # ntp时区参数错误
NET_DVR_ERR_NTP_INTERVAL_TIME = 1444 # ntp校时间隔错误
NET_DVR_ERR_NETWORK_CARD_NUM = 1445 # 可配置网卡数目错误
NET_DVR_ERR_DEFAULT_ROUTE = 1446 # 默认路由错误
NET_DVR_ERR_BONDING_WORK_MODE = 1447 # bonding网卡工作模式错误
NET_DVR_ERR_SLAVE_CARD = 1448 # slave网卡错误
NET_DVR_ERR_PRIMARY_CARD = 1449 # Primary网卡错误
NET_DVR_ERR_DHCP_PPOE_WORK = 1450 # dhcp和pppoE不能同时启动
NET_DVR_ERR_NET_INTERFACE = 1451 # 网络接口错误
NET_DVR_ERR_MTU = 1452 # MTU错误
NET_DVR_ERR_NETMASK = 1453 # 子网掩码错误
NET_DVR_ERR_IP_INVALID = 1454 # IP地址不合法
NET_DVR_ERR_MULTICAST_IP_INVALID = 1455 # 多播地址不合法
NET_DVR_ERR_GATEWAY_INVALID = 1456 # 网关不合法
NET_DVR_ERR_DNS_INVALID = 1457 # DNS不合法
NET_DVR_ERR_ALARMHOST_IP_INVALID = 1458 # 告警主机地址不合法
NET_DVR_ERR_IP_CONFLICT = 1459 # IP冲突
NET_DVR_ERR_NETWORK_SEGMENT = 1460 # IP不支持同网段
NET_DVR_ERR_NETPORT = 1461 # 端口错误

NET_DVR_ERR_PPPOE_NOSUPPORT = 1462 # PPPOE不支持
NET_DVR_ERR_DOMAINNAME_NOSUPPORT = 1463 # 域名不支持
NET_DVR_ERR_NO_SPEED = 1464 # 未启用测速功能
NET_DVR_ERR_IOSTATUS_INVALID = 1465 # IO状态错误
NET_DVR_ERR_BURST_INTERVAL_INVALID = 1466 # 连拍间隔非法
NET_DVR_ERR_RESERVE_MODE = 1467 # 备用模式错误

NET_DVR_ERR_LANE_NO = 1468 # 叠加车道号错误
NET_DVR_ERR_COIL_AREA_TYPE = 1469 # 线圈区域类型错误
NET_DVR_ERR_TRIGGER_AREA_PARAM = 1470 # 触发区域参数错误
NET_DVR_ERR_SPEED_LIMIT_PARAM = 1471 # 违章限速参数错误
NET_DVR_ERR_LANE_PROTOCOL_TYPE = 1472 # 车道关联协议类型错误

NET_DVR_ERR_INTERVAL_TYPE = 1473 # 连拍间隔类型非法
NET_DVR_ERR_INTERVAL_DISTANCE = 1474 # 连拍间隔距离非法
NET_DVR_ERR_RS485_ASSOCIATE_DEVTYPE = 1475 # RS485关联类型非法
NET_DVR_ERR_RS485_ASSOCIATE_LANENO = 1476 # RS485关联车道号非法
NET_DVR_ERR_LANENO_ASSOCIATE_MULTIRS485 = 1477 # 车道号关联多个RS485口
NET_DVR_ERR_LIGHT_DETECTION_REGION = 1478 # 视频检测信号灯配置信号灯个数，但是检测区域宽或高为0

NET_DVR_ERR_DN2D_NOSUPPORT = 1479 # 不支持抓拍帧2D降噪
NET_DVR_ERR_IRISMODE_NOSUPPORT = 1480 # 不支持的镜头类型
NET_DVR_ERR_WB_NOSUPPORT = 1481 # 不支持的白平衡模式
NET_DVR_ERR_IO_EFFECTIVENESS = 1482 # IO口的有效性
NET_DVR_ERR_LIGHTNO_MAX = 1483 # 信号灯检测器接入红/黄灯超限(16)
NET_DVR_ERR_LIGHTNO_CONFLICT = 1484 # 信号灯检测器接入红/黄灯冲突

NET_DVR_ERR_CANCEL_LINE = 1485 # 直行触发线
NET_DVR_ERR_STOP_LINE = 1486 # 待行区停止线
NET_DVR_ERR_RUSH_REDLIGHT_LINE = 1487 # 闯红灯触发线
NET_DVR_ERR_IOOUTNO_MAX = 1488 # IO输出口编号越界

NET_DVR_ERR_IOOUTNO_AHEADTIME_MAX = 1489 # IO输出口提前时间超限
NET_DVR_ERR_IOOUTNO_IOWORKTIME = 1490 # IO输出口有效持续时间超限
NET_DVR_ERR_IOOUTNO_FREQMULTI = 1491 # IO输出口脉冲模式下倍频出错
NET_DVR_ERR_IOOUTNO_DUTYRATE = 1492 # IO输出口脉冲模式下占空比出错
NET_DVR_ERR_VIDEO_WITH_EXPOSURE = 1493 # 以曝闪起效，工作方式不支持视频
NET_DVR_ERR_PLATE_BRIGHTNESS_WITHOUT_FLASHDET = 1494 # 车牌亮度自动使能闪光灯仅在车牌亮度补偿模式下起效

NET_DVR_ERR_RECOGNIZE_TYPE_PARAM = 1495 # 识别类型非法 车牌识别参数（如大车、小车、背向、正向、车标识别等）
NET_DVR_ERR_PALTE_RECOGNIZE_AREA_PARAM = 1496 # 牌识参数非法 牌识区域配置时判断出错
NET_DVR_ERR_PORT_CONFLICT = 1497 # 端口有冲突
NET_DVR_ERR_LOOP_IP = 1498 # IP不能设置为回环地址
NET_DVR_ERR_DRIVELINE_SENSITIVE = 1499 # 压线灵敏度出错(视频电警模式下)


# 2013-3-6VQD错误码（1500～1550）
NET_ERR_VQD_TIME_CONFLICT = 1500 # VQD诊断时间段冲突
NET_ERR_VQD_PLAN_NO_EXIST = 1501 # VQD诊断计划不存在
NET_ERR_VQD_CHAN_NO_EXIST = 1502 # VQD监控点不存在
NET_ERR_VQD_CHAN_MAX = 1503 # VQD计划数已达上限
NET_ERR_VQD_TASK_MAX = 1504 # VQD任务数已达上限

NET_SDK_GET_INPUTSTREAMCFG = 1551 # 获取信号源
NET_SDK_AUDIO_SWITCH_CONTROL = 1552 # 子窗口音频开关控制
NET_SDK_GET_VIDEOWALLDISPLAYNO = 1553 # 获取设备显示输出号
NET_SDK_GET_ALLSUBSYSTEM_BASIC_INFO = 1554 # 获取所有子系统基本信息
NET_SDK_SET_ALLSUBSYSTEM_BASIC_INFO = 1555 # 设置所有子系统基本信息
NET_SDK_GET_AUDIO_INFO = 1556 # 获取所有音频信息
NET_SDK_GET_MATRIX_STATUS_V50 = 1557 #  获取视频综合平台状态_V50
NET_SDK_DELETE_MONITOR_INFO = 1558 # 删除Monitor信息
NET_SDK_DELETE_CAMERA_INFO = 1559 # 删除Camaera信息


# 抓拍机错误码新增扩展(1600~1900)
NET_DVR_ERR_EXCEED_MAX_CAPTURE_TIMES = 1600 # 抓拍模式为频闪时最大抓拍张数为2张(IVT模式下)
NET_DVR_ERR_REDAR_TYPE_CONFLICT = 1601 # 相同485口关联雷达类型冲突
NET_DVR_ERR_LICENSE_PLATE_NULL = 1602 # 车牌号为空
NET_DVR_ERR_WRITE_DATABASE = 1603 # 写入数据库失败
NET_DVR_ERR_LICENSE_EFFECTIVE_TIME = 1604 # 车牌有效时间错误
# 视频电警
NET_DVR_ERR_PRERECORDED_STARTTIME_LONG = 1605 # 预录开始时间大于违法抓拍张数
# 混合卡口
NET_DVR_ERR_TRIGGER_RULE_LINE = 1606 # 触发规则线错误
NET_DVR_ERR_LEFTRIGHT_TRIGGERLINE_NOTVERTICAL = 1607 # 左/右触发线不垂直
NET_DVR_ERR_FLASH_LAMP_MODE = 1608 # 闪光灯闪烁模式错误
NET_DVR_ERR_ILLEGAL_SNAPSHOT_NUM = 1609 # 违章抓拍张数错误
NET_DVR_ERR_ILLEGAL_DETECTION_TYPE = 1610 # 违章检测类型错误
NET_DVR_ERR_POSITIVEBACK_TRIGGERLINE_HIGH = 1611 # 正背向触发线高度错误
NET_DVR_ERR_MIXEDMODE_CAPTYPE_ALLTARGETS = 1612 # 混合模式下只支持机非人抓拍类型

NET_DVR_ERR_CARSIGNSPEED_GREATERTHAN_LIMITSPEED = 1613 # 小车标志限速大于限速值
NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_LIMITSPEED = 1614 # 大车标志限速大于限速值
NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_CARSIGNSPEED = 1615 # 大车标志限速大于小车标志限速值
NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_CARLIMITSPEED = 1616 # 大车限速值大于小车限速值
NET_DVR_ERR_BIGCARLOWSPEEDLIMIT_GREATERTHAN_CARLOWSPEEDLIMIT = 1617 # 大车低速限速值大于小车低速限速值
NET_DVR_ERR_CARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED = 1618 # 小车限速大于异常高速值
NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED = 1619 # 大车限速大于异常高速值
NET_DVR_ERR_STOPLINE_MORETHAN_TRIGGERLINE = 1620 # 停止线超过直行触发线
NET_DVR_ERR_YELLOWLIGHTTIME_INVALID = 1621 # 视频检测黄灯持续时间不合法报错
NET_DVR_ERR_TRIGGERLINE1_FOR_NOT_YIELD_TO_PEDESTRIAN_CANNOT_EXCEED_TRIGGERLINE2 = 1622 # 第一条不礼让行人触发线的位置超过了第二条不礼让行人触发线
NET_DVR_ERR_TRIGGERLINE2_FOR_NOT_YIELD_TO_PEDESTRIAN_CANNOT_EXCEED_TRIGGERLINE1 = 1623 # 第二条不礼让行人触发线的位置超过了第一条不礼让行人触发线

# 门禁主机错误码
NET_ERR_TIME_OVERLAP = 1900 # 时间段重叠
NET_ERR_HOLIDAY_PLAN_OVERLAP = 1901 # 假日计划重叠
NET_ERR_CARDNO_NOT_SORT = 1902 # 卡号未排序
NET_ERR_CARDNO_NOT_EXIST = 1903 # 卡号不存在
NET_ERR_ILLEGAL_CARDNO = 1904 # 卡号错误
NET_ERR_ZONE_ALARM = 1905 # 防区处于布防状态(参数修改不允许)
NET_ERR_ZONE_OPERATION_NOT_SUPPORT = 1906 # 防区不支持该操作
NET_ERR_INTERLOCK_ANTI_CONFLICT = 1907 # 多门互锁和反潜回同时配置错误
NET_ERR_DEVICE_CARD_FULL = 1908 # 卡已满（卡达到10W后返回）
NET_ERR_HOLIDAY_GROUP_DOWNLOAD = 1909 # 假日组下载失败
NET_ERR_LOCAL_CONTROL_OFF = 1910 # 就地控制器离线
NET_ERR_LOCAL_CONTROL_DISADD = 1911 # 就地控制器未添加
NET_ERR_LOCAL_CONTROL_HASADD = 1912 # 就地控制器已添加
NET_ERR_LOCAL_CONTROL_DOORNO_CONFLICT = 1913 # 与已添加的就地控制器门编号冲突
NET_ERR_LOCAL_CONTROL_COMMUNICATION_FAIL = 1914 # 就地控制器通信失败
NET_ERR_OPERAND_INEXISTENCE = 1915 # 操作对象不存在（对门、报警输出、报警输入相关操作，当对象未添加时返回）
NET_ERR_LOCAL_CONTROL_OVER_LIMIT = 1916 # 就地控制器超出设备最大能力（主控对就地数量有限制）
NET_ERR_DOOR_OVER_LIMIT = 1917 # 门超出设备最大能力
NET_ERR_ALARM_OVER_LIMIT = 1918 # 报警输入输出超出设备最大能力
NET_ERR_LOCAL_CONTROL_ADDRESS_INCONFORMITY_TYPE = 1919 # 就地控制器地址与类型不符
NET_ERR_NOT_SUPPORT_ONE_MORE_CARD = 1920 # 不支持一人多卡
NET_ERR_DELETE_NO_EXISTENCE_FACE = 1921 # 删除的人脸不存在
NET_ERR_DOOR_SPECIAL_PASSWORD_REPEAT = 1922 # 与设备门特殊密码重复
NET_ERR_AUTH_CODE_REPEAT = 1923 # 与设备认证码重复
NET_ERR_DEPLOY_EXCEED_MAX = 1924 # 布防超过最大连接数
NET_ERR_NOT_SUPPORT_DEL_FP_BY_ID = 1925 # 读卡器不支持按手指ID删除指纹
NET_ERR_TIME_RANGE = 1926 # 有效期参数配置范围有误
NET_ERR_CAPTURE_TIMEOUT = 1927 # 采集超时
NET_ERR_LOW_SCORE = 1928 # 采集质量低
NET_ERR_OFFLINE_CAPTURING = 1929 # 离线采集中，无法响应

# 可视对讲错误码
NET_DVR_ERR_OUTDOOR_COMMUNICATION = 1950 # 与门口机通信异常
NET_DVR_ERR_ROOMNO_UNDEFINED = 1951 # 未设置房间号
NET_DVR_ERR_NO_CALLING = 1952 # 无呼叫
NET_DVR_ERR_RINGING = 1953 # 响铃
NET_DVR_ERR_IS_CALLING_NOW = 1954 # 正在通话
NET_DVR_ERR_LOCK_PASSWORD_WRONG = 1955 # 智能锁密码错误
NET_DVR_ERR_CONTROL_LOCK_FAILURE = 1956 # 开关锁失败
NET_DVR_ERR_CONTROL_LOCK_OVERTIME = 1957 # 开关锁超时
NET_DVR_ERR_LOCK_DEVICE_BUSY = 1958 # 智能锁设备繁忙
NET_DVR_ERR_UNOPEN_REMOTE_LOCK_FUNCTION = 1959 # 远程开锁功能未打开


# 后端错误码 （2100 - 3000）
NET_DVR_ERR_FILE_NOT_COMPLETE = 2100 # 下载的文件不完整
NET_DVR_ERR_IPC_EXIST = 2101 # 该IPC已经存在
NET_DVR_ERR_ADD_IPC = 2102 # 该通道已添加IPC
NET_DVR_ERR_OUT_OF_RES = 2103 # 网络带宽能力不足
NET_DVR_ERR_CONFLICT_TO_LOCALIP = 2104 # IPC的ip地址跟DVR的ip地址冲突
NET_DVR_ERR_IP_SET = 2105 # 非法ip地址
NET_DVR_ERR_PORT_SET = 2106 # 非法的端口号

NET_ERR_WAN_NOTSUPPORT = 2107 # 不在同一个局域网，无法设置安全问题或导出GUID文件
NET_ERR_MUTEX_FUNCTION = 2108 # 功能互斥
NET_ERR_QUESTION_CONFIGNUM = 2109 # 安全问题配置数量错误
NET_ERR_FACECHAN_NORESOURCE = 2110 # 人脸智能通道资源已用完
NET_ERR_DATA_CALLBACK = 2111 # 正在数据回迁
NET_ERR_ATM_VCA_CHAN_IS_RELATED = 2112 # ATM智能通道已被关联
NET_ERR_ATM_VCA_CHAN_IS_OVERLAPED = 2113 # ATM智能通道已被叠加
NET_ERR_FACE_CHAN_UNOVERLAP_EACH_OTHER = 2114 # 人脸通道不能互相叠加
NET_ERR_ACHIEVE_MAX_CHANNLE_LIMIT = 2115 # 达到最大路数限制
NET_DVR_SMD_ENCODING_NORESOURSE = 2116 # SMD编码资源不足
NET_DVR_SMD_DECODING_NORESOURSE = 2117 # SMD解码资源不足
NET_DVR_FACELIB_DATA_PROCESSING = 2118 # 人脸库数据正在处理
NET_DVR_ERR_LARGE_TIME_DIFFRENCE = 2119 # 设备和服务器之间的时间差异太大
NET_DVR_NO_SUPPORT_WITH_PLAYBACK = 2120 # 已开启回放，不支持本功能
NET_DVR_CHANNEL_NO_SUPPORT_WITH_SMD = 2121 # 通道已开启SMD，不支持本功能
NET_DVR_CHANNEL_NO_SUPPORT_WITH_FD = 2122 # 通道已开启人脸抓拍，不支持本功能
NET_DVR_ILLEGAL_PHONE_NUMBER = 2123 # 非法的电话号码
NET_DVR_ILLEGAL_CERITIFICATE_NUMBER = 2124 # 非法的证件号码
NET_DVR_ERR_CHANNEL_RESOLUTION_NO_SUPPORT = 2125 # 通道分辨率不支持
NET_DVR_ERR_CHANNEL_COMPRESSION_NO_SUPPORT = 2126 # 通道编码格式不支持

NET_DVR_ERR_CLUSTER_DEVICE_TOO_LESS = 2127 # 设备数少，不允许删除
NET_DVR_ERR_CLUSTER_DEL_DEVICE_CM_PLAYLOAD = 2128 # 该设备是集群主机，不允许删除
NET_DVR_ERR_CLUSTER_DEVNUM_OVER_UPPER_LIMIT = 2129 # 设备数达到上限，不允许增加
NET_DVR_ERR_CLUSTER_DEVICE_TYPE_INCONFORMITY = 2130 # 设备类型不一致
NET_DVR_ERR_CLUSTER_DEVICE_VERSION_INCONFORMITY = 2131 # 设备版本不一致
NET_DVR_ERR_CLUSTER_IP_CONFLICT = 2132 # 集群系统IP地址冲突：ipv4地址冲突、ipv6地址冲突
NET_DVR_ERR_CLUSTER_IP_INVALID = 2133 # 集群系统IP地址无效：ipv4非法、ipv6非法
NET_DVR_ERR_CLUSTER_PORT_CONFLICT = 2134 # 集群系统端口冲突
NET_DVR_ERR_CLUSTER_PORT_INVALID = 2135 # 集群系统端口非法
NET_DVR_ERR_CLUSTER_USERNAEM_OR_PASSWORD_INVALID = 2136 # 组网用户名或密码非法
NET_DVR_ERR_CLUSTER_DEVICE_ALREADY_EXIST = 2137 # 存在相同设备
NET_DVR_ERR_CLUSTER_DEVICE_NOT_EXIST = 2138 # 设备不存在(组网时下发的cs列表中的设备信息在任何一台cs上都找不到，删除的时候下发的id不对)
NET_DVR_ERR_CLUSTER_NON_CLUSTER_MODE = 2139 # 设备处于非集群模式
NET_DVR_ERR_CLUSTER_IP_NOT_SAME_LAN = 2140 # IP地址不在同一局域网，不同区域网不允许组网/扩容

NET_DVR_ERR_CAPTURE_PACKAGE_FAILED = 2141 # 抓包失败
NET_DVR_ERR_CAPTURE_PACKAGE_PROCESSING = 2142 # 正在抓包
NET_DVR_ERR_SAFETY_HELMET_NO_RESOURCE = 2143 # 安全帽检测资源不足
NET_DVR_NO_SUPPORT_WITH_ABSTRACT = 2144 # 已开启视频摘要，不支持本功能
NET_DVR_ERR_TAPE_LIB_NEED_STOP_ARCHIVE = 2145 # 磁带库归档需要停止
NET_DVR_INSUFFICIENT_DEEP_LEARNING_RESOURCES = 2146 # 深度学习资源超限
NET_DVR_ERR_IDENTITY_KEY = 2147 # 交互口令错误
NET_DVR_MISSING_IDENTITY_KEY = 2148 # 交互口令缺失
NET_DVR_NO_SUPPORT_WITH_PERSON_DENSITY_DETECT = 2149 # 已开启人员密度检测，不支持本功能
NET_DVR_IPC_RESOLUTION_OVERFLOW = 2150 # IPC分辨率超限
NET_DVR_IPC_BITRATE_OVERFLOW = 2151 # IPC码率超限
NET_DVR_ERR_INVALID_TASKID = 2152 # 无效的taskID
NET_DVR_PANEL_MODE_NOT_CONFIG = 2153 # 没有配置面板路智能
NET_DVR_NO_HUMAN_ENGINES_RESOURCE = 2154 # 人体引擎资源不足
NET_DVR_ERR_TASK_NUMBER_OVERFLOW = 2155 # 任务数据超过上限
NET_DVR_ERR_COLLISION_TIME_OVERFLOW = 2156 # 碰撞时间超过上限
NET_DVR_ERR_CAPTURE_PACKAGE_NO_USB = 2157 # 未识别到U盘，请插入U盘或重新插入
NET_DVR_ERR_NO_SET_SECURITY_EMAIL = 2158 # 未设置安全邮箱
NET_DVR_ERR_EVENT_NOTSUPPORT = 2159 # 订阅事件不支持
NET_DVR_ERR_PASSWORD_FORMAT = 2160 # 密码格式不对
NET_DVR_ACCESS_FRONT_DEVICE_PARAM_FAILURE = 2161 # 获取前端设备参数失败
NET_DVR_ACCESS_FRONT_DEVICE_STREAM_FAILURE = 2162 # 对前端设备取流失败
NET_DVR_ERR_USERNAME_FORMAT = 2163 # 用户名格式不对
NET_DVR_ERR_UNOPENED_HIGH_RESOLUTION_MODE = 2164 # 超高分辨率模式未开启
NET_DVR_ERR_TOO_SMALL_QUATO = 2165 # 配额设置太小
NET_DVR_ERR_EMAIL_FORMAT = 2166 # 邮箱格式不对
NET_DVR_ERR_SECURITY_CODE_FORMAT = 2167 # 安全码格式不对
NET_DVR_PD_SPACE_TOO_SMALL = 2168 # 阵列硬盘容量太小
NET_DVR_PD_NUM_TOO_BIG = 2169 # 阵列硬盘总数超过总盘数的二分之一
NET_DVR_ERR_USB_IS_FULL = 2170 # U盘已满
NET_DVR_EXCEED_MAX_SMD_TYPE = 2171 # 达到最大SMD事件种类上限
NET_DVR_CHANNEL_NO_SUPPORT_WITH_BEHAVIOR = 2172 # 通道已开启行为分析，不支持本功能
NET_DVR_NO_BEHAVIOR_ENGINES_RESOURCE = 2173 # 行为分析资源不足
NET_DVR_NO_RETENTION_ENGINES_RESOURCE = 2174 # 人员滞留检测资源不足
NET_DVR_NO_LEAVE_POSITION_ENGINES_RESOURCE = 2175 # 离岗检测资源不足
NET_DVR_NO_PEOPLE_NUM_CHANGE_ENGINES_RESOURCE = 2176 # 人数异常资源不足
NET_DVR_PANEL_MODE_NUM_OVER_LIMIT = 2177 # 超过面板路最大路数
NET_DVR_SURROUND_MODE_NUM_OVER_LIMIT = 2178 # 超过环境路最大路数
NET_DVR_FACE_MODE_NUM_OVER_LIMIT = 2179 # 超过人脸路最大路数
NET_DVR_SAFETYCABIN_MODE_NUM_OVER_LIMIT = 2180 # 超过防护舱路最大路数
NET_DVR_DETECT_REGION_RANGE_INVALID = 2181 # 检测区域范围非法
NET_DVR_CHANNEL_CAPTURE_PICTURE_FAILURE = 2182 # 通道抓图失败
NET_DVR_VCACHAN_IS_NORESOURCE = 2183 # 智能通道资源用完
NET_DVR_IPC_NUM_REACHES_LIMIT = 2184 #  Ipc通道数目达到上限
NET_DVR_IOT_NUM_REACHES_LIMIT = 2185 #  IOT通道数目达到上限
NET_DVR_IOT_CHANNEL_DEVICE_EXIST = 2186 # 当前IOT通道已经添加设备
NET_DVR_IOT_CHANNEL_DEVICE_NOT_EXIST = 2187 # 当前IOT通道不存在设备
NET_DVR_INVALID_IOT_PROTOCOL_TYPE = 2188 # 非法的IOT协议类型
NET_DVR_INVALID_EZVIZ_SECRET_KEY = 2189 # 非法的萤石注册验证码
NET_DVR_DUPLICATE_IOT_DEVICE = 2190 # 重复的IOT设备
NET_DVR_SADP_MODIFY_FALIURE = 2191 #  SADP修改失败
NET_DVR_IPC_NETWORK_ABNORMAL = 2192 #  IPC网络异常
NET_DVR_IPC_PASSWORD_ERROR = 2193 #  IPC用户名密码错误
NET_DVR_ERROR_IPC_TYPE = 2194 # IPC类型不对
NET_DVR_ERROR_IPC_LIST_NOT_EMPTY = 2195 # 已添加IPC列表不为空，不支持一键配置
NET_DVR_ERROR_IPC_LIST_NOT_MATCH_PAIRING = 2196 # IPC列表和配单不匹配
NET_DVR_ERROR_IPC_BAD_LANGUAGE = 2197 # IPC语言和设备不匹配
NET_DVR_ERROR_IPC_IS_LOCKING = 2198 # IPC已被锁
NET_DVR_ERROR_IPC_NOT_ACTIVATED = 2199 # IPC未激活
NET_DVR_FIELD_CODING_NOT_SUPPORT = 2200 # 场编码不支持
NET_DVR_ERROR_H323_NOT_SUPPORT_H265 = 2201 # H323视频会议就不支持H265码流
NET_DVR_ERROR_EXPOSURE_TIME_TOO_BIG_IN_MODE_P = 2202 # P制式下，曝光时间过大
NET_DVR_ERROR_EXPOSURE_TIME_TOO_BIG_IN_MODE_N = 2203 # N制式下，曝光时间过大
NET_DVR_ERROR_PING_PROCESSING = 2204 # 正在PING
NET_DVR_ERROR_PING_NOT_START = 2205 # Ping功能未开始
NET_DVR_ERROR_NEED_DOUBLE_VERIFICATION = 2206 # 需要二次认证
NET_DVR_NO_DOUBLE_VERIFICATION_USER = 2207 # 无二次认证用户
NET_DVR_CHANNEL_OFFLINE = 2208 # 通道离线
NET_DVR_TIMESPAN_NUM_OVER_LIMIT = 2209 # 时间段超出支持最大数目
NET_DVR_CHANNEL_NUM_OVER_LIMIT = 2210 # 通道数目超出支持最大数目
NET_DVR_NO_SEARCH_ID_RESOURCE = 2211 # 分页查询的searchID资源不足
NET_DVR_ERROR_ONEKEY_EXPORT = 2212 # 正在进行导出操作，请稍后再试
NET_DVR_NO_CITY_MANAGEMENT_ENGINES_RESOURCE = 2213 # 城管算法引擎资源不足
NET_DVR_NO_SITUATION_ANALYSIS_ENGINES_RESOURCE = 2214 # 态势分析引擎资源不足
NET_DVR_INTELLIGENT_ANALYSIS_IPC_CANNT_DELETE = 2215 # 正在进行智能分析的IPC无法删除
NET_DVR_NOSUPPORT_RESET_PASSWORD = 2216 # NVR不支持对IPC重置密码
NET_DVR_ERROR_IPC_NEED_ON_LAN = 2217 #  IPC需要在局域网内
NET_DVR_CHANNEL_NO_SUPPORT_WITH_SAFETY_HELMET = 2218 # 通道已开启安全帽检测，不支持本功能
NET_DVR_ERROR_GET_RESETPASSWORDTYPE_IS_ABNORMAL = 2219 # IPC重置密码时，获取IPC的重置密码类型异常
NET_DVR_ERROR_IPC_NOSUPPORT_RESET_PASSWORD = 2220 #  IPC不支持重置密码
NET_DVR_ERROR_IP_IS_NOT_ONLY_ONE = 2221 # IPC的IP不唯一，有重复
NET_DVR_NO_SUPPORT_WITH_SMD_OR_SCD = 2222 # 已开启SMD/SCD，不支持本功能（SCD为场景变更）
NET_DVR_NO_SUPPORT_WITH_FD = 2223 # 已开启人脸抓拍，不支持本功能
NET_DVR_NO_FD_ENGINES_RESOURCE = 2224 # 人脸抓拍资源不足
NET_DVR_ERROR_ONEKEY_REMOVE = 2225 # 正在进行删除操作，请稍后再试
NET_DVR_FACE_PIP_BACKGROUND_CHANNEL_OVERFLOW = 2226 # 人脸画中画背景通道超限
NET_DVR_MICIN_CHANNEL_OCCUPIED = 2227 # micin通道被占用
NET_DVR_IPC_CHANNEL_IS_IN_PIP = 2228 # 操作失败，该通道已关联到审讯通道，请先取消画中画配置关联

NET_DVR_CHANNEL_NO_SUPPORT_WITH_FACE_CONTRAST = 2229 # 通道已开启人脸比对，不支持本功能

NET_DVR_INVALID_RECHARGE_CARD = 2230 # 无效的充值卡
NET_DVR_CLOUD_PLATFORM_SERVER_EXCEPTION = 2231 # 云平台服务器异常
NET_DVR_OPERATION_FAILURE_WITHOUT_LOGIN = 2232 # 未登录操作失败
NET_DVR_INVALID_ASSOCIATED_SERIAL_NUMBER = 2233 # 关联序列号非法
NET_DVR_CLOUD_PLATFORM_ACCOUNT_NOT_EXIST = 2234 # 云平台帐号不存在
NET_DVR_DEVICE_SERIAL_NUMBER_REGISTERED = 2235 # 设备序列号已注册
NET_DVR_CONFERENCE_ROOM_NOT_EXIST = 2236 # 会议室不存在
NET_DVR_NEED_DISABLED_ANALOG_CHANNEL = 2237 # 需禁用模拟通道
NET_DVR_STUDENT_ROLL_CALL_FAILURE = 2238 # 学生点名失败
NET_DVR_SUB_DEVICE_NOT_ENABLE_INDIVIDUAL_BEHAVIOR = 2239 # 子设备未启用个体行为模式
NET_DVR_SUB_DEVICE_CHANNEL_CONTROL_FAILED = 2240 # 子设备通道控制失败
NET_DVR_DEVICE_NOT_IN_CONFERENCE = 2241 # 设备不在会议中
NET_DVR_ALREADY_EXIST_CONFERENCE = 2242 # 当前已经存在会议
NET_DVR_NO_SUPPORT_WITH_VIDEO_CONFERENCE = 2243 # 当前正在视频会议中，不支持本功能
NET_DVR_START_INTERACTION_FAILURE = 2244 # 互动开始失败
NET_DVR_ASK_QUESTION_STARTED = 2245 # 已开始提问
NET_DVR_ASK_QUESTION_CLOSED = 2246 # 已结束提问
NET_DVR_UNABLE_OPERATE_BY_HOST = 2247 # 已被主持人禁用，无法操作
NET_DVR_REPEATED_ASK_QUESTION = 2248 # 重复提问
NET_DVR_SWITCH_TIMEDIFF_LESS_LIMIT = 2249 # 开关机时间差小于限制值(10分钟)
NET_DVR_CHANNEL_DEVICE_EXIST = 2250 # 当前通道已经添加设备
NET_DVR_CHANNEL_DEVICE_NOT_EXIST = 2251 # 当前通道不存在设备
NET_DVR_ERROR_ADJUSTING_RESOLUTION = 2252 # 先关闭摄像机的裁剪，再调整分辨率
NET_DVR_SSD_FILE_SYSTEM_IS_UPGRADING = 2253 # SSD文件系统正在升级
NET_DVR_SSD_FILE_SYSTEM_IS_FORMAT = 2254 # SSD正在格式化
NET_DVR_CHANNEL_IS_CONNECTING = 2255 # 当前通道正在连接

NET_DVR_CHANNEL_STREAM_TYPE_NOT_SUPPORT = 2257 # 当前通道码流类型不支持
NET_DVR_CHANNEL_USERNAME_NOT_EXIST = 2258 # 当前通道用户名不存在
NET_DVR_CHANNEL_ACCESS_PARAM_FAILURE = 2259 # 当前通道获取参数失败
NET_DVR_CHANNEL_GET_STREAM_FAILURE = 2260 # 当前通道取流失败
NET_DVR_CHANNEL_RISK_PASSWORD = 2261 # 当前通道密码为风险密码

NET_DVR_NO_SUPPORT_DELETE_STRANGER_LIB = 2262 # 不支持删除陌生人库
NET_DVR_NO_SUPPORT_CREATE_STRANGER_LIB = 2263 # 不支持创建陌生人库

NET_DVR_NETWORK_PORT_CONFLICT = 2264 # 网络配置端口冲突
NET_DVR_TRANSCODE_NO_RESOURCES = 2265 # 转码资源不足
NET_DVR_SSD_FILE_SYSTEM_ERROR = 2266 # SSD文件系统错误
NET_DVR_INSUFFICIENT_SSD__FOR_FPD = 2267 # 用于人员频次业务的SSD容量不够
NET_DVR_ASSOCIATED_FACELIB_OVER_LIMIT = 2268 # 关联人脸库已达上限
NET_DVR_NEED_DELETE_DIGITAL_CHANNEL = 2269 # 需删除数字通道

# 热成像产线相关错误码（3001 - 3500）
NET_DVR_ERR_NOTSUPPORT_DEICING = 3001 # 设备当前状态不支持除冰功能（只在POE+、AC24V、DC12V供电下支持除冰功能）
NET_DVR_ERR_THERMENABLE_CLOSE = 3002 # 测温功能总使能未开启。(即NET_DVR_THERMOMETRY_BASICPARAM使能未开启)
NET_DVR_ERR_NOTMEET_DEICING = 3003 # 当前空腔温度不满足手动除冰开启条件（需空腔温度小于30度才可开启）
NET_DVR_ERR_PANORAMIC_LIMIT_OPERATED = 3004 # 全景地图和限位不可同时操作
NET_DVR_ERR_SMARTH264_ROI_OPERATED = 3005 # SmartH264和ROI不可同时操作
NET_DVR_ERR_RULENUM_LIMIT = 3006 # 规则数上限
NET_DVR_ERR_LASER_DEICING_OPERATED = 3007 # 激光以及除冰功能不可同时操作
NET_DVR_ERR_OFFDIGITALZOOM_OR_MINZOOMLIMIT = 3008 # 请先关闭数据变倍功能或变倍限制设置为最小值。当执行烟火检测、行为分析、船只检测、坏点矫正、测温、烟火屏蔽功能时，若没有关闭数据变倍或者变倍限制没有设置为最小值时，将会提示该错误码。
NET_DVR_ERR_FIREWAITING = 3009 # 设备云台正在火点等待中
NET_DVR_SYNCHRONIZEFOV_ERROR = 3010 # 同步视场角错误
NET_DVR_CERTIFICATE_VALIDATION_ERROR = 3011 # 证书验证不通过
NET_DVR_CERTIFICATES_NUM_EXCEED_ERROR = 3012 # 证书个数超过上限
NET_DVR_RULE_SHIELDMASK_CONFLICT_ERROR = 3013 # 规则区域与屏蔽区域冲突

# 前端产品线错误码（3501-4000）
NET_DVR_ERR_NO_SAFETY_HELMET_REGION = 3501 # 未配置安全帽检测区域
NET_DVR_ERR_UNCLOSED_SAFETY_HELMET = 3502 # 未关闭安全帽检测使能

NET_ERR_NPQ_BASE_INDEX = 8000 # NPQ库错误码
NET_ERR_NPQ_PARAM = (NET_ERR_NPQ_BASE_INDEX + 1) # NPQ库参数有误
NET_ERR_NPQ_SYSTEM = (NET_ERR_NPQ_BASE_INDEX + 2) # NPQ库操作系统调用错误(包括资源申请失败或内部错误等）
NET_ERR_NPQ_GENRAL = (NET_ERR_NPQ_BASE_INDEX + 3) # NPQ库内部通用错误
NET_ERR_NPQ_PRECONDITION = (NET_ERR_NPQ_BASE_INDEX + 4) # NPQ库调用顺序错误
NET_ERR_NPQ_NOTSUPPORT = (NET_ERR_NPQ_BASE_INDEX + 5) # NPQ库功能不支持

NET_ERR_NPQ_NOTCALLBACK = (NET_ERR_NPQ_BASE_INDEX + 100) # 数据没有回调上来
NET_ERR_NPQ_LOADLIB = (NET_ERR_NPQ_BASE_INDEX + 101) # NPQ库加载失败
NET_ERR_NPQ_STEAM_CLOSE = (NET_ERR_NPQ_BASE_INDEX + 104) # 本路码流NPQ功能未开启
NET_ERR_NPQ_MAX_LINK = (NET_ERR_NPQ_BASE_INDEX + 110) # NPQ取流路数达到上限
NET_ERR_NPQ_STREAM_CFG = (NET_ERR_NPQ_BASE_INDEX + 111) # 编码参数存在冲突配置


# 传显错误码 8501~9500
NET_ERR_UPGRADE_PROG_ERR = 8501 # 程序执行出错
NET_ERR_UPGRADE_NO_DEVICE = 8502 # 没有设备(指LED控制器没有接接收卡)
NET_ERR_UPGRADE_NO_FILE = 8503 # 没有找到升级文件
NET_ERR_UPGRADE_DATA_ERROR = 8504 # 升级文件数据不兼容
NET_ERR_UPGRADE_LINK_SERVER_ERR = 8505 # 与服务器连接失败
NET_ERR_UPGRADE_OEMCODE_NOMATCH = 8506 # oemCode不匹配
NET_ERR_UPGRADE_FLASH_NOENOUGH = 8507 # flash不足
NET_ERR_UPGRADE_RAM_NOENOUGH = 8508 # RAM不足
NET_ERR_UPGRADE_DSPRAM_NOENOUGH = 8509 # DSP RAM不足
NET_ERR_NOT_SUPPORT_CHECK = 8510 # 该屏幕型号不支持校正
NET_ERR_LED_DEVICE_BUSY_CHECK = 8511 # LED设备忙（正在校正）
NET_ERR_DEVICE_MEM_NOT_ENOUGH = 8512 # 设备内存不足
NET_ERR_CHECK_PARAM = 8513 # 校正参数错误
NET_ERR_RESOLUTION_OVER_LIMIT = 8514 # 输入分辨率超过限制
NET_ERR_NO_CUSTOM_BASE = 8515 # 无自定义底图
NET_ERR_PRIORITY_LOWER = 8516 # 优先级低于当前模式
NET_ERR_SEND_MESSAGE_EXCEPT = 8517 # 消息发送异常
NET_ERR_SENDCARD_UPGRADING = 8518 # 发送卡升级中
NET_ERR_NO_WIRELESS_NETCARD = 8519 # 未插入无线网卡
NET_ERR_LOAD_FS_FAIL = 8520 # 从屏幕加载失败
NET_ERR_FLASH_UNSTORAGE_RECCARD = 8521 # Flash中未存储接收卡参数

# NET_DVR_IsSupport()返回值
# 1－9位分别表示以下信息（位与是TRUE)表示支持
NET_DVR_SUPPORT_DDRAW = 0x01 # 支持DIRECTDRAW，如果不支持，则播放器不能工作；
NET_DVR_SUPPORT_BLT = 0x02 # 显卡支持BLT操作，如果不支持，则播放器不能工作；
NET_DVR_SUPPORT_BLTFOURCC = 0x04 # 显卡BLT支持颜色转换，如果不支持，播放器会用软件方法作RGB转换；
NET_DVR_SUPPORT_BLTSHRINKX = 0x08 # 显卡BLT支持X轴缩小；如果不支持，系统会用软件方法转换；
NET_DVR_SUPPORT_BLTSHRINKY = 0x10 # 显卡BLT支持Y轴缩小；如果不支持，系统会用软件方法转换；
NET_DVR_SUPPORT_BLTSTRETCHX = 0x20 # 显卡BLT支持X轴放大；如果不支持，系统会用软件方法转换；
NET_DVR_SUPPORT_BLTSTRETCHY = 0x40 # 显卡BLT支持Y轴放大；如果不支持，系统会用软件方法转换；
NET_DVR_SUPPORT_SSE = 0x80 # CPU支持SSE指令，Intel Pentium3以上支持SSE指令；
NET_DVR_SUPPORT_MMX = 0x100 # CPU支持MMX指令集，Intel Pentium3以上支持SSE指令；

# 云台控制命令
LIGHT_PWRON = 2 #  接通灯光电源
WIPER_PWRON = 3 #  接通雨刷开关
FAN_PWRON = 4 #  接通风扇开关
HEATER_PWRON = 5 #  接通加热器开关
AUX_PWRON1 = 6 #  接通辅助设备开关
AUX_PWRON2 = 7 #  接通辅助设备开关
SET_PRESET = 8 #  设置预置点
CLE_PRESET = 9 #  清除预置点

ZOOM_IN = 11 #  焦距以速度SS变大(倍率变大)
ZOOM_OUT = 12 #  焦距以速度SS变小(倍率变小)
FOCUS_NEAR = 13 #  焦点以速度SS前调
FOCUS_FAR = 14 #  焦点以速度SS后调
IRIS_OPEN = 15 #  光圈以速度SS扩大
IRIS_CLOSE = 16 #  光圈以速度SS缩小

TILT_UP = 21 #  云台以SS的速度上仰
TILT_DOWN = 22 #  云台以SS的速度下俯
PAN_LEFT = 23 #  云台以SS的速度左转
PAN_RIGHT = 24 #  云台以SS的速度右转
UP_LEFT = 25 #  云台以SS的速度上仰和左转
UP_RIGHT = 26 #  云台以SS的速度上仰和右转
DOWN_LEFT = 27 #  云台以SS的速度下俯和左转
DOWN_RIGHT = 28 #  云台以SS的速度下俯和右转
PAN_AUTO = 29 #  云台以SS的速度左右自动扫描

FILL_PRE_SEQ = 30 #  将预置点加入巡航序列
SET_SEQ_DWELL = 31 #  设置巡航点停顿时间
SET_SEQ_SPEED = 32 #  设置巡航速度
CLE_PRE_SEQ = 33 #  将预置点从巡航序列中删除
STA_MEM_CRUISE = 34 #  开始记录轨迹
STO_MEM_CRUISE = 35 #  停止记录轨迹
RUN_CRUISE = 36 #  开始轨迹
RUN_SEQ = 37 #  开始巡航
STOP_SEQ = 38 #  停止巡航
GOTO_PRESET = 39 #  快球转到预置点

DEL_SEQ = 43 #  删除巡航路径
STOP_CRUISE = 44 #  停止轨迹
DELETE_CRUISE = 45 #  删除单条轨迹
DELETE_ALL_CRUISE = 46 #  删除所有轨迹

PAN_CIRCLE = 50 #  云台以SS的速度自动圆周扫描
DRAG_PTZ = 51 #  拖动PTZ
LINEAR_SCAN = 52 #  区域扫描  # 2014-03-15
CLE_ALL_PRESET = 53 #  预置点全部清除
CLE_ALL_SEQ = 54 #  巡航全部清除
CLE_ALL_CRUISE = 55 #  轨迹全部清除

POPUP_MENU = 56 #  显示操作菜单

TILT_DOWN_ZOOM_IN = 58 #  云台以SS的速度下俯&&焦距以速度SS变大(倍率变大)
TILT_DOWN_ZOOM_OUT = 59 #  云台以SS的速度下俯&&焦距以速度SS变小(倍率变小)
PAN_LEFT_ZOOM_IN = 60 #  云台以SS的速度左转&&焦距以速度SS变大(倍率变大)
PAN_LEFT_ZOOM_OUT = 61 #  云台以SS的速度左转&&焦距以速度SS变小(倍率变小)
PAN_RIGHT_ZOOM_IN = 62 #  云台以SS的速度右转&&焦距以速度SS变大(倍率变大)
PAN_RIGHT_ZOOM_OUT = 63 #  云台以SS的速度右转&&焦距以速度SS变小(倍率变小)
UP_LEFT_ZOOM_IN = 64 #  云台以SS的速度上仰和左转&&焦距以速度SS变大(倍率变大)
UP_LEFT_ZOOM_OUT = 65 #  云台以SS的速度上仰和左转&&焦距以速度SS变小(倍率变小)
UP_RIGHT_ZOOM_IN = 66 #  云台以SS的速度上仰和右转&&焦距以速度SS变大(倍率变大)
UP_RIGHT_ZOOM_OUT = 67 #  云台以SS的速度上仰和右转&&焦距以速度SS变小(倍率变小)
DOWN_LEFT_ZOOM_IN = 68 #  云台以SS的速度下俯和左转&&焦距以速度SS变大(倍率变大)
DOWN_LEFT_ZOOM_OUT = 69 #  云台以SS的速度下俯和左转&&焦距以速度SS变小(倍率变小)
DOWN_RIGHT_ZOOM_IN = 70 #  云台以SS的速度下俯和右转&&焦距以速度SS变大(倍率变大)
DOWN_RIGHT_ZOOM_OUT = 71 #  云台以SS的速度下俯和右转&&焦距以速度SS变小(倍率变小)
TILT_UP_ZOOM_IN = 72 #  云台以SS的速度上仰&&焦距以速度SS变大(倍率变大)
TILT_UP_ZOOM_OUT = 73 #  云台以SS的速度上仰&&焦距以速度SS变小(倍率变小)

DVR_VEHICLE_CONTROL_LIST = 0x1 # 车辆黑白名单数据类型(发送的数据类型)2013-11-04

# 回放时播放控制命令宏定义
# NET_DVR_PlayBackControl
# NET_DVR_PlayControlLocDisplay
# NET_DVR_DecPlayBackCtrl的宏定义
# 具体支持查看函数说明和代码
NET_DVR_PLAYSTART = 1 # 开始播放
NET_DVR_PLAYSTOP = 2 # 停止播放
NET_DVR_PLAYPAUSE = 3 # 暂停播放
NET_DVR_PLAYRESTART = 4 # 恢复播放
NET_DVR_PLAYFAST = 5 # 快放
NET_DVR_PLAYSLOW = 6 # 慢放
NET_DVR_PLAYNORMAL = 7 # 正常速度
NET_DVR_PLAYFRAME = 8 # 单帧放
NET_DVR_PLAYSTARTAUDIO = 9 # 打开声音
NET_DVR_PLAYSTOPAUDIO = 10 # 关闭声音
NET_DVR_PLAYAUDIOVOLUME = 11 # 调节音量
NET_DVR_PLAYSETPOS = 12 # 改变文件回放的进度
NET_DVR_PLAYGETPOS = 13 # 获取文件回放的进度
NET_DVR_PLAYGETTIME = 14 # 获取当前已经播放的时间(按文件回放的时候有效)
NET_DVR_PLAYGETFRAME = 15 # 获取当前已经播放的帧数(按文件回放的时候有效)
NET_DVR_GETTOTALFRAMES = 16 # 获取当前播放文件总的帧数(按文件回放的时候有效)
NET_DVR_GETTOTALTIME = 17 # 获取当前播放文件总的时间(按文件回放的时候有效)
NET_DVR_THROWBFRAME = 20 # 丢B帧
NET_DVR_SETSPEED = 24 # 设置码流速度
NET_DVR_KEEPALIVE = 25 # 保持与设备的心跳(如果回调阻塞，建议2秒发送一次)
NET_DVR_PLAYSETTIME = 26 # 按绝对时间定位
NET_DVR_PLAYGETTOTALLEN = 27 # 获取按时间回放对应时间段内的所有文件的总长度
NET_DVR_PLAYSETTIME_V50 = 28 # 按绝对时间定位(支持时区扩展)
NET_DVR_PLAY_FORWARD = 29 # 倒放切换为正放
NET_DVR_PLAY_REVERSE = 30 # 正放切换为倒放
NET_DVR_SET_DECODEFFRAMETYPE = 31
NET_DVR_SET_TRANS_TYPE = 32 # 设置转码格式
NET_DVR_PLAY_CONVERT = 33 # 回放转码
NET_DVR_START_DRAWFRAME = 34 # 开始抽帧回放
NET_DVR_STOP_DRAWFRAME = 35 # 停止抽帧回放
NET_DVR_CHANGEWNDRESOLUTION = 36 # 窗口大小改变，通知播放库
NET_DVR_RESETBUFFER	 = 37 # 清空矩阵解码缓冲区（远程回放文件）
NET_DVR_VOD_DRAG_ING = 38 # 回放拖动中
NET_DVR_VOD_DRAG_END = 39 # 回放拖动结束
NET_DVR_VOD_RESET_PLAYTIME = 40 # 重设播放时间


PLAYM4_DECODE_NORMAIL = 0 # 正常解码
PLAYM4_DECODE_KEY_FRAME = 1 # 只解I帧
PLAYM4_DECODE_NONE = 2 # 全不解
PLAYM4_DECODE_TEMPORAL_LAYER_0 = 3 # 解1/2
PLAYM4_DECODE_TEMPORAL_LAYER_1 = 4 # 解1/4


# 远程按键定义如下：
#  key value send to CONFIG program
KEY_CODE_1 = 1
KEY_CODE_2 = 2
KEY_CODE_3 = 3
KEY_CODE_4 = 4
KEY_CODE_5 = 5
KEY_CODE_6 = 6
KEY_CODE_7 = 7
KEY_CODE_8 = 8
KEY_CODE_9 = 9
KEY_CODE_0 = 10
KEY_CODE_POWER = 11
KEY_CODE_MENU = 12
KEY_CODE_ENTER = 13
KEY_CODE_CANCEL = 14
KEY_CODE_UP = 15
KEY_CODE_DOWN = 16
KEY_CODE_LEFT = 17
KEY_CODE_RIGHT = 18
KEY_CODE_EDIT = 19
KEY_CODE_ADD = 20
KEY_CODE_MINUS = 21
KEY_CODE_PLAY = 22
KEY_CODE_REC = 23
KEY_CODE_PAN = 24
KEY_CODE_M = 25
KEY_CODE_A = 26
KEY_CODE_F1 = 27
KEY_CODE_F2 = 28

#  for PTZ control
KEY_PTZ_UP_START = KEY_CODE_UP
KEY_PTZ_UP_STOP = 32

KEY_PTZ_DOWN_START = KEY_CODE_DOWN
KEY_PTZ_DOWN_STOP = 33

KEY_PTZ_LEFT_START = KEY_CODE_LEFT
KEY_PTZ_LEFT_STOP = 34

KEY_PTZ_RIGHT_START = KEY_CODE_RIGHT
KEY_PTZ_RIGHT_STOP = 35

KEY_PTZ_AP1_START = KEY_CODE_EDIT # 光圈+
KEY_PTZ_AP1_STOP = 36

KEY_PTZ_AP2_START = KEY_CODE_PAN # 光圈-
KEY_PTZ_AP2_STOP = 37

KEY_PTZ_FOCUS1_START = KEY_CODE_A # 聚焦+
KEY_PTZ_FOCUS1_STOP = 38

KEY_PTZ_FOCUS2_START = KEY_CODE_M # 聚焦-
KEY_PTZ_FOCUS2_STOP = 39

KEY_PTZ_B1_START = 40 # 变倍+
KEY_PTZ_B1_STOP = 41

KEY_PTZ_B2_START = 42 # 变倍-
KEY_PTZ_B2_STOP = 43

# 9000新增
KEY_CODE_11 = 44
KEY_CODE_12 = 45
KEY_CODE_13 = 46
KEY_CODE_14 = 47
KEY_CODE_15 = 48
KEY_CODE_16 = 49

# 用于NET_DVR_SetDVRConfig和NET_DVR_GetDVRConfig,注意其对应的配置结构
NET_DVR_GET_DEVICECFG = 100 # 获取设备参数
NET_DVR_SET_DEVICECFG = 101 # 设置设备参数
NET_DVR_GET_NETCFG = 102 # 获取网络参数
NET_DVR_SET_NETCFG = 103 # 设置网络参数
NET_DVR_GET_PICCFG = 104 # 获取图象参数
NET_DVR_SET_PICCFG = 105 # 设置图象参数
NET_DVR_GET_COMPRESSCFG = 106 # 获取压缩参数
NET_DVR_SET_COMPRESSCFG = 107 # 设置压缩参数
NET_DVR_GET_RECORDCFG = 108 # 获取录像时间参数
NET_DVR_SET_RECORDCFG = 109 # 设置录像时间参数
NET_DVR_GET_DECODERCFG = 110 # 获取解码器参数
NET_DVR_SET_DECODERCFG = 111 # 设置解码器参数
NET_DVR_GET_RS232CFG = 112 # 获取232串口参数
NET_DVR_SET_RS232CFG = 113 # 设置232串口参数
NET_DVR_GET_ALARMINCFG = 114 # 获取报警输入参数
NET_DVR_SET_ALARMINCFG = 115 # 设置报警输入参数
NET_DVR_GET_ALARMOUTCFG = 116 # 获取报警输出参数
NET_DVR_SET_ALARMOUTCFG = 117 # 设置报警输出参数
NET_DVR_GET_TIMECFG = 118 # 获取DVR时间
NET_DVR_SET_TIMECFG = 119 # 设置DVR时间
NET_DVR_GET_PREVIEWCFG = 120 # 获取预览参数
NET_DVR_SET_PREVIEWCFG = 121 # 设置预览参数
NET_DVR_GET_VIDEOOUTCFG = 122 # 获取视频输出参数
NET_DVR_SET_VIDEOOUTCFG = 123 # 设置视频输出参数
NET_DVR_GET_USERCFG = 124 # 获取用户参数
NET_DVR_SET_USERCFG = 125 # 设置用户参数
NET_DVR_GET_EXCEPTIONCFG = 126 # 获取异常参数
NET_DVR_SET_EXCEPTIONCFG = 127 # 设置异常参数
NET_DVR_GET_ZONEANDDST = 128 # 获取时区和夏时制参数
NET_DVR_SET_ZONEANDDST = 129 # 设置时区和夏时制参数

# 注：该命令只支持4条OSD的类型，通常用于V30以下的设备版本。
NET_DVR_GET_SHOWSTRING = 130 # 获取叠加字符参数
NET_DVR_SET_SHOWSTRING = 131 # 设置叠加字符参数

NET_DVR_GET_EVENTCOMPCFG = 132 # 获取事件触发录像参数
NET_DVR_SET_EVENTCOMPCFG = 133 # 设置事件触发录像参数
NET_DVR_GET_FTPCFG = 134 # 获取抓图的FTP参数(基线)
NET_DVR_SET_FTPCFG = 135 # 设置抓图的FTP参数(基线)
NET_DVR_GET_AUXOUTCFG = 140 # 获取报警触发辅助输出设置(HS设备辅助输出2006-02-28)
NET_DVR_SET_AUXOUTCFG = 141 # 设置报警触发辅助输出设置(HS设备辅助输出2006-02-28)
NET_DVR_GET_PREVIEWCFG_AUX = 142 # 获取-s系列双输出预览参数(-s系列双输出2006-04-13)
NET_DVR_SET_PREVIEWCFG_AUX = 143 # 设置-s系列双输出预览参数(-s系列双输出2006-04-13)

NET_DVR_GET_PASSWORD_MANAGE_CFG = 144 # 获取密码管理配置
NET_DVR_SET_PASSWORD_MANAGE_CFG = 145 # 设置密码管理配置
NET_DVR_UNLOCK_USER = 146 # 用户解锁
NET_DVR_GET_SECURITY_CFG = 147 # 获取安全认证配置
NET_DVR_SET_SECURITY_CFG = 148 # 设置安全认证配置
NET_DVR_GET_LOCKED_INFO_LIST = 149 # 获取所有被锁定信息

# 智能部分接口
# 行为对应（NET_VCA_RULECFG）
NET_DVR_SET_RULECFG = 152 # 设置行为分析规则
NET_DVR_GET_RULECFG = 153 # 获取行为分析规则
# 球机标定参数（NET_DVR_TRACK_CFG ）
NET_DVR_SET_TRACK_CFG = 160 # 设置球机的配置参数
NET_DVR_GET_TRACK_CFG = 161 # 获取球机的配置参数

# 智能分析仪取流配置结构
NET_DVR_SET_IVMS_STREAMCFG = 162 # 设置智能分析仪取流参数
NET_DVR_GET_IVMS_STREAMCFG = 163 # 获取智能分析仪取流参数
# 智能控制参数结构
NET_DVR_SET_VCA_CTRLCFG = 164 # 设置智能控制参数
NET_DVR_GET_VCA_CTRLCFG = 165 # 获取智能控制参数
# 屏蔽区域NET_VCA_MASK_REGION_LIST
NET_DVR_SET_VCA_MASK_REGION = 166 # 设置屏蔽区域参数
NET_DVR_GET_VCA_MASK_REGION = 167 # 获取屏蔽区域参数

# ATM进入区域 NET_VCA_ENTER_REGION
NET_DVR_SET_VCA_ENTER_REGION = 168 # 设置进入区域参数
NET_DVR_GET_VCA_ENTER_REGION = 169 # 获取进入区域参数

# 标定线配置NET_VCA_LINE_SEGMENT_LIST
NET_DVR_SET_VCA_LINE_SEGMENT = 170 # 设置标定线
NET_DVR_GET_VCA_LINE_SEGMENT = 171 # 获取标定线

#  ivms屏蔽区域NET_IVMS_MASK_REGION_LIST
NET_DVR_SET_IVMS_MASK_REGION = 172 # 设置IVMS屏蔽区域参数
NET_DVR_GET_IVMS_MASK_REGION = 173 # 获取IVMS屏蔽区域参数
#  ivms进入检测区域NET_IVMS_ENTER_REGION
NET_DVR_SET_IVMS_ENTER_REGION = 174 # 设置IVMS进入区域参数
NET_DVR_GET_IVMS_ENTER_REGION = 175 # 获取IVMS进入区域参数

NET_DVR_SET_IVMS_BEHAVIORCFG = 176 # 设置智能分析仪行为规则参数
NET_DVR_GET_IVMS_BEHAVIORCFG = 177 # 获取智能分析仪行为规则参数

#  IVMS 回放检索
NET_DVR_IVMS_SET_SEARCHCFG = 178 # 设置IVMS回放检索参数
NET_DVR_IVMS_GET_SEARCHCFG = 179 # 获取IVMS回放检索参数

NET_DVR_SET_POSITION_TRACK = 180 #  设置场景跟踪配置信息
NET_DVR_GET_POSITION_TRACK = 181 #  获取场景跟踪配置信息

NET_DVR_SET_CALIBRATION = 182 #  设置标定信息
NET_DVR_GET_CALIBRATION = 183 #  获取标定信息

NET_DVR_SET_PDC_RULECFG = 184 #  设置人流量统计规则
NET_DVR_GET_PDC_RULECFG = 185 #  获取人流量统计规则

NET_DVR_SET_PU_STREAMCFG = 186 #  设置前段取流设备信息
NET_DVR_GET_PU_STREAMCFG = 187 #  获取前段取流设备信息

NET_VCA_SET_IVMS_BEHAVIOR_CFG = 192 #  设置IVMS行为规则配置 不带时间段
NET_VCA_GET_IVMS_BEHAVIOR_CFG = 193 #  获取IVMS行为规则配置 不带时间段

NET_VCA_SET_SIZE_FILTER = 194 #  设置全局尺寸过滤器
NET_VCA_GET_SIZE_FILTER = 195 #  获取全局尺寸过滤器

NET_DVR_SET_TRACK_PARAMCFG = 196 #  设置球机本地菜单规则
NET_DVR_GET_TRACK_PARAMCFG = 197 #  获取球机本地菜单规则

NET_DVR_SET_DOME_MOVEMENT_PARAM = 198 #  设置球机机芯参数
NET_DVR_GET_DOME_MOVEMENT_PARAM = 199 #  获取球机机芯参数

NET_DVR_GET_PICCFG_EX = 200 # 获取图象参数(SDK_V14扩展命令)
NET_DVR_SET_PICCFG_EX = 201 # 设置图象参数(SDK_V14扩展命令)
NET_DVR_GET_USERCFG_EX = 202 # 获取用户参数(SDK_V15扩展命令)
NET_DVR_SET_USERCFG_EX = 203 # 设置用户参数(SDK_V15扩展命令)
NET_DVR_GET_COMPRESSCFG_EX = 204 # 获取压缩参数(SDK_V15扩展命令2006-05-15)
NET_DVR_SET_COMPRESSCFG_EX = 205 # 设置压缩参数(SDK_V15扩展命令2006-05-15)


NET_DVR_GET_NETAPPCFG = 222 # 获取网络应用参数 NTP/DDNS/EMAIL
NET_DVR_SET_NETAPPCFG = 223 # 设置网络应用参数 NTP/DDNS/EMAIL
NET_DVR_GET_NTPCFG = 224 # 获取网络应用参数 NTP
NET_DVR_SET_NTPCFG = 225 # 设置网络应用参数 NTP
NET_DVR_GET_DDNSCFG = 226 # 获取网络应用参数 DDNS
NET_DVR_SET_DDNSCFG = 227 # 设置网络应用参数 DDNS
# 对应NET_DVR_EMAILPARA
NET_DVR_GET_EMAILCFG = 228 # 获取网络应用参数 EMAIL
NET_DVR_SET_EMAILCFG = 229 # 设置网络应用参数 EMAIL

NET_DVR_GET_NFSCFG = 230 #  NFS disk config
NET_DVR_SET_NFSCFG = 231 #  NFS disk config

# 注：该命令为定制，只支持8条OSD的类型，不会兼容V30设备版本之前的
# NET_DVR_GET_SHOWSTRING 、NET_DVR_SET_SHOWSTRING 命令。（不建议使用）
NET_DVR_GET_SHOWSTRING_EX = 238 # 获取叠加字符参数扩展(支持8条字符)
NET_DVR_SET_SHOWSTRING_EX = 239 # 设置叠加字符参数扩展(支持8条字符)
NET_DVR_GET_NETCFG_OTHER = 244 # 获取网络参数
NET_DVR_SET_NETCFG_OTHER = 245 # 设置网络参数

# 对应NET_DVR_EMAILCFG结构
NET_DVR_GET_EMAILPARACFG = 250 # Get EMAIL parameters
NET_DVR_SET_EMAILPARACFG = 251 # Setup EMAIL parameters


NET_DVR_GET_DDNSCFG_EX = 274 # 获取扩展DDNS参数
NET_DVR_SET_DDNSCFG_EX = 275 # 设置扩展DDNS参数

NET_DVR_SET_PTZPOS = 292 # 云台设置PTZ位置
NET_DVR_GET_PTZPOS = 293 # 云台获取PTZ位置
NET_DVR_GET_PTZSCOPE = 294 # 云台获取PTZ范围

NET_DVR_GET_AP_INFO_LIST = 305 # 获取无线网络资源参数
NET_DVR_SET_WIFI_CFG = 306 # 设置IP监控设备无线参数
NET_DVR_GET_WIFI_CFG = 307 # 获取IP监控设备无线参数
NET_DVR_SET_WIFI_WORKMODE = 308 # 设置IP监控设备网口工作模式参数
NET_DVR_GET_WIFI_WORKMODE = 309 # 获取IP监控设备网口工作模式参数
NET_DVR_GET_WIFI_STATUS = 310 # 获取设备当前wifi连接状态

# 智能交通事件
NET_DVR_GET_REFERENCE_REGION = 400 # 获取参考区域
NET_DVR_SET_REFERENCE_REGION = 401 # 设置参考区域

NET_DVR_GET_TRAFFIC_MASK_REGION = 402 # 获取交通事件屏蔽区域
NET_DVR_SET_TRAFFIC_MASK_REGION = 403 # 设置交通事件屏蔽区域
NET_DVR_SET_AID_RULECFG = 404 # 设置交通事件规则参数
NET_DVR_GET_AID_RULECFG = 405 # 获取交通事件规则参数

NET_DVR_SET_TPS_RULECFG = 406 # 设置交通统计规则参数
NET_DVR_GET_TPS_RULECFG = 407 # 获取交通统计规则参数

NET_DVR_SET_LANECFG = 408 # 设置车道规则
NET_DVR_GET_LANECFG = 409 # 获取车道规则
NET_DVR_GET_VCA_RULE_COLOR_CFG = 410 # 获取智能规则关联的颜色参数
NET_DVR_SET_VCA_RULE_COLOR_CFG = 411 # 设置智能规则关联的颜色参数
NET_DVR_GET_SWITCH_LAMP_CFG = 412 # 获取开关灯检测规则配置参数
NET_DVR_SET_SWITCH_LAMP_CFG = 413 # 设置开关灯检测规则配置参数

NET_DVR_SET_FACEDETECT_RULECFG = 420 #  设置人脸检测规则
NET_DVR_GET_FACEDETECT_RULECFG = 421 #  获取人脸检测规则

NET_DVR_SET_VEHICLE_RECOG_TASK = 422 # 车辆二次识别任务提交
NET_DVR_GET_VEHICLE_RECOG_TASK = 423 # 车辆二次识别任务获取

NET_DVR_SET_TIMECORRECT = 432 # 校时配置（只做校时操作，不记录校时配置 eg.NET_DVR_SET_TIMECFG 会修改设备的校时配置（NTP校时，会被修改为手动校时））
NET_DVR_GET_CONNECT_LIST = 433 # 获取连接设备列表信息

# DS9000新增命令(_V30)
# 网络(NET_DVR_NETCFG_V30结构)
NET_DVR_GET_NETCFG_V30 = 1000 # 获取网络参数
NET_DVR_SET_NETCFG_V30 = 1001 # 设置网络参数

# 图象(NET_DVR_PICCFG_V30结构)
NET_DVR_GET_PICCFG_V30 = 1002 # 获取图象参数
NET_DVR_SET_PICCFG_V30 = 1003 # 设置图象参数

# 录像时间(NET_DVR_RECORD_V30结构)
NET_DVR_GET_RECORDCFG_V30 = 1004 # 获取录像参数
NET_DVR_SET_RECORDCFG_V30 = 1005 # 设置录像参数

# 用户(NET_DVR_USER_V30结构)
NET_DVR_GET_USERCFG_V30 = 1006 # 获取用户参数
NET_DVR_SET_USERCFG_V30 = 1007 # 设置用户参数

# 录像时间(NET_DVR_RECORD_V40结构)
NET_DVR_GET_RECORDCFG_V40 = 1008 # 获取录像参数(扩展)
NET_DVR_SET_RECORDCFG_V40 = 1009 # 设置录像参数(扩展)

# 9000DDNS参数配置(NET_DVR_DDNSPARA_V30结构)
NET_DVR_GET_DDNSCFG_V30 = 1010 # 获取DDNS(9000扩展)
NET_DVR_SET_DDNSCFG_V30 = 1011 # 设置DDNS(9000扩展)

# EMAIL功能(NET_DVR_EMAILCFG_V30结构)
NET_DVR_GET_EMAILCFG_V30 = 1012 # 获取EMAIL参数
NET_DVR_SET_EMAILCFG_V30 = 1013 # 设置EMAIL参数

NET_DVR_GET_NETCFG_V50 = 1015 # 获取网络参数配置(V50)
NET_DVR_SET_NETCFG_V50 = 1016 # 设置网络参数配置(V50)

NET_GET_CRUISEPOINT_V40 = 1018 # 获取巡航路径配置

# 巡航参数 (NET_DVR_CRUISE_PARA结构)
NET_DVR_GET_CRUISE = 1020
NET_DVR_SET_CRUISE = 1021


# 报警输入结构参数 (NET_DVR_ALARMINCFG_V30结构)
NET_DVR_GET_ALARMINCFG_V30 = 1024
NET_DVR_SET_ALARMINCFG_V30 = 1025

# 报警输出结构参数 (NET_DVR_ALARMOUTCFG_V30结构)
NET_DVR_GET_ALARMOUTCFG_V30 = 1026
NET_DVR_SET_ALARMOUTCFG_V30 = 1027

# 视频输出结构参数 (NET_DVR_VIDEOOUT_V30结构)
NET_DVR_GET_VIDEOOUTCFG_V30 = 1028
NET_DVR_SET_VIDEOOUTCFG_V30 = 1029


# 该命令支持8条OSD的类型（即设备版本为V30以上时），并会通过设备版本的匹配，
# 同时兼容之前的NET_DVR_GET_SHOWSTRING 、NET_DVR_SET_SHOWSTRING 命令。（建议使用）
# 叠加字符结构参数 (NET_DVR_SHOWSTRING_V30结构)
NET_DVR_GET_SHOWSTRING_V30 = 1030
NET_DVR_SET_SHOWSTRING_V30 = 1031

# 异常结构参数 (NET_DVR_EXCEPTION_V30结构)
NET_DVR_GET_EXCEPTIONCFG_V30 = 1034
NET_DVR_SET_EXCEPTIONCFG_V30 = 1035

# 串口232结构参数 (NET_DVR_RS232CFG_V30结构)
NET_DVR_GET_RS232CFG_V30 = 1036
NET_DVR_SET_RS232CFG_V30 = 1037

# 网络硬盘接入结构参数 (NET_DVR_NET_DISKCFG结构)
NET_DVR_GET_NET_DISKCFG = 1038 # 网络硬盘接入获取
NET_DVR_SET_NET_DISKCFG = 1039 # 网络硬盘接入设置
# 压缩参数 (NET_DVR_COMPRESSIONCFG_V30结构)
NET_DVR_GET_COMPRESSCFG_V30 = 1040
NET_DVR_SET_COMPRESSCFG_V30 = 1041

# 获取485解码器参数 (NET_DVR_DECODERCFG_V30结构)
NET_DVR_GET_DECODERCFG_V30 = 1042 # 获取解码器参数
NET_DVR_SET_DECODERCFG_V30 = 1043 # 设置解码器参数

# 获取预览参数 (NET_DVR_PREVIEWCFG_V30结构)
NET_DVR_GET_PREVIEWCFG_V30 = 1044 # 获取预览参数
NET_DVR_SET_PREVIEWCFG_V30 = 1045 # 设置预览参数

# 辅助预览参数 (NET_DVR_PREVIEWCFG_AUX_V30结构)
NET_DVR_GET_PREVIEWCFG_AUX_V30 = 1046 # 获取辅助预览参数
NET_DVR_SET_PREVIEWCFG_AUX_V30 = 1047 # 设置辅助预览参数

# IP接入配置参数 （NET_DVR_IPPARACFG结构）
NET_DVR_GET_IPPARACFG = 1048 # 获取IP接入配置信息
NET_DVR_SET_IPPARACFG = 1049 # 设置IP接入配置信息

# IP报警输入接入配置参数 （NET_DVR_IPALARMINCFG结构）
NET_DVR_GET_IPALARMINCFG = 1050 # 获取IP报警输入接入配置信息
NET_DVR_SET_IPALARMINCFG = 1051 # 设置IP报警输入接入配置信息

# IP报警输出接入配置参数 （NET_DVR_IPALARMOUTCFG结构）
NET_DVR_GET_IPALARMOUTCFG = 1052 # 获取IP报警输出接入配置信息
NET_DVR_SET_IPALARMOUTCFG = 1053 # 设置IP报警输出接入配置信息

# 硬盘管理的参数获取 (NET_DVR_HDCFG结构)
NET_DVR_GET_HDCFG = 1054 # 获取硬盘管理配置参数
NET_DVR_SET_HDCFG = 1055 # 设置硬盘管理配置参数
# 盘组管理的参数获取 (NET_DVR_HDGROUP_CFG结构)
NET_DVR_GET_HDGROUP_CFG = 1056 # 获取盘组管理配置参数
NET_DVR_SET_HDGROUP_CFG = 1057 # 设置盘组管理配置参数

# 设备编码类型配置(NET_DVR_COMPRESSION_AUDIO结构)
NET_DVR_GET_COMPRESSCFG_AUD = 1058 # 获取设备语音对讲编码参数
NET_DVR_SET_COMPRESSCFG_AUD = 1059 # 设置设备语音对讲编码参数

# IP接入配置参数 （NET_DVR_IPPARACFG_V31结构）
NET_DVR_GET_IPPARACFG_V31 = 1060 # 获取IP接入配置信息
NET_DVR_SET_IPPARACFG_V31 = 1061 # 设置IP接入配置信息

#  通道资源配置 (NET_DVR_IPPARACFG_V40结构)
NET_DVR_GET_IPPARACFG_V40 = 1062 #  获取IP接入配置
NET_DVR_SET_IPPARACFG_V40 = 1063 #  设置IP接入配置

NET_DVR_GET_CCDPARAMCFG = 1067 # IPC获取CCD参数配置
NET_DVR_SET_CCDPARAMCFG = 1068 # IPC设置CCD参数配置

NET_DVR_GET_IOINCFG = 1070 # 获取抓拍机IO输入参数
NET_DVR_SET_IOINCFG = 1071 # 设置抓拍机IO输入参数

NET_DVR_GET_IOOUTCFG = 1072 # 获取抓拍机IO输出参数
NET_DVR_SET_IOOUTCFG = 1073 # 设置抓拍机IO输出参数

NET_DVR_GET_FLASHCFG = 1074 # 获取IO闪光灯输出参数
NET_DVR_SET_FLASHCFG = 1075 # 设置IO闪光灯输出参数

NET_DVR_GET_LIGHTSNAPCFG = 1076 # 获取抓拍机红绿灯参数
NET_DVR_SET_LIGHTSNAPCFG = 1077 # 设置抓拍机红绿灯参数

NET_DVR_GET_MEASURESPEEDCFG = 1078 # 获取抓拍机测速参数
NET_DVR_SET_MEASURESPEEDCFG = 1079 # 设置抓拍机测速参数

NET_DVR_GET_IMAGEOVERLAYCFG = 1080 # 获取抓拍机图像叠加信息参数
NET_DVR_SET_IMAGEOVERLAYCFG = 1081 # 设置抓拍机图像叠加信息参数

NET_DVR_GET_SNAPCFG = 1082 # 获取单IO触发抓拍功能配置
NET_DVR_SET_SNAPCFG = 1083 # 设置单IO触发抓拍功能配置

NET_DVR_GET_VTPPARAM = 1084 # 获取虚拟线圈参数
NET_DVR_SET_VTPPARAM = 1085 # 设置虚拟线圈参数

NET_DVR_GET_SNAPENABLECFG = 1086 # 获取抓拍机使能参数
NET_DVR_SET_SNAPENABLECFG = 1087 # 设置抓拍机使能参数

NET_DVR_GET_POSTEPOLICECFG = 1088 # 获取卡口电警参数
NET_DVR_SET_POSTEPOLICECFG = 1089 # 设置卡口电警参数

NET_DVR_GET_JPEGCFG_V30 = 1090 # 获取抓图的JPEG参数(基线)
NET_DVR_SET_JPEGCFG_V30 = 1091 # 设置抓图的JPEG参数(基线)

NET_DVR_GET_SPRCFG = 1092 # 获取车牌识别参数
NET_DVR_SET_SPRCFG = 1093 # 设置车牌识别参数
NET_DVR_GET_PLCCFG = 1094 # 获取车牌亮度补偿参数
NET_DVR_SET_PLCCFG = 1095 # 设置车牌亮度补偿参数

NET_DVR_GET_DEVICESTATECFG = 1096 # 获取设备当前状态参数
NET_DVR_SET_CALIBRATE_TIME = 1097 # 设置扩展时间校时
NET_DVR_GET_CALIBRATE_TIME = 1098 # 获取扩展时间校时

NET_DVR_GET_DEVICECFG_V40 = 1100 # 获取扩展设备参数
NET_DVR_SET_DEVICECFG_V40 = 1101 # 设置扩展设备参数

NET_DVR_GET_ZEROCHANCFG = 1102 # 获取零通道压缩参数
NET_DVR_SET_ZEROCHANCFG = 1103 # 设置零通道压缩参数

NET_DVR_GET_ZERO_PREVIEWCFG_V30 = 1104 #  获取零通道预览参数配置
NET_DVR_SET_ZERO_PREVIEWCFG_V30 = 1105 #  设置零通道预览参数配置

NET_DVR_SET_ZERO_ZOOM = 1106 # 设置零通道的缩放配置
NET_DVR_GET_ZERO_ZOOM = 1107 # 获取零通道的缩放配置

NET_DVR_NATASSOCIATECFG_GET = 1110 # 获取NAT功能相关信息
NET_DVR_NATASSOCIATECFG_SET = 1111 # 设置NAT功能相关信息

NET_DVR_GET_SNMPCFG = 1112 # 获取SNMP参数
NET_DVR_SET_SNMPCFG = 1113 # 设置SNMP参数

NET_DVR_GET_SNMPCFG_V30 = 1114 # 获取SNMPv30参数
NET_DVR_SET_SNMPCFG_V30 = 1115 # 设置SNMPv30参数

NET_DVR_VIDEOPLATFORMALARMCFG_GET = 1130 # 获取视频综合平台报警配置
NET_DVR_VIDEOPLATFORMALARMCFG_SET = 1131 # 设置视频综合平台报警配置

NET_DVR_GET_RAID_ADAPTER_INFO = 1134 #  获取适配器信息
NET_DVR_SET_RAID_ADAPTER_INFO = 1135 #  设置适配器信息

NET_DVR_MATRIX_BIGSCREENCFG_GET = 1140 # 获取大屏拼接参数
NET_DVR_MATRIX_BIGSCREENCFG_SET = 1141 # 设置大屏拼接参数

NET_DVR_GET_MB_PLATFORMPARA = 1145 # 获取平台登录参数
NET_DVR_SET_MB_PLATFORMPARA = 1146 # 设置平台登录参数
NET_DVR_GET_MB_DEVSTATUS = 1147 # 获取移动设备状态

NET_DVR_GET_DECODER_JOINT_CHAN = 1151 # 获取解码关联通道
NET_DVR_SET_DECODER_JOINT_CHAN = 1152 # 设置解码关联通道

# 多网卡配置
NET_DVR_GET_NETCFG_MULTI = 1161 # 获取多网卡配置
NET_DVR_SET_NETCFG_MULTI = 1162 # 设置多网卡配置
NET_DVR_GET_NETCFG_MULTI_V50 = 1163 # 获取多网卡配置(分组)
NET_DVR_SET_NETCFG_MULTI_V50 = 1164 # 设置多网卡配置(分组)

NET_DVR_GET_CMSPARA = 1170 # 获取平台参数
NET_DVR_SET_CMSPARA = 1171 # 设置平台参数
NET_DVR_GET_DIALSTATUS = 1172 # 获取拨号状态参数
NET_DVR_GET_SMSRELATIVEPARA = 1173 # 获取短信相关参数
NET_DVR_SET_SMSRELATIVEPARA = 1174 # 设置短信相关参数
NET_DVR_GET_PINSTATUS = 1175 # 获取Pin状态
NET_DVR_SET_PINCMD = 1176 # 设置PIN命令
NET_DVR_SET_SENSOR_CFG = 1180 # 设置模拟量参数
NET_DVR_GET_SENSOR_CFG = 1181 # 获取模拟量参数
NET_DVR_SET_ALARMIN_PARAM = 1182 # 设置报警输入参数
NET_DVR_GET_ALARMIN_PARAM = 1183 # 获取报警输入参数
NET_DVR_SET_ALARMOUT_PARAM = 1184 # 设置报警输出参数
NET_DVR_GET_ALARMOUT_PARAM = 1185 # 获取报警输出参数
NET_DVR_SET_SIREN_PARAM = 1186 # 设置警号参数
NET_DVR_GET_SIREN_PARAM = 1187 # 获取警号参数
NET_DVR_SET_ALARM_RS485CFG = 1188 # 设置报警主机485参数
NET_DVR_GET_ALARM_RS485CFG = 1189 # 获取报警主机485参数
NET_DVR_GET_ALARMHOST_MAIN_STATUS = 1190 # 获取报警主机主要状态
NET_DVR_GET_ALARMHOST_OTHER_STATUS = 1191 # 获取报警主机其他状态
NET_DVR_SET_ALARMHOST_ENABLECFG = 1192 # 获取报警主机使能状态
NET_DVR_GET_ALARMHOST_ENABLECFG = 1193 # 设置报警主机使能状态
NET_DVR_SET_ALARM_CAMCFG = 1194 # 设置视频综合平台报警触发CAM操作配置
NET_DVR_GET_ALARM_CAMCFG = 1195 # 设置视频综合平台报警触发CAM操作配置
NET_DVR_GET_GATEWAY_CFG = 1196 # 获取门禁参数配置
NET_DVR_SET_GATEWAY_CFG = 1197 # 设置门禁参数配置

NET_DVR_GET_ALARMDIALMODECFG = 1198 # 获取报警主机拨号参数
NET_DVR_SET_ALARMDIALMODECFG = 1199 # 设置报警主机拨号参数
NET_DVR_SET_ALARMIN_PARAM_V50 = 1200 #  设置防区参数V50
NET_DVR_GET_ALARMIN_PARAM_V50 = 1201 #  获取防区参数V50
NET_DVR_SET_WINCFG = 1202 # 窗口参数设置
NET_DVR_GET_ALARMHOSTDIALSETUPMODE = 1204 # 获取报警主机拨号启用方式
NET_DVR_SET_ALARMHOSTDIALSETUPMODE = 1205 # 设置报警主机拨号启用方式

# 视频报警主机海外版命令(视频报警主机 V1.3)
NET_DVR_SET_SUBSYSTEM_ALARM = 1210 # 设置子系统布/撤防
NET_DVR_GET_SUBSYSTEM_ALARM = 1211 # 获取子系统布/撤防
NET_DVR_GET_WHITELIST_ALARM = 1215 # 获取白名单参数
NET_DVR_SET_WHITELIST_ALARM = 1216 # 设置白名单参数
NET_DVR_GET_ALARMHOST_MODULE_LIST = 1222 # 获取所有模块
NET_DVR_SET_PRIOR_ALARM = 1223 # 设置子系统布/撤防
NET_DVR_GET_PRIOR_ALARM = 1224 # 获取子系统布/撤防
NET_DVR_SET_TAMPER_ALARMIN_PARAM = 1225 #  设置防区防拆参数
NET_DVR_GET_TAMPER_ALARMIN_PARAM = 1226 #  获取防区防拆参数

NET_DVR_GET_HOLIDAY_PARAM_CFG = 1240 #  获取节假日参数
NET_DVR_SET_HOLIDAY_PARAM_CFG = 1241 #  设置节假日参数

NET_DVR_GET_MOTION_HOLIDAY_HANDLE = 1242 #  获取移动侦测假日报警处理方式
NET_DVR_SET_MOTION_HOLIDAY_HANDLE = 1243 #  获取移动侦测假日报警处理方式

NET_DVR_GET_VILOST_HOLIDAY_HANDLE = 1244 #  获取视频信号丢失假日报警处理方式
NET_DVR_SET_VILOST_HOLIDAY_HANDLE = 1245 #  获取视频信号丢失假日报警处理方式

NET_DVR_GET_HIDE_HOLIDAY_HANDLE = 1246 #  获取遮盖假日报警处理方式
NET_DVR_SET_HIDE_HOLIDAY_HANDLE = 1247 #  设置遮盖假日报警处理方式

NET_DVR_GET_ALARMIN_HOLIDAY_HANDLE = 1248 #  获取报警输入假日报警处理方式
NET_DVR_SET_ALARMIN_HOLIDAY_HANDLE = 1249 #  设置报警输入假日报警处理方式
NET_DVR_GET_ALARMOUT_HOLIDAY_HANDLE = 1250 #  获取报警输出假日报警处理方式
NET_DVR_SET_ALARMOUT_HOLIDAY_HANDLE = 1251 #  设置报警输出假日报警处理方式
NET_DVR_GET_HOLIDAY_RECORD = 1252 #  获取假日录像参数
NET_DVR_SET_HOLIDAY_RECORD = 1253 #  设置假日录像参数
NET_DVR_GET_NETWORK_BONDING = 1254 #  获取BONDING网络参数
NET_DVR_SET_NETWORK_BONDING = 1255 #  设置BONDING网络参数
NET_DVR_GET_LINK_STATUS = 1256 #  获取通道IP工作状态
NET_DVR_GET_DISK_QUOTA_CFG = 1278 #  获取磁盘配额信息
NET_DVR_SET_DISK_QUOTA_CFG = 1279 #  设置磁盘配额信息
NET_DVR_GET_JPEG_CAPTURE_CFG = 1280 #  获取DVR抓图配置
NET_DVR_SET_JPEG_CAPTURE_CFG = 1281 #  设置DVR抓图配置
NET_DVR_GET_SCHED_CAPTURECFG = 1282 #  获取抓图计划
NET_DVR_SET_SCHED_CAPTURECFG = 1283 #  设置抓图计划
NET_DVR_GET_VGA_PREVIEWCFG = 1284 #  获取VGA预览配置
NET_DVR_SET_VGA_PREVIEWCFG = 1285 #  设置VGA预览配置
NET_DVR_GET_VIDEO_INPUT_EFFECT = 1286 #  获取通道视频输入图像参数
NET_DVR_SET_VIDEO_INPUT_EFFECT = 1287 #  设置通道视频输入图像参数

NET_DVR_GET_STORAGE_SERVER_SWITCH = 1290 # 获取存储服务器开关状态
NET_DVR_SET_STORAGE_SERVER_SWITCH = 1291 # 设置存储服务器开关状态

NET_DVR_GET_DISK_QUOTA_CFG_V60 = 1292 # 获取磁盘配额信息V60
NET_DVR_SET_DISK_QUOTA_CFG_V60 = 1293 # 设置磁盘配额信息V60

NET_DVR_GET_OPTICAL_CHANNEL = 1300 # 获取光端子系统通道关联信息
NET_DVR_SET_OPTICAL_CHANNEL = 1301 # 设置光端子系统通道关联信息
NET_DVR_GET_FIBER_CASCADE = 1302 # 获取光纤级联模式
NET_DVR_SET_FIBER_CASCADE = 1303 # 设置光纤级联模式
NET_DVR_GET_SPARTAN_STATUS = 1304 # 获取畅显状态
NET_DVR_SET_SPARTAN_STATUS = 1305 # 设置畅显状态
NET_DVR_GET_ETHERNET_CHANNEL = 1306 # 获取端口聚合参数
NET_DVR_SET_ETHERMET_CHANNEL = 1307 # 设置端口聚合参数
NET_DVR_OPTICAL_REBOOT = 1320 # 光端机重启
NET_DVR_SET_AUDIOCHAN_CFG = 1321 # 设置音频切换参数
NET_DVR_GET_AUDIOCHAN_CFG = 1322 # 获取音频切换参数
# SDI矩阵1.0
NET_DVR_SET_MATRIX_BASE_CFG = 1332 # 设置矩阵基本参数
NET_DVR_GET_MATRIX_BASE_CFG = 1333 # 获取矩阵基本参数
NET_DVR_SWITCH_MATRIX_IO = 1334 # 矩阵输入输出切换
NET_DVR_GET_MATRIX_IO_RELATION = 1335 # 获取矩阵输入输入关联关系

NET_DVR_V6PSUBSYSTEMARAM_GET = 1501 # 获取V6子系统配置
NET_DVR_V6PSUBSYSTEMARAM_SET = 1502 # 设置V6子系统配置
NET_DVR_GET_ALLWINCFG = 1503 # 窗口参数获取

NET_DVR_BIGSCREENASSOCIATECFG_GET = 1511 # 获取大屏关联配置
NET_DVR_BIGSCREENASSOCIATECFG_SET = 1512 # 设置大屏关联配置

# 1200起
NET_DVR_GETSCREENINFO = 1601 # 获取大屏信息配置
NET_DVR_SETSCREENINFO = 1602 # 设置大屏信息配置
NET_DVR_GET_SCREEN_WINCFG = 1603 # 单个窗口参数获取
NET_DVR_LAYOUTLIST_GET = 1605 # 获取布局列表
NET_DVR_SET_LAYOUTCFG = 1606 # 布局设置
NET_DVR_LAYOUTCTRL = 1607 # 布局控制，1-open，2-close
NET_DVR_INPUTLIST_GET = 1608 # 获取输入信号源列表
NET_DVR_SET_INPUTSTREAMCFG = 1609 # 输入信号源设置
NET_DVR_OUTPUT_SET = 1610 # 输出参数设置
NET_DVR_OUTPUT_GET = 1611 # 输出参数获取
NET_DVR_SET_OSDCFG = 1612 # OSD参数设置
NET_DVR_GET_OSDCFG = 1613 # OSD参数获取
NET_DVR_BIGSCREEN_GETSERIAL = 1614 # 获取大屏串口信息
NET_DVR_GET_PLANLIST = 1615 # 获取预案列表
NET_DVR_SET_PLAN = 1616 # 设置预案
NET_DVR_CTRL_PLAN = 1617 # 控制预案
NET_DVR_GET_DEVICE_RUN_STATUS = 1618 # 获取设备运行状态
NET_DVR_GET_EXTERNAL_MATRIX_CFG = 1619 # 获取矩阵信息
NET_DVR_SET_EXTERNAL_MATRIX_CFG = 1620 # 设置矩阵信息
NET_DVR_GET_OUTPUT_SCREEN_RELATION = 1621 # 获取输出和屏幕的绑定关系
NET_DVR_SET_OUTPUT_SCREEN_RELATION = 1622 # 设置输出和屏幕的绑定关系
NET_DVR_GET_VCS_USER_CFG = 1623 # 获取用户信息配置
NET_DVR_SET_VCS_USER_CFG = 1624 # 设置用户信息配置
NET_DVR_CONTROL_SCREEN = 1625 # 屏幕控制
NET_DVR_GET_EXTERNAL_MATRIX_CFG_V50 = 1626 # 获取矩阵信息
NET_DVR_SET_EXTERNAL_MATRIX_CFG_V50 = 1627 # 设置矩阵信息

NET_DVR_GET_DEV_BASEINFO = 1650 # 获取单个设备信息
NET_DVR_SET_DEV_BASEINFO = 1651 # 设置单个设备信息
NET_DVR_GET_DEV_NETINFO = 1652 # 获取设备的网络信息
NET_DVR_SET_DEV_NETINFO = 1653 # 设置设备的网络信息
NET_DVR_GET_SIGNAL_SOURCE_INFO = 1654 # 获取信号源信息
NET_DVR_SET_SIGNAL_SOURCE_INFO = 1655 # 设置信号源信息
NET_DVR_ADJUST_PIC_V40 = 1656 # 图像微调
NET_DVR_RESTORE_V40 = 1657 # 恢复默认参数
NET_DVR_SET_NET_SIGNAL = 1658 # 设置网络信号源
NET_DVR_REBOOT_V40 = 1659 # 重启
NET_DVR_CONTROL_PICTURE_V41 = 1660 # 图片控制V41

NET_DVR_GET_AUTO_REBOOT_CFG = 1710 # 获取自动重启参数
NET_DVR_SET_AUTO_REBOOT_CFG = 1711 # 设置自动重启参数
NET_DVR_GET_TRUNK_USE_STATE = 1713 # 获取指定干线使用状态
NET_DVR_SET_PTZ_CTRL_INFO = 1714 # 设置PTZ控制参数
NET_DVR_GET_PTZ_CTRL_INFO = 1715 # 获取PTZ控制参数
NET_DVR_GET_PTZ_STATUS = 1716 # 获取PTZ状态
NET_DVR_GET_DISP_ROUTE_LIST = 1717 # 获取显示路径列表

NET_DVR_GET_DEC_RESOURCE_LIST = 1720 # 获取可用解码资源列表
NET_DVR_SET_DEC_RESOURCE_LIST = 1721 # 预分配解码资源
NET_DVR_GET_DEC_YUV = 1722 # 获取解码通道关联YUV输出参数
NET_DVR_SET_DEC_YUV = 1723 # 设置解码通道关联YUV输出参数
NET_DVR_GET_DEC_RESOUCE = 1724 # 向视频综合平台申请解码资源
NET_DVR_FREE_DEC_RESOURCE = 1725 # 释放解码资源

NET_DVR_SET_VIDEOWALLDISPLAYMODE = 1730 # 设置电视墙拼接模式
NET_DVR_GET_VIDEOWALLDISPLAYMODE = 1731 # 获取电视墙拼接模式
NET_DVR_GET_VIDEOWALLDISPLAYNO = 1732 # 获取设备显示输出号
NET_DVR_SET_VIDEOWALLDISPLAYPOSITION = 1733 # 设置显示输出位置参数
NET_DVR_GET_VIDEOWALLDISPLAYPOSITION = 1734 # 获取显示输出位置参数
NET_DVR_GET_VIDEOWALLWINDOWPOSITION = 1735 # 获取电视墙窗口参数
NET_DVR_SET_VIDEOWALLWINDOWPOSITION = 1736 # 设置电视墙窗口参数
NET_DVR_VIDEOWALLWINDOW_CLOSEALL = 1737 # 电视墙关闭所有窗口
NET_DVR_SET_VIRTUALLED = 1738 # 虚拟LED设置
NET_DVR_GET_VIRTUALLED = 1739 # 虚拟LED获取
NET_DVR_GET_IMAGE_CUT_MODE = 1740 # 获取图像切割模式
NET_DVR_SET_IMAGE_CUT_MODE = 1741 # 设置图像切割模式
NET_DVR_GET_USING_SERIALPORT = 1742 # 获取当前使用串口
NET_DVR_SET_USING_SERIALPORT = 1743 # 设置当前使用串口
NET_DVR_SCENE_CONTROL = 1744 # 场景控制
NET_DVR_GET_CURRENT_SCENE = 1745 # 获取当前场景号
NET_DVR_GET_VW_SCENE_PARAM = 1746 # 获取电视墙场景模式参数
NET_DVR_SET_VW_SCENE_PARAM = 1747 # 设置电视墙场景模式参数
NET_DVR_DISPLAY_CHANNO_CONTROL = 1748 # 电视墙显示编号控制
NET_DVR_GET_WIN_DEC_INFO = 1749 # 获取窗口解码信息（批量）
NET_DVR_RESET_VIDEOWALLDISPLAYPOSITION = 1750 # 解除电视墙输出接口绑定
NET_DVR_SET_VW_AUDIO_CFG = 1752 # 设置音频切换参数
NET_DVR_GET_VW_AUDIO_CFG = 1753 # 获取音频切换参数
NET_DVR_GET_GBT28181_DECCHANINFO_CFG = 1754 # 获取GBT28181协议接入设备的解码通道信息
NET_DVR_SET_GBT28181_DECCHANINFO_CFG = 1755 # 设置GBT28181协议接入设备的解码通道信息
NET_DVR_SET_MAINBOARD_SERIAL = 1756 # 设置主控板串口参数
NET_DVR_GET_MAINBOARD_SERIAL = 1757 # 获取主控板串口参数
NET_DVR_GET_SUBBOARD_INFO = 1758 # 获取子板信息
NET_DVR_GET_SUBBOARD_EXCEPTION = 1759 # 获取异常子板异常信息

NET_DVR_GET_CAMERACHAN_SERIALCFG = 1760 # 获取Camera通道绑定串口配置
NET_DVR_SET_CAMERACHAN_SERIALCFG = 1761 # 设置Camera通道绑定串口配置
NET_DVR_GET_MATRIX_STATUS = 1762 # 获取视频综合平台状态
NET_SET_MULTIFUNCTION_SERIALCFG = 1763 # 设置多功能串口配置
NET_GET_MULTIFUNCTION_SERIALCFG = 1764 # 获取多功能串口配置
NET_DVR_PTZ_3D_SPEED = 1765 #  3维带速度的云台控制

NET_DVR_GET_SIGNAL_JOINT = 1766 # 获取信号源绑定配置
NET_DVR_SET_SIGNAL_JOINT = 1767 # 设置信号源绑定配置
NET_DVR_SIGNAL_CUT = 1768 # 信号源裁剪
NET_DVR_DYNAMIC_DECODE_BATCH = 1769 # 批量动态解码
NET_DVR_DECSWITCH_SET_BATCH = 1770 # 批量设置解码通道开关
NET_DVR_DECSWITCH_GET_BATCH = 1771 # 批量获取解码通道开关
NET_DVR_GET_ALL_SIGNAL_JOINT = 1772 # 获取所有信号源绑定配置
NET_DVR_GET_PLAYING_PLAN = 1773 # 获取正在执行预案
NET_DVR_WALL_RELATION_GET = 1774 # 获取设备墙与物理墙的关联
NET_DVR_WALL_RELATION_SET = 1775 # 设置设备墙与物理墙的关联
NET_DVR_SET_INPUTSTREAMCFG_V40 = 1776 # 输入信号源设置
NET_DVR_PTZCFG_INPUTSTREAM_GET = 1777 # 获取输入源反向云台控制配置
NET_DVR_PTZCFG_INPUTSTREAM_SET = 1778 # 设置输入源反向云台控制配置
NET_DVR_SIGNAL_CUTPARAM_GET = 1779 # 获取信号源裁剪参数

NET_DVR_GET_SUBSYSTEM_NETCFG = 1780 # 获取子系统网卡参数
NET_DVR_SET_SUBSYSTEM_NETCFG = 1781 # 设置子系统网卡参数
NET_DVR_DEL_SIGNAL_JOINT = 1782 # 删除拼接信号源

NET_DVR_GET_PICTURE_INFO = 1783 # 获取图片信息
NET_DVR_SET_PICTURE_INFO = 1784 # 设置图片信息
NET_DVR_GET_VIDEO_INFO = 1785 # 获取视频信息
NET_DVR_SET_VIDEO_INFO = 1786 # 设置视频信息
NET_DVR_SET_PLAYLIST = 1787 # 设置播放列表
NET_DVR_GET_PLAYLIST = 1788 # 获取播放列表
NET_DVR_GET_ALL_PLAYLIST = 1789 # 获取所有播放列表
NET_DVR_PLAYITEM_CONTROL = 1790 # 播放项操作
NET_DVR_SET_PLAYPLAN_TEMPLATE = 1791 # 设置播放计划模板
NET_DVR_GET_PLAYPLAN_TEMPLATE = 1792 # 获取播放计划
NET_DVR_GET_ALL_PLAYPLAN_TEMPLATE = 1793 # 获取所有播放计划
NET_DVR_SET_WINDOW_PLAYPLAN = 1794 # 设置窗口播放计划
NET_DVR_GET_WINDOW_PLAYPLAN = 1795 # 获取窗口播放计划
NET_DVR_TOPLAY_ITEM = 1796 # 指定播放
NET_DVR_DEVICE_PLAY_CONTROL = 1797 # 设备播放控制
NET_DVR_GET_PLAY_INFO = 1798 # 获取当前播放信息
NET_DVR_GET_ALL_PICTURE_INFO = 1799 # 获取图片信息
NET_DVR_GET_ALL_VIDEO_INFO = 1800 # 获取视频信息
NET_DVR_DELETE_VIDEO_FILE = 1801 # 删除视频


NET_DVR_GET_ALARMHOSTSUBSYSTEM_CFG = 2001 # 报警主机获取子系统参数
NET_DVR_SET_ALARMHOSTSUBSYSTEM_CFG = 2002 # 报警主机设置子系统参数
NET_DVR_GETEXTENDALARMININFO = 2003 # 获取防区编号信息
NET_DVR_MODIFYALARMINNO = 2004 # 修改防区编号信息
NET_DVR_GET_ALARMHOST_WIRELESS_NETWORK_CFG = 2005 # 获取无线网络参数配置
NET_DVR_SET_ALARMHOST_WIRELESS_NETWORK_CFG = 2006 # 设置无线网络参数配置
NET_DVR_GET_ALARMHOST_NETCFG = 2007 # 获取网络参数配置
NET_DVR_SET_ALARMHOST_NETCFG = 2008 # 设置网络参数配置
NET_DVR_GET_LED_SCREEN_CFG = 2009 #  获取LED屏幕参数
NET_DVR_SET_LED_SCREEN_CFG = 2010 #  设置LED屏幕参数
NET_DVR_GET_LED_CONTENT_CFG = 2011 #  获取LED屏显内容
NET_DVR_SET_LED_CONTENT_CFG = 2012 #  设置LED屏显内容
NET_DVR_TURNON_LED = 2013 #  打开LED屏
NET_DVR_TURNOFF_LED = 2014 #  关闭LED屏
NET_DVR_GET_LED_TIMER_SWITCH = 2015 #  获取LED屏定时开关参数
NET_DVR_SET_LED_TIMER_SWITCH = 2016 #  设置LED屏定时开关参数
NET_DVR_SET_LED_BRIGHTNESS = 2017 #  手动设置LED屏亮度
NET_DVR_GET_LED_TIMER_BRIGHTNESS = 2018 # 设置分时LED屏亮度
NET_DVR_SET_LED_TIMER_BRIGHTNESS = 2019 # 获取分时LED屏亮度
NET_DVR_LED_CHECKTIME = 2020 # LED校时
NET_DVR_GET_ALARMHOST_AUDIO_ASSOCIATE_ALARM = 2021 # 获取音频跟随报警事件
NET_DVR_SET_ALARMHOST_AUDIO_ASSOCIATE_ALARM = 2022 # 设置音频跟随报警事件
NET_DVR_GET_LED_STATUS = 2023 # 获取LED屏状态
NET_DVR_CLOSE_SUBSYSTEM_FAULT_ALARM = 2027 # 关闭子系统故障提示音
NET_DVR_SET_SUBSYSTEM_BYPASS = 2028 # 子系统旁路
NET_DVR_CANCEL_SUBSYSTEM_BYPASS = 2029 # 子系统旁路恢复

NET_DVR_GET_ALARMHOST_SUBSYSTEM_CFG_EX = 2030 # 获取子系统扩展参数
NET_DVR_SET_ALARMHOST_SUBSYSTEM_CFG_EX = 2031 # 设置子系统扩展参数
NET_DVR_GET_ALARMHOST_PRINTER_CFG = 2032 # 获取打印机打印使能
NET_DVR_SET_ALARMHOST_PRINTER_CFG = 2033 # 设置打印机打印使能
NET_DVR_GET_ALARMHOST_ZONE_LIST_IN_SUBSYSTEM = 2034 # 获取指定子系统内的所有防区
NET_DVR_GET_ALARMHOST_TRIGGER_LIST = 2035 # 获取所有触发器
NET_DVR_ARM_ALARMHOST_SUBSYSTEM = 2036 # 按布防类型对子系统布防
NET_DVR_GET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG = 2037 #  获取事件触发报警输出配置
NET_DVR_SET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG = 2038 #  设置事件触发报警输出配置
NET_DVR_GET_ALARMHOST_FAULT_CFG = 2039 #  获取故障处理配置
NET_DVR_SET_ALARMHOST_FAULT_CFG = 2040 #  设置故障处理配置
NET_DVR_SEARCH_ARMHOST_EXTERNAL_MODULE = 2041 # 自动搜索
NET_DVR_REGISTER_ALARMHOST_EXTERNAL_MODULE = 2042 # 自动注册
NET_DVR_CLOSE_ALARMHOST_OVERALL_FAULT_ALARM = 2043 # 关闭全局故障提示音

NET_DVR_GET_SAFETYCABIN_WORK_MODE = 2044 # 获取防护舱工作模式参数
NET_DVR_SET_SAFETYCABIN_WORK_MODE = 2045 # 设置防护舱工作模式参数
NET_DVR_GET_SAFETYCABIN_PERSON_SIGNAL_CFG = 2046 # 获取防护舱人信号探测参数
NET_DVR_SET_SAFETYCABIN_PERSON_SIGNAL_CFG = 2047 # 设置防护舱人信号探测参数

NET_DVR_GET_ALARMHOST_MODULE_CFG = 2048 # 获取模块信息
 #   NET_DVR_SET_ALARMHOST_MODULE_CFG            2049# 设置模块信息(预留)

NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_STATE = 2050 # 获取485外接设备状态
NET_DVR_SET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE = 2051 # 设置外接设备报警限值
NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE = 2052 # 获取外接设备报警限值
NET_DVR_GET_ALARMHOST_SENSOR_JOINT_CFG = 2053 #  获取模拟量关联配置
NET_DVR_SET_ALARMHOST_SENSOR_JOINT_CFG = 2054 #  设置模拟量关联配置
NET_DVR_SET_ALARMHOST_RS485_SLOT_CFG = 2055 #  设置报警主机485槽位参数
NET_DVR_GET_ALARMHOST_RS485_SLOT_CFG = 2056 #  获取报警主机485槽位参数

NET_DVR_GET_ALL_VARIABLE_INFO = 2057 #  获取所有变量元素信息
NET_DVR_GET_ALARM_POINT_CFG = 2058 #  获取点号信息
NET_DVR_SET_ALARM_POINT_CFG = 2059 #  设置点号信息
NET_DVR_GET_HISTORY_VALUE = 2060 #  获取历史数据
NET_DVR_GET_ALARMHOST_ALARM_MODE = 2061 #  获取数据上传方式
NET_DVR_SET_ALARMHOST_ALARM_MODE = 2062 #  设置数据上传方式
NET_DVR_GET_ALARMHOST_SENSOR_VALUE = 2063 #  获取模拟量实时数据

NET_DVR_GET_ALARMHOST_REPORT_CENTER_V40 = 2064 #  获取数据上传方式
NET_DVR_SET_ALARMHOST_REPORT_CENTER_V40 = 2065 #  设置数据上传方式
NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG = 2068 #  获取时控输出参数
NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG = 2069 #  设置时控输出参数
NET_DVR_GET_CMS_CFG = 2070
NET_DVR_SET_CMS_CFG = 2071

NET_DVR_GET_PASSTHROUGH_CAP = 2073 # 获取设备透传能力集

NET_DVR_GET_ALARMHOST_MAIN_STATUS_V40 = 2072 #  获取主要状态V40
NET_DVR_GET_ALARMHOST_MAIN_STATUS_V51 = 2083 #  获取主要状态V51

# 视频报警主机1.3
NET_DVR_GET_ALARM_CAPTRUE_CFG = 2074 # 获取报警抓图参数配置
NET_DVR_SET_ALARM_CAPTRUE_CFG = 2075 # 设置报警抓图参数配置
NET_DVR_GET_ONE_OUTPUT_SCH_RULECFG_V40 = 2078 #  获取单个时控输出参数V40
NET_DVR_SET_ONE_OUTPUT_SCH_RULECFG_V40 = 2079 #  设置单个时控输出参数V40
NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG_V40 = 2080 #  获取时控输出参数V40
NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG_V40 = 2081 #  设置时控输出参数V40
NET_DVR_ALARMHOST_CLOSE_SUBSYSTEM = 2082 # 对子系统撤防操作

NET_DVR_GET_WEEK_PLAN_CFG = 2100 # 获取门状态周计划参数
NET_DVR_SET_WEEK_PLAN_CFG = 2101 # 设置门状态周计划参数
NET_DVR_GET_DOOR_STATUS_HOLIDAY_PLAN = 2102 # 获取门状态假日计划参数
NET_DVR_SET_DOOR_STATUS_HOLIDAY_PLAN = 2103 # 设置门状态假日计划参数
NET_DVR_GET_DOOR_STATUS_HOLIDAY_GROUP = 2104 # 获取门状态假日组参数
NET_DVR_SET_DOOR_STATUS_HOLIDAY_GROUP = 2105 # 设置门状态假日组参数
NET_DVR_GET_DOOR_STATUS_PLAN_TEMPLATE = 2106 # 获取门状态计划模板参数
NET_DVR_SET_DOOR_STATUS_PLAN_TEMPLATE = 2107 # 设置门状态计划模板参数
NET_DVR_GET_DOOR_CFG = 2108 # 获取门参数
NET_DVR_SET_DOOR_CFG = 2109 # 设置门参数
NET_DVR_GET_DOOR_STATUS_PLAN = 2110 # 获取门状态计划参数
NET_DVR_SET_DOOR_STATUS_PLAN = 2111 # 设置门状态计划参数
NET_DVR_GET_GROUP_CFG = 2112 # 获取群组参数
NET_DVR_SET_GROUP_CFG = 2113 # 设置群组参数
NET_DVR_GET_MULTI_CARD_CFG = 2114 # 获取多重卡参数
NET_DVR_SET_MULTI_CARD_CFG = 2115 # 设置多重卡参数
NET_DVR_GET_CARD_CFG = 2116 # 获取卡参数
NET_DVR_SET_CARD_CFG = 2117 # 设置卡参数
NET_DVR_CLEAR_ACS_PARAM = 2118 # 清空门禁主机参数
NET_DVR_GET_SNEAK_CFG = 2119 # 获取反潜回参数
NET_DVR_SET_SNEAK_CFG = 2120 # 设置反潜回参数
NET_DVR_GET_MULTI_DOOR_INTERLOCK_CFG = 2121 # 获取多门互锁参数
NET_DVR_SET_MULTI_DOOR_INTERLOCK_CFG = 2122 # 设置多门互锁参数
NET_DVR_GET_ACS_WORK_STATUS = 2123 # 获取门禁主机工作状态
NET_DVR_GET_VERIFY_WEEK_PLAN = 2124 # 获取读卡器验证方式周计划参数
NET_DVR_SET_VERIFY_WEEK_PLAN = 2125 # 设置读卡器验证方式周计划参数
NET_DVR_GET_CARD_RIGHT_WEEK_PLAN = 2126 # 获取卡权限周计划参数
NET_DVR_SET_CARD_RIGHT_WEEK_PLAN = 2127 # 设置卡权限周计划参数
NET_DVR_GET_VERIFY_HOLIDAY_PLAN = 2128 # 获取读卡器验证方式假日计划参数
NET_DVR_SET_VERIFY_HOLIDAY_PLAN = 2129 # 设置读卡器验证方式假日计划参数
NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN = 2130 # 获取卡权限假日计划参数
NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN = 2131 # 设置卡权限假日计划参数
NET_DVR_GET_VERIFY_HOLIDAY_GROUP = 2132 # 获取读卡器验证方式假日组参数
NET_DVR_SET_VERIFY_HOLIDAY_GROUP = 2133 # 设置读卡器验证方式假日组参数
NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP = 2134 # 获取卡权限假日组参数
NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP = 2135 # 设置卡权限假日组参数
NET_DVR_GET_VERIFY_PLAN_TEMPLATE = 2136 # 获取读卡器验证方式计划模板参数
NET_DVR_SET_VERIFY_PLAN_TEMPLATE = 2137 # 设置读卡器验证方式计划模板参数
NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE = 2138 # 获取卡权限计划模板参数
NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE = 2139 # 设置卡权限计划模板参数
NET_DVR_GET_CARD_READER_CFG = 2140 # 获取读卡器参数
NET_DVR_SET_CARD_READER_CFG = 2141 # 设置读卡器参数
NET_DVR_GET_CARD_READER_PLAN = 2142 # 获取读卡器验证计划参数
NET_DVR_SET_CARD_READER_PLAN = 2143 # 设置读卡器验证计划参数
NET_DVR_GET_CASE_SENSOR_CFG = 2144 # 获取事件触发器参数
NET_DVR_SET_CASE_SENSOR_CFG = 2145 # 设置事件触发器参数
NET_DVR_GET_CARD_READER_ANTI_SNEAK_CFG = 2146 # 获取读卡器反潜回参数
NET_DVR_SET_CARD_READER_ANTI_SNEAK_CFG = 2147 # 设置读卡器反潜回参数
NET_DVR_GET_PHONE_DOOR_RIGHT_CFG = 2148 # 获取手机关联门权限参数
NET_DVR_SET_PHONE_DOOR_RIGHT_CFG = 2149 # 获取手机关联门权限参数
NET_DVR_GET_FINGERPRINT_CFG = 2150 # 获取指纹参数
NET_DVR_SET_FINGERPRINT_CFG = 2151 # 设置指纹参数
NET_DVR_DEL_FINGERPRINT_CFG = 2152 # 删除指纹参数
NET_DVR_GET_EVENT_CARD_LINKAGE_CFG = 2153 # 获取事件卡号联动配置参数
NET_DVR_SET_EVENT_CARD_LINKAGE_CFG = 2154 # 设置事件卡号联动配置参数
NET_DVR_GET_ANTI_SNEAK_HOST_CFG = 2155 # 获取主机组反潜回参数
NET_DVR_SET_ANTI_SNEAK_HOST_CFG = 2156 # 设置主机组反潜回参数
NET_DVR_GET_READER_ANTI_SNEAK_HOST_CFG = 2157 # 获取主机组读卡器反潜回参数
NET_DVR_SET_READER_ANTI_SNEAK_HOST_CFG = 2158 # 设置主机组读卡器反潜回参数
NET_DVR_GET_ACS_CFG = 2159 # 获取门禁主机参数
NET_DVR_SET_ACS_CFG = 2160 # 设置门禁主机参数
NET_DVR_GET_CARD_PASSWD_CFG = 2161 # 获取卡密码开门使能配置
NET_DVR_SET_CARD_PASSWD_CFG = 2162 # 设置卡密码开门使能配置
NET_DVR_GET_CARD_USERINFO_CFG = 2163 # 获取卡号关联用户信息参数
NET_DVR_SET_CARD_USERINFO_CFG = 2164 # 设置卡号关联用户信息参数

NET_DVR_GET_ACS_EXTERNAL_DEV_CFG = 2165 # 获取门禁主机串口外设参数
NET_DVR_SET_ACS_EXTERNAL_DEV_CFG = 2166 # 设置门禁主机串口外设参数
NET_DVR_GET_PERSONNEL_CHANNEL_CFG = 2167 # 获取人员通道参数
NET_DVR_SET_PERSONNEL_CHANNEL_CFG = 2168 # 设置人员通道参数
NET_DVR_SET_PLATFORM_VERIFY_CFG = 2169 # 下发平台认证结果
NET_DVR_GET_PERSON_STATISTICS_CFG = 2170 # 获取人数统计参数
NET_DVR_SET_PERSON_STATISTICS_CFG = 2171 # 设置人数统计参数
NET_DVR_GET_ACS_SCREEN_DISPLAY_CFG = 2172 # 获取屏幕字符串显示参数
NET_DVR_SET_ACS_SCREEN_DISPLAY_CFG = 2173 # 设置屏幕字符串显示参数
NET_DVR_GET_GATE_TIME_CFG = 2174 # 获取人员通道闸门时间参数
NET_DVR_SET_GATE_TIME_CFG = 2175 # 设置人员通道闸门时间参数
NET_DVR_GET_LOCAL_CONTROLLER_STATUS = 2176 # 获取就地控制器状态
NET_DVR_GET_ONLINE_LOCAL_CONTROLLER = 2177 # 搜索在线就地控制器
NET_DVR_GET_CARD_CFG_V50 = 2178 # 获取新卡参数(V50)
NET_DVR_SET_CARD_CFG_V50 = 2179 # 设置新卡参数(V50)
NET_DVR_GET_ACS_WORK_STATUS_V50 = 2180 # 获取门禁主机工作状态(V50)
NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V50 = 2181 # 获取事件卡号联动配置参数(V50)
NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V50 = 2182 # 设置事件卡号联动配置参数(V50)
NET_DVR_GET_FINGERPRINT_CFG_V50 = 2183 # 获取指纹参数V50
NET_DVR_SET_FINGERPRINT_CFG_V50 = 2184 # 设置指纹参数V50

NET_DVR_GET_SAFETYCABIN_STATE = 2197 # 获取防护舱状态
NET_DVR_GET_RS485_CASCADE_CFG = 2198 # 获取Rs485级联设备配置
NET_DVR_SET_RS485_CASCADE_CFG = 2199 # 设置Rs485级联设备配置

# 视频报警主机2.0
NET_DVR_GET_REMOTECONTROLLER_PERMISION_CFG = 2200 # 获取遥控器权限参数
NET_DVR_SET_REMOTECONTROLLER_PERMISION_CFG = 2201 # 设置遥控器权限参数
NET_DVR_GET_KEYBOARD_CFG = 2202 # 获取键盘参数配置
NET_DVR_SET_KEYBOARD_CFG = 2203 # 设置键盘参数配置
NET_DVR_GET_ALARMHOST_WIRELESS_BUSINNESS_INFO = 2204 # 无线业务查询
NET_DVR_GET_ALL_REMOTECONTROLLER_LIST = 2205 # 获取所有遥控器
NET_DVR_GET_PREVIEW_DELAY_CFG = 2206 # 获取延迟预览参数配置
NET_DVR_SET_PREVIEW_DELAY_CFG = 2207 # 设置延迟预览参数配置
NET_DVR_GET_ZONE_CHANNEL_LINKAGE_CFG = 2208 # 获取防区联动视频通道配置
NET_DVR_SET_ZONE_CHANNEL_LINKAGE_CFG = 2209 # 设置防区联动视频通道配置
NET_DVR_GET_CENTER_SERVER_CFG = 2210 # 获取报警中心服务器
NET_DVR_SET_CENTER_SERVER_CFG = 2211 # 设置报警中心服务器

# 一键式紧急报警产品V1.0.0
NET_DVR_GET_EMERGENCE_ALARM_PRODUCT_CAP = 2212 # 获取一键式紧急报警产品能力
NET_DVR_GET_CALL_WAITTING_CFG_CAP = 2213 # 获取呼叫等待参数配置能力
NET_DVR_GET_CALL_WAITTING_CFG = 2214 # 获取呼叫等待参数配置
NET_DVR_SET_CALL_WAITTING_CFG = 2215 # 设置呼叫等待参数配置
NET_DVR_GET_ALARM_LAMP_CFG_CAP = 2216 # 获取警灯参数配置能力
NET_DVR_GET_ALARM_LAMP_CFG = 2217 # 获取警灯参数配置
NET_DVR_SET_ALARM_LAMP_CFG = 2218 # 设置警灯参数配置
NET_DVR_GET_VOICE_PROMPTION_CFG_CAP = 2219 # 获取语音提示配置能力
NET_DVR_GET_VOICE_PROMPTION_CFG = 2220 # 获取语音提示配置
NET_DVR_SET_VOICE_PROMPTION_CFG = 2221 # 设置语音提示配置
NET_DVR_GET_EMERGENCE_ALARM_RESPONSE_CAP = 2222 # 获取紧急报警处理能力
NET_DVR_EMERGENCE_ALARM_RESPONSE_CTRL = 2223 # 紧急报警处理控制

# 网络报警主机 V2.2
NET_DVR_GET_ALARMHOST_NETCFG_V50 = 2224 # 获取报警主机网络参数配置V50
NET_DVR_SET_ALARMHOST_NETCFG_V50 = 2225 # 设置报警主机网络参数配置V50
NET_DVR_REGISTER_ALARM_RS485 = 2226 # RS485重新注册

NET_DVR_GET_ALARMIN_PARAM_LIST = 2227 # 获取防区参数列表
# 无线报警主机1.0.0
NET_DVR_GET_ALARMHOST_OTHER_STATUS_V50 = 2228 # 获取报警主机其他状态v50
NET_DVR_GET_ALARMHOST_OTHER_STATUS_V51 = 2236 # 获取报警主机其他状态V51
NET_DVR_GET_ALARMIN_ASSOCIATED_CHAN_LIST = 2229 # 获取防区防区联动视频通道参数列表
NET_DVR_GET_ALARMIN_TRIGGER = 2230 # 获取报警主机防区联动配置
NET_DVR_SET_ALARMIN_TRIGGER = 2231 # 设置报警主机防区联动配置
NET_DVR_GET_EMERGENCY_CALL_HELP_TRIGGER = 2232 # 获取报警主机紧急求助联动配置
NET_DVR_SET_EMERGENCY_CALL_HELP_TRIGGER = 2233 # 设置报警主机紧急求助联动配置
NET_DVR_GET_CONSULT_TRIGGER = 2234 # 获取报警主机业务咨询联动配置
NET_DVR_SET_CONSULT_TRIGGER = 2235 # 设置报警主机业务咨询联动配置
NET_DVR_GET_ALARMIN_PARAM_LIST_V50 = 2237 # 获取防区参数列表V50

NET_DVR_GET_CARD_RIGHT_WEEK_PLAN_V50 = 2304 # 获取卡权限周计划参数V50
NET_DVR_SET_CARD_RIGHT_WEEK_PLAN_V50 = 2305 # 设置卡权限周计划参数V50

NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN_V50 = 2310 # 获取卡权限假日计划参数V50
NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN_V50 = 2311 # 设置卡权限假日计划参数V50

NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP_V50 = 2316 # 获卡权限假日组参数V50
NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP_V50 = 2317 # 设置卡权限假日组参数V50

NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE_V50 = 2322 # 获取卡权限计划模板参数V50
NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE_V50 = 2323 # 设置卡权限计划模板参数V50

# 经济型指纹门禁产品V1.0 设备不做
NET_DVR_GET_SCHEDULE_INFO = 2500 # 获取排班信息
NET_DVR_GET_ATTENDANCE_SUMMARY_INFO = 2501 # 获取考勤汇总信息
NET_DVR_GET_ATTENDANCE_RECORD_INFO = 2502 # 获取考勤记录信息
NET_DVR_GET_ABNORMAL_INFO = 2503 # 获取异常统计信息

# 视频门禁一体机1.0
NET_DVR_CAPTURE_FINGERPRINT_INFO = 2504 # 采集指纹信息

# 嵌入式智能终端
NET_DVR_BULK_UPLOAD_BLACK_LIST_PICTURE = 2520 # 批量上传黑名单图片
NET_DVR_BULK_UPLOAD_ID_BLACK_LIST = 2521 # 批量上传身份证黑名单
NET_DVR_GET_FAILED_FACE_INFO = 2522 # 获取设备升级建模失败的人脸记录
NET_DVR_GET_FACE_AND_TEMPLATE = 2523 # 获取人脸及模板数据
NET_DVR_SET_FACE_AND_TEMPLATE = 2524 # 设置人脸及模板数据

# 人脸识别门禁一体机
NET_DVR_GET_CARD_READER_CFG_V50 = 2505 # 获取读卡器参数(V50)
NET_DVR_SET_CARD_READER_CFG_V50 = 2506 # 设置读卡器参数(V50)
NET_DVR_GET_FACE_PARAM_CFG = 2507 # 获取人脸参数
NET_DVR_SET_FACE_PARAM_CFG = 2508 # 设置人脸参数
NET_DVR_DEL_FACE_PARAM_CFG = 2509 # 删除人脸参数
NET_DVR_CAPTURE_FACE_INFO = 2510 # 采集人脸信息

NET_DVR_GET_REGISTER_INFO = 2511 # 登记信息获取

NET_DVR_GET_SMSRELATIVEPARA_V50 = 2512 # 获取短信相关参数
NET_DVR_SET_SMSRELATIVEPARA_V50 = 2513 # 设置短信相关参数
NET_DVR_GET_ACS_EVENT = 2514 # 设备事件获取
NET_DVR_GET_MULTI_CARD_CFG_V50 = 2515 # 获取多重卡参数V50
NET_DVR_SET_MULTI_CARD_CFG_V50 = 2516 # 设置多重卡参数V50
NET_DVR_DEL_FINGERPRINT_CFG_V50 = 2517 # 删除指纹参数V50
NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V51 = 2518 # 获取事件卡号联动配置参数(V51)
NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V51 = 2519 # 设置事件卡号联动配置参数(V51)

NET_DVR_SET_EXAM_INFO = 2530 # 考试信息下发
NET_DVR_SET_EXAMINEE_INFO = 2531 # 考生信息下发
NET_DVR_SEARCH_EXAM_COMPARE_RESULT = 2532 # 考试比对结果查询
NET_DVR_BULK_CHECK_FACE_PICTURE = 2533 # 批量校验人脸图片
NET_DVR_JSON_CONFIG = 2550 # JSON透传数据
NET_DVR_FACE_DATA_RECORD = 2551 # 添加人脸数据到人脸库
NET_DVR_FACE_DATA_SEARCH = 2552 # 查询人脸库中的人脸数据
NET_DVR_FACE_DATA_MODIFY = 2553 # 修改人脸库中的人脸数据
NET_DVR_CAPTURE_DATA_SEARCH = 2554 # 查询离线采集数据集中数据

NET_DVR_GET_CARD = 2560
NET_DVR_SET_CARD = 2561
NET_DVR_DEL_CARD = 2562
NET_DVR_GET_FINGERPRINT = 2563
NET_DVR_SET_FINGERPRINT = 2564
NET_DVR_DEL_FINGERPRINT = 2565
NET_DVR_GET_FACE = 2566
NET_DVR_SET_FACE = 2567

NET_DVR_GET_ALL_ALARM_RS485CFG = 2705 #  获取485参数
NET_DVR_GET_ALL_ALARMHOST_RS485_SLOT_CFG = 2706 #  获取所有报警主机485槽位参数
NET_DVR_GET_DEVICE_SELF_CHECK_STATE = 2707 # 获取设备自检功能
NET_DVR_GET_ALL_ALARM_POINT_CFG = 2708 #  获取所有点号参数
NET_DVR_GET_ALL_ALARM_SENSOR_CFG = 2709 #  获取所有模拟量参数
NET_DVR_GET_ALL_ALARM_SENSOR_JOINT = 2710 # 获取所有模拟量联动参数
NET_DVR_GET_AIR_CONDITION_PARAM = 2711 # 获取空调参数
NET_DVR_GET_OUT_SCALE_CFG = 2712 # 获取主辅口输出配置
NET_DVR_SET_OUT_SCALE_CFG = 2713 # 设置主辅口输出配置
NET_DVR_GET_ALARM_CHAN_ABLITITY = 2714 # 获取报警相关通道参
# 动环报警主机V3.0

# 动环报警主机D2000 V1.0
NET_DVR_GET_ALARMCENTER_NETCFG = 2715 # 获取报警中心网络参数配置
NET_DVR_SET_ALARMCENTER_NETCFG = 2716 # 获取报警中心网络参数配置


NET_ITC_GET_TRIGGERCFG = 3003 # 获取触发参数
NET_ITC_SET_TRIGGERCFG = 3004 # 设置触发参数
NET_ITC_GET_IOOUT_PARAM_CFG = 3005 # 获取IO输出参数（3.1含之后版本）
NET_ITC_SET_IOOUT_PARAM_CFG = 3006 # 设置IO输出参数（3.1含之后版本）

NET_DVR_GET_CAMERA_SETUPCFG = 3007 # 获取相机架设参数
NET_DVR_SET_CAMERA_SETUPCFG = 3008 # 设置相机架设参数

NET_ITC_GET_TRIGGER_DEFAULTCFG = 3013 # 获取触发模式推荐参数
NET_DVR_GET_STATUS_DETECTCFG = 3015 # 获取状态检测使能参数
NET_DVR_SET_STATUS_DETECTCFG = 3016 # 设置状态检测使能参数
NET_ITC_GET_VIDEO_TRIGGERCFG = 3017 # 获取视频电警触发参数
NET_ITC_SET_VIDEO_TRIGGERCFG = 3018 # 设置视频电警触发参数
NET_DVR_GET_TPS_ALARMCFG = 3019 # 获取交通统计报警参数
NET_DVR_SET_TPS_ALARMCFG = 3020 # 设置交通统计报警参数


NET_DVR_GET_REDAREACFG = 3100 # 获取红绿灯区域参数
NET_DVR_SET_REDAREACFG = 3101 # 设置红绿灯区域参数
NET_DVR_GET_TEST_SPOT = 3102 # 获取SPOT口测试总步数和当前第几步
NET_DVR_SET_TEST_SPOT = 3103 # 设置SPOT口测试总步数和当前第几步
NET_DVR_GET_CABINETCFG = 3104 # 机柜参数配置获取
NET_DVR_SET_CABINETCFG = 3105 # 机柜参数配置设置
NET_DVR_VEHICLE_CHECK_START = 3106 # 黑名单稽查数据回传
NET_DVR_SET_CAPTUREPIC_CFG = 3107 # 车载抓图配置设置命令
NET_DVR_GET_CAPTUREPIC_CFG = 3108 # 车载抓图配置获取命令
NET_DVR_SET_MOBILEPLATE_RECOG_CFG = 3109 # 车载车牌识别配置设置命令
NET_DVR_GET_MOBILEPLATE_RECOG_CFG = 3110 # 车载车牌识别配置获取命令
NET_DVR_SET_MOBILE_RADAR_CFG = 3111 # 车载雷达配置设置命令
NET_DVR_GET_MOBILE_RADAR_CFG = 3112 # 车载雷达配置获取命令
NET_DVR_SET_MOBILE_LOCALPLATECHK_CFG = 3113 # 车载黑名单本地对比配置设置命令
NET_DVR_GET_MOBILE_LOCALPLATECHK_CFG = 3114 # 车载黑名单本地对比配置获取命令

NET_ITC_GET_ICRCFG = 3115 # 获取ICR配置切换
NET_ITC_SET_ICRCFG = 3116 # 设置ICR配置切换
NET_ITC_GET_RS485_ACCESSINFO = 3117 # 获取Rs485关联接入设备的信息
NET_ITC_SET_RS485_ACCESSINFO = 3118 # 设置Rs485关联接入设备的信息
NET_ITC_GET_EXCEPTIONCFG = 3119 # 获取异常参数
NET_ITC_SET_EXCEPTIONCFG = 3120 # 设置异常参数
NET_ITC_GET_FTPCFG = 3121 # 获取ITC  FTP设置参数
NET_ITC_SET_FTPCFG = 3122 # 设置ITC FTP设置参数

NET_DVR_VEHICLE_CONTROL_LIST_START = 3123 # 设置车辆黑白名单信息
NET_DVR_GET_ALL_VEHICLE_CONTROL_LIST = 3124 # 获取所有车辆黑白名单信息
NET_DVR_VEHICLE_DELINFO_CTRL = 3125 # 删除设备内黑名单数据库信息
NET_DVR_GET_ENTRANCE_PARAMCFG = 3126 # 获取出入口控制参数
NET_DVR_SET_ENTRANCE_PARAMCFG = 3127 # 设置出入口控制参数
NET_DVR_BARRIERGATE_CTRL = 3128 # 远程控制道闸
NET_DVR_GATELAMP_CTRL = 3129 # 常亮灯功能
NET_DVR_GET_CURTRIGGERMODE = 3130 # 获取设备当前触发模式
NET_DVR_GET_GPSDATACFG = 3131 # 获取GPS参数
NET_DVR_SET_GPSDATACFG = 3132 # 设置GPS参数
NET_DVR_VEHICLELIST_CTRL_START = 3133 # 设置车辆黑白名单信息

NET_DVR_GET_GUARDCFG = 3134 # 获取车牌识别检测计划
NET_DVR_SET_GUARDCFG = 3135 # 设置车牌识别检测计划
NET_DVR_GET_SNAPINFO_CFG = 3136 # 获取抓拍图片参数
NET_DVR_SET_SNAPINFO_CFG = 3137 # 设置抓拍图片参数
NET_DVR_GET_SNAPINFO_CFG_V40 = 3138 # 获取抓拍图片参数扩展
NET_DVR_SET_SNAPINFO_CFG_V40 = 3139 # 设置抓拍图片参数扩展
NET_DVR_SET_CURTRIGGERMODE = 3140 # 设置设备当前触发模式(仅IPC/D支持)
NET_DVR_GET_TRAFFIC_DATA = 3141 # 长连接获取交通数据
NET_DVR_GET_TRAFFIC_FLOW = 3142 # 长连接获取交通流量
NET_DVR_PARKING_VEHICLE_SEND = 3143 # 停车车辆信息下发
NET_DVR_PARKING_CARD_SEND = 3144 # 停车卡下发
NET_DVR_PARKING_CARD_CTRL = 3145 # 停车场停车卡控制接口

NET_DVR_GET_ALARMCTRL_CAPABILITIES = 3146 # 获取报警控制能力
NET_DVR_SET_ALARMCTRL_CFG = 3147 # 设置报警控制
NET_DVR_GET_ALARMCTRL_CFG = 3148 # 获取报警控制

NET_DVR_GET_AUDIO_INPUT = 3201 # 获取音频输入参数
NET_DVR_SET_AUDIO_INPUT = 3202 # 设置音频输入参数
NET_DVR_GET_CAMERA_DEHAZE_CFG = 3203 # 获取透雾参数配置
NET_DVR_SET_CAMERA_DEHAZE_CFG = 3204 # 设置透雾参数配置
NET_DVR_REMOTECONTROL_ALARM = 3205 # 远程控制遥控器布防
NET_DVR_REMOTECONTROL_DISALARM = 3206 # 远程控制遥控器撤防
NET_DVR_REMOTECONTROL_STUDY = 3207 # 远程控制遥控器学习
NET_DVR_WIRELESS_ALARM_STUDY = 3208 # 远程控制无线报警学习
NET_IPC_GET_AUX_ALARMCFG = 3209 # 获取辅助报警参数配置
NET_IPC_SET_AUX_ALARMCFG = 3210 # 设置辅助报警参数配置
NET_DVR_GET_PREVIEW_DISPLAYCFG = 3211 # 获取预览显示参数
NET_DVR_SET_PREVIEW_DISPLAYCFG = 3212 # 设置预览显示参数
NET_DVR_REMOTECONTROL_PTZ = 3213 # 远程控制PTZ
NET_DVR_REMOTECONTROL_PRESETPOINT = 3214 # 远程控制预置点
NET_DVR_REMOTECONTROL_CRUISE = 3215 # 远程控制巡航

NET_DVR_GET_MULTI_STREAM_COMPRESSIONCFG = 3216 # 远程获取多码流压缩参数
NET_DVR_SET_MULTI_STREAM_COMPRESSIONCFG = 3217 # 远程设置多码流压缩参数

NET_DVR_GET_WPSCFG = 3218 # 获取WPS参数
NET_DVR_SET_WPSCFG = 3219 # 设置WPS参数
NET_DVR_WPS_CONNECT = 3220 # 远程启用WPS连接
NET_DVR_GET_DEVICE_PIN = 3221 # 获取设备PIN码
NET_DVR_UPDATE_PIN = 3223 # 更新设备PIN码
NET_DVR_GET_PRESETCFG = 3224 # 获取预置点参数
NET_DVR_GET_PTZCRUISECFG = 3225 # 获取巡航路径参数
NET_DVR_GET_PRESET_NUM = 3226 # 获取预置点个数
NET_DVR_GET_PTZCRUISE_NUM = 3227 # 获取巡航路径个数

NET_DVR_GET_MOTION_TRACK_CFG = 3228 # 获取跟踪参数
NET_DVR_SET_MOTION_TRACK_CFG = 3229 # 设置跟踪参数
NET_DVR_CLEAR_IPC_PARAM = 3230 # 清空前端参数
NET_DVR_GET_IPADDR_FILTERCFG = 3232 # 获取IP地址过滤参数
NET_DVR_SET_IPADDR_FILTERCFG = 3233 # 设置IP地址过滤参数

NET_DVR_GET_LOGO_OVERLAYCFG = 3234 # 获取LOGO图片叠加参数
NET_DVR_SET_LOGO_OVERLAYCFG = 3235 # 设置LOGO图片叠加参数

NET_DVR_GET_IPV6_LIST = 3236 # 获取网卡的全部IPV6地址信息
NET_DVR_GET_AUDIOOUT_VOLUME = 3237 # 获取输出音频大小
NET_DVR_SET_AUDIOOUT_VOLUME = 3238 # 设置输出音频大小
NET_DVR_GET_FUZZY_UPGRADE = 3239 # 获取模糊升级匹配信息

NET_DVR_GET_BV_CORRECT_PARAM = 3240 # 获取相机校正参数
NET_DVR_SET_BV_CORRECT_PARAM = 3241 # 设置相机校正参数
NET_DVR_GET_OUTPUT_VIDEO_TYPE = 3242 # 获取输出视频类型
NET_DVR_SET_OUTPUT_VIDEO_TYPE = 3243 # 设置输出视频类型

NET_DVR_FISHEYE_CFG = 3244 # 鱼眼长连接配置
NET_DVR_GET_PTZ_POINT = 3245 # 获取PTZ点坐标
NET_DVR_SET_PTZ_POINT = 3246 # 设置PTZ点坐标
NET_DVR_REMOTECONTROL_DEV_PARAM = 3247 # 设置设备登录客户端参数
NET_DVR_GET_FISHEYE_STREAM_STATUS = 3248 # 获取鱼眼码流状态

NET_DVR_GET_GBT28181_ACCESS_CFG = 3249 # 获取GBT28181协议接入配置
NET_DVR_SET_GBT28181_ACCESS_CFG = 3250 # 设置GBT28181协议接入配置
NET_DVR_GET_GBT28181_CHANINFO_CFG = 3251 # 获取GBT28181协议接入设备的通道信息
NET_DVR_SET_GBT28181_CHANINFO_CFG = 3252 # 设置GBT28181协议接入设备的通道信息
NET_DVR_GET_GBT28181_ALARMINCFG = 3253 # 获取GBT28181协议接入设备的报警信息
NET_DVR_SET_GBT28181_ALARMINCFG = 3254 # 设置GBT28181协议接入设备的报警信息
NET_DVR_GET_ISP_CAMERAPARAMCFG = 3255 # 获取ISP前端参数配置
NET_DVR_SET_ISP_CAMERAPARAMCFG = 3256 # 设置ISP前端参数配置
NET_DVR_GET_DEVSERVER_CFG = 3257 # 获取模块服务配置
NET_DVR_SET_DEVSERVER_CFG = 3258 # 设置模块服务配置

# 2013-11-25
NET_DVR_GET_WIPERINFO_CFG = 3259 # 雨刷配置获取
NET_DVR_SET_WIPERINFO_CFG = 3260 # 雨刷配置设置
NET_DVR_GET_TRACK_DEV_PARAM = 3261 # 获取跟踪设备参数
NET_DVR_SET_TRACK_DEV_PARAM = 3262 # 设置跟踪设备参数
NET_DVR_GET_PTZ_TRACK_PARAM = 3263 # 获取PTZ跟踪参数
NET_DVR_SET_PTZ_TRACK_PARAM = 3264 # 设置PTZ跟踪参数
NET_DVR_GET_CENTER_POINT_CFG = 3265 # 获取中心点参数
NET_DVR_SET_CENTER_POINT_CFG = 3266 # 设置中心点参数
NET_DVR_GET_CENTER_POINT_CFG_CAPABILITIES = 3267 # 获取中心点参数能力
NET_DVR_GET_FISHEYE_CAPABILITIES = 3268 # 获取鱼眼能力

NET_DVR_GET_BASICPARAMCFG = 3270 # 获取PTZ配置基本参数信息
NET_DVR_SET_BASICPARAMCFG = 3271 # 设置PTZ配置基本参数信息
NET_DVR_GET_PTZOSDCFG = 3272 # 获取PTZ OSD配置参数信息
NET_DVR_SET_PTZOSDCFG = 3273 # 设置PTZ OSD配置参数信息
NET_DVR_GET_POWEROFFMEMCFG = 3274 # 获取掉电记忆模式参数信息
NET_DVR_SET_POWEROFFMEMCFG = 3275 # 设置掉电记忆模式参数信息
NET_DVR_GET_LIMITCFG = 3276 # 获取限位参数配置信息
NET_DVR_SET_LIMITCFG = 3277 # 设置限位参数配置信息
NET_DVR_PTZLIMIT_CTRL = 3278 # 清除限位参数控制

NET_DVR_PTZ_CLEARCTRL = 3279 # 清除配置信息控制接口
NET_DVR_GET_PRIORITIZECFG = 3281 # 获取云台优先配置信息
NET_DVR_SET_PRIORITIZECFG = 3282 # 设置云台优先配置信息
NET_DVR_PTZ_INITIALPOSITIONCTRL = 3283 # 零方位角控制
NET_DVR_GET_PRIVACY_MASKSCFG = 3285 # 获取隐私遮蔽参数
NET_DVR_SET_PRIVACY_MASKSCFG = 3286 # 设置隐私遮蔽参数
NET_DVR_GET_PTZLOCKCFG = 3287 # 获取云台锁定信息
NET_DVR_SET_PTZLOCKCFG = 3288 # 设置云台锁定信息
NET_DVR_PTZ_ZOOMRATIOCTRL = 3289 # 设置跟踪倍率
NET_DVR_GET_PTZLOCKINFO = 3290 # 获取云台锁定剩余秒数
NET_DVR_GET_PRIVACY_MASKS_ENABLECFG = 3291 # 获取全局使能
NET_DVR_SET_PRIVACY_MASKS_ENABLECFG = 3292 # 设置全局使能
NET_DVR_GET_SMARTTRACKCFG = 3293 # 获取智能运动跟踪配置信息
NET_DVR_SET_SMARTTRACKCFG = 3294 # 设置智能运动跟踪配置信息
NET_DVR_GET_EPTZ_CFG = 3295 # 获取EPTZ参数
NET_DVR_SET_EPTZ_CFG = 3296 # 设置EPTZ参数
NET_DVR_GET_EPTZ_CFG_CAPABILITIES = 3297 # 获取EPTZ参数能力

NET_DVR_GET_LOW_LIGHTCFG = 3303 # 获取快球低照度设置信息
NET_DVR_SET_LOW_LIGHTCFG = 3304 # 设置快球低照度设置信息
NET_DVR_GET_FOCUSMODECFG = 3305 # 获取快球聚焦模式信息
NET_DVR_SET_FOCUSMODECFG = 3306 # 设置快球聚焦模式信息
NET_DVR_GET_INFRARECFG = 3307 # 获取快球红外设置信息
NET_DVR_SET_INFRARECFG = 3308 # 设置快球红外设置信息
NET_DVR_GET_AEMODECFG = 3309 # 获取快球其他设置信息
NET_DVR_SET_AEMODECFG = 3310 # 设置快球其他设置信息
NET_DVR_CONTROL_RESTORE_SUPPORT = 3311 # 恢复前端默认参数(参数能力中有的前端参数配置相关的都恢复)
NET_DVR_CONTROL_RESTART_SUPPORT = 3312 # 快球机芯重启
NET_DVR_CONTROL_PTZ_PATTERN = 3313 # 云台花样扫描
NET_DVR_GET_PTZ_PARKACTION_CFG = 3314 # 获取云台守望参数
NET_DVR_SET_PTZ_PARKACTION_CFG = 3315 # 设置云台守望参数
NET_DVR_CONTROL_PTZ_MANUALTRACE = 3316 # 手动跟踪定位
NET_DVR_GET_ROI_DETECT_NUM = 3349 # 获取ROI检测区域编号数目
NET_DVR_GET_ROI_DETECT = 3350 # 获取ROI检测区域配置
NET_DVR_SET_ROI_DETECT = 3351 # 设置ROI检测区域配置
NET_DVR_GET_FACE_DETECT = 3352 # 获取人脸侦测配置
NET_DVR_SET_FACE_DETECT = 3353 # 设置人脸侦测配置
NET_DVR_GET_CORRIDOR_MODE = 3354 # 获取走廊模式功能配置
NET_DVR_SET_CORRIDOR_MODE = 3355 # 设置走廊模式功能配置
NET_DVR_GET_SCENECHANGE_DETECTIONCFG = 3356 # 获取场景变更报警配置
NET_DVR_SET_SCENECHANGE_DETECTIONCFG = 3357 # 设置场景变更报警配置
NET_DVR_GET_TRAVERSE_PLANE_DETECTION = 3360
NET_DVR_SET_TRAVERSE_PLANE_DETECTION = 3361
NET_DVR_GET_FIELD_DETECTION = 3362 # 获取区域侦测配置
NET_DVR_SET_FIELD_DETECTION = 3363 # 设置区域侦测配置
NET_DVR_GET_DEFOCUSPARAM = 3364 # 获取虚焦侦测参数配置
NET_DVR_SET_DEFOCUSPARAM = 3365 # 设置虚焦侦测参数配置
NET_DVR_GET_AUDIOEXCEPTIONPARAM = 3366 # 获取音频异常配置
NET_DVR_SET_AUDIOEXCEPTIONPARAM = 3367 # 设置音频异常配置
NET_DVR_GET_CCDPARAMCFG_EX = 3368 # 获取CCD参数配置
NET_DVR_SET_CCDPARAMCFG_EX = 3369 # 设置CCD参数配置
NET_DVR_START_GET_INPUTVOLUME = 3370 # 开始获取音量
NET_DVR_SET_SCH_TASK = 3380 # 设置球机定时任务
NET_DVR_GET_SCH_TASK = 3381 # 获取球机定时任务
NET_DVR_SET_PRESET_NAME = 3382 # 设置预置点名称
NET_DVR_GET_PRESET_NAME = 3383 # 获取预置点名称
NET_DVR_SET_AUDIO_NAME = 3384 # 设置语音名称
NET_DVR_GET_AUDIO_NAME = 3385 # 获取语音名称
NET_DVR_RESUME_INITRACKPOS = 3386 # 恢复跟踪初始位
NET_DVR_NTP_SERVER_TEST = 3387 # NTP服务器测试
NET_DVR_NAS_SERVER_TEST = 3388 # NAS服务器测试
NET_DVR_EMAIL_SERVER_TEST = 3389 # Email服务器测试
NET_DVR_FTP_SERVER_TEST = 3390 # FTP服务器测试
NET_DVR_IP_TEST = 3391 # IP测试
NET_DVR_GET_NET_DISKCFG_V40 = 3392 # 网络硬盘接入获取v40
NET_DVR_SET_NET_DISKCFG_V40 = 3393 # 网络硬盘接入设置v40
NET_DVR_GET_IOOUT_CFG = 3394 # 获取补光灯参数
NET_DVR_SET_IOOUT_CFG = 3395 # 设置补光灯参数
NET_DVR_GET_SIGNAL_SYNC = 3396 # 获取信号灯同步配置参数
NET_DVR_SET_SIGNAL_SYNC = 3397 # 设置信号灯同步配置参数

NET_DVR_GET_EZVIZ_ACCESS_CFG = 3398 # 获取EZVIZ接入参数
NET_DVR_SET_EZVIZ_ACCESS_CFG = 3399 # 设置EZVIZ接入参数
NET_DVR_GET_SCHEDULE_AUTO_TRACK_CFG = 3400 # 获取定时智能跟踪参数
NET_DVR_SET_SCHEDULE_AUTO_TRACK_CFG = 3401 # 设置定时智能跟踪参数
NET_DVR_MAKE_I_FRAME = 3402 # 强制I帧
NET_DVR_GET_ALARM_RELATE = 3403 # 获取报警联动通道功能参数
NET_DVR_SET_ALARM_RELATE = 3404 # 设置报警联动通道功能参数
NET_DVR_GET_PDC_RULECFG_V42 = 3405 # 设置人流量统计规则(扩展)
NET_DVR_SET_PDC_RULECFG_V42 = 3406 # 获取人流量统计规则(扩展)
NET_DVR_GET_HEATMAP_CFG = 3407 # 设置热度图参数配置
NET_DVR_SET_HEATMAP_CFG = 3408 # 获取热度图参数配置
NET_DVR_REMOTECONTROL_LINEARSCAN = 3409 # 设置左右边界参数 2014-03-15
NET_DVR_DPC_CTRL = 3410 # 坏点校正控制
NET_DVR_FFC_MANUAL_CTRL = 3411 # 非均匀性校正(FFC)手动模式
NET_DVR_FFC_BACKCOMP_CTRL = 3412 # 非均匀性校正(FFC)背景补偿
NET_DVR_GET_FOCUSING_POSITION_STATE = 3413 # 获取聚焦到位状态参数
NET_DVR_GET_PRIVATE_PROTOCOL_CFG = 3414 # 获取 私有关键信息上传配置接口配置
NET_DVR_SET_PRIVATE_PROTOCOL_CFG = 3415 # 设置 私有关键信息上传配置接口配置
NET_DVR_COMPLETE_RESTORE_CTRL = 3420 # 设置完全恢复出厂值

NET_DVR_CLOUDSTORAGE_SERVER_TEST = 3421 # 云存储服务器测试
NET_DVR_PHONE_NUM_TEST = 3422 # 电话号码测试
NET_DVR_GET_REMOTECONTROL_STATUS = 3423 # 获取无线布防状态
NET_DVR_GET_MONITOR_LOCATION_INFO = 3424 # 获取监测点信息
NET_DVR_SET_MONITOR_LOCATION_INFO = 3425 # 设置监测点信息


NET_DVR_GET_SMART_CAPABILITIES = 3500 # 获取Smart能力
NET_DVR_GET_EVENT_TRIGGERS_CAPABILITIES = 3501 # 获取事件触发能力
NET_DVR_GET_REGION_ENTRANCE_CAPABILITIES = 3502 # 获取进入区域侦测能力
NET_DVR_GET_REGION_ENTR_DETECTION = 3503 # 获取进入区域配置
NET_DVR_SET_REGION_ENTR_DETECTION = 3504 # 设置进入区域配置
NET_DVR_GET_REGION_ENTR_REGION = 3505 # 获取进入区域的单个区域配置
NET_DVR_SET_REGION_ENTR_REGION = 3506 # 设置进入区域的单个区域配置
NET_DVR_GET_REGION_ENTR_TRIGGER = 3507 # 获取进入区域联动配置
NET_DVR_SET_REGION_ENTR_TRIGGER = 3508 # 设置进入区域联动配置
NET_DVR_GET_REGION_ENTR_SCHEDULE = 3509 # 获取进入区域布防时间配置
NET_DVR_SET_REGION_ENTR_SCHEDULE = 3510 # 设置进入区域布防时间配置
NET_DVR_GET_REGION_EXITINT_CAPABILITIES = 3511 # 获取离开区域侦测能力
NET_DVR_GET_REGION_EXITING_DETECTION = 3512 # 获取离开区域配置
NET_DVR_SET_REGION_EXITING_DETECTION = 3513 # 设置离开区域配置
NET_DVR_GET_REGION_EXITING_REGION = 3514 # 获取离开区域的单个区域配置
NET_DVR_SET_REGION_EXITING_REGION = 3515 # 设置离开区域的单个区域配置
NET_DVR_GET_REGION_EXIT_TRIGGER = 3516 # 获取离开区域联动配置
NET_DVR_SET_REGION_EXIT_TRIGGER = 3517 # 设置离开区域联动配置
NET_DVR_GET_REGION_EXIT_SCHEDULE = 3518 # 获取离开区域布防时间配置
NET_DVR_SET_REGION_EXIT_SCHEDULE = 3519 # 设置离开区域布防时间配置
NET_DVR_GET_LOITERING_CAPABILITIES = 3520 # 获取徘徊侦测能力
NET_DVR_GET_LOITERING_DETECTION = 3521 # 获取徘徊侦测配置
NET_DVR_SET_LOITERING_DETECTION = 3522 # 设置徘徊侦测配置
NET_DVR_GET_LOITERING_REGION = 3523 # 获取徘徊的单个区域配置
NET_DVR_SET_LOITERING_REGION = 3524 # 设置徘徊的单个区域配置
NET_DVR_GET_LOITERING_TRIGGER = 3525 # 获取徘徊联动配置
NET_DVR_SET_LOITERING_TRIGGER = 3526 # 设置徘徊联动配置
NET_DVR_GET_LOITERING_SCHEDULE = 3527 # 获取徘徊布防时间配置
NET_DVR_SET_LOITERING_SCHEDULE = 3528 # 设置徘徊布防时间配置
NET_DVR_GET_GROUPDETECTION_CAPABILITIES = 3529 # 获取人员聚集侦测能力
NET_DVR_GET_GROUP_DETECTION = 3530 # 获取人员聚集侦测配置
NET_DVR_SET_GROUP_DETECTION = 3531 # 设置人员聚集侦测配置
NET_DVR_GET_GROUPDETECTION_REGION = 3532 # 获取人员聚集的单个区域配置
NET_DVR_SET_GROUPDETECTION_REGION = 3533 # 设置人员聚集的单个区域配置
NET_DVR_GET_GROUPDETECTION_TRIGGER = 3534 # 获取人员聚集联动配置
NET_DVR_SET_GROUPDETECTION_TRIGGER = 3535 # 设置人员聚集联动配置
NET_DVR_GET_GROUPDETECTION_SCHEDULE = 3536 # 获取人员聚集布防时间配置
NET_DVR_SET_GROUPDETECTION_SCHEDULE = 3537 # 设置人员聚集布防时间配置
NET_DVR_GET_RAPIDMOVE_CAPABILITIES = 3538 # 获取快速运动侦测能力
NET_DVR_GET_RAPIDMOVE_DETECTION = 3539 # 获取快速运动侦测配置
NET_DVR_SET_RAPIDMOVE_DETECTION = 3540 # 设置快速运动侦测配置
NET_DVR_GET_RAPIDMOVE_REGION = 3541 # 获取快速运动的单个区域配置
NET_DVR_SET_RAPIDMOVE_REGION = 3542 # 设置快速运动的单个区域配置
NET_DVR_GET_RAPIDMOVE_TRIGGER = 3543 # 获取快速运动联动配置
NET_DVR_SET_RAPIDMOVE_TRIGGER = 3544 # 设置快速运动联动配置
NET_DVR_GET_RAPIDMOVE_SCHEDULE = 3545 # 获取快速运动的布防时间配置
NET_DVR_SET_RAPIDMOVE_SCHEDULE = 3546 # 设置快速运动的布防时间配置
NET_DVR_GET_PATKING_CAPABILITIES = 3547 # 获取停车侦测能力
NET_DVR_GET_PARKING_DETECTION = 3548 # 获取停车侦测配置
NET_DVR_SET_PARKING_DETECTION = 3549 # 设置停车侦测配置
NET_DVR_GET_PARKING_REGION = 3550 # 获取停车侦测的单个区域配置
NET_DVR_SET_PARKING_REGION = 3551 # 设置停车侦测的单个区域配置
NET_DVR_GET_PARKING_TRIGGER = 3552 # 获取停车侦测联动配置
NET_DVR_SET_PARKING_TRIGGER = 3553 # 设置停车侦测联动配置
NET_DVR_GET_PARKING_SCHEDULE = 3554 # 获取停车侦测的布防时间配置
NET_DVR_SET_PARKING_SCHEDULE = 3555 # 设置停车侦测的布防时间配置
NET_DVR_GET_UNATTENDED_BAGGAGE_CAPABILITIES = 3556 # 获取物品遗留侦测能力
NET_DVR_GET_UNATTENDED_BAGGAGE_DETECTION = 3557 # 获取物品遗留侦测配置
NET_DVR_SET_UNATTENDED_BAGGAGE_DETECTION = 3558 # 设置物品遗留侦测配置
NET_DVR_GET_UNATTENDED_BAGGAGE_REGION = 3559 # 获取物品遗留侦测的单个区域配置
NET_DVR_SET_UNATTENDED_BAGGAGE_REGION = 3560 # 设置物品遗留侦测的单个区域配置
NET_DVR_GET_UNATTENDED_BAGGAGE_TRIGGER = 3561 # 获取物品遗留侦测联动配置
NET_DVR_SET_UNATTENDED_BAGGAGE_TRIGGER = 3562 # 设置物品遗留侦测联动配置
NET_DVR_GET_UNATTENDED_BAGGAGE_SCHEDULE = 3563 # 获取物品遗留侦测的布防时间配置
NET_DVR_SET_UNATTENDED_BAGGAGE_SCHEDULE = 3564 # 设置物品遗留侦测的布防时间配置
NET_DVR_GET_ATTENDEDBAGGAGE_CAPABILITIES = 3565 # 获取物品拿取侦测能力
NET_DVR_GET_ATTENDEDBAGGAGE_DETECTION = 3566 # 获取物品拿取侦测配置
NET_DVR_SET_ATTENDEDBAGGAGE_DETECTION = 3567 # 设置物品拿取侦测配置
NET_DVR_GET_ATTENDEDBAGGAGE_REGION = 3568 # 获取物品拿取侦测的单个区域配置
NET_DVR_SET_ATTENDEDBAGGAGE_REGION = 3569 # 设置物品拿取侦测的单个区域配置
NET_DVR_GET_ATTENDEDBAGGAGE_TRIGGER = 3570 # 获取物品拿取侦测联动配置
NET_DVR_SET_ATTENDEDBAGGAGE_TRIGGER = 3571 # 设置物品拿取侦测联动配置
NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE = 3572 # 获取物品遗留侦测的布防时间配置
NET_DVR_SET_ATTENDEDBAGGAGE_SCHEDULE = 3573 # 设置物品拿取侦测的布防时间配置
NET_DVR_GET_REGIONCLIP_CAPABILITIES = 3574 # 获取区域裁剪能力
NET_DVR_GET_REGION_CLIP = 3575 # 获取区域裁剪配置
NET_DVR_SET_REGION_CLIP = 3576 # 设置区域裁剪配置
NET_DVR_GET_NETWORK_CAPABILITIES = 3577 # 获取网络能力
NET_DVR_GET_WIRELESS_DIAL = 3578 # 获取无线参数配置
NET_DVR_SET_WIRELESS_DIAL = 3579 # 设置无线参数配置
NET_DVR_GET_WIRELESSDIAL_CAPABILITIES = 3580 # 获取无线拨号参数能力
NET_DVR_GET_WIRELESSDIAL_SCHEDULE = 3581 # 获取拨号计划配置
NET_DVR_SET_WIRELESSDIAL_SCHEDULE = 3582 # 设置拨号计划配置
NET_DVR_GET_WIRELESSDIAL_STATUS = 3583 # 获取拨号状态
NET_DVR_GET_REGION_ENTRANCE_SCHEDULE_CAPABILITIES = 3584 # 获取进入区域侦测布防时间能力
NET_DVR_GET_REGION_EXITING_SCHEDULE_CAPABILITIES = 3585 # 获取离开区域侦测布防时间能力
NET_DVR_GET_LOITERING_SCHEDULE_CAPABILITIES = 3586 # 获取徘徊侦测布防时间能力
NET_DVR_GET_GROUP_SCHEDULE_CAPABILITIES = 3587 # 获取人员聚集侦测布防时间能力
NET_DVR_GET_RAPIDMOVE_SCHEDULE_CAPABILITIES = 3588 # 获取快速运动侦测布防时间能力
NET_DVR_GET_PARKING_SCHEDULE_CAPABILITIES = 3589 # 获取停车侦测布防时间能力
NET_DVR_GET_UNATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES = 3590 # 获取物品遗留侦测布防时间能力
NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES = 3591 # 获取物品拿取侦测布防时间能力
NET_DVR_GET_WIRELESSDIAL_SCHEDULE_CAPABILITIES = 3592 # 获取拨号计划能力
NET_DVR_WIRELESSDIAL_CONNECT = 3593 # 控制无线网络连网断网

NET_DVR_GET_LITESTORAGE = 3594 # 获取轻存储配置
NET_DVR_SET_LITESTORAGE = 3595 # 设置轻存储配置
NET_DVR_GET_LITESTORAGE_CAPABILITIES = 3596 # 获取轻存储能力

NET_DVR_GET_VEHICLE_CAPABILITIES = 3597 # 获取车俩检测标定能力
NET_DVR_GET_VEHICLE_CALIBRATION = 3598 # 获取车辆检测标定

NET_DVR_GET_SLAVECAMERA_CAPABILITIES = 3599 # 获取从摄像机IP信息配置能力
NET_DVR_GET_SLAVECAMERA = 3600 # 获取从摄像机IP信息配置
NET_DVR_SET_SLAVECAMERA = 3601 # 设置从摄像机IP信息配置
NET_DVR_GET_SLAVECAMERA_STATUS = 3602 # 获取从摄像机连接状态
NET_DVR_GET_SLAVECAMERA_CALIB_CAPABILITIES = 3603 # 获取从摄像机配置&&标定能力
NET_DVR_GET_SLAVECAMERA_CALIB = 3604 # 获取从摄像机标定配置
NET_DVR_SET_SLAVECAMERA_CALIB = 3605 # 设置从摄像机标定配置
NET_DVR_GET_PHY_RATIO = 3606 # 获取物理倍率坐标信息
NET_DVR_SET_PHY_RATIO = 3607 # 设置物理倍率坐标信息
NET_DVR_GET_MASTERSLAVETRACKING_CAPABILITIES = 3608 # 获取主从跟踪能力
NET_DVR_SET_TRACKINGRATIO = 3610 # 设置从摄像机跟踪倍率
NET_DVR_GET_TRACKING = 3611 # 获取主从跟踪功能相机跟踪配置
NET_DVR_SET_TRACKING = 3612 # 设置主从跟踪功能相机跟踪配置
NET_DVR_GET_TRACKING_CAPABILITIES = 3613 # 获取主从跟踪功能相机跟踪配置能力

NET_DVR_GET_SLAVECAMERA_CALIB_V50 = 3614 # 获取从摄像机标定配置V50
NET_DVR_SET_SLAVECAMERA_CALIB_V50 = 3615 # 设置从摄像机标定配置V50
NET_DVR_SET_TRACKINGRATIO_MANUAL = 3616 # 设置从摄像机手动跟踪倍率
NET_DVR_GET_TRACKINGRATIO_MANUAL = 3617 # 获取从摄像机手动跟踪倍率
NET_DVR_SET_TRACK_INITPOSTION = 3618 # 设置从摄像机初始跟踪位置
NET_DVR_GET_PTZ_CAPABILITIES = 3619 # 获取ptz球机控制能力

NET_DVR_GET_THERMOMETRY_BASICPARAM_CAPABILITIES = 3620 # 获取测温配置能力
NET_DVR_GET_THERMOMETRY_BASICPARAM = 3621 # 获取测温配置参数
NET_DVR_SET_THERMOMETRY_BASICPARAM = 3622 # 设置测温配置参数
NET_DVR_GET_THERMOMETRY_SCENE_CAPABILITIES = 3623 # 获取测温预置点关联配置能力
NET_DVR_GET_THERMOMETRY_PRESETINFO = 3624 # 获取测温预置点关联配置参数
NET_DVR_SET_THERMOMETRY_PRESETINFO = 3625 # 设置测温预置点关联配置参数
NET_DVR_GET_THERMOMETRY_ALARMRULE_CAPABILITIES = 3626 # 获取测温报警方式配置能力
NET_DVR_GET_THERMOMETRY_ALARMRULE = 3627 # 获取测温预置点报警规则配置参数
NET_DVR_SET_THERMOMETRY_ALARMRULE = 3628 # 设置测温预置点报警规则配置参数
NET_DVR_GET_REALTIME_THERMOMETRY = 3629 # 实时温度检测
NET_DVR_GET_THERMOMETRY_DIFFCOMPARISON = 3630 # 获取测温预置点温差规则配置参数
NET_DVR_SET_THERMOMETRY_DIFFCOMPARISON = 3631 # 设置测温预置点温差规则配置参数
NET_DVR_GET_THERMOMETRY_TRIGGER = 3632 # 获取测温联动配置
NET_DVR_SET_THERMOMETRY_TRIGGER = 3633 # 设置测温联动配置

NET_DVR_GET_THERMAL_CAPABILITIES = 3634 # 获取热成像（Thermal）能力
NET_DVR_GET_FIREDETECTION_CAPABILITIES = 3635 # 获取火点检测配置能力
NET_DVR_GET_FIREDETECTION = 3636 # 获取火点检测参数
NET_DVR_SET_FIREDETECTION = 3637 # 设置火点检测参数
NET_DVR_GET_FIREDETECTION_TRIGGER = 3638 # 获取火点检测联动配置
NET_DVR_SET_FIREDETECTION_TRIGGER = 3639 # 设置火点检测联动配置

NET_DVR_GET_OIS_CAPABILITIES = 3640 # 获取光学防抖参数配置能力
NET_DVR_GET_OIS_CFG = 3641 # 获取光学防抖配置
NET_DVR_SET_OIS_CFG = 3642 # 设置光学防抖配置
NET_DVR_GET_MACFILTER_CAPABILITIES = 3643 # 获取MAC地址过滤配置能力
NET_DVR_GET_MACFILTER_CFG = 3644 # 获取MAC地址过滤配置
NET_DVR_SET_MACFILTER_CFG = 3645 # 设置MAC地址过滤配置
NET_DVR_GET_EAGLEFOCUS_CALCFG_CAPABILITIES = 3646 # 鹰视聚焦标定配置能力
NET_DVR_GET_EAGLEFOCUSING_CALCFG = 3647 # 获取鹰视聚焦标定配置
NET_DVR_SET_EAGLEFOCUSING_CALCFG = 3648 # 设置鹰视聚焦标定配置
NET_DVR_GET_EAGLEFOCUSING_CFG_CAPABILITIES = 3649 # 获取鹰视聚焦配置能力
NET_DVR_GET_EAGLEFOCUSING_CTRL = 3650 # 获取鹰视聚焦配置
NET_DVR_SET_EAGLEFOCUSING_CTRL = 3651 # 设置鹰视聚焦配置

NET_DVR_GET_PXOFFLINE_CAPABILITIES = 3652 # 获取停车场票箱脱机下参数配置 能力
NET_DVR_SET_PXOFFLINE_CFG = 3653 # 设置停车场票箱脱机下参数配置信息
NET_DVR_GET_PXOFFLINE_CFG = 3654 # 获取停车场票箱脱机下参数配置信息
NET_DVR_GET_PAPERCHARGEINFO_CAPABILITIES = 3655 # 获取停车场出入口纸票信息下发 能力
NET_DVR_SET_PAPERCHARGEINFO = 3656 # 设置停车场出入口纸票信息下发
NET_DVR_GET_PARKINGSAPCE_CAPABILITIES = 3657 # 获取停车场出入口停车位信息下发 能力
NET_DVR_SET_PARKINGSAPCE_INFO = 3658 # 设置停车场出入口停车位信息下发
NET_DVR_GET_PXMULTICTRL_CAPABILITIES = 3659 # 获取停车场票箱从属设备多角度参数配置 能力
NET_DVR_GET_CHARGEACCOUNT_CAPABILITIES = 3661 # 获取停车场票箱参数配置能力
NET_DVR_SET_CHARGE_ACCOUNTINFO = 3662 # 设置缴费金额信息
NET_DVR_SET_PXMULTICTRL_CFG = 3663 # 设置停车场票箱从属设备多角度参数配置信息
NET_DVR_GET_PXMULTICTRL_CFG = 3664 # 获取停车场票箱从属设备多角度参数配置信息
NET_DVR_GET_TME_CHARGERULE = 3665 # 获取停车场出入口车卡收费规则规则
NET_DVR_SET_TME_CHARGERULE = 3666 # 设置停车场出入口车卡收费规则规则
NET_DVR_GET_TME_CHARGERULE_CAPABILITIES = 3667 # 获取停车场出入口 车卡收费信息配置能力
NET_DVR_GET_ILLEGALCARDFILTERING_CAPABILITIES = 3668 # 获取停车场票箱参数配置能力
NET_DVR_GET_ILLEGALCARDFILTERING_CFG = 3669 # 获取停车场票箱参数配置
NET_DVR_SET_ILLEGALCARDFILTERING_CFG = 3670 # 设置停车场票箱参数配置
NET_DVR_GET_LEDDISPLAY_CAPABILITIES = 3671 # 获取LED屏幕显示参数配置参数能力
NET_DVR_SET_LEDDISPLAY_CFG = 3672 # 设置LED屏幕显示参数
NET_DVR_GET_LEDDISPLAY_CFG = 3673 # 获取LED屏幕显示参数
NET_DVR_GET_VOICEBROADCAST_CAPABILITIES = 3674 # 获取语音播报控制参数配置参数能力
NET_DVR_SET_VOICEBROADCAST_CFG = 3675 # 设置语音播报控制参数
NET_DVR_GET_PAPERPRINTFORMAT_CAPABILITIES = 3676 # 获取纸票打印格式配置能力
NET_DVR_GET_PAPERPRINTFORMAT_CFG = 3677 # 获取纸票打印格式参数配置
NET_DVR_SET_PAPERPRINTFORMAT_CFG = 3678 # 设置纸票打印格式参数配置
NET_DVR_GET_LOCkGATE_CAPABILITIES = 3679 # 获取智能锁闸配置能力
NET_DVR_GET_LOCKGATE_CFG = 3680 # 获取智能锁闸参数配置
NET_DVR_SET_LOCKGATE_CFG = 3681 # 设置智能锁闸参数配置
NET_DVR_GET_PARKING_DATASTATE = 3682 # 获取数据同步状态
NET_DVR_SET_PARKING_DATASTATE = 3683 # 设置数据同步状态
NET_DVR_GET_TME_CAPABILITIES = 3684 # 获取停车场出入口设备 能力

NET_DVR_GET_TMEVOICE_CAPABILITIES = 3686 # 获取语音配置信息能力
NET_DVR_SET_TMEVOICE_CFG = 3687 # 设置语音参数配置
NET_DVR_GET_TMEVOICE_CFG = 3688 # 获取语音参数配置
NET_DVR_DEL_TMEVOICE_CFG = 3689 # 删除语音参数配置
NET_DVR_GET_POSITION = 3698 #  获取方位矫正配置参数
NET_DVR_SET_POSITION = 3699 #  设置方位矫正配置参数
NET_DVR_GET_CENTRALIZEDCTRL_CAPABILITIES = 3700 # 获取集中布控能力
NET_DVR_GET_CENTRALIZEDCTRL = 3701 # 获取集中布控参数配置
NET_DVR_SET_CENTRALIZEDCTRL = 3702 # 设置集中布控参数配置
NET_DVR_GET_COMPASS_CAPABILITIES = 3703 # 获取电子罗盘能力
NET_DVR_GET_VANDALPROOFALARM = 3704 # 获取防破坏报警参数配置
NET_DVR_SET_VANDALPROOFALARM = 3705 # 设置防破坏报警参数配置
NET_DVR_COMPASS_CALIBRATE_CTRL = 3706 # 电子罗盘矫正控制接口
NET_DVR_COMPASS_NORTH_CTRL = 3707 # 电子罗盘指向正北控制接口
NET_DVR_GET_AZIMUTHINFO = 3708 # 获取方位角度参数配置


NET_DVR_GET_SATELLITETIME = 3709 # 获取卫星定位参数配置
NET_DVR_SET_SATELLITETIME = 3710 # 设置卫星定位参数配置
NET_DVR_GET_GISINFO = 3711 # 获取当前球机的GIS信息数据
NET_DVR_GET_STREAMING_CAPABILITIES = 3712 # 获取视频流的能力
NET_DVR_GET_REFRESHFRAME_CAPABILITIES = 3713 # 获取刷新帧的能力
NET_DVR_STREAMING_REFRESH_FRAME = 3714 # 取流预览的强制刷新帧
NET_DVR_FACECAPTURE_STATISTICS = 3715 # 长连接人员统计
NET_DVR_GET_WIRELESSSERVER_CAPABILITIES = 3716 # 获取热点功能配置协议的能力
NET_DVR_GET_WIRELESSSERVER = 3717 # 获取热点功能配置协议
NET_DVR_SET_WIRELESSSERVER = 3718 # 设置热点功能配置协议
NET_DVR_GET_CONNECT_LIST_CAPABILITIES = 3719 # 获取连接设备列表信息的能力
NET_DVR_GET_THSCREEN_CAPABILITIES = 3720 # 获取温湿度配置协议的能力
NET_DVR_GET_THSCREEN = 3721 # 获取温湿度配置协议
NET_DVR_GET_EXTERNALDEVICE_CAPABILITIES = 3722 # 获取外设配置协议的能力
NET_DVR_GET_EXTERNALDEVICE = 3723 # 获取外设配置协议
NET_DVR_SET_EXTERNALDEVICE = 3724 # 设置外设配置协议
NET_DVR_GET_LEDDISPLAYINFO_CAPABILITIES = 3725 # 获取LED显示信息的能力
NET_DVR_SET_LEDDISPLAYINFO = 3726 # 设置LED显示信息
NET_DVR_GET_SUPPLEMENTLIGHT_CAPABILITIES = 3727 # 获取内置补光灯配置协议的能力 (球机支持，软件实现，补光灯是设计在设备内部的)
NET_DVR_GET_SUPPLEMENTLIGHT = 3728 # 获取内置补光灯配置协议
NET_DVR_SET_SUPPLEMENTLIGHT = 3729 # 设置内置补光灯配置协议
NET_DVR_SET_THSCREEN = 3730 # 设置温湿度配置协议
NET_DVR_GET_LOWPOWER_CAPABILITIES = 3731 # 获取低功耗配置协议的能力
NET_DVR_GET_LOWPOWER = 3732 # 获取低功耗配置协议
NET_DVR_SET_LOWPOWER = 3733 # 设置低功耗配置协议
NET_DVR_GET_ZOOMLINKAGE_CAPABILITIES = 3734 # 获取变倍联动配置协议的能力
NET_DVR_GET_ZOOMLINKAGE = 3735 # 获取变倍联动配置协议
NET_DVR_SET_ZOOMLINKAGE = 3736 # 设置变倍联动配置协议
NET_DVR_THSCREEN_TIMING = 3737 # 温湿度
NET_DVR_GET_OSD_BATTERY_POWER_CFG = 3741 # 获取OSD电池电量显示参数
NET_DVR_SET_OSD_BATTERY_POWER_CFG = 3742 # 设置OSD电池电量显示参数
NET_DVR_GET_OSD_BATTERY_POWER_CFG_CAPABILITIES = 3743 # OSD电池电量显示参数的能力
NET_DVR_GET_VANDALPROOFALARM_TRIGGER = 3744 # 获取防破坏报警联动配置
NET_DVR_SET_VANDALPROOFALARM_TRIGGER = 3745 # 设置防破坏报警联动配置
NET_DVR_GET_PANORAMAIMAGE_CAPABILITIES = 3746 # 获取全景图像的能力
NET_DVR_GET_PANORAMAIMAGE = 3747 # 获取全景图像参数的协议
NET_DVR_SET_PANORAMAIMAGE = 3748 # 设置全景图像参数的协议
NET_DVR_GET_STREAMENCRYPTION = 3749 # 获取码流加密配置
NET_DVR_SET_STREAMENCRYPTION = 3750 # 设置码流加密配置
NET_DVR_GET_STREAMENCRYPTION_CAPABILITIES = 3751 # 获取码流加密能力
NET_DVR_GET_REVISE_GPS_CAPABILITIES = 3752 # 获取校准GPS经纬度能力
NET_DVR_GET_REVISE_GPS = 3753 # 获取校准GPS经纬度能力
NET_DVR_SET_REVISE_GPS = 3754 # 设置校准GPS经纬度能力
NET_DVR_GET_PDC_RECOMMEND = 3755 # 获取客流统计表示推荐值
NET_DVR_REMOVE_FLASHSTORAGE = 3756 # 客流数据清除操作
NET_DVR_GET_COUNTING_CAPABILITIES = 3757 # 获取客流量统计能力
NET_DVR_SET_SENSOR_ADJUSTMENT = 3758 # 设置Sensor 调节参数的协议
NET_DVR_GET_SENSOR_ADJUSTMENT_CAPABILITIES = 3759 # 获取Sensor 调节参数的协议的能力
NET_DVR_GET_WIRELESSSERVER_FULLVERSION_CFG = 3760 # 获取wifi热点参数配置(完整版)
NET_DVR_SET_WIRELESSSERVER_FULLVERSION_CFG = 3761 # 设置wifi热点参数配置(完整版)
NET_DVR_GET_ONLINEUSER_INFO = 3762 # 长连接获取用户在线信息
NET_DVR_GET_SENSOR_ADJUSTMENT_INFO = 3763 # 获取指定sensor调节参数
NET_DVR_SENSOR_RESET_CTRL = 3764 # Sensor 调节复位

NET_DVR_GET_POSTRADAR_CAPABILITIES = 3765 # 获取雷达测速配置能力
NET_DVR_GET_POSTRADARSPEED_CFG = 3766 # 获取雷达测速配置
NET_DVR_SET_POSTRADARSPEED_CFG = 3767 # 设置雷达测速配置
NET_DVR_GET_POSTRADARSPEED_RECOM_CFG = 3768 # 获取雷达测速推荐值
NET_DVR_GET_POSTRADARPARAM_CFG = 3769 # 获取雷达参数配置
NET_DVR_SET_POSTRADARPARAM_CFG = 3770 # 设置雷达参数配置
NET_DVR_GET_POSTRADARPARAM_RECOM_CFG = 3771 # 获取雷达参数推荐值

NET_DVR_GET_ENCRYPT_DEVICE_INFO = 3772 # 获取加密设备信息
NET_DVR_GET_ANR_ARMING_HOST = 3773 # 获取断网续传的主机信息
NET_DVR_GET_FIRMWARE_VERSION = 3776 # GET firmware version
# IPC基线FF车牌
NET_DVR_GET_FTP_CAPABILITIES = 3782 # 获取ftp能力
NET_DVR_GET_FTPUPLOAD_CFG = 3783 # 获取ftp上传信息规整参数
NET_DVR_SET_FTPUPLOAD_CFG = 3784 # 设置ftp上传信息规整参数
NET_DVR_GET_VEHICLE_INFORMATION = 3785 # 获取车辆信息
NET_DVR_GET_DDNS_COUNTRY_ABILITY = 3800 # 获取设备支持的DDNS国家能力列表
NET_DVR_GET_DEVICECFG_V50 = 3801 # 获取设备参数
NET_DVR_SET_DEVICECFG_V50 = 3802 # 设置设备参数
NET_DVR_SET_VEHICLE_RECOG_TASK_V50 = 3851 # 车辆二次识别任务提交V50扩展
NET_DVR_GET_SMARTCALIBRATION_CAPABILITIES = 3900 #  Smart行为标定过滤尺寸功能能力
NET_DVR_GET_TEMPERATURE_TRIGGER = 3903 # 获取测温差联动配置
NET_DVR_SET_TEMPERATURE_TRIGGER = 3904 # 设置测温差联动配置

NET_DVR_GET_SMARTCALIBRATION_CFG = 3910 # 获取Smart行为标定过滤尺寸功能
NET_DVR_SET_SMARTCALIBRATION_CFG = 3911 # 设置Smart行为标定过滤尺寸功能
NET_DVR_POST_SETUP_CALIB = 3912 # 架设标定
NET_DVR_SET_POS_INFO_OVERLAY = 3913 # 设置Pos信息码流叠加控制
NET_DVR_GET_POS_INFO_OVERLAY = 3914 # 获取Pos信息码流叠加控制
NET_DVR_GET_CAMERA_WORK_MODE = 3915 # 设置相机工作模式参数
NET_DVR_SET_CAMERA_WORK_MODE = 3916 # 获取相机工作模式参数
NET_DVR_GET_RESOLUTION_SWITCH_CAPABILITIES = 3917 # 获取分辨率模式切换能力
NET_DVR_GET_RESOLUTION_SWITCH = 3918 # 获取分辨率模式切换配置
NET_DVR_SET_RESOLUTION_SWITCH = 3919 # 设置分辨率模式切换配置
NET_DVR_GET_CONFIRM_MECHANISM_CAPABILITIES = 3920 # 报警上传确认机制控制能力
NET_DVR_CONFIRM_MECHANISM_CTRL = 3921 # 报警上传确认机制控制
NET_DVR_GET_VEHICLLE_RESULT_CAPABILITIES = 3951 # 获取获取车辆信息结果能力
NET_DVR_GET_CALIB_CAPABILITIES = 3952 # 获取架设标定能力
NET_DVR_GET_POSINFO_OVERLAY_CAPABILITIES = 3953 # 获取获取Pos叠加能力
NET_SDK_FINDMEDICALFILE = 3954 # 慧影科技智慧医疗查找录像文件
NET_SDK_FINDMEDICALPICTURE = 3955 # 慧影科技智慧医疗查找图片文件
NET_DVR_SET_POSINFO_OVERLAY = 3960 # 设置Pos叠加
NET_DVR_GET_POSINFO_OVERLAY = 3961 # 获取Pos叠加
NET_DVR_GET_FACELIB_TRIGGER = 3962 # 获取人脸比对库的联动配置
NET_DVR_SET_FACELIB_TRIGGER = 3963 # 设置人脸比对库的联动配置
NET_DVR_GET_FACECONTRAST_TRIGGER = 3965 # 获取人脸比对联动配置
NET_DVR_SET_FACECONTRAST_TRIGGER = 3966 # 设置人脸比对联动配置
NET_DVR_GET_FACECONTRAST_SCHEDULE_CAPABILITIES = 3967 # 获取人脸比对布防时间能力
NET_DVR_GET_FACECONTRAST_SCHEDULE = 3968 # 获取人脸比对布防时间配置
NET_DVR_SET_FACECONTRAST_SCHEDULE = 3969 # 设置人脸比对布防时间配置
NET_DVR_GET_FACELIB_SCHEDULE_CAPABILITIES = 3970 # 获取人脸比对库的布防时间能力
NET_DVR_GET_VCA_VERSION_LIST = 3973 # 获取算法库版本
NET_DVR_GET_SETUP_CALIB = 3974 # 获取架设标定
NET_DVR_GET_PANORAMA_LINKAGE = 3975 # 获取联动抓图上传使能配置
NET_DVR_SET_PANORAMA_LINKAGE = 3976 # 设置联动抓图上传使能配置
NET_DVR_GET_FACELIB_SCHEDULE = 3977 # 获取人脸比对库的布防时间配置
NET_DVR_SET_FACELIB_SCHEDULE = 3978 # 设置人脸比对库的布防时间配置
NET_DVR_GET_SOFTWARE_SERVICE_CAPABILITIES = 3980 # 获取软件服务能力
NET_DVR_GET_SOFTWARE_SERVICE = 3981 # 获取软件服务配置
NET_DVR_SET_SOFTWARE_SERVICE = 3982 # 设置软件服务配置
NET_DVR_GET_PREVIEW_MODE_CAPABILITIES = 3983 # 获取预览模式配置能力
NET_DVR_SET_EAGLE_FOCUS_GOTOSCENE = 3984 # 鹰式聚焦设置摄像机转向指定的场景ID
NET_DVR_EAGLE_FOCUS_SCENE_DEL = 3985 # 删除鹰式聚焦标定的场景
NET_DVR_GET_SAFETY_HELMET_TRIGGER = 3986 # 获取安全帽检测联动配置
NET_DVR_SET_SAFETY_HELMET_TRIGGER = 3987 # 设置安全帽检测联动配置
NET_DVR_GET_SAFETY_HELMET_SCHEDULE_CAPABILITIES = 3988 # 获取安全帽检测布防时间能力
NET_DVR_GET_SAFETY_HELMET_SCHEDULE = 3989 # 获取安全帽检测布防时间配置
NET_DVR_SET_SAFETY_HELMET_SCHEDULE = 3990 # 设置安全帽检测布防时间配置

NET_DVR_GET_SIGN_ABNORMAL_TRIGGER = 4150 # 获取体征异常联动配置
NET_DVR_SET_SIGN_ABNORMAL_TRIGGER = 4151 # 设置体征异常联动配置

NET_DVR_ONE_KEY_CONFIG_SAN_V50 = 4152 # 一键配置SAN(V50)
NET_DVR_GET_HDCFG_V50 = 4153 # 获取硬盘信息参数V50
NET_DVR_SET_HDCFG_V50 = 4154 # 设置硬盘信息参数V50
NET_DVR_GET_HDVOLUME_CFG = 4155 # 获取硬盘卷信息
NET_DVR_SET_HDVOLUME_CFG = 4156 # 设置硬盘卷信息
NET_DVR_GET_POWER_SUPPLY_CABINET_TRIGGER = 4157 # 获取机柜供电检测的联动配置
NET_DVR_SET_POWER_SUPPLY_CABINET_TRIGGER = 4158 # 设置机柜供电检测的联动配置
NET_DVR_GET_SENSOR_TRIGGER = 4159 # 获取传感器检测的联动配置
NET_DVR_SET_SENSOR_TRIGGER = 4160 # 设置传感器检测的联动配置
NET_DVR_GET_FACESNAP_TRIGGER = 4161 # 获取人脸抓拍联动配置
NET_DVR_SET_FACESNAP_TRIGGER	 = 4162 # 设置人脸抓拍联动配置
NET_DVR_GET_FACESNAP_SCHEDULE_CAPABILITIES = 4163 # 获取人脸抓拍布防时间能力
NET_DVR_GET_FACESNAP_SCHEDULE = 4164 # 获取人脸抓拍布防时间配置
NET_DVR_SET_FACESNAP_SCHEDULE = 4165 # 设置人脸抓拍布防时间配置

NET_DVR_SET_SCREEN_SWITCH = 4171 # 画面切换控制
NET_DVR_GET_BV_CALIB_PIC = 4172 # 获取设备抓取图片和附加信息
NET_DVR_GET_BV_CALIB_RESULT = 4173 # 获取双目外参标定结果
NET_DVR_GET_BV_HCORRECTION = 4174 # 获取双目高度矫正数据
NET_DVR_DEL_BV_CALIB_PIC = 4175 # 删除样本图片
NET_DVR_GET_TV_SCREEN_CFG = 4176 # 获取导播画面停留时间配置
NET_DVR_SET_TV_SCREEN_CFG = 4177 # 设置导播画面停留时间配置
NET_DVR_ADJUST_BV_CALIB = 4178 # 双目标定微调
NET_DVR_GET_HUMAN_CALIB = 4179 # 获取人体坐标标定配置
NET_DVR_SET_HUMAN_CALIB = 4180 # 设置人体坐标标定配置
NET_DVR_GET_USERCFG_V51 = 4181 # 获取用户参数
NET_DVR_SET_USERCFG_V51 = 4182 # 设置用户参数
NET_DVR_GET_SOFTIO_TRIGGER = 4183 # 获取SoftIO联动配置
NET_DVR_SET_SOFTIO_TRIGGER = 4184 # 设置SoftIO联动配置
NET_DVR_GET_SOFTIO_SCHEDULE_CAPABILITIES = 4185 # 获取SoftIO布防时间能力
NET_DVR_GET_SOFTIO_SCHEDULE = 4186 # 获取SoftIO布防时间配置
NET_DVR_SET_SOFTIO_SCHEDULE = 4187 # 设置SoftIO布防时间配置
NET_DVR_GET_HFPD_TRIGGER = 4188 # 获取高频人员侦测联动配置
NET_DVR_SET_HFPD_TRIGGER = 4189 # 设置高频人员侦测联动配置
NET_DVR_GET_HFPD_SCHEDULE_CAPABILITIES = 4190 # 获取高频人员侦测布防时间能力
NET_DVR_GET_HFPD_SCHEDULE = 4191 # 获取高频人员侦测布防时间配置
NET_DVR_SET_HFPD_SCHEDULE = 4192 # 设置高频人员侦测布防时间配置
NET_DVR_GET_ALARM_INFO = 4193 # 获取报警事件信息
NET_DVR_GET_USERCFG_V52 = 4194 # 获取用户参数
NET_DVR_SET_USERCFG_V52 = 4195 # 设置用户参数

# NVR_后端产品线
NET_DVR_GET_MUTEX_FUNCTION = 4353 # 获取功能互斥信息

NET_DVR_GET_SINGLE_CHANNELINFO = 4360 # 获取单个通道属性数据
NET_DVR_GET_CHANNELINFO = 4361 # 获取通道属性数据
NET_DVR_CHECK_LOGIN_PASSWORDCFG = 4362 # 用户登录密码校验
NET_DVR_GET_SINGLE_SECURITY_QUESTION_CFG = 4363 # 获取单个设备安全问题
NET_DVR_SET_SINGLE_SECURITY_QUESTION_CFG = 4364 # 设置单个设备安全问题
NET_DVR_GET_SECURITY_QUESTION_CFG = 4365 # 获取设备安全问题
NET_DVR_SET_SECURITY_QUESTION_CFG = 4366 # 设置设备安全问题
NET_DVR_GET_ONLINEUSERLIST_SC = 4367 # 远程获取登陆用户信息（短连接）

NET_DVR_GET_BLACKLIST_FACECONTRAST_TRIGGER = 4368 # 获取黑名单人脸比对联动配置
NET_DVR_SET_BLACKLIST_FACECONTRAST_TRIGGER = 4369 # 设置黑名单人脸比对联动配置
NET_DVR_GET_WHITELIST_FACECONTRAST_TRIGGER = 4370 # 获取白名单人脸比对联动配置
NET_DVR_SET_WHITELIST_FACECONTRAST_TRIGGER = 4371 # 设置白名单人脸比对联动配置
NET_DVR_GET_BLACKLIST_FACECONTRAST_SCHEDULE_CAPABILITIES = 4372 # 获取黑名单人脸比对布防时间能力
NET_DVR_GET_BLACKLIST_FACECONTRAST_SCHEDULE = 4373 # 获取黑名单人脸比对布防时间配置
NET_DVR_SET_BLACKLIST_FACECONTRAST_SCHEDULE = 4374 # 设置黑名单人脸比对布防时间配置
NET_DVR_GET_WHITELIST_FACECONTRAST_SCHEDULE_CAPABILITIES = 4375 # 获取白名单人脸比对布防时间能力
NET_DVR_GET_WHITELIST_FACECONTRAST_SCHEDULE = 4376 # 获取白名单人脸比对布防时间配置
NET_DVR_SET_WHITELIST_FACECONTRAST_SCHEDULE = 4377 # 设置白名单人脸比对布防时间配置

NET_DVR_GET_HUMAN_RECOGNITION_SCHEDULE_CAPABILITIES = 4378 # 获取人体识别布防时间能力
NET_DVR_GET_HUMAN_RECOGNITION_SCHEDULE = 4379 # 获取人体识别布防时间配置
NET_DVR_SET_HUMAN_RECOGNITION_SCHEDULE = 4380 # 设置人体识别布防时间配置
NET_DVR_GET_HUMAN_RECOGNITION_TRIGGER = 4381 # 获取人体识别联动配置
NET_DVR_SET_HUMAN_RECOGNITION_TRIGGER = 4382 # 设置人体识别联动配置
NET_DVR_GET_GBT28181_AUDIO_OUTPUT_CFG = 4383 # 获取GBT28181协议接入设备的语音对讲信息
NET_DVR_SET_GBT28181_AUDIO_OUTPUT_CFG = 4384 # 设置GBT28181协议接入设备的语音对讲信息

NET_DVR_GET_STUDENTS_STOODUP_TRIGGER = 4386 # 获取学生起立检测联动配置
NET_DVR_SET_STUDENTS_STOODUP_TRIGGER = 4387 # 设置学生起立检测联动配置
NET_DVR_GET_FRAMES_PEOPLE_COUNTING_SCHEDULE_CAPABILITIES = 4388 # 获取区域人数统计布防时间能力
NET_DVR_GET_FRAMES_PEOPLE_COUNTING_SCHEDULE = 4389 # 获取区域人数统计布防时间配置
NET_DVR_SET_FRAMES_PEOPLE_COUNTING_SCHEDULE = 4390 # 设置区域人数统计布防时间配置
NET_DVR_GET_FRAMES_PEOPLE_COUNTING_TRIGGER = 4391 # 获取区域人数统计联动配置
NET_DVR_SET_FRAMES_PEOPLE_COUNTING_TRIGGER = 4392 # 设置区域人数统计联动配置

NET_DVR_GET_PERSONDENSITY_TRIGGER = 4393 # 获取人员密度检测的联动配置
NET_DVR_SET_PERSONDENSITY_TRIGGER = 4394 # 设置人员密度检测的联动配置
NET_DVR_GET_PERSONDENSITY_SCHEDULE_CAPABILITIES = 4395 # 获取人员密度检测的布防时间能力
NET_DVR_GET_PERSONDENSITY_SCHEDULE = 4396 # 获取人员密度检测的布防时间配置
NET_DVR_SET_PERSONDENSITY_SCHEDULE = 4397 # 设置人员密度检测的布防时间配置

NET_DVR_GET_STUDENTS_STOODUP_SCHEDULE_CAPABILITIES = 4398 # 获取学生起立检测布防时间能力
NET_DVR_GET_STUDENTS_STOODUP_SCHEDULE = 4399 # 获取学生起立检测布防时间配置
NET_DVR_SET_STUDENTS_STOODUP_SCHEDULE = 4400 # 设置学生起立检测布防时间配置

NET_DVR_SET_FACE_THERMOMETRY_TRIGGER = 4401 # 设置人脸测温联动配置
NET_DVR_GET_FACE_THERMOMETRY_SCHEDULE_CAPABILITIES = 4402 # 获取人脸测温布防时间能力
NET_DVR_GET_FACE_THERMOMETRY_SCHEDULE = 4403 # 获取人脸测温布防时间配置
NET_DVR_SET_FACE_THERMOMETRY_SCHEDULE = 4404 # 设置人脸测温布防时间配置
NET_DVR_GET_FACE_THERMOMETRY_TRIGGER = 4405 # 获取人脸测温联动配置
NET_DVR_GET_PERSONQUEUE_TRIGGER = 4406 # 获取人员排队检测的联动配置
NET_DVR_SET_PERSONQUEUE_TRIGGER	 = 4407 # 设置人员排队检测的联动配置
NET_DVR_GET_PERSONQUEUE_SCHEDULE_CAPABILITIES = 4408 # 获取人员排队检测的布防时间能力
NET_DVR_GET_PERSONQUEUE_SCHEDULE = 4409 # 获取人员排队检测的布防时间配置
NET_DVR_SET_PERSONQUEUE_SCHEDULE = 4410 # 设置人员排队检测的布防时间配置


# 智能人脸识别
NET_DVR_GET_FACESNAPCFG = 5001 # 获取人脸抓拍参数
NET_DVR_SET_FACESNAPCFG = 5002 # 设置人脸抓拍参数
NET_DVR_GET_DEVACCESS_CFG = 5005 # 获取接入设备参数
NET_DVR_SET_DEVACCESS_CFG = 5006 # 设置接入设备参数
NET_DVR_GET_SAVE_PATH_CFG = 5007 # 获取存储信息参数
NET_DVR_SET_SAVE_PATH_CFG = 5008 # 设置存储信息参数
NET_VCA_GET_RULECFG_V41 = 5011 # 获取行为分析参数(扩展)
NET_VCA_SET_RULECFG_V41 = 5012 # 设置行为分析参数(扩展)
NET_DVR_GET_AID_RULECFG_V41 = 5013 # 获取交通事件规则参数
NET_DVR_SET_AID_RULECFG_V41 = 5014 # 设置交通事件规则参数
NET_DVR_GET_TPS_RULECFG_V41 = 5015 # 获取交通统计规则参数(扩展)
NET_DVR_SET_TPS_RULECFG_V41 = 5016 # 设置交通统计规则参数(扩展)
NET_VCA_GET_FACEDETECT_RULECFG_V41 = 5017 # 获取ATM人脸检测规则(扩展)
NET_VCA_SET_FACEDETECT_RULECFG_V41 = 5018 # 设置ATM人脸检测规则(扩展)
NET_DVR_GET_PDC_RULECFG_V41 = 5019 # 设置人流量统计规则(扩展)
NET_DVR_SET_PDC_RULECFG_V41 = 5020 # 获取人流量统计规则(扩展)
NET_DVR_GET_TRIAL_VERSION_CFG = 5021 # 获取试用版信息
NET_DVR_GET_VCA_CTRLINFO_CFG = 5022 # 批量获取智能控制参数
NET_DVR_SET_VCA_CTRLINFO_CFG = 5023 # 批量设置智能控制参数
NET_DVR_SYN_CHANNEL_NAME = 5024 # 同步通道名
NET_DVR_GET_RESET_COUNTER = 5025 # 获取统计数据清零参数（人流量、交通统计）
NET_DVR_SET_RESET_COUNTER = 5026 # 设置统计数据清零参数（人流量、交通统计）
NET_DVR_GET_OBJECT_COLOR = 5027 # 获取物体颜色属性
NET_DVR_SET_OBJECT_COLOR = 5028 # 设置物体颜色属性
NET_DVR_GET_AUX_AREA = 5029 # 获取辅助区域
NET_DVR_SET_AUX_AREA = 5030 # 设置辅助区域
NET_DVR_GET_CHAN_WORKMODE = 5031 # 获取通道工作模式
NET_DVR_SET_CHAN_WORKMODE = 5032 # 设置通道工作模式
NET_DVR_GET_SLAVE_CHANNEL = 5033 # 获取从通道参数
NET_DVR_SET_SLAVE_CHANNEL = 5034 # 设置从通道参数
NET_DVR_GET_VQD_EVENT_RULE = 5035 # 获取视频质量诊断事件规则
NET_DVR_SET_VQD_EVENT_RULE = 5036 # 设置视频质量诊断事件规则
NET_DVR_GET_BASELINE_SCENE = 5037 # 获取基准场景参数
NET_DVR_SET_BASELINE_SCENE = 5038 # 设置基准场景参数
NET_DVR_CONTROL_BASELINE_SCENE = 5039 # 基准场景操作
NET_DVR_SET_VCA_DETION_CFG = 5040 # 设置智能移动参数配置
NET_DVR_GET_VCA_DETION_CFG = 5041 # 获取智能移动参数配置
NET_DVR_GET_STREAM_ATTACHINFO_CFG = 5042 # 获取码流附加信息配置
NET_DVR_SET_STREAM_ATTACHINFO_CFG = 5043 # 设置码流附加信息配置

NET_DVR_GET_BV_CALIB_TYPE = 5044 # 获取双目标定类型
NET_DVR_CONTROL_BV_SAMPLE_CALIB = 5045 # 双目样本标定
NET_DVR_GET_BV_SAMPLE_CALIB_CFG = 5046 # 获取双目标定参数
NET_DVR_GET_RULECFG_V42 = 5049 # 获取行为分析参数(支持16条规则扩展)
NET_DVR_SET_RULECFG_V42 = 5050 # 设置行为分析参数(支持16条规则扩展)
NET_DVR_SET_VCA_DETION_CFG_V40 = 5051 # 设置智能移动参数配置
NET_DVR_GET_VCA_DETION_CFG_V40 = 5052 # 获取智能移动参数配置
NET_DVR_SET_FLASH_CFG = 5110 # 写入数据到Flash 测试使用

# 2014-12-03
NET_DVR_GET_T1TEST_CFG = 5053 # 产线测试配置接口（获取）
NET_DVR_SET_T1TEST_CFG = 5054 # # 产线测试配置接口（设置）

# ITS
NET_ITS_GET_OVERLAP_CFG_V50 = 5055 # 获取字符叠加参数配置扩展
NET_ITS_SET_OVERLAP_CFG_V50 = 5056 # 设置字符叠加参数配置扩展

NET_DVR_GET_PARKLAMP_STATE = 5057 # 获取停车场信号灯状态信息
NET_DVR_GET_CLOUDSTORAGE_CFG = 5058 # 获取云存储配置参数
NET_DVR_SET_CLOUDSTORAGE_CFG = 5059 # 设置云存储配置参数

NET_ITS_GET_BASE_INFO = 5060 # 获取终端基本信息
NET_DVR_GET_SENSOR_INFO = 5061 # 传感器信息查询
NET_DVR_SET_SENSOR_SWITCH = 5062 # 传感器远程控制
NET_ITS_GET_IMGMERGE_CFG = 5063 # 获取图片合成配置参数
NET_ITS_SET_IMGMERGE_CFG = 5064 # 设置图片合成配置参数
NET_ITS_GET_UPLOAD_CFG = 5065 # 获取数据上传配置
NET_ITS_SET_UPLOAD_CFG = 5066 # 设置数据上传配置
NET_DVR_GET_SENSOR_PORT_CAPABILITIES = 5067 # 获取传感器能力
NET_ITS_GET_WORKSTATE = 5069 # 获取终端工作状态
NET_ITS_GET_IPC_CHAN_CFG = 5070 # 获取通道IPC信息
NET_ITS_SET_IPC_CHAN_CFG = 5071 # 设置通道IPC信息
NET_ITS_GET_OVERLAP_CFG = 5072 # 获取字符叠加参数配置
NET_ITS_SET_OVERLAP_CFG = 5073 # 设置字符叠加参数配置
NET_DVR_GET_TRIGGEREX_CFG = 5074 # 获取ITC扩展配置
NET_DVR_SET_TRIGGEREX_CFG = 5075 # 设置ITC扩展配置
NET_ITS_GET_ROAD_INFO = 5076 # 获取路口信息

NET_ITS_REMOTE_DEVICE_CONTROL = 5077 # 设置远程设备控制
NET_ITS_GET_GATEIPC_CHAN_CFG = 5078 # 获取出入口参数
NET_ITS_SET_GATEIPC_CHAN_CFG = 5079 # 设置出入口参数
NET_ITS_TRANSCHAN_START = 5080 # 同步数据服务器建立连接
NET_ITS_GET_ECTWORKSTATE = 5081 # 获取出入口终端工作状态
NET_ITS_GET_ECT_CHAN_INFO = 5082 # 获取出入口终端通道状态
NET_DVR_GET_HEATMAP_RESULT = 5083 # 热度图数据查找
NET_DVR_SET_ITS_EXDEVCFG = 5084 # 设置ITS外接设备信息
NET_DVR_GET_ITS_EXDEVCFG = 5085 # 获取ITS外接设备信息
NET_DVR_GET_ITS_EXDEVSTATUS = 5086 # 获取ITS所有外接设备信息
NET_DVR_SET_ITS_ENDEVCMD = 5087 # 设置ITS终端出入口控制命令
NET_DVR_SET_ENISSUED_DATADEL = 5088 # 设置ITS终端出入口控制清除
NET_DVR_GET_PDC_RESULT = 5089 # 客流量数据查询 2014-03-21
NET_ITS_GET_LAMP_CTRLCFG = 5090 # 获取内外置灯参数
NET_ITS_SET_LAMP_CTRLCFG = 5091 # 设置内外置灯参数
NET_ITS_GET_PARKSPACE_ATTRIBUTE_CFG = 5092 # 获取特殊车位参数
NET_ITS_SET_PARKSPACE_ATTRIBUTE_CFG = 5093 # 设置特殊车位参数
NET_ITS_SET_LAMP_EXTERNAL_CFG = 5095 # 设置外控配置参数
NET_ITS_SET_COMPEL_CAPTURE = 5096 # 设置车位强制抓图
NET_DVR_SET_TIMESIGN_CFG = 5097 # 设置扩展校时自定义标记
NET_DVR_GET_TIMESIGN_CFG = 5098 # 获取扩展校时自定义标记
NET_DVR_GET_SIGNALLAMP_STATUS = 5099 # 信号灯检测
# ITS

NET_DVR_GET_MONITOR_PLAN_VQD = 5100 # 长连接获取诊断服务器计划
NET_DVR_GET_MONITORID_VQD = 5101 # 长连接获取对应计划内的监控点信息
NET_DVR_SET_MONITOR_INFO = 5102 # 批量设置计划内的监控点信息
NET_DVR_DEL_MONITOR_PLAN_VQD = 5103 # 删除计划
NET_DVR_GET_MONITOR_VQD_STATUS = 5104 # 平台查询诊断服务器的状态
NET_DVR_GET_RECORD_INFO = 5105 # 获取资源图片查询
NET_DVR_GET_MONITOR_VQDCFG = 5106 # 获取服务器的监控点信息
NET_DVR_SET_MONITOR_VQDCFG = 5107 # 设置服务器的监控点信息
NET_DVR_SET_MONITOR_PLAN_VQDCFG = 5108 # 设置管理计划(单独的计划)

NET_DVR_SCENE_CHANGE_UPDATE = 5109 # 场景变更数据更新

NET_DVR_GET_CALIBRATE_POINT = 5153 # 归一化坐标转换（枪球联动设备 外部交互命令码 基线代码不实现，防止冲突，提交基线）

# 智能多场景
NET_DVR_GET_SCENE_CFG = 5201 # 获取场景信息
NET_DVR_SET_SCENE_CFG = 5202 # 设置场景信息
NET_DVR_GET_SCENE_REFERENCE_REGION = 5203 # 获取参考区域
NET_DVR_SET_SCENE_REFERENCE_REGION = 5204 # 设置参考区域
NET_DVR_GET_SCENE_CALIBRATION = 5205 # 获取标定信息
NET_DVR_SET_SCENE_CALIBRATION = 5206 # 设置标定信息
NET_DVR_GET_SCENE_MASK_REGION = 5207 # 获取屏蔽区域
NET_DVR_SET_SCENE_MASK_REGION = 5208 # 设置屏蔽区域
NET_DVR_GET_SCENE_LANECFG = 5209 # 获取车道规则
NET_DVR_SET_SCENE_LANECFG = 5210 # 设置车道规则
NET_DVR_GET_SCENE_AID_RULECFG = 5211 # 获取交通事件规则参数
NET_DVR_SET_SCENE_AID_RULECFG = 5212 # 设置交通事件规则参数
NET_DVR_GET_SCENE_TPS_RULECFG = 5213 # 获取交通统计规则参数
NET_DVR_SET_SCENE_TPS_RULECFG = 5214 # 设置交通统计规则参数
NET_DVR_GET_SCENE_TIME_CFG = 5215 # 获取通道的场景时间段配置
NET_DVR_SET_SCENE_TIME_CFG = 5216 # 设置通道的场景时间段配置
NET_DVR_GET_FORENSICS_MODE = 5217 # 获取取证方式参数
NET_DVR_SET_FORENSICS_MODE = 5218 # 设置取证方式参数
NET_DVR_FORCESTOP_FORENSICS_CTRL = 5219 # 强制停止取证
NET_DVR_GET_ALARM_PROCESS_CFG = 5220 # 获取报警处理参数
NET_DVR_SET_ALARM_PROCESS_CFG = 5221 # 设置报警处理参数
NET_DVR_GET_BLACKLIST_ALARM_INFO = 5222 # 获取黑白名单报警轨迹
NET_DVR_GET_STORAGE_RESOURCE_CFG = 5225 # 获取存储资源参数
NET_DVR_SET_STORAGE_RESOURCE_CFG = 5226 # 设置存储资源参数
NET_DVR_DEL_BLACKLIST_ALARM_RECORD = 5227 # 远程删除名单报警记录
NET_DVR_SET_BLACKLIST_GROUP_INFO = 5229 # 远程分组列表参数配置
NET_DVR_DEL_BLACKLIST_GROUP_INFO = 5230 # 远程删除分组列表
NET_DVR_GET_BLACKLIST_GROUP_INFO = 5231 # 远程获取全部分组列表
NET_DVR_SET_BLACKLIST_GROUP_RECORD_CFG = 5232 # 分组记录参数配置
NET_DVR_GET_BLACKLIST_GROUP_RECORD_CFG = 5234 # 远程获取分组记录参数
NET_DVR_DEL_BLACKLIST_GROUP_RECORD_CFG = 5235 # 远程删除分组记录参数
NET_DVR_GET_AREA_MONITOR_CFG = 5236 # 获取区域监控点参数
NET_DVR_SET_AREA_MONITOR_CFG = 5237 # 设置区域监控点参数
NET_DVR_DEL_AREA_MONITOR_CFG = 5238 # 删除区域监控点
NET_DVR_RETRIEVAL_SNAP_RECORD = 5240 # 抓拍库检索
NET_DVR_GET_ALARMLIST = 5241 # 获取名单报警列表
NET_DVR_DETECT_IMAGE = 5242 # 单张图片检测
NET_DVR_GET_SNAP_RECORD = 5243 # 获取抓拍记录
NET_DVR_DEL_SNAP_RECORD = 5244 # 删除抓拍记录
NET_DVR_GET_FACE_RECORD = 5245 # 远程获取人脸记录列表
NET_DVR_SET_FACE_RECORD = 5246 # 添加人脸记录
NET_DVR_DEL_FACE_RECORD = 5247 # 删除人脸记录
NET_DVR_GET_FACE_DATABASE = 5248 # 获取人脸库配置参数
NET_DVR_SET_FACE_DATABASE = 5249 # 设置人脸库配置参数
NET_DVR_DEL_FACE_DATABASE = 5250 # 删除人脸库
NET_DVR_RETRIEVAL_FACE_DATABASE = 5251 # 人脸库检索
NET_DVR_SET_BLACKLIST_REL_DEV_CFG = 5252 # 设备关联名单分组关联
NET_DVR_DEL_BLACKLIST_REL_DEV = 5253 # 删除 设备关联名单分组信息

NET_DVR_GET_DISK_RAID_INFO = 6001 # 获取磁盘Raid信息
NET_DVR_SET_DISK_RAID_INFO = 6002 # 设置磁盘Raid信息

NET_DVR_GET_DVR_SYNCHRONOUS_IPC = 6005 # 获取：是否为前端IPC同步设备参数
NET_DVR_SET_DVR_SYNCHRONOUS_IPC = 6006 # 设置：是否为前端IPC同步设备参数

NET_DVR_SET_DVR_IPC_PASSWD = 6008 # 设置：IPC用户名密码
NET_DVR_GET_DEVICE_NET_USING_INFO = 6009 # 获取：当前设备网络资源使用情况

NET_DVR_SET_DVR_IPC_NET = 6012 # 设置：设置前端IPC的网络地址

NET_DVR_GET_RECORD_CHANNEL_INFO = 6013 # 获取：录像通道信息
NET_DVR_SET_RECORD_CHANNEL_INFO = 6014 # 设置：录像通道信息


NET_DVR_MOUNT_DISK = 6015 #  加载磁盘
NET_DVR_UNMOUNT_DISK = 6016 #  卸载磁盘

#  CVR
NET_DVR_GET_STREAM_SRC_INFO = 6017 # 获取：流来源信息
NET_DVR_SET_STREAM_SRC_INFO = 6018 # 设置：流来源信息
NET_DVR_GET_STREAM_RECORD_INFO = 6019 # 获取：流录像信息
NET_DVR_SET_STREAM_RECORD_INFO = 6020 # 设置：流录像信息
NET_DVR_GET_STREAM_RECORD_STATUS = 6021 # 获取：流录像状态
NET_DVR_SET_STREAM_RECORD_STATUS = 6022 # 设置：流录像状态
NET_DVR_GET_STREAM_INFO = 6023 # 获取已添加的流ID信息
NET_DVR_GET_STREAM_SRC_INFO_V40 = 6024 # 获取：流来源信息
NET_DVR_SET_STREAM_SRC_INFO_V40 = 6025 # 设置：流来源信息
NET_DVR_GET_RELOCATE_INFO = 6026 # 获取N+0模式下重定向信息
NET_DVR_START_GOP_INFO_PASSBACK = 6032 # 智能信息回填
NET_DVR_GET_CHANS_RECORD_STATUS_CFG = 6035 # 获取通道录像状态信息
NET_DVR_SET_CHANS_RECORD_STATUS_CFG = 6036 # 设置通道录像状态信息
# NVR：96xx
NET_DVR_GET_IP_ALARM_GROUP_NUM = 6100 # 获取：IP通道报警输入输出组数
NET_DVR_GET_IP_ALARM_IN = 6101 # 获取：IP通道报警输入信息
NET_DVR_GET_IP_ALARM_OUT = 6102 # 获取：IP通道报警输出信息

# 9000 v2.2
NET_DVR_GET_FTPCFG_SECOND = 6103 # 获取图片上传FTP参数
NET_DVR_SET_FTPCFG_SECOND = 6104 # 设置图片上传FTP参数

NET_DVR_GET_DEFAULT_VIDEO_EFFECT = 6105 #  获取视频输入效果参数默认值
NET_DVR_SET_VIDEO_EFFECT = 6106 #  设置通道视频输入图像参数
NET_DVR_DEL_INVALID_DISK = 6107 #  删除无效磁盘

NET_DVR_GET_DRAWFRAME_DISK_QUOTA_CFG = 6109 # 获取抽帧通道磁盘配额
NET_DVR_SET_DRAWFRAME_DISK_QUOTA_CFG = 6110 # 设置抽帧通道磁盘配额

NET_DVR_GET_NAT_CFG = 6111 # 获取NAT映射参数
NET_DVR_SET_NAT_CFG = 6112 # 设置NAT映射参数
NET_DVR_GET_AES_KEY = 6113 # 获取设备AES加密密钥
NET_DVR_GET_POE_CFG = 6114 # 获取POE参数
NET_DVR_SET_POE_CFG = 6115 # 设置POE参数
NET_DVR_GET_CUSTOM_PRO_CFG = 6116 # 获取自定义协议参数
NET_DVR_SET_CUSTOM_PRO_CFG = 6117 # 设置自定义协议参数
NET_DVR_GET_STREAM_CABAC = 6118 # 获取码流压缩性能选项
NET_DVR_SET_STREAM_CABAC = 6119 # 设置码流压缩性能选项
NET_DVR_GET_ESATA_MINISAS_USAGE_CFG = 6120 # 获取eSATA和miniSAS用途
NET_DVR_SET_ESATA_MINISAS_USAGE_CFG = 6121 # 设置eSATA和miniSAS用途

NET_DVR_GET_HDCFG_V40 = 6122 # 获取硬盘信息参数
NET_DVR_SET_HDCFG_V40 = 6123 # 设置硬盘信息参数
NET_DVR_GET_POE_CHANNEL_ADD_MODE = 6124 # 获取POE通道添加方式
NET_DVR_SET_POE_CHANNEL_ADD_MODE = 6125 # 设置POE通道添加方式
NET_DVR_GET_DIGITAL_CHANNEL_STATE = 6126 # 获取设备数字通道状态
NET_DVR_GET_BONJOUR_CFG = 6127 #  获取Bonjour信息
NET_DVR_SET_BONJOUR_CFG = 6128 #  设置Bonjour信息


NET_DVR_GET_SOCKS_CFG = 6130 # 获取SOCKS信息
NET_DVR_SET_SOCKS_CFG = 6131 # 设置SOCKS信息

NET_DVR_GET_QOS_CFG = 6132 # 获取QoS信息
NET_DVR_SET_QOS_CFG = 6133 # 设置QoS信息

NET_DVR_GET_HTTPS_CFG = 6134 # 获取HTTPS信息
NET_DVR_SET_HTTPS_CFG = 6135 # 设置HTTPS信息

NET_DVR_GET_WD1_CFG = 6136 # 远程获取WD1使能开关
NET_DVR_SET_WD1_CFG = 6137 # 远程设置WD1使能开关

NET_DVR_CREATE_CERT = 6138 # 创建证书
NET_DVR_DELETE_CERT = 6139 # 删除证书


NET_DVR_GET_RECORD_LOCK_PERCENTAGE = 6140 # 获取录像段锁定比例
NET_DVR_SET_RECORD_LOCK_PERCENTAGE = 6141 # 设置录像段锁定比例

NET_DVR_CMD_TRIGGER_PERIOD_RECORD = 6144 # 外部命令触发指定时间录像
NET_DVR_UPLOAD_CERT = 6145 # 上传证书
NET_DVR_DOWNLOAD_CERT = 6146 # 下载证书
NET_DVR_GET_CERT = 6147 # 获取证书

NET_DVR_GET_POS_FILTER_CFG = 6148 # 获取POS过滤规则
NET_DVR_SET_POS_FILTER_CFG = 6149 # 设置POS过滤规则
NET_DVR_GET_CONNECT_POS_CFG = 6150 # 获取DVR与POS连接方式
NET_DVR_SET_CONNECT_POS_CFG = 6151 # 设置DVR与POS连接方式
NET_DVR_GET_CHAN_FILTER_CFG = 6152 # 获取规则与通道关联信息
NET_DVR_SET_CHAN_FILTER_CFG = 6153 # 设置规则与通道关联信息


NET_DVR_GET_FTPCFG_V40 = 6162 # 获取FTP信息
NET_DVR_SET_FTPCFG_V40 = 6163 # 设置FTP信息

NET_DVR_GET_MONTHLY_RECORD_DISTRIBUTION = 6164 # 获取月历录像分布
NET_DVR_GET_ACCESS_DEVICE_CHANNEL_INFO = 6165 # 获取待接入设备通道信息
NET_DVR_GET_PREVIEW_SWITCH_CFG = 6166 # 获取设备本地预览切换参数
NET_DVR_SET_PREVIEW_SWITCH_CFG = 6167 # 设置设备本地预览切换参数

# Netra3.0.0
NET_DVR_GET_N_PLUS_ONE_WORK_MODE = 6168 # 获取N+1工作模式
NET_DVR_SET_N_PLUS_ONE_WORK_MODE = 6169 # 设置N+1工作模式

NET_DVR_GET_HD_STATUS = 6170 # 获取硬盘状态
NET_DVR_SET_HD_STATUS = 6171 # 设置硬盘状态

NET_DVR_IMPORT_IPC_CFG_FILE = 6172 # 导入IPC配置文件
NET_DVR_EXPORT_IPC_CFG_FILE = 6173 # 导出IPC配置文件
NET_DVR_UPGRADE_IPC = 6174 # 升级IP通道

NET_DVR_GET_RAID_BACKGROUND_TASK_SPEED = 6175 # 获取RAID后台任务速度
NET_DVR_SET_RAID_BACKGROUND_TASK_SPEED = 6176 # 设置RAID后台任务速度

# marvell 256路NVR
NET_DVR_GET_EXCEPTIONCFG_V40 = 6177 # 获取异常参数配置
NET_DVR_SET_EXCEPTIONCFG_V40 = 6178 # 设置异常参数配置
NET_DVR_GET_PICCFG_V40 = 6179 # 获取图象参数 支持变长    NetSDK_
NET_DVR_SET_PICCFG_V40 = 6180 # 设置图象参数， 支持变长
NET_DVR_GET_ALARMINCFG_V40 = 6181 # 获取报警输入参数，支持变长
NET_DVR_SET_ALARMINCFG_V40 = 6182 # 获取报警输入参数，支持变长
NET_DVR_GET_IPALARMINCFG_V40 = 6183 # 获取IP报警输入接入配置信息
NET_DVR_GET_IPALARMOUTCFG_V40 = 6185 # 获取IP报警输出接入配置信息
NET_DVR_GET_USERCFG_V40 = 6187 # 获取用户参数
NET_DVR_SET_USERCFG_V40 = 6188 # 设置用户参数
NET_DVR_GET_WORK_STATUS = 6189 # 获取设备工作状态
NET_DVR_GET_JPEG_CAPTURE_CFG_V40 = 6190 # 获取DVR抓图配置
NET_DVR_SET_JPEG_CAPTURE_CFG_V40 = 6191 # 设置DVR抓图配置
NET_DVR_GET_HDGROUP_CFG_V40 = 6192 # 获取盘组管理配置参数
NET_DVR_SET_HDGROUP_CFG_V40 = 6193 # 设置盘组管理配置参数
NET_DVR_GET_SMD_HOLIDAY_HANDLE = 6194 # 获取简易智能假日计划
NET_DVR_SET_SMD_HOLIDAY_HANDLE = 6195 # 设置简易智能假日计划
NET_DVR_GET_PIC_MODEL_CFG = 6196 # 获取图片建模配置参数
NET_DVR_SET_PIC_MODEL_CFG = 6197 # 设置图片建模配置参数
NET_DVR_START_LOCAL_MOUSE_EVENT = 6198 # 开启设备本地鼠标事件记录
NET_DVR_START_SIMULARE_MOUSE_EVENT = 6199 # 远程模拟鼠标事件
NET_DVR_GET_WORK_STATUS_V50 = 6200 # 获取设备工作状态V50

# 91系列HD-SDI高清DVR
NET_DVR_GET_ACCESS_CAMERA_INFO = 6201 #  获取前端相机信息
NET_DVR_SET_ACCESS_CAMERA_INFO = 6202 #  设置前端相机信息
NET_DVR_PULL_DISK = 6203 #  安全拔盘
NET_DVR_SCAN_RAID = 6204 #  扫描阵列
#  CVR 2.0.X
NET_DVR_GET_USER_RIGHT_CFG = 6210 #  获取用户权限
NET_DVR_SET_USER_RIGHT_CFG = 6211 #  设置用户权限

NET_DVR_ONE_KEY_CONFIG = 6212 #  一键配置CVR
NET_DVR_RESTART_SERVICE = 6213 #  重启CVR服务

NET_DVR_GET_MAX_MACHINE_NUM_CFG = 6214 #  获取备机最大个数
NET_DVR_SET_MAX_MACHINE_NUM_CFG = 6215 #  设置备机最大个数

NET_DVR_ADD_DEVICE = 6216 # N+1模式添加设备
NET_DVR_DEL_DEVICE = 6217 # N+1模式删除设备

NET_DVR_GET_DATA_CALLBACK_CFG = 6218 #  获取数据回迁状态
NET_DVR_SET_DATA_CALLBACK_CFG = 6219 #  设置数据回迁状态

NET_DVR_CLONE_LUN = 6220 # 克隆LUN卷
NET_DVR_EXPAND_LUN = 6221 # 扩展和重命名LUN卷

NET_DVR_GET_N_PLUS_ONE_DEVICE_INFO = 6222 # 获取N+1设备信息
NET_DVR_MODIFY_DVR_NET_DISK = 6223 # 修改DVR网盘
NET_DVR_DEL_DVR_NET_DISK = 6224 # 删除DVR网盘

NET_DVR_CREATE_NAS = 6225 # 创建NAS
NET_DVR_DELETE_NAS = 6226 # 删除NAS

NET_DVR_OPEN_ISCSI = 6227 # 开启iSCSI
NET_DVR_CLOSE_ISCSI = 6228 # 关闭iSCSI

NET_DVR_GET_FC = 6229 # 获取光纤信息
NET_DVR_OPEN_FC = 6230 # 开启FC
NET_DVR_CLOSE_FC = 6231 # 关闭FC
NET_DVR_ONE_KEY_CONFIG_SAN = 6232 #  一键配置SAN, 与一键配置CVR逻辑一样

# CVR2.3.2
NET_DVR_RECORD_CHECK = 6233 # 录像完整性检测
NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL = 6234 # 手动添加录像回传任务
NET_DVR_GET_ALL_RECORD_PASSBACK_TASK_MANUAL = 6235 # 获取所有手动添加录像回传任务
NET_DVR_RECORD_PASSBACK_TASK_MANUAL_CTRL = 6236 # 控制手动录像回传任务
NET_DVR_DEL_RECORD_PASSBACK_TASK_MANUAL = 6237 # 删除手动录像回传任务
NET_DVR_GET_RECORD_PASSBACK_PLAN_CFG = 6238 # 获取录像回传计划配置
NET_DVR_SET_RECORD_PASSBACK_PLAN_CFG = 6239 # 设置录像回传计划配置
NET_DVR_GET_DEV_STORAGE_CFG = 6240 # 获取设备存储信息
NET_DVR_GET_ONLINE_USER_CFG = 6241 # 获取在线用户参数
NET_DVR_GET_RECORD_SEGMENT_CFG = 6242 # 获取录像段总量

NET_DVR_GET_REC_PASSBACK_TASK_EXECUTABLE = 6243 # 查询手动录像回传任务可执行性
NET_DVR_GET_STREAM_MEDIA_CFG = 6244 # 获取流媒体回传录像参数配置（流ID方式）
NET_DVR_SET_STREAM_MEDIA_CFG = 6245 # 设置流媒体回传录像参数配置（流ID方式）
NET_DVR_GET_USERCFG_V50 = 6246 # 获取用户参数V50
NET_DVR_SET_USERCFG_V50 = 6247 # 设置用户参数V50

NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG_CAP = 6248 # 获取CVR回传功能基础配置能力
NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG = 6249 # 获取CVR回传功能基础配置
NET_DVR_SET_RECORD_PASSBACK_BASIC_CFG = 6250 # 设置CVR回传功能基础配置
NET_DVR_ONE_KEY_CONFIG_V50 = 6251 #  一键配置CVR(V50)
NET_DVR_GET_RACM_CAP = 6252 # 获取存储总能力（RACM能力）
NET_DVR_GET_THUMBNAILS = 6253 # 获取缩略图（默认是录像的缩略图）(支持流ID)
NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL_V50 = 6254 # 手动添加录像回传任务V50（返回任务ID）
NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG_CAP = 6255 # 获取CVR回传历史录像计划能力
NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG = 6256 # 获取CVR回传历史录像计划配置
NET_DVR_SET_RECORD_PASSBACK_HISTORY_PLAN_CFG = 6257 # 设置CVR回传历史录像计划配置
NET_DVR_ONE_KEY_CONFIG_V51 = 6258 #  一键配置CVR(V51)


NET_DVR_GET_RECORD_PACK = 6301 # 获取录像打包参数
NET_DVR_SET_RECORD_PACK = 6302 # 设置录像打包参数

NET_DVR_GET_CLOUD_STORAGE_CFG = 6303 # 获取设备当前工作模式
NET_DVR_SET_CLOUD_STORAGE_CFG = 6304 # 设置设备当前工作模式
NET_DVR_GET_GOP_INFO = 6305 # 获取GOP信息
NET_DVR_GET_PHY_DISK_INFO = 6306 # 获取物理磁盘信息
# 录播主机外部命令
NET_DVR_GET_RECORDING_AUTO_TRACK_CFG = 6307 # 获取SDI自动跟踪配置信息
NET_DVR_SET_RECORDING_AUTO_TRACK_CFG = 6308 # 设置SDI自动跟踪配置信息

NET_DVR_GET_RECORDING_PUBLISH_CFG = 6309 # 获取一键发布信息
NET_DVR_SET_RECORDING_PUBLISH_CFG = 6310 # 设置一键发布信息


NET_DVR_RECORDING_ONEKEY_CONTROL = 6311 # 录播主机控制

NET_DVR_GET_RECORDING_END_TIME = 6312 # 获取录播剩余时间

NET_DVR_RECORDING_PUBLISH = 6313 # 一键发布录像

NET_DVR_GET_CURRICULUM_CFG = 6314 # 获取课表配置信息
NET_DVR_SET_CURRICULUM_CFG = 6315 # 设置课表配置信息

NET_DVR_GET_COURSE_INDEX_CFG = 6316 # 获取课程信息索引
NET_DVR_SET_COURSE_INDEX_CFG = 6317 # 设置课程信息索引

NET_DVR_GET_PPT_CHANNEL = 6318 # 获取PPT支持通道号
NET_DVR_GET_PPT_DETECT_CFG = 6319 # 获取PPT检测参数
NET_DVR_SET_PPT_DETECT_CFG = 6320 # 设置PPT检测参数

NET_DVR_GET_RECORDINGHOST_CFG = 6321 # 获取录播主机配置信息
NET_DVR_SET_RECORDINGHOST_CFG = 6322 # 设置录播主机配置信息
NET_DVR_GET_BACKUP_RECORD_CFG = 6323 # 获取一键备份配置信息
NET_DVR_SET_BACKUP_RECORD_CFG = 6324 # 设置一键备份配置信息

# 庭审主机
NET_DVR_GET_AUDIO_ACTIVATION_CFG = 6326 # 获取语音激励配置参数
NET_DVR_SET_AUDIO_ACTIVATION_CFG = 6327 # 设置语音激励配置参数
NET_DVR_GET_DECODERCFG_V40 = 6328 # 获取解码器参数信息
NET_DVR_SET_DECODERCFG_V40 = 6329 # 设置解码器参数信息

NET_DVR_INFRARED_OUTPUT_CONTROL = 6330 # 红外输出控制
NET_DVR_GET_INFRARED_CMD_NAME_CFG = 6331 # 获取红外命令名称参数配置
NET_DVR_SET_INFRARED_CMD_NAME_CFG = 6332 # 设置红外命令名称参数配置
NET_DVR_START_INFRARED_LEARN = 6333 # 远程红外学码

NET_DVR_GET_TRIAL_SYSTEM_CFG = 6334 # 获取庭审主机系统信息
NET_DVR_SET_CASE_INFO = 6335 # 案件信息录入
NET_DVR_GET_TRIAL_MICROPHONE_STATUS = 6336 # 获取麦克风状态信息
NET_DVR_SET_TRIAL_MICROPHONE_STATUS = 6337 # 获取麦克风状态信息
NET_DVR_GET_TRIAL_HOST_STATUS = 6338 # 获取庭审主机状态信息
NET_DVR_GET_LAMP_OUT = 6339 # 获取LAMP输出口信息
NET_DVR_SET_LAMP_OUT = 6340 # 设置LAMP输出口信息
NET_DVR_LAMP_REMOTE_CONTROL = 6341 #  LAMP控制
NET_DVR_REMOTE_CONTROL_PLAY = 6342 # 远程控制本地回放
NET_DVR_GET_LOCAL_INPUT_CFG = 6343 # 获取庭审主机状态信息庭审主机本地输入信息
NET_DVR_SET_LOCAL_INPUT_CFG = 6344 # 设置庭审主机本地输入信息
NET_DVR_GET_CASE_INFO = 6345 # 获取当前案件信息

# 审讯机外部命令
NET_DVR_INQUEST_GET_CDW_STATUS = 6350 # 获取审讯机刻录状态-长连接
NET_DVR_GET_MIX_AUDIOIN_CFG = 6351 # 获取混音输入口参数配置
NET_DVR_SET_MIX_AUDIOIN_CFG = 6352 # 设置混音输入口参数配置
NET_DVR_GET_MIX_AUDIOOUT_CFG = 6353 # 获取混音输出口参数配置
NET_DVR_SET_MIX_AUDIOOUT_CFG = 6354 # 设置混音输出口参数配置
NET_DVR_GET_AUDIOIN_VOLUME_CFG = 6355 # 获取音频输入口音量调节参数配置
NET_DVR_SET_AUDIOIN_VOLUME_CFG = 6356 # 设置音频输入口音量调节参数配置
NET_DVR_GET_AREA_MASK_CFG = 6357 # 获取马赛克区域配置
NET_DVR_SET_AREA_MASK_CFG = 6358 # 设置马赛克区域配置
NET_DVR_GET_AUDIO_DIACRITICAL_CFG = 6359 # 获取音频变音配置
NET_DVR_SET_AUDIO_DIACRITICAL_CFG = 6360 # 设置音频变音配置
NET_DVR_GET_WIFI_DHCP_ADDR_CFG = 6361 # 获WIFI DHCP 地址范围参数配置
NET_DVR_SET_WIFI_DHCP_ADDR_CFG = 6362 # 设WIFI DHCP 地址范围参数配置
NET_DVR_GET_WIFI_CLIENT_LIST_INFO = 6363 # 获取wifi热点下连接的设备信息
NET_DVR_REMOTECONTROL_POWER_ON = 6364 # 远程开机
NET_DVR_GET_MULTISTREAM_RELATION_CHAN_CFG = 6365 # 获取多码流关联通道参数配置
NET_DVR_SET_MULTISTREAM_RELATION_CHAN_CFG = 6366 # 设置多码流关联通道参数配置
NET_DVR_GET_VIDEOOUT_RESOLUTION_CFG = 6367 # 获取设备本地视频输出口分辨率
NET_DVR_SET_VIDEOOUT_RESOLUTION_CFG = 6368 # 设置设备本地视频输出口分辨率
NET_DVR_GET_AUDIOOUT_VOLUME_CFG = 6369 # 获取音频输出口音量调节参数配置
NET_DVR_SET_AUDIOOUT_VOLUME_CFG = 6370 # 设置音频输出口音量调节参数配置
NET_DVR_INQUEST_PAUSE_CDW = 6371 # 暂停刻录
NET_DVR_INQUEST_RESUME_CDW = 6372 # 恢复刻录
NET_DVR_GET_INPUT_CHAN_CFG = 6373 # 获取输入通道配置
NET_DVR_SET_INPUT_CHAN_CFG = 6374 # 设置输入通道配置
NET_DVR_GET_INQUEST_MIX_AUDIOIN_CFG = 6375 # 获取审讯机音频输入混音配置
NET_DVR_SET_INQUEST_MIX_AUDIOIN_CFG = 6376 # 设置审讯机音频输入混音配置
NET_DVR_CASE_INFO_CTRL = 6377 # 案件信息显示控制
NET_DVR_GET_INQUEST_USER_RIGHT = 6378 # 获取审讯机用户权限
NET_DVR_SET_INQUEST_USER_RIGHT = 6379 # 设置审讯机用户权限
NET_DVR_GET_INQUEST_CASE_INFO = 6380 # 获取审讯案件信息配置
NET_DVR_SET_INQUEST_CASE_INFO = 6381 # 设置审讯案件信息配置

NET_DVR_GET_FILM_MODE_CFG = 6387 # 获取电影模式
NET_DVR_SET_FILM_MODE_CFG = 6388 # 设置电影模式
NET_DVR_GET_FILM_MODE_CFG_CAP = 6389 # 获取电影模式配置能力

NET_DVR_GET_DIRECTED_STRATEGY_CFG = 6390 # 获取导播策略类型
NET_DVR_SET_DIRECTED_STRATEGY_CFG = 6391 # 设置导播策略类型
NET_DVR_GET_DIRECTED_STRATEGY_CFG_CAP = 6392 # 获取电影模式配置能力
NET_DVR_GET_FRAME_CFG = 6393 # 获取画面边框
NET_DVR_SET_FRAME_CFG = 6394 # 设置画面边框
NET_DVR_GET_FRAME_CFG_CAP = 6395 # 获取画面边框配置能力
NET_DVR_GET_AUDIO_EFFECTIVE_CFG = 6396 # 获取音频优化参数
NET_DVR_SET_AUDIO_EFFECTIVE_CFG = 6397 # 设置音频效果参数
NET_DVR_GET_AUDIO_EFFECTIVE_CFG_CAP = 6398 # 获取音频效果优化配置能力
NET_DVR_GET_RECORD_VIDEO_CFG = 6399 # 获取录制视频参数
NET_DVR_SET_RECORD_VIDEO_CFG = 6400 # 设置录制视频参数


NET_DVR_GET_OUTPUT_CFG = 6401 # 获取显示输出参数
NET_DVR_SET_OUTPUT_CFG = 6402 # 设置显示输出参数
NET_DVR_CODER_DISPLAY_START = 6403 # 开始输出
NET_DVR_CODER_DISPLAY_STOP = 6404 # 停止输出
NET_DVR_GET_WINDOW_STATUS = 6405 # 获取显示窗口状态

# VQD功能接口
NET_DVR_GET_VQD_LOOP_DIAGNOSE_CFG = 6406 # 获取VQD循环诊断配置参数
NET_DVR_SET_VQD_LOOP_DIAGNOSE_CFG = 6407 # 设置VQD循环诊断配置参数
NET_DVR_GET_VQD_DIAGNOSE_INFO = 6408 # 手动获取VQD诊断信息

NET_DVR_RECORDING_PUBLISH_FILE = 6421 # 文件发布
NET_DVR_GET_RECORDING_PUBLISH_FILE_CAP = 6422 # 获取文件发布能力
NET_DVR_GET_PUBLISH_PROGRESS = 6423 # 获取发布进度
NET_DVR_GET_RECORD_VIDEO_CFG_CAP = 6424 # 获取录制视频配置能力
NET_DVR_GET_RTMP_CFG = 6425 # 获取RTMP参数
NET_DVR_SET_RTMP_CFG = 6426 # 设置RTMP参数
NET_DVR_GET_RTMP_CFG_CAP = 6427 # 获取RTMP配置能力
NET_DVR_DEL_BACKGROUND_PIC = 6428 # 删除背景图片文件
NET_DVR_GET_BACKGROUND_PIC_CFG = 6429 # 查询背景图片文件
NET_DVR_GET_BACKGROUND_PIC_INFO = 6430 # 获取哪张图片作为背景图片
NET_DVR_SET_BACKGROUND_PIC_INFO = 6431 # 设置哪张图片作为背景图片
NET_DVR_GET_BACKGROUND_PIC_INFO_CAP = 6432 # 获取哪张图片作为背景图片配置能力
NET_DVR_GET_RECORD_HOST_CAP = 6433 # 获取录播主机总能力
NET_DVR_GET_COURSE_LIST = 6434 # 获取课程列表
NET_DVR_GET_RECORD_STATUS = 6435 # 查询录播主机当前状态
NET_DVR_MANUAL_CURRICULUM_CONTROL = 6436 # 手动课表控制
NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG = 6437 # 获取图像差分检测参数
NET_DVR_SET_IMAGE_DIFF_DETECTION_CFG = 6438 # 设置图像差分检测参数
NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG_CAP = 6439 # 获取图像差分检测配置能力
NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO = 6440 # 获取发布文件信息参数
NET_DVR_SET_RECORDING_PUBLISH_FILE_INFO = 6441 # 设置发布文件信息参数
NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO_CAP = 6442 # 获取发布文件信息配置能力
NET_DVR_MANUAL_CURRICULUM_CONTROL_CAP = 6443 # 获取手动课程录像的能力
NET_DVR_GET_STATISTIC_DATA_LIST = 6444 # 获取统计数据列表

NET_DVR_GET_DEVICE_LAN_ENCODE = 6501 # 获取设备的语言编码
NET_DVR_GET_GBT28181_SERVICE_CFG = 6503 # 获取GB28181服务器参数
NET_DVR_SET_GBT28181_SERVICE_CFG = 6504 # 设置GB28181服务器参数
NET_DVR_GET_GBT28181_SERVICE_CAPABILITIES = 6505 # 获取GB28181服务器能力

NET_DVR_GET_CLOUD_URL = 6506 # 获取云存储URL
NET_DVR_GET_CLOUD_URL_CAP = 6507 # 获取云存储URL-能力集
NET_DVR_GET_CLOUD_CFG = 6508 # 获取云存储配置参数
NET_DVR_SET_CLOUD_CFG = 6509 # 设置云存储配置参数
NET_DVR_GET_CLOUD_CFG_CAP = 6510 # 获取云存储配置-能力集
NET_DVR_GET_CLOUD_UPLOADSTRATEGY = 6511 # 获取云存储上传策略
NET_DVR_SET_CLOUD_UPLOADSTRATEGY = 6512 # 设置云存储上传策略
NET_DVR_GET_CLOUDSTORAGE_UPLOADSTRATEGY_CAP = 6513 # 云存储上传策略配置-能力集

NET_DVR_GET_VIDEO_IMAGE_DB_CFG = 6601 # 获取视图库信息
NET_DVR_SET_VIDEO_IMAGE_DB_CFG = 6602 # 设置视图库信息
NET_DVR_GET_VIDEO_IMAGE_DB_CFG_CAP = 6603 # 获取视图库相关能力
NET_DVR_GET_FILE_INFO_BY_ID = 6604 # 根据文件ID获取视图库中文件信息
NET_DVR_QUERY_FILE_INFO_CAP = 6605 # 根据文件名查询文件信息能力
NET_DVR_DEL_FILE_FROM_DB = 6606 # 从视图库中删除文件
NET_DVR_GET_VIDEO_IMAGE_DB_CAP = 6607 # 获取视图库总能力

NET_DVR_GET_FIGURE = 6610 # 获取缩略图

NET_DVR_SYNC_IPC_PASSWD = 6621 # 同步IPC密码与NVR一致
NET_DVR_GET_VEHICLE_BLACKLST_SCHEDULE = 6622 # 获取黑名单布防时间配置
NET_DVR_SET_VEHICLE_BLACKLST_SCHEDULE = 6623 # 设置黑名单布防时间配置

NET_DVR_GET_VEHICLE_WHITELST_SCHEDULE = 6624 # 获取白名单布防时间配置
NET_DVR_SET_VEHICLE_WHITELST_SCHEDULE = 6625 # 设置白名单布防时间配置

NET_DVR_GET_VEHICLE_BLACKLIST_EVENT_TRIGGER = 6626 # 获取黑名单布防联动配置
NET_DVR_SET_VEHICLE_BLACKLIST_EVENT_TRIGGER = 6627 # 设置黑名单布防联动配置

NET_DVR_GET_VEHICLE_WHITELIST_EVENT_TRIGGER = 6628 # 获取白名单布防联动配置
NET_DVR_SET_VEHICLE_WHITELIST_EVENT_TRIGGER = 6629 # 设置白名单布防联动配置

NET_DVR_GET_TRAFFIC_CAP = 6630 # 获取抓拍相关能力集
NET_DVR_GET_VEHICLE_ALLLIST_EVENT_TRIGGER = 6631 # 获取全部车辆检测布防联动配置
NET_DVR_SET_VEHICLE_ALLLIST_EVENT_TRIGGER = 6632 # 设置全部车辆检测布防联动配置
NET_DVR_GET_VEHICLE_OTHERLIST_EVENT_TRIGGER = 6633 # 获取其他单布防联动配置
NET_DVR_SET_VEHICLE_OTHERLIST_EVENT_TRIGGER = 6634 # 设置其他单布防联动配置

NET_DVR_GET_STORAGEDETECTION_EVENT_TRIGGER = 6635 # 获取存储健康检测联动配置
NET_DVR_SET_STORAGEDETECTION_EVENT_TRIGGER = 6636 # 设置存储健康检测联动配置
NET_DVR_GET_STORAGEDETECTION_SCHEDULE_CAPABILITIES = 6637 # 获取存储健康检测布防时间能力
NET_DVR_GET_STORAGEDETECTION_SCHEDULE = 6638 # 获取存储健康布防时间配置
NET_DVR_SET_STORAGEDETECTION_SCHEDULE = 6639 # 设置存储健康布防时间配置
NET_DVR_GET_STORAGEDETECTION_STATE = 6640 # 获取存储健康状态

NET_DVR_GET_STORAGEDETECTION_RWLOCK = 6646 # 获取存储侦测的读写锁配置
NET_DVR_GET_STORAGEDETECTION_RWLOCK_CAPABILITIES = 6647 # 获取存储侦测的读写锁配置能力
NET_DVR_SET_STORAGEDETECTION_RWLOCK = 6648 # 设置存储侦测的读写锁配置
NET_DVR_GET_PTZTRACKSTATUS = 6649 # 获取球机联动跟踪状态

NET_DVR_SET_STORAGEDETECTION_UNLOCK = 6653 # 设置存储侦测的解锁配置
NET_DVR_GET_STORAGEDETECTION_UNLOCK_CAPABILITIES = 6654 # 获取存储侦测的解锁配置能力

NET_DVR_SET_SHIPSDETECTION_CFG = 6655 # 设置船只检测参数配置
NET_DVR_GET_SHIPSDETECTION_CFG = 6656 # 获取船只检测参数配置
NET_DVR_GET_SHIPSDETECTION_CAPABILITIES = 6657 # 获取船只检测参数配置能力
NET_DVR_GET_SHIPSDETECTION_COUNT = 6658 # 获取船只计数信息
NET_DVR_SHIPSCOUNT_DELETE_CTRL = 6659 # 清空船只计数信息

NET_DVR_GET_BAREDATAOVERLAY_CAPABILITIES = 6660 # 获取裸数据叠加能力
NET_DVR_SET_BAREDATAOVERLAY_CFG = 6661 # 设置裸数据叠加
NET_DVR_GET_BAREDATAOVERLAY_CFG = 6662 # 获取裸数据叠加
NET_DVR_GET_SHIPSDETECTION_SCHEDULE = 6663 # 获取船只检测布防时间配置
NET_DVR_SET_SHIPSDETECTION_SCHEDULE = 6664 # 设置船只检测布防时间配置
NET_DVR_GET_SHIPSDETECTION_EVENT_TRIGGER = 6665 # 获取船只检测联动配置
NET_DVR_SET_SHIPSDETECTION_EVENT_TRIGGER = 6666 # 设置船只检测联动配置
NET_DVR_GET_SHIPSDETECTION_SCHEDULE_CAPABILITIES = 6667 # 获取船只检测布防时间能力

NET_DVR_FIRE_FOCUSZOOM_CTRL = 6670 # 火点可见光镜头聚焦变倍

NET_DVR_GET_FIREDETECTION_SCHEDULE_CAPABILITIES = 6671 # 获取火点检测布防时间能力
NET_DVR_GET_FIREDETECTION_SCHEDULE = 6672 # 获取火点检测布防时间配置
NET_DVR_SET_FIREDETECTION_SCHEDULE = 6673 # 设置火点检测布防时间配置
NET_DVR_GET_MANUALRANGING_CAPABILITIES = 6675 # 获取手动测距配置能力
NET_DVR_SET_MANUALRANGING = 6677 # 设置手动测距参数
NET_DVR_GET_MANUALDEICING_CAPABILITIES = 6678 # 获取手动除冰配置能力
NET_DVR_SET_MANUALDEICING = 6679 # 设置手动除冰
NET_DVR_GET_MANUALDEICING = 6680 # 获取手动除冰

NET_DVR_GET_THERMALPOWER_CAPABILITIES = 6689 # 获取相机电源配置能力
NET_DVR_GET_THERMALPOWER = 6690 # 获取相机电源配置参数
NET_DVR_SET_THERMALPOWER = 6691 # 设置相机电源配置参数
NET_DVR_GET_PTZABSOLUTEEX_CAPABILITIES = 6695 # 获取高精度PTZ绝对位置配置扩展能力
NET_DVR_GET_PTZABSOLUTEEX = 6696 # 获取高精度PTZ绝对位置配置扩展
NET_DVR_SET_PTZABSOLUTEEX = 6697 # 设置高精度PTZ绝对位置配置扩展

NET_DVR_GET_CRUISE_CAPABILITIES = 6698 # 获取设备巡航模式配置能力
NET_DVR_GET_CRUISE_INFO = 6699 # 获取设备巡航模式
NET_DVR_GET_TEMP_HUMI_CAPABILITIES = 6700 # 温湿度实时能力获取
NET_DVR_GET_TEMP_HUMI_INFO = 6701 # 温湿度实时获取

NET_DVR_GET_MANUALTHERM_INFO = 6706 # 手动测温实时获取
NET_DVR_GET_MANUALTHERM_CAPABILITIES = 6707 # 获取手动测温实时数据能力
NET_DVR_SET_MANUALTHERM = 6708 # 设置手动测温数据设置

# DVR96000
NET_DVR_GET_ACCESSORY_CARD_INFO_CAPABILITIES = 6709 # 获取配件板信息能力
NET_DVR_GET_ACCESSORY_CARD_INFO = 6710 # 获取配件板信息

NET_DVR_GET_THERMINTELL_CAPABILITIES = 6711 # 获取热成像智能互斥能力
NET_DVR_GET_THERMINTELL = 6712 # 获取热成像智能互斥配置参数
NET_DVR_SET_THERMINTELL = 6713 # 设置热成像智能互斥配置参数
NET_GET_CRUISEPOINT_V50 = 6714 # 获取巡航路径配置扩展
NET_DVR_GET_MANUALTHERM_BASIC_CAPABILITIES = 6715 # 获取手动测温基本参数配置能力
NET_DVR_SET_MANUALTHERM_BASICPARAM = 6716 # 设置手动测温基本参数
NET_DVR_GET_MANUALTHERM_BASICPARAM = 6717 # 获取手动测温基本参数

NET_DVR_GET_FIRESHIELDMASK_CAPABILITIES = 6718 # 获取火点区域屏蔽能力

NET_DVR_GET_HIDDEN_INFORMATION_CAPABILITIES = 6720 # 隐藏信息配置能力
NET_DVR_GET_HIDDEN_INFORMATION = 6721 # 获取隐藏信息参数
NET_DVR_SET_HIDDEN_INFORMATION = 6722 # 设置隐藏信息参数

NET_DVR_SET_FIRESHIELDMASK_CFG = 6723 # 设置火点区域屏蔽参数
NET_DVR_GET_FIRESHIELDMASK_CFG = 6724 # 获取火点区域屏蔽参数

NET_DVR_GET_SMOKESHIELDMASK_CAPABILITIES = 6725 # 获取烟雾区域屏蔽能力
NET_DVR_SET_SMOKESHIELDMASK_CFG = 6726 # 设置烟雾区域屏蔽参数
NET_DVR_GET_SMOKESHIELDMASK_CFG = 6727 # 获取烟雾区域屏蔽参数

NET_DVR_GET_AREASCAN_CAPABILITIES = 6728 # 获取区域扫描能力
NET_DVR_GET_AREASCAN_CFG = 6730 # 获取区域扫描参数

NET_DVR_DEL_AREASCAN_CFG = 6731 # 扫描区域删除
NET_DVR_AREASCAN_INIT_CTRL = 6732 # 进入区域扫描设置
NET_DVR_AREASCAN_CONFIRM_CTRL = 6733 # 保存区域扫描设置
NET_DVR_AREASCAN_STOP_CTRL = 6734 # 停止区域扫描设置
NET_DVR_SAVE_SCANZOOM_CTRL = 6735 # 设置扫描倍率；保存当前光学倍率为扫描倍率
NET_DVR_GET_SCANZOOM_CTRL = 6736 # 获取扫描倍率；将预览界面中的光学倍率返回到当前扫描倍率。
NET_DVR_DEL_FIRESHIELDMASK_CTRL = 6737 # 删除火点屏蔽区域
NET_DVR_DEL_SMOKESHIELDMASK_CTRL = 6738 # 删除烟雾屏蔽区域

NET_DVR_GET_DENSEFOG_EVENT_TRIGGER = 6740 # 获取大雾检测联动配置
NET_DVR_SET_DENSEFOG_EVENT_TRIGGER = 6741 # 设置大雾检测联动配置
NET_DVR_SET_DENSEFOGDETECTION_CFG = 6742 # 设置大雾检测参数配置
NET_DVR_GET_DENSEFOGDETECTION_CFG = 6743 # 获取大雾检测参数配置
NET_DVR_GET_DENSEFOGDETECTION_CAPABILITIES = 6744 # 获取大雾检测参数配置能力

NET_DVR_GET_THERMOMETRY_SCHEDULE_CAPABILITIES = 6750 # 获取测温检测布防时间能力
NET_DVR_GET_THERMOMETRY_SCHEDULE = 6751 # 获取测温检测布防时间配置
NET_DVR_SET_THERMOMETRY_SCHEDULE = 6752 # 设置测温检测布防时间配置
NET_DVR_GET_TEMPERTURE_SCHEDULE_CAPABILITIES = 6753 # 获取温差布防时间能力
NET_DVR_GET_TEMPERTURE_SCHEDULE = 6754 # 获取温差布防时间配置
NET_DVR_SET_TEMPERTURE_SCHEDULE = 6755 # 设置温差布防时间配置
NET_DVR_GET_SEARCH_LOG_CAPABILITIES = 6756 # 日志类型支持能力
NET_DVR_GET_VEHICLEFLOW = 6758 # 获取车流量数据
NET_DVR_GET_IPADDR_FILTERCFG_V50 = 6759 # 获取IP地址过滤参数扩展
NET_DVR_SET_IPADDR_FILTERCFG_V50 = 6760 # 设置IP地址过滤参数扩展
NET_DVR_GET_TEMPHUMSENSOR_CAPABILITIES = 6761 # 获取温湿度传感器的能力
NET_DVR_GET_TEMPHUMSENSOR = 6762 # 获取温湿度传感器配置协议
NET_DVR_SET_TEMPHUMSENSOR = 6763 # 设置温湿度传感器配置协议

NET_DVR_GET_THERMOMETRY_MODE_CAPABILITIES = 6764 # 获取测温模式能力
NET_DVR_GET_THERMOMETRY_MODE = 6765 # 获取测温模式参数
NET_DVR_SET_THERMOMETRY_MODE = 6766 # 设置测温模式参数

NET_DVR_GET_THERMAL_PIP_CAPABILITIES = 6767 # 获取热成像画中画配置能力
NET_DVR_GET_THERMAL_PIP = 6768 # 获取热成像画中画配置参数
NET_DVR_SET_THERMAL_PIP = 6769 # 设置热成像画中画配置参数
NET_DVR_GET_THERMAL_INTELRULEDISPLAY_CAPABILITIES = 6770 # 获取热成像智能规则显示能力
NET_DVR_GET_THERMAL_INTELRULE_DISPLAY = 6771 # 获取热成像智能规则显示参数
NET_DVR_SET_THERMAL_INTELRULE_DISPLAY = 6772 # 设置热成像智能规则显示参数
NET_DVR_GET_THERMAL_ALGVERSION = 6773 # 获取热成像相关算法库版本
NET_DVR_GET_CURRENT_LOCK_CAPABILITIES = 6774 # 获取电流锁定配置能力
NET_DVR_GET_CURRENT_LOCK = 6775 # 获取电流锁定配置参数
NET_DVR_SET_CURRENT_LOCK = 6776 # 设置电流锁定配置参数

NET_DVR_DEL_MANUALTHERM_RULE = 6778 # 删除手动测温规则

NET_DVR_GET_UPGRADE_INFO = 6779 # 获取升级信息

NET_DVR_SWITCH_TRANSFER = 7000

NET_DVR_GET_MB_POWERCTRLPARA = 8000 # 获取启动控制参数
NET_DVR_SET_MB_POWERCTRLPARA = 8001 # 设置启动控制参数
NET_DVR_GET_AUTOBACKUPPARA = 8002 # 获取自动备份参数
NET_DVR_SET_AUTOBACKUPPARA = 8003 # 设置自动备份参数
NET_DVR_GET_MB_GPSPARA = 8004 # 获取GPS参数
NET_DVR_SET_MB_GPSPARA = 8005 # 设置GPS参数
NET_DVR_GET_MB_SENSORINPARA = 8006 # 获取SENSOR参数
NET_DVR_SET_MB_SENSORINPARA = 8007 # 设置SENSOR参数
NET_DVR_GET_GSENSORPARA = 8008 # 获取GSENSOR参数
NET_DVR_SET_GSENSORPARA = 8009 # 设置GSENSOR参数
NET_DVR_GET_MB_DOWNLOADSVRPARA = 8010 # 获取下载服务器参数
NET_DVR_SET_MB_DOWNLOADSVRPARA = 8011 # 设置下载服务器参数
NET_DVR_GET_PLATERECOG_PARA = 8012 # 获取车牌识别参数
NET_DVR_SET_PLATERECOG_PARA = 8013 # 设置车牌识别参数
NET_DVR_GET_ENFORCESYS_PARA = 8014 # 获取车辆稽查参数
NET_DVR_SET_ENFORCESYS_PARA = 8015 # 设置车辆稽查参数
NET_DVR_GET_GPS_DATA = 8016 # 获取GPS数据
NET_DVR_GET_ANALOG_ALARMINCFG = 8017 # 获取模拟报警输入参数
NET_DVR_SET_ANALOG_ALARMINCFG = 8018 # 设置模拟报警输入参数

NET_DVR_GET_SYSTEM_CAPABILITIES = 8100 # 获取设备的系统能力
NET_DVR_GET_EAGLEEYE_CAPABILITIES = 8101 # 获取设备鹰眼能力
NET_DVR_GET_SLAVECAMERA_CALIB_V51 = 8102 # 获取从摄像机标定配置V51
NET_DVR_SET_SLAVECAMERA_CALIB_V51 = 8103 # 设置从摄像机标定配置V51
NET_DVR_SET_GOTOSCENE = 8105 # 设置主摄像机转向指定的场景ID

# I、K、E系列NVR产品升级
NET_DVR_GET_PTZ_NOTIFICATION = 8201 # 获取多通道事件联动PTZ
NET_DVR_SET_PTZ_NOTIFICATION = 8202 # 设置多通道事件联动PTZ
# 电视墙
NET_DVR_MATRIX_WALL_SET = 9001 # 设置电视墙中屏幕参数
NET_DVR_MATRIX_WALL_GET = 9002 # 获取电视墙中屏幕参数
NET_DVR_WALLWIN_GET = 9003 # 电视墙中获取窗口参数
NET_DVR_WALLWIN_SET = 9004 # 电视墙中设置窗口参数
NET_DVR_WALLWINPARAM_SET = 9005 # 设置电视墙窗口相关参数
NET_DVR_WALLWINPARAM_GET = 9006 # 获取电视墙窗口相关参数
NET_DVR_WALLSCENEPARAM_GET = 9007 # 设置场景模式参数
NET_DVR_WALLSCENEPARAM_SET = 9008 # 获取场景模式参数
NET_DVR_MATRIX_GETWINSTATUS = 9009 # 获取窗口解码状态
NET_DVR_GET_WINASSOCIATEDDEVINFO = 9010 # 电视墙中获取对应资源信息
NET_DVR_WALLOUTPUT_GET = 9011 # 电视墙中获取显示输出参数
NET_DVR_WALLOUTPUT_SET = 9012 # 电视墙中设置显示输出参数
NET_DVR_GET_UNITEDMATRIXSYSTEM = 9013 # 电视墙中获取对应资源
NET_DVR_GET_WALL_CFG = 9014 # 获取电视墙全局参数
NET_DVR_SET_WALL_CFG = 9015 # 设置电视墙全局参数
NET_DVR_CLOSE_ALL_WND = 9016 # 关闭所有窗口
NET_DVR_SWITCH_WIN_TOP = 9017 # 窗口置顶
NET_DVR_SWITCH_WIN_BOTTOM = 9018 # 窗口置底

NET_DVR_CLOSE_ALL_WND_V41 = 9019 # 电视墙关闭所有窗口v41（有多个电视墙）
NET_DVR_GET_WALL_WINDOW_V41 = 9020 # 获取电视墙中的窗口v41
NET_DVR_SET_WALL_WINDOW_V41 = 9021 # 设置电视墙中的窗口v41
NET_DVR_GET_CURRENT_SCENE_V41 = 9022 # 获取当前电视墙中正在使用的场景v41
NET_DVR_GET_WALL_SCENE_PARAM_V41 = 9023 # 获取当前电视墙中正在使用的场景v41
NET_DVR_SET_WALL_SCENE_PARAM_V41 = 9024 # 设置当前电视墙中正在使用的场景v41
NET_DVR_GET_MATRIX_LOGO_CFG = 9025 # 获取logo参数
NET_DVR_SET_MATRIX_LOGO_CFG = 9026 # 设置logo参数
NET_DVR_GET_WIN_LOGO_CFG = 9027 # 获取窗口logo参数
NET_DVR_SET_WIN_LOGO_CFG = 9028 # 设置窗口logo参数
NET_DVR_DELETE_LOGO = 9029 # 删除logo
NET_DVR_SET_DISPLAY_EFFECT_CFG = 9030 # 设置显示输出效果参数v41
NET_DVR_GET_DISPLAY_EFFECT_CFG = 9031 # 获取显示输出效果参数v41
NET_DVR_DEC_PLAY_REMOTE_FILE = 9032 # 解码播放远程文件
NET_DVR_DEC_PLAY_REMOTE_FILE_V50 = 9314 # 解码播放远程文件V50
NET_DVR_GET_WIN_ZOOM_STATUS = 9033 # 获取窗口电子放大状态
NET_DVR_GET_ALL_MATRIX_LOGOCFG = 9034 # 获取所有logo参数

# LCD拼接屏
NET_DVR_SIMULATE_REMOTE_CONTROL = 9035 # 模拟遥控按键 2013-09-05
NET_DVR_SET_SCREEN_SIGNAL_CFG = 9036 # 设置屏幕信号源参数
NET_DVR_GET_SCREEN_SIGNAL_CFG = 9037 # 获取屏幕信号源参数
NET_DVR_SET_SCREEN_SPLICE_CFG = 9038 # 设置屏幕拼接
NET_DVR_GET_SCREEN_SPLICE_CFG = 9039 # 获取屏幕拼接
NET_DVR_GET_SCREEN_FAN_WORK_MODE = 9040 # 获取风扇工作方式
NET_DVR_SET_SCREEN_FAN_WORK_MODE = 9041 # 设置风扇工作方式
NET_DVR_SHOW_SCREEN_WORK_STATUS = 9044 # 显示屏幕状态
NET_DVR_GET_VGA_CFG = 9045 # 获取VGA信号配置
NET_DVR_SET_VGA_CFG = 9046 # 设置VGA信号配置
NET_DVR_GET_SCREEN_MENU_CFG = 9048 # 获取屏幕菜单配置
NET_DVR_SET_SCREEN_MENU_CFG = 9049 # 设置屏幕菜单配置
NET_DVR_SET_SCREEN_DISPLAY_CFG = 9050 # 设置显示参数 2013-08-28
NET_DVR_GET_SCREEN_DISPLAY_CFG = 9051 # 获取显示参数 2013-08-28

NET_DVR_SET_FUSION_CFG = 9052 # 设置图像融合参数
NET_DVR_GET_FUSION_CFG = 9053 # 获取图像融合参数

NET_DVR_SET_PIP_CFG = 9060 # 设置画中画参数
NET_DVR_GET_PIP_CFG = 9061 # 获取画中画参数
NET_DVR_SET_DEFOG_LCD = 9073 # 设置透雾参数
NET_DVR_GET_DEFOG_LCD = 9074 # 获取透雾参数
NET_DVR_SHOW_IP = 9075 # 显示IP
NET_DVR_SCREEN_MAINTENANCE_WALL = 9076 # 屏幕维墙
NET_DVR_SET_SCREEN_POS = 9077 # 设置屏幕位置参数
NET_DVR_GET_SCREEN_POS = 9078 # 获取屏幕位置参数

# LCD拼接屏V1.2
NET_DVR_SCREEN_INDEX_SET = 9079 # 屏幕索引相关参数设置
NET_DVR_SCREEN_INDEX_GET = 9080 # 屏幕索引相关参数获取
NET_DVR_SCREEN_SPLICE_SET = 9081 # 设置屏幕拼接参数
NET_DVR_SCREEN_SPLICE_GET = 9082 # 获取屏幕拼接参数
NET_DVR_SET_SCREEN_PARAM = 9083 # 设置屏幕相关参数
NET_DVR_GET_SCREEN_PARAM = 9084 # 获取屏幕相关参数
NET_DVR_SET_SWITCH_CFG = 9085 # 设置定时开关机参数
NET_DVR_GET_SWITCH_CFG = 9086 # 获取定时开关机参数
NET_DVR_SET_POWERON_DELAY_CFG = 9087 # 设置延时开机参数
NET_DVR_GET_POWERON_DELAY_CFG = 9088 # 获取延时开机参数
NET_DVR_SET_SCREEN_POSITION = 9089 # 设置屏幕位置参数
NET_DVR_GET_SCREEN_POSITION = 9090 # 获取屏幕位置参数
NET_DVR_SCREEN_SCENE_CONTROL = 9091 # 屏幕场景控制
NET_DVR_GET_CURRENT_SCREEN_SCENE = 9092 # 获取当前屏幕场景号
NET_DVR_GET_SCREEN_SCENE_PARAM = 9093 # 获取屏幕场景模式参数
NET_DVR_SET_SCREEN_SCENE_PARAM = 9094 # 设置屏幕场景模式参数
NET_DVR_GET_EXTERNAL_MATRIX_RELATION = 9095 # 获取外接矩阵输入输出关联关系
NET_DVR_GET_LCD_AUDIO_CFG = 9096 # 获取LCD屏幕音频参数
NET_DVR_SET_LCD_AUDIO_CFG = 9097 # 设置LCD屏幕音频参数
NET_DVR_GET_LCD_WORK_STATE = 9098 # 获取LCD屏幕工作状态
NET_DVR_GET_BOOT_LOGO_CFG = 9099 # 获取LCD屏幕开机logo显示参数
NET_DVR_SET_BOOT_LOGO_CFG = 9100 # 设置LCD屏幕开机logo显示参数

NET_DVR_GET_STREAM_DST_COMPRESSIONINFO = 9101 # 获取目标压缩参数
NET_DVR_SET_STREAM_DST_COMPRESSIONINFO = 9102 # 设置目标压缩参数
NET_DVR_GET_STREAM_TRANS_STATUS = 9103 # 获取流状态
NET_DVR_GET_DEVICE_TRANS_STATUS = 9104 # 获取设备转码状态
NET_DVR_GET_ALLSTREAM_SRC_INFO = 9105 # 获取所有流信息
NET_DVR_GET_BIG_SCREEN_AUDIO = 9106 # 获取大屏音频信息
NET_DVR_SET_BIG_SCREEN_AUDIO = 9107 # 设置大屏音频信息
NET_DVR_GET_DEV_WORK_MODE = 9108 # 获取转码设备工作模式
NET_DVR_SET_DEV_WORK_MODE = 9109 # 设置转码设备工作模式
NET_DVR_APPLY_TRANS_CHAN = 9110 # 按流ID申请转码通道
NET_DVR_GET_DISPCHAN_CFG = 9111 # 批量获取显示通道参数
NET_DVR_SET_DISPCHAN_CFG = 9112 # 批量设置显示通道参数

NET_DVR_GET_DEC_CHAN_STATUS = 9113 # 获取解码通道解码状态
NET_DVR_GET_DISP_CHAN_STATUS = 9114 # 获取显示通道状态
NET_DVR_GET_ALARMIN_STATUS = 9115 # 获取报警输入状态
NET_DVR_GET_ALARMOUT_STATUS = 9116 # 获取报警输出状态
NET_DVR_GET_AUDIO_CHAN_STATUS = 9117 # 获取语音对讲状态

NET_DVR_GET_VIDEO_AUDIOIN_CFG = 9118 # 获取视频的音频输入参数
NET_DVR_SET_VIDEO_AUDIOIN_CFG = 9119 # 设置视频的音频输入参数

NET_DVR_SET_BASEMAP_CFG = 9120 # 设置底图参数
NET_DVR_GET_BASEMAP_CFG = 9121 # 获取底图参数
NET_DVR_GET_VIRTUAL_SCREEN_CFG = 9122 # 获取超高清输入子系统参数
NET_DVR_SET_VIRTUAL_SCREEN_CFG = 9123 # 设置超高清输入子系统参数
NET_DVR_GET_BASEMAP_WIN_CFG = 9124 # 获取底图窗口参数
NET_DVR_SET_BASEMAP_WIN_CFG = 9125 # 设置底图窗口参数
NET_DVR_DELETE_PICTURE = 9126 # 删除底图
NET_DVR_GET_BASEMAP_PIC_INFO = 9127 # 获取底图图片信息
NET_DVR_SET_BASEMAP_WIN_CFG_V40 = 9128 # 设置底图窗口参数V40
NET_DVR_GET_BASEMAP_WIN_CFG_V40 = 9129 # 获取底图窗口参数V40

NET_DVR_GET_DEC_VCA_CFG = 9130 # 获取解码器智能报警参数
NET_DVR_SET_DEC_VCA_CFG = 9131 # 设置解码器智能报警参数

NET_DVR_SET_VS_INPUT_CHAN_INIT_ALL = 9132 # 初始化虚拟屏子板的所有输入通道
NET_DVR_GET_VS_INPUT_CHAN_INIT_ALL = 9133 # 获取虚拟屏子板的所有输入通道的初始化参数
NET_DVR_GET_VS_INPUT_CHAN_INIT = 9134 # 获取虚拟屏输入通道的初始化参数
NET_DVR_GET_VS_INPUT_CHAN_CFG = 9135 # 获取虚拟屏输入通道配置参数

NET_DVR_GET_TERMINAL_CONFERENCE_STATUS = 9136 # 获取终端会议状态
NET_DVR_GET_TERMINAL_INPUT_CFG_CAP = 9137 # 获取终端输入参数能力
NET_DVR_GET_TERMINAL_INPUT_CFG = 9138 # 获取终端视频会议输入参数
NET_DVR_SET_TERMINAL_INPUT_CFG = 9139 # 设置终端视频会议输入参数

NET_DVR_GET_CONFERENCE_REGION_CAP = 9140 # 获取终端会议区域能力
NET_DVR_GET_CONFERENCE_REGION = 9141 # 获取终端会议区域参数
NET_DVR_SET_CONFERENCE_REGION = 9142 # 设置终端会议区域参数
NET_DVR_GET_TERMINAL_CALL_CFG_CAP = 9143 # 获取终端呼叫配置能力
NET_DVR_GET_TERMINAL_CALL_CFG = 9144 # 获取终端呼叫参数
NET_DVR_SET_TERMINAL_CALL_CFG = 9145 # 设置终端呼叫参数
NET_DVR_GET_TERMINAL_CTRL_CAP = 9146 # 获取终端呼叫控制能力
NET_DVR_TERMINAL_CTRL = 9147 # 终端呼叫控制
NET_DVR_GET_CALL_QUERY_CAP = 9148 # 获取会议查找能力
NET_DVR_GET_CALLINFO_BY_COND = 9149 # 按条件查询呼叫记录

NET_DVR_SET_FUSION_SCALE = 9150 # 设置图像融合规模
NET_DVR_GET_FUSION_SCALE = 9151 # 获取图像融合规模

NET_DVR_GET_VCS_CAP = 9152 # 获取MCU能力集


NET_DVR_GET_TERMINAL_GK_CFG_CAP = 9153 # 获取终端注册GK能力
NET_DVR_GET_TERMINAL_GK_CFG = 9154 # 获取终端注册GK参数
NET_DVR_SET_TERMINAL_GK_CFG = 9155 # 设置终端注册GK参数
NET_DVR_GET_MCU_CONFERENCESEARCH_CAP = 9156 # 获取MCU设备的能力
NET_DVR_SET_VS_INPUT_CHAN_CFG = 9157 # 设置虚拟屏输入通道配置参数
NET_DVR_GET_VS_NETSRC_CFG = 9158 # 设置虚拟屏网络源参数
NET_DVR_SET_VS_NETSRC_CFG = 9159 # 设置虚拟屏网络源参数

NET_DVR_GET_LLDP_CFG = 9160 # 获取LLDP参数
NET_DVR_SET_LLDP_CFG = 9161 # 设置LLDP参数
NET_DVR_GET_LLDP_CAP = 9162 # 获取LLDP能力集
NET_DVR_GET_FIBER_CONVERT_BASIC_INFO = 9163 # 获取光纤收发器基本信息
NET_DVR_GET_FIBER_CONVERT_WORK_STATE = 9164 # 获取光纤收发器工作状
NET_DVR_GET_FIBER_CONVERT_TOPOLOGY = 9165 # 获取光纤收发器拓扑信息
NET_DVR_GET_FC_PORT_REMARKS = 9166 # 获取光纤收发器端口注释参数
NET_DVR_SET_FC_PORT_REMARKS = 9167 # 设置光纤收发器端口注释参数
NET_DVR_GET_PORT_REMARKS_CAP = 9168 # 获取光纤收发器端口注释能力集

NET_DVR_GET_MCU_CONFERENCECONTROL_CAP = 9169 # 获取会议控制能力
NET_DVR_GET_MCU_TERMINALCONTROL_CAP = 9170 # 获取终端控制能力
NET_DVR_GET_MCU_TERIMINALGROUP_CAP = 9171 # 获取终端分组能力
NET_DVR_GET_MCU_TERMINAL_CAP = 9174 # 获取终端管理能力
NET_DVR_GET_MCU_CONFERENCE_CAP = 9175 # 获取会议能力
NET_DVR_GET_MCU_GK_CFG_CAP = 9176 # 获取MCUGK配置能力
NET_DVR_GET_MCU_GK_SERVER_CAP = 9177 # 获取MCUGK服务能力

NET_DVR_GET_EDID_CFG_FILE_INFO = 9178 # 获取EDID配置文件信息
NET_DVR_GET_EDID_CFG_FILE_INFO_LIST = 9179 # 获取所有EDID配置文件信息
NET_DVR_SET_EDID_CFG_FILE_INFO = 9180 # 设置EDID配置文件信息
NET_DVR_DEL_EDID_CFG_FILE_INFO = 9181 # 删除EDID配置文件信息（包括文件）
NET_DVR_GET_EDID_CFG_FILE_INFO_CAP = 9182 # EDID配置文件信息能力集

NET_DVR_GET_SUBWND_DECODE_OSD = 9183 # 获取子窗口解码OSD信息
NET_DVR_GET_SUBWND_DECODE_OSD_ALL = 9184 # 获取所有子窗口解码OSD信息
NET_DVR_SET_SUBWND_DECODE_OSD = 9185 # 设置子窗口解码OSD信息
NET_DVR_GET_SUBWND_DECODE_OSD_CAP = 9186 # 获取子窗口解码OSD信息能力集
NET_DVR_GET_DECODE_CHANNEL_OSD = 9187 # 获取解码通道OSD信息
NET_DVR_SET_DECODE_CHANNEL_OSD = 9188 # 设置解码通道OSD信息


NET_DVR_GET_OUTPUT_PIC_INFO = 9200 # 获取输出口图片参数
NET_DVR_SET_OUTPUT_PIC_INFO = 9201 # 设置输出口图片参数
NET_DVR_GET_OUTPUT_PIC_WIN_CFG = 9202 # 获取输出口图片窗口参数
NET_DVR_SET_OUTPUT_PIC_WIN_CFG = 9203 # 设置输出口图片窗口参数
NET_DVR_GET_OUTPUT_ALL_PIC_WIN_CFG = 9204 # 获取输出口所有图片窗口参数
NET_DVR_DELETE_OUPUT_PIC = 9205 # 删除输出口图片
NET_DVR_GET_OUTPUT_OSD_CFG = 9206 # 获取输出口OSD参数
NET_DVR_SET_OUTPUT_OSD_CFG = 9207 # 设置输出口OSD参数
NET_DVR_GET_OUTPUT_ALL_OSD_CFG = 9208 # 获取输出口所有OSD参数
NET_DVR_GET_CHAN_RELATION = 9209 # 获取编码通道关联资源参数
NET_DVR_SET_CHAN_RELATION = 9210 # 设置编码通道关联资源参数
NET_DVR_GET_ALL_CHAN_RELATION = 9211 # 获取所有编码通道关联资源参数
NET_DVR_GET_NS_RING_CFG = 9212 # 获取光纤板环网配置
NET_DVR_SET_NS_RING_CFG = 9213 # 设置光纤板环网配置
NET_DVR_GET_NS_RING_STATUS = 9214 # 获取光纤板环网状态
NET_DVR_GET_OPTICAL_PORT_INFO = 9220 # 获取光口信息
NET_DVR_SET_OPTICAL_PORT_INFO = 9221 # 设置光口信息
NET_DVR_GET_OPTICAL_CHAN_RELATE_CFG = 9222 # 获取编码通道关联光口输入源参数
NET_DVR_SET_OPTICAL_CHAN_RELATE_CFG = 9223 # 设置编码通道关联光口输入源参数
NET_DVR_GET_WIN_ROAM_SWITCH_CFG = 9224 # 获取解码器窗口漫游开关参数
NET_DVR_SET_WIN_ROAM_SWITCH_CFG = 9225 # 设置解码器窗口漫游开关参数
NET_DVR_START_SCREEN_CRTL = 9226 # 开始屏幕控制
NET_DVR_GET_SCREEN_FLIE_LIST = 9227 # 获取屏幕文件列表
NET_DVR_GET_SCREEN_FILEINFO = 9228 # 获取屏幕文件信息参数
NET_DVR_SET_SCREEN_FILEINFO = 9229 # 设置屏幕文件信息参数

# 小间距LED显示屏
NET_DVR_GET_LED_OUTPUT_CFG = 9230 # 获取发送卡输出参数
NET_DVR_SET_LED_OUTPUT_CFG = 9231 # 设置发送卡输出参数
NET_DVR_GET_LED_OUTPUT_PORT_CFG = 9232 # 获取LED发送卡输出端口参数
NET_DVR_SET_LED_OUTPUT_PORT_CFG = 9233 # 设置LED发送卡输出端口参数
NET_DVR_GET_LED_DISPLAY_AREA_CFG = 9234 # 获取LED发送卡显示区域
NET_DVR_SET_LED_DISPLAY_AREA_CFG = 9235 # 设置LED发送卡显示区域
NET_DVR_GET_LED_PORT_CFG = 9236 # 获取LED发送卡端口参数
NET_DVR_SET_LED_PORT_CFG = 9237 # 设置LED发送卡端口参数
NET_DVR_GET_LED_DISPLAY_CFG = 9238 # 获取LED发送卡显示参数
NET_DVR_SET_LED_DISPLAY_CFG = 9239 # 设置LED发送卡显示参数
NET_DVR_GET_ALL_LED_PORT_CFG = 9240 # 获取LED发送卡某个输出对应
NET_DVR_SAVE_LED_CONFIGURATION = 9241 # 参数固化
NET_DVR_GET_LED_TEST_SIGNAL_CFG = 9242 # 获取LED屏测试信号参数
NET_DVR_SET_LED_TEST_SIGNAL_CFG = 9243 # 设置LED屏测试信号参数
NET_DVR_GET_LED_NOSIGNAL_CFG = 9244 # 获取LED屏无信号显示模式参数
NET_DVR_SET_LED_NOSIGNAL_CFG = 9245 # 设置LED屏无信号显示模式参数
NET_DVR_GET_LED_INPUT_CFG = 9246 # 获取LED发送卡输入参数
NET_DVR_SET_LED_INPUT_CFG = 9247 # 设置LED发送卡输入参数
NET_DVR_GET_LED_RECV_GAMMA_CFG = 9248 # 获取接收卡GAMMA表参数
NET_DVR_SET_LED_RECV_GAMMA_CFG = 9249 # 设置接收卡GAMMA表参数
NET_DVR_GET_LED_RECV_CFG = 9250 # 获取接收卡基本参数
NET_DVR_SET_LED_RECV_CFG = 9251 # 设置接收卡基本参数
NET_DVR_GET_LED_RECV_ADVANCED_CFG = 9252 # 获取接收卡高级参数
NET_DVR_SET_LED_RECV_ADVANCED_CFG = 9253 # 设置接收卡高级参数
NET_DVR_GET_LED_SCREEN_DISPLAY_CFG = 9254 # 获取LED屏显示参数
NET_DVR_SET_LED_SCREEN_DISPLAY_CFG = 9255 # 设置LED屏显示参数
# 小间距LED显示屏

NET_DVR_GET_INSERTPLAY_PROGRESS = 9273 # 获取插播进度

NET_DVR_GET_SCREEN_CONFIG = 9260 # 获取屏幕服务器参数
NET_DVR_SET_SCREEN_CONFIG = 9261 # 设置屏幕服务器参数
NET_DVR_GET_SCREEN_CONFIG_CAP = 9262 # 获取屏幕服务器参数能力集

NET_DVR_GET_SCHEDULE_PUBLISH_PROGRESS = 9271 # 获取日程发布进度
NET_DVR_GET_PUBLISH_UPGRADE_PROGRESS = 9272 # 获取信息发布终端升级进度

NET_DVR_GET_INPUT_BOARD_CFG = 9281 # 获取输入板配置信息
NET_DVR_GET_INPUT_BOARD_CFG_LIST = 9282 # 获取输入板配置信息列表
NET_DVR_SET_INPUT_BOARD_CFG = 9283 # 设置输入板配置信息

NET_DVR_GET_INPUT_SOURCE_TEXT_CAP = 9284 # 获取输入源字符叠加能力
NET_DVR_GET_INPUT_SOURCE_TEXT_CFG = 9285 # 获取输入源字符叠加参数
NET_DVR_GET_INPUT_SOURCE_TEXT_CFG_LSIT = 9286 # 获取输入源字符叠加参数列表
NET_DVR_SET_INPUT_SOURCE_TEXT_CFG = 9287 # 设置输入源字符叠加参数
NET_DVR_SET_INPUT_SOURCE_TEXT_CFG_LIST = 9288 # 设置输入源字符叠加参数列表
NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CAP = 9289 # 获取输入源自定义分辨率能力
NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG = 9290 # 获取输入源自定义分辨率参数
NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG_LIST = 9291 # 获取输入源自定义分辨率列表
NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG = 9292 # 设置输入源自定义分辨率参数
NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG_LIST = 9293 # 设置输入源自定义分辨率参数
NET_DVR_GET_LED_AREA_INFO_LIST = 9295 # 获取LED区域列表

NET_DVR_GET_DISPINPUT_CFG = 9296 # 获取显示输入参数
NET_DVR_GET_DISPINPUT_CFG_LIST = 9297 # 获取所有显示输入参数
NET_DVR_SET_DISPINPUT_CFG = 9298 # 设置显示输入参数
NET_DVR_GET_DISPINPUT_CFG_CAP = 9299 # 获取显示输入参数能力集
NET_DVR_GET_CURRENT_VALID_PORT = 9300 # 获取当前有效的,可以连接的端口

NET_DVR_SET_ONLINE_UPGRADE = 9301 # 允许在线升级
NET_DVR_GET_ONLINEUPGRADE_PROGRESS = 9302 # 获取在线升级进度
NET_DVR_GET_FIRMWARECODE = 9303 # 获取识别码
NET_DVR_GET_ONLINEUPGRADE_SERVER = 9304 # 获取升级服务器状态
NET_DVR_GET_ONLINEUPGRADE_VERSION = 9305 # 获取新版本信息
NET_DVR_GET_RECOMMEN_VERSION = 9306 # 检测是否推荐升级到此版本
NET_DVR_GET_ONLINEUPGRADE_ABILITY = 9309 # 获取在线升级能力集

NET_DVR_GET_FIBER_CONVERT_BASIC_INFO_V50 = 9310 # 获取远端网管收发器基本信息V50
NET_DVR_GET_FIBER_CONVERT_WORK_STATE_V50 = 9311 # 获取远端网管收发器工作状态

NET_SDK_LED_SCREEN_CHECK = 9312 # LED屏幕校正
NET_SDK_GENERATE_OUTPUT_CONTROL	 = 9315 # 通用扩展输出口模块控制
NET_SDK_GET_MATRIX_STATUS_V51 = 9313 # 获取视频综合平台状态

# DS-19D2000-S V2.0升级 报警联动配置参数命令码
NET_DVR_GET_ALARM_LINKAGE_CFG = 9316 # 获取动环报警联动配置参数
NET_DVR_SET_ALARM_LINKAGE_CFG = 9317 # 设置动环报警联动配置参数


NET_DVR_GET_RS485_WORK_MODE = 10001 # 获取RS485串口工作模式
NET_DVR_SET_RS485_WORK_MODE = 10002 # 设置RS485串口工作模式
NET_DVR_GET_SPLITTER_TRANS_CHAN_CFG = 10003 # 获取码分器透明通道参数
NET_DVR_SET_SPLITTER_TRANS_CHAN_CFG = 10004 # 设置码分器透明通道参数

NET_DVR_GET_RS485_PROTOCOL_VERSION = 10301 # 获取RS485协议库版本信息
NET_DVR_ALARMHOST_REGISTER_DETECTOR = 10302 # 自动注册探测器

NET_DVR_GET_SIP_CFG = 11001 # IP可视化机获取SIP参数
NET_DVR_SET_SIP_CFG = 11002 # IP可视化机设置SIP参数
NET_DVR_GET_IP_VIEW_DEVCFG = 11003 # 获取IP对讲分机配置
NET_DVR_SET_IP_VIEW_DEVCFG = 11004 # 设置IP对讲分机配置
NET_DVR_GET_IP_VIEW_AUDIO_CFG = 11005 # 获取IP对讲分机音频参数
NET_DVR_SET_IP_VIEW_AUDIO_CFG = 11006 # 设置IP对讲分机音频参数
NET_DVR_GET_IP_VIEW_CALL_CFG = 11007 # 获取IP对讲分机呼叫参数
NET_DVR_SET_IP_VIEW_CALL_CFG = 11008 # 设置IP对讲分机呼叫参数
NET_DVR_GET_AUDIO_LIMIT_ALARM_CFG = 11009 # 获取声音超限配置参数
NET_DVR_SET_AUDIO_LIMIT_ALARM_CFG = 11010 # 设置声音超限配置参数
NET_DVR_GET_BUTTON_DOWN_ALARM_CFG = 11011 # 获取按钮按下告警配置参数
NET_DVR_SET_BUTTON_DOWN_ALARM_CFG = 11012 # 设置按钮按下告警配置参数

NET_DVR_GET_ISCSI_CFG = 11070 #  获取ISCSI存储配置协议
NET_DVR_SET_ISCSI_CFG = 11071 #  获取ISCSI存储配置协议

NET_DVR_GET_SECURITYMODE = 12004 # 获取当前安全模式
# 2013-11-21 获取设备当前的温度和湿度
NET_DVR_GET_TEMP_HUMI = 12005

# 2014-02-15 民用IPC自动化测试项目
NET_DVR_SET_ALARMSOUNDMODE = 12006 # 设置报警声音模式
NET_DVR_GET_ALARMSOUNDMODE = 12007 # 获取报警声音模式

NET_DVR_SET_IPDEVICE_ACTIVATED = 13000 # 通过NVR激活前端设备
NET_DVR_GET_DIGITAL_CHAN_SECURITY_STATUS = 13001 # 获取数字通道对应设备安全状态
NET_DVR_GET_ACTIVATE_IPC_ABILITY = 13003 # 获取NVR激活IPC能力集


# 楼宇可视对讲机
NET_DVR_GET_VIDEO_INTERCOM_DEVICEID_CFG = 16001 # 获取可视对讲设备编号
NET_DVR_SET_VIDEO_INTERCOM_DEVICEID_CFG = 16002 # 设置可视对讲设备编号
NET_DVR_SET_PRIVILEGE_PASSWORD = 16003 # 设置权限密码配置信息
NET_DVR_GET_OPERATION_TIME_CFG = 16004 # 获取操作时间配置
NET_DVR_SET_OPERATION_TIME_CFG = 16005 # 设置操作时间配置
NET_DVR_GET_VIDEO_INTERCOM_RELATEDEV_CFG = 16006 # 获取关联网络设备参数
NET_DVR_SET_VIDEO_INTERCOM_RELATEDEV_CFG = 16007 # 设置关联网络设备参数
NET_DVR_REMOTECONTROL_NOTICE_DATA = 16008 # 公告信息下发
NET_DVR_REMOTECONTROL_GATEWAY = 16009 # 远程开锁
NET_DVR_REMOTECONTROL_OPERATION_AUTH = 16010 # 操作权限验证

NET_DVR_GET_VIDEO_INTERCOM_IOIN_CFG = 16016 # 获取IO输入参数
NET_DVR_SET_VIDEO_INTERCOM_IOIN_CFG = 16017 # 设置IO输入参数
NET_DVR_GET_VIDEO_INTERCOM_IOOUT_CFG = 16018 # 获取IO输出参数
NET_DVR_SET_VIDEO_INTERCOM_IOOUT_CFG = 16019 # 设置IO输出参数
NET_DVR_GET_ELEVATORCONTROL_CFG = 16020 # 获取梯控器参数
NET_DVR_SET_ELEVATORCONTROL_CFG = 16021 # 设置梯控器参数
NET_DVR_GET_VIDEOINTERCOM_STREAM = 16022 # 获取可视对讲流通道参数
NET_DVR_SET_VIDEOINTERCOM_STREAM = 16023 # 设置可视对讲流通道参数
NET_DVR_GET_WDR_CFG = 16024 # 获取宽动态参数配置
NET_DVR_SET_WDR_CFG = 16025 # 设置宽动态参数配置
NET_DVR_GET_VIS_DEVINFO = 16026 # 获取可设备编号信息
NET_DVR_GET_VIS_REGISTER_INFO = 16027 # 获取可设备注册的设备信息
NET_DVR_GET_ELEVATORCONTROL_CFG_V40 = 16028 # 获取梯控器参数-扩展
NET_DVR_SET_ELEVATORCONTROL_CFG_V40 = 16029 # 设置梯控器参数-扩展
NET_DVR_GET_CALL_ROOM_CFG = 16030 # 获取按键呼叫住户配置
NET_DVR_SET_CALL_ROOM_CFG = 16031 # 设置按键呼叫住户配置
NET_DVR_VIDEO_CALL_SIGNAL_PROCESS = 16032 # 可视话对讲信令处理
NET_DVR_GET_CALLER_INFO = 16033 # 获取主叫长号信息
NET_DVR_GET_CALL_STATUS = 16034 # 获取通话状态
NET_DVR_GET_SERVER_DEVICE_INFO = 16035 # 获取设备列表
NET_DVR_SET_CALL_SIGNAL = 16036 # 可视对讲手机端发送信令
NET_DVR_GET_VIDEO_INTERCOM_ALARM_CFG = 16037 # 获取可视对讲报警事件参数
NET_DVR_SET_VIDEO_INTERCOM_ALARM_CFG = 16038 # 设置可视对讲报警事件参数
NET_DVR_GET_RING_LIST = 16039 # 查询铃音参数列表

NET_DVR_GET_ROOM_CUSTOM_CFG = 16040 # 房间自定义获取
NET_DVR_SET_ROOM_CUSTOM_CFG = 16041 # 房间自定义设置
NET_DVR_GET_ELEVATORCONTROL_CFG_V50 = 16042 # 获取梯控器参数V50
NET_DVR_SET_ELEVATORCONTROL_CFG_V50 = 16043 # 设置梯控器参数V50
NET_DVR_GET_SIP_CFG_V50 = 16044 # 获取SIP参数V50
NET_DVR_SET_SIP_CFG_V50 = 16045 # 设置SIP参数V50
NET_DVR_GET_NOTICE_VIDEO_DATA = 16050 # 公告视频获取

# 楼宇可视对讲机

NET_DVR_DEBUGINFO_START = 18000 # 网传设备调试信息启动命令
NET_DVR_AUTO_TEST_START = 18001 # 自动测试长连接获取

NET_DVR_GET_SELFCHECK_RESULT = 20000 # 获取设备自检结果
NET_DVR_SET_TEST_COMMAND = 20001 # 设置测试控制命令
NET_DVR_SET_TEST_DEVMODULE = 20002 # 设置测试硬件模块控制命令
NET_DVR_GET_TEST_DEVMODULE = 20003 # 获取测试硬件模块控制命令

NET_DVR_SET_AUTOFOCUS_TEST = 20004 # 保存自动对焦参数 2013-10-26
NET_DVR_CHECK_USER_STATUS = 20005 # 检测用户是否在线
NET_DVR_GET_TEST_COMMAND = 20010 # 获取测试控制命令
NET_DVR_GET_DIAL_SWITCH_CFG = 20200 # 获取拨码开关信息
NET_DVR_SET_AGING_TRICK_SCAN = 20201 # 设置老化前后工具参数
NET_DVR_GET_ECCENTRIC_CORRECT_STATE = 20202 # 获取获取偏心校正状态

NET_DVR_GET_THERMOMETRYRULE_TEMPERATURE_INFO = 23001 # 手动获取测温规则温度信息

NET_DVR_T1_TEST_CMD = 131073 # 当测试命令来用，通过数据区域的文本内容区分具体做什么.数据长度不得大于1024
# 数据区格式为：<T1TestCmd type="0"/># 恢复设备默认参数并关机。

#  美分定制菜单输出模式外部命令
NET_DVR_GET_MEMU_OUTPUT_MODE = 155649 #  获取菜单输出模式
NET_DVR_SET_MEMU_OUTPUT_MODE = 155650 #  设置菜单输出模式

# DS9000新增命令(_V30)

NET_DVR_GET_DEV_LOGIN_RET_INFO = 16777200 # 设备登陆返回参数


NET_DVR_GET_TEST_VERSION_HEAD = 268435441 # 获取测试版本头
NET_DVR_SET_TEST_VERSION_HEAD = 268435442 # 设置测试版本头
NET_DVR_GET_TEST_VERSION_HEAD_V1 = 268435443 # 获取测试版本头-第二版
NET_DVR_SET_TEST_VERSION_HEAD_V1 = 268435444 # 设置测试版本头-第二版
NET_DVR_GET_TEST_VERSION_HEAD_V2 = 268435445 # 获取测试版本头-第三版
NET_DVR_SET_TEST_VERSION_HEAD_V2 = 268435446 # 设置测试版本头-第三版

NET_DVR_GET_TEST_VERSION_HEAD_ONLY_0 = 268435447 # 获取测试版本头,当前仅有一个版本
NET_DVR_SET_TEST_VERSION_HEAD_ONLY_0 = 268435448 # 设置测试版本头,当前仅有一个版本


MAX_LOCAL_ADDR_LEN = 96 # SOCKS最大本地网段个数
MAX_COUNTRY_NAME_LEN = 4 # 国家简写名称长度

# DVR日志

#  报警
# 主类型
MAJOR_ALARM = 0x1
# 次类型
MINOR_ALARM_IN = 0x1 #  报警输入
MINOR_ALARM_OUT = 0x2 #  报警输出
MINOR_MOTDET_START = 0x3 #  移动侦测报警开始
MINOR_MOTDET_STOP = 0x4 #  移动侦测报警结束
MINOR_HIDE_ALARM_START = 0x5 #  遮挡报警开始
MINOR_HIDE_ALARM_STOP = 0x6 #  遮挡报警结束
MINOR_VCA_ALARM_START = 0x7 # 智能报警开始
MINOR_VCA_ALARM_STOP = 0x8 # 智能报警停止
MINOR_ITS_ALARM_START = 0x09 #  交通事件报警开始
MINOR_ITS_ALARM_STOP = 0x0A #  交通事件报警结束
# 2010-11-10 网络报警日志
MINOR_NETALARM_START = 0x0b # 网络报警开始
MINOR_NETALARM_STOP = 0x0c # 网络报警结束
# 2010-12-16 报警板日志，与"MINOR_ALARM_IN"配对使用
MINOR_NETALARM_RESUME = 0x0d # 网络报警恢复
# 2012-4-5 IPC PIR、无线、呼救报警
MINOR_WIRELESS_ALARM_START = 0x0e #  无线报警开始
MINOR_WIRELESS_ALARM_STOP = 0x0f #  无线报警结束
MINOR_PIR_ALARM_START = 0x10 #  人体感应报警开始
MINOR_PIR_ALARM_STOP = 0x11 #  人体感应报警结束
MINOR_CALLHELP_ALARM_START = 0x12 #  呼救报警开始
MINOR_CALLHELP_ALARM_STOP = 0x13 #  呼救报警结束
MINOR_IPCHANNEL_ALARMIN_START = 0x14 # 数字通道报警输入开始：PCNVR在接收到数字通道的MINOR_ALARM_IN产生“数字通道报警输入开始”，10s，再收不到MINOR_ALARM_IN，产生“数字通道报警输入结束”
MINOR_IPCHANNEL_ALARMIN_STOP = 0x15 # 数字通道报警输入开始：同上
MINOR_DETECTFACE_ALARM_START = 0x16 #  人脸侦测报警开始
MINOR_DETECTFACE_ALARM_STOP = 0x17 #  人脸侦测报警结束
MINOR_VQD_ALARM_START = 0x18 # VQD报警
MINOR_VQD_ALARM_STOP = 0x19 # VQD报警结束
MINOR_VCA_SECNECHANGE_DETECTION = 0x1a # 场景侦测报警 2013-07-16

MINOR_SMART_REGION_EXITING_BEGIN = 0x1b # 离开区域侦测开始
MINOR_SMART_REGION_EXITING_END = 0x1c # 离开区域侦测结束
MINOR_SMART_LOITERING_BEGIN = 0x1d # 徘徊侦测开始
MINOR_SMART_LOITERING_END = 0x1e # 徘徊侦测结束

MINOR_VCA_ALARM_LINE_DETECTION_BEGIN = 0x20
MINOR_VCA_ALARM_LINE_DETECTION_END = 0x21
MINOR_VCA_ALARM_INTRUDE_BEGIN = 0x22 # 区域侦测开始
MINOR_VCA_ALARM_INTRUDE_END = 0x23 # 区域侦测结束
MINOR_VCA_ALARM_AUDIOINPUT = 0x24 # 音频异常输入
MINOR_VCA_ALARM_AUDIOABNORMAL = 0x25 # 声强突变
MINOR_VCA_DEFOCUS_DETECTION_BEGIN = 0x26 # 虚焦侦测开始
MINOR_VCA_DEFOCUS_DETECTION_END = 0x27 # 虚焦侦测结束

# 民用NVR
MINOR_EXT_ALARM = 0x28 # IPC外部报警
MINOR_VCA_FACE_ALARM_BEGIN = 0x29 # 人脸侦测开始
MINOR_SMART_REGION_ENTRANCE_BEGIN = 0x2a # 进入区域侦测开始
MINOR_SMART_REGION_ENTRANCE_END = 0x2b # 进入区域侦测结束
MINOR_SMART_PEOPLE_GATHERING_BEGIN = 0x2c # 人员聚集侦测开始
MINOR_SMART_PEOPLE_GATHERING_END = 0x2d # 人员聚集侦测结束
MINOR_SMART_FAST_MOVING_BEGIN = 0x2e # 快速运动侦测开始
MINOR_SMART_FAST_MOVING_END = 0x2f # 快速运动侦测结束

MINOR_VCA_FACE_ALARM_END = 0x30 # 人脸侦测结束
MINOR_VCA_SCENE_CHANGE_ALARM_BEGIN = 0x31 # 场景变更侦测开始
MINOR_VCA_SCENE_CHANGE_ALARM_END = 0x32 # 场景变更侦测结束
MINOR_VCA_ALARM_AUDIOINPUT_BEGIN = 0x33 # 音频异常输入开始
MINOR_VCA_ALARM_AUDIOINPUT_END = 0x34 # 音频异常输入结束
MINOR_VCA_ALARM_AUDIOABNORMAL_BEGIN = 0x35 # 声强突变侦测开始
MINOR_VCA_ALARM_AUDIOABNORMAL_END = 0x36 # 声强突变侦测结束

MINOR_VCA_LECTURE_DETECTION_BEGIN = 0x37 # 授课侦测开始报警
MINOR_VCA_LECTURE_DETECTION_END = 0x38 # 授课侦测结束报警
MINOR_VCA_ALARM_AUDIOSTEEPDROP = 0x39 # 声强陡降 2014-03-21
MINOR_VCA_ANSWER_DETECTION_BEGIN = 0x3a # 回答问题侦测开始报警
MINOR_VCA_ANSWER_DETECTION_END = 0x3b # 回答问题侦测结束报警

MINOR_SMART_PARKING_BEGIN = 0x3c # 停车侦测开始
MINOR_SMART_PARKING_END = 0x3d # 停车侦测结束
MINOR_SMART_UNATTENDED_BAGGAGE_BEGIN = 0x3e # 物品遗留侦测开始
MINOR_SMART_UNATTENDED_BAGGAGE_END = 0x3f # 物品遗留侦测结束
MINOR_SMART_OBJECT_REMOVAL_BEGIN = 0x40 # 物品拿取侦测开始
MINOR_SMART_OBJECT_REMOVAL_END = 0x41 # 物品拿取侦测结束
MINOR_SMART_VEHICLE_ALARM_START = 0x46 # 车牌检测开始
MINOR_SMART_VEHICLE_ALARM_STOP = 0x47 # 车牌检测结束
MINOR_THERMAL_FIREDETECTION = 0x48 # 热成像火点检测侦测开始
MINOR_THERMAL_FIREDETECTION_END = 0x49 # 热成像火点检测侦测结束
MINOR_SMART_VANDALPROOF_BEGIN = 0x50 # 防破坏检测开始
MINOR_SMART_VANDALPROOF_END = 0x51 # 防破坏检测结束

MINOR_FACESNAP_MATCH_ALARM_START = 0x55 # 人脸比对报警开始
MINOR_FACESNAP_MATCH_ALARM_STOP = 0x56 # 人脸比对报警结束
MINOR_WHITELIST_FACESNAP_MATCH_ALARM_START = 0x57 # 白名单人脸比对（陌生人）报警开始
MINOR_WHITELIST_FACESNAP_MATCH_ALARM_STOP = 0x58 # 白名单人脸比对（陌生人）报警结束

MINOR_THERMAL_SHIPSDETECTION = 0x5a # 热成像船只检测侦测
MINOR_THERMAL_THERMOMETRY_EARLYWARNING_BEGIN = 0x5b # 热成像测温预警开始
MINOR_THERMAL_THERMOMETRY_EARLYWARNING_END = 0x5c # 热成像测温预警结束
MINOR_THERMAL_THERMOMETRY_ALARM_BEGIN = 0x5d # 热成像测温报警开始
MINOR_THERMAL_THERMOMETRY_ALARM_END = 0x5e # 热成像测温报警结束
MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_BEGIN = 0x5f # 热成像温差报警开始
MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_END = 0x60 # 热成像温差报警结束
MINOR_FACE_THERMOMETRY_ALARM = 0x63 # 人脸测温报警
MINOR_SMART_DENSEFOGDETECTION_BEGIN = 0x6e # 大雾侦测开始
MINOR_SMART_DENSEFOGDETECTION_END = 0x6f # 大雾侦测结束
MINOR_RUNNING_ALARM = 0x70 # 奔跑检测
MINOR_RETENTION_ALARM = 0x71 # 滞留检测
MINOR_SAFETY_HELMET_ALARM_START = 0x72 # 未佩戴安全帽检测报警开始
MINOR_SAFETY_HELMET_ALARM_STOP = 0x73 # 未佩戴安全帽检测报警结束
MINOR_HFPD_ALARM_START = 0x74 # 高频人员检测报警开始
MINOR_HFPD_ALARM_STOP = 0x75 # 高频人员检测报警结束
MINOR_MIXED_TARGET_ALARM_START = 0x76 # 混合目标检测报警开始
MINOR_MIXED_TARGET_ALARM_STOP = 0x77 # 混合目标检测报警结束
MINOR_VCA_PLAY_CELLPHONE_ALARM_BEGIN = 0x78 # 玩手机检测报警开始
MINOR_VCA_PLAY_CELLPHONE_ALARM_END = 0x79 # 玩手机检测报警结束
MINOR_VCA_GET_UP_ALARM_BEGIN = 0x80 # 起床检测报警开始
MINOR_VCA_GET_UP_ALARM_END = 0x81 # 起床检测报警结束
MINOR_VCA_ADV_REACH_HEIGHT_ALARM_BEGIN = 0x82 # 折线攀高报警开始
MINOR_VCA_ADV_REACH_HEIGHT_ALARM_END = 0x83 # 折线攀高报警结束
MINOR_VCA_TOILET_TARRY_ALARM_BEGIN = 0x84 # 如厕超时报警开始
MINOR_VCA_TOILET_TARRY_ALARM_END = 0x85 # 如厕超时报警结束
MINOR_HUMAN_RECOGNITION_ALARM_BEGIN = 0x86 # 人体识别报警开始
MINOR_HUMAN_RECOGNITION_ALARM_END = 0x87 # 人体识别报警结束
MINOR_STUDENTS_STOODUP_ALARM_BEGIN = 0x88 # 学生起立报警开始
MINOR_STUDENTS_STOODUP_ALARM_END = 0x89 # 学生起立报警结束
MINOR_FRAMES_PEOPLE_COUNTING_ALARM = 0x8a # 区域人数统计报警
MINOR_FACE_SNAP_ALARM_BEGIN = 0x8b # 人脸抓拍报警开始
MINOR_FACE_SNAP_ALARM_END = 0x8c # 人脸抓拍报警结束
MINOR_TEACHER_BEHAVIOR_DETECT_ALARM_BEGIN = 0x8d # 教师行为检测报警开始
MINOR_TEACHER_BEHAVIOR_DETECT_ALARM_END = 0x8e # 教师行为检测报警结束
MINOR_PERIMETER_CAPTURE_ALARM_BEGIN = 0x8f # 周界抓拍报警开始
MINOR_PERIMETER_CAPTURE_ALARM_END = 0x90 # 周界抓拍报警结束
MINOR_UNREGISTERED_STREET_VENDOR_ALARM = 0x91 # 非法摆摊报警

MINOR_PERSON_QUEUE_TIME_ALARM_BEGIN = 0x92 # 排队时长检测报警开始
MINOR_PERSON_QUEUE_TIME_ALARM_END = 0x93 # 排队时长检测报警结束
MINOR_PERSON_QUEUE_COUNTING_ALARM_BEGIN = 0x94 # 排队人数检测报警开始
MINOR_PERSON_QUEUE_COUNTING_ALARM_END = 0x95 # 排队人数检测报警结束
MINOR_FACE_SNAP_MATCH_FAILURE_ALARM_START = 0x96 # 人脸比对失败报警开始
MINOR_FACE_SNAP_MATCH_FAILURE_ALARM_END = 0x97 # 人脸比对失败报警结束


MINOR_ACCESS_CONTROLLER_EVENT = 0x100 # 门禁主机事件
MINOR_VIDEO_INTERCOM_EVENT = 0x101 # 可视对讲设备事件
MINOR_GJD_EVENT = 0x102 # GJD报警主机事件
MINOR_LUMINITE_EVENT = 0x103 #  LUMINITE报警主机事件
MINOR_OPTEX_EVENT = 0x104 #  OPTEX报警主机事件
MINOR_CAMERA_DETECTOR_EVENT = 0x105 #  传感器事件
MINOR_SECURITY_CONTROL_PANEL_EVENT = 0x106 # 海康报警主机事件

MINOR_VCA_SPACE_CHANGE_START = 0x10c # 间距异常检测开始
MINOR_VCA_SPACE_CHANGE_STOP = 0x10d # 间距异常检测结束
MINOR_MANUAL_ALARM = 0x10e # 手动报警
MINOR_DETECTOR_ALARM = 0x10f # 探测器报警
MINOR_LINKAGE_ALARM = 0x110 # 联动报警
MINOR_VCA_SITUATION_ANALYSIS_START = 0x111 # 态势分析检测开始
MINOR_VCA_SITUATION_ANALYSIS_STOP = 0x112 # 态势分析检测结束
MINOR_FIRE_ALARM = 0x113 # 火警报警
MINOR_SUPERVISE_ALARM = 0x114 # 监管报警
MINOR_SHIELD_ALARM = 0x115 # 屏蔽报警
MINOR_ABNORMAL_ALARM = 0x116 # 故障报警
MINOR_RESIDUAL_CURRENT_ALARM = 0x117 # 剩余电流报警
MINOR_TEMPERATURE_ALARM = 0x118 # 温度报警
MINOR_ARC_ALARM = 0x119 # 电弧报警

MINOR_VCA_YARD_TARRY_ALARM_BEGIN = 0x11a # 放风场滞留报警开始
MINOR_VCA_YARD_TARRY_ALARM_END = 0x11b # 放风场滞留报警结束
MINOR_VCA_KEY_PERSON_GET_UP_ALARM_BEGIN = 0x11c # 重点人员起身报警开始
MINOR_VCA_KEY_PERSON_GET_UP_ALARM_END = 0x11d # 重点人员起身报警结束
MINOR_VCA_SIT_QUIETLY_ALARM_BEGIN = 0x11e # 静坐报警开始
MINOR_VCA_SIT_QUIETLY_ALARM_END = 0x11f # 静坐报警结束
MINOR_VCA_STAND_UP_ALARM_BEGIN = 0x120 # 站立报警开始
MINOR_VCA_STAND_UP_ALARM_END = 0x121 # 站立报警结束
MINOR_VCA_REACH_HIGHT_ALARM_BEGIN = 0x122 # 攀高报警开始
MINOR_VCA_REACH_HIGHT_ALARM_END = 0x123 # 攀高报警结束

MINOR_LFPD_ALARM_START = 0x124 # 低频人员检测报警开始
MINOR_LFPD_ALARM_STOP = 0x125 # 低频人员检测报警结束

MINOR_DREDGERDETECTION_ALARM = 0x126 #  挖沙船检测报警
MINOR_STUDENT_BEHAVIOR_ALARM_BEGIN = 0x127 # 课堂学生行为报警开始
MINOR_STUDENT_BEHAVIOR_ALARM_END = 0x128 # 课堂学生行为报警结束
MINOR_VCA_ALARM_VEHICLEMONITOR = 0x129 # 车辆布控报警(用于车辆布控第一次上来车辆检测（带车辆布控信息）的日志)
MINOR_WASTEGASDETECTION_ALARM = 0x130 #  废气排放监测事件上报
MINOR_GREYSCALE_ALARM = 0x131 #  灰度报警
MINOR_VIBRATION_DETECTION_ALARM_BEGIN = 0x132 # 振动侦测报警开始
MINOR_VIBRATION_DETECTION_ALARM_END = 0x133 # 振动侦测报警结束

# 0x400-0x1000 门禁报警
MINOR_ALARMIN_SHORT_CIRCUIT = 0x400 # 防区短路报警
MINOR_ALARMIN_BROKEN_CIRCUIT = 0x401 # 防区断路报警
MINOR_ALARMIN_EXCEPTION = 0x402 # 防区异常报警
MINOR_ALARMIN_RESUME = 0x403 # 防区报警恢复
MINOR_HOST_DESMANTLE_ALARM = 0x404 # 设备防拆报警
MINOR_HOST_DESMANTLE_RESUME = 0x405 # 设备防拆恢复
MINOR_CARD_READER_DESMANTLE_ALARM = 0x406 # 读卡器防拆报警
MINOR_CARD_READER_DESMANTLE_RESUME = 0x407 # 读卡器防拆恢复
MINOR_CASE_SENSOR_ALARM = 0x408 # 事件输入报警
MINOR_CASE_SENSOR_RESUME = 0x409 # 事件输入恢复
MINOR_STRESS_ALARM = 0x40a # 胁迫报警
MINOR_OFFLINE_ECENT_NEARLY_FULL = 0x40b # 离线事件满90%报警
MINOR_CARD_MAX_AUTHENTICATE_FAIL = 0x40c # 卡号认证失败超次报警
MINOR_SD_CARD_FULL = 0x40d # SD卡存储满报警
MINOR_LINKAGE_CAPTURE_PIC = 0x40e # 联动抓拍事件报警
MINOR_SECURITY_MODULE_DESMANTLE_ALARM = 0x40f # 门控安全模块防拆报警
MINOR_SECURITY_MODULE_DESMANTLE_RESUME = 0x410 # 门控安全模块防拆恢复

MINOR_POS_START_ALARM = 0x411 # POS开启
MINOR_POS_END_ALARM = 0x412 # POS结束
MINOR_FACE_IMAGE_QUALITY_LOW = 0x413 # 人脸图像画质低
MINOR_FINGE_RPRINT_QUALITY_LOW = 0x414 # 指纹图像画质低
MINOR_FIRE_IMPORT_SHORT_CIRCUIT = 0x415 # 消防输入短路报警
MINOR_FIRE_IMPORT_BROKEN_CIRCUIT = 0x416 # 消防输入断路报警
MINOR_FIRE_IMPORT_RESUME = 0x417 # 消防输入恢复
MINOR_FIRE_BUTTON_TRIGGER = 0x418 # 消防按钮触发
MINOR_FIRE_BUTTON_RESUME = 0x419 # 消防按钮恢复
MINOR_MAINTENANCE_BUTTON_TRIGGER = 0x41a # 维护按钮触发
MINOR_MAINTENANCE_BUTTON_RESUME = 0x41b # 维护按钮恢复
MINOR_EMERGENCY_BUTTON_TRIGGER = 0x41c # 紧急按钮触发
MINOR_EMERGENCY_BUTTON_RESUME = 0x41d # 紧急按钮恢复
MINOR_DISTRACT_CONTROLLER_ALARM = 0x41e # 分控器防拆报警
MINOR_DISTRACT_CONTROLLER_RESUME = 0x41f # 分控器防拆报警恢复

MINOR_PERSON_DENSITY_DETECTION_START = 0x420 # 人员密度超阈值报警开始
MINOR_PERSON_DENSITY_DETECTION_END = 0x421 # 人员密度超阈值报警结束

MINOR_CHANNEL_CONTROLLER_DESMANTLE_ALARM = 0x422 # 通道控制器防拆报警
MINOR_CHANNEL_CONTROLLER_DESMANTLE_RESUME = 0x423 # 通道控制器防拆报警恢复
MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM = 0x424 # 通道控制器消防输入报警
MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME = 0x425 # 通道控制器消防输入报警恢复

MINOR_HEART_RATE_ABNORMAL_BEGIN = 0x426 # 心率异常报警开始
MINOR_HEART_RATE_ABNORMAL_END = 0x427 # 心率异常报警结束
MINOR_BLOOD_OXYGEN_ABNORMAL_BEGIN = 0x428 # 血氧异常报警开始
MINOR_BLOOD_OXYGEN_ABNORMAL_END = 0x429 # 血氧异常报警结束
MINOR_SYSTOLIC_BLOOD_PRESSURE_ABNORMAL_BEGIN = 0x42a # 血压收缩压异常报警开始
MINOR_SYSTOLIC_BLOOD_PRESSURE_ABNORMAL_END = 0x42b # 血压收缩压异常报警结束
MINOR_DIASTOLIC_BLOOD_PRESSURE_ABNORMAL_BEGIN = 0x42c # 血压舒张压异常报警开始
MINOR_DIASTOLIC_BLOOD_PRESSURE_ABNORMAL_END = 0x42d # 血压舒张压异常报警结束
MINOR_VCA_LEAVE_POSITION_START = 0x42e # 离岗检测开始
MINOR_VCA_LEAVE_POSITION_STOP = 0x42f # 离岗检测结束
MINOR_VCA_STOOODUP_START = 0x430 # 起立检测开始
MINOR_VCA_STOOODUP_STOP = 0x431 # 起立检测结束
MINOR_VCA_PEOPLENUM_CHANGE_START = 0x434 # 人数变化开始
MINOR_VCA_PEOPLENUM_CHANGE_STOP = 0x435 # 人数变化结束
MINOR_VCA_RUNNING_START = 0x438 # 人员奔跑开始
MINOR_VCA_RUNNING_STOP = 0x439 # 人员奔跑结束
MINOR_VCA_VIOLENT_MOTION_START = 0x43a # 剧烈运动开始
MINOR_VCA_VIOLENT_MOTION_STOP = 0x43b # 剧烈运动结束
MINOR_VCA_FAIL_DOWN_START = 0x43c # 人员倒地开始
MINOR_VCA_FAIL_DOWN_STOP = 0x43d # 人员倒地结束
MINOR_VCA_RETENTION_START = 0x43e # 人员滞留开始
MINOR_VCA_RETENTION_STOP = 0x43f # 人员滞留结束

MINOR_PRINTER_OUT_OF_PAPER = 0x440 # 打印机缺纸报警
MINOR_LEGAL_EVENT_NEARLY_FULL = 0x442 # 离线合法事件满90%报警

MINOR_ALARM_CUSTOM1 = 0x900 # 门禁自定义报警1
MINOR_ALARM_CUSTOM2 = 0x901 # 门禁自定义报警2
MINOR_ALARM_CUSTOM3 = 0x902 # 门禁自定义报警3
MINOR_ALARM_CUSTOM4 = 0x903 # 门禁自定义报警4
MINOR_ALARM_CUSTOM5 = 0x904 # 门禁自定义报警5
MINOR_ALARM_CUSTOM6 = 0x905 # 门禁自定义报警6
MINOR_ALARM_CUSTOM7 = 0x906 # 门禁自定义报警7
MINOR_ALARM_CUSTOM8 = 0x907 # 门禁自定义报警8
MINOR_ALARM_CUSTOM9 = 0x908 # 门禁自定义报警9
MINOR_ALARM_CUSTOM10 = 0x909 # 门禁自定义报警10
MINOR_ALARM_CUSTOM11 = 0x90a # 门禁自定义报警11
MINOR_ALARM_CUSTOM12 = 0x90b # 门禁自定义报警12
MINOR_ALARM_CUSTOM13 = 0x90c # 门禁自定义报警13
MINOR_ALARM_CUSTOM14 = 0x90d # 门禁自定义报警14
MINOR_ALARM_CUSTOM15 = 0x90e # 门禁自定义报警15
MINOR_ALARM_CUSTOM16 = 0x90f # 门禁自定义报警16
MINOR_ALARM_CUSTOM17 = 0x910 # 门禁自定义报警17
MINOR_ALARM_CUSTOM18 = 0x911 # 门禁自定义报警18
MINOR_ALARM_CUSTOM19 = 0x912 # 门禁自定义报警19
MINOR_ALARM_CUSTOM20 = 0x913 # 门禁自定义报警20
MINOR_ALARM_CUSTOM21 = 0x914 # 门禁自定义报警21
MINOR_ALARM_CUSTOM22 = 0x915 # 门禁自定义报警22
MINOR_ALARM_CUSTOM23 = 0x916 # 门禁自定义报警23
MINOR_ALARM_CUSTOM24 = 0x917 # 门禁自定义报警24
MINOR_ALARM_CUSTOM25 = 0x918 # 门禁自定义报警25
MINOR_ALARM_CUSTOM26 = 0x919 # 门禁自定义报警26
MINOR_ALARM_CUSTOM27 = 0x91a # 门禁自定义报警27
MINOR_ALARM_CUSTOM28 = 0x91b # 门禁自定义报警28
MINOR_ALARM_CUSTOM29 = 0x91c # 门禁自定义报警29
MINOR_ALARM_CUSTOM30 = 0x91d # 门禁自定义报警30
MINOR_ALARM_CUSTOM31 = 0x91e # 门禁自定义报警31
MINOR_ALARM_CUSTOM32 = 0x91f # 门禁自定义报警32
MINOR_ALARM_CUSTOM33 = 0x920 # 门禁自定义报警33
MINOR_ALARM_CUSTOM34 = 0x921 # 门禁自定义报警34
MINOR_ALARM_CUSTOM35 = 0x922 # 门禁自定义报警35
MINOR_ALARM_CUSTOM36 = 0x923 # 门禁自定义报警36
MINOR_ALARM_CUSTOM37 = 0x924 # 门禁自定义报警37
MINOR_ALARM_CUSTOM38 = 0x925 # 门禁自定义报警38
MINOR_ALARM_CUSTOM39 = 0x926 # 门禁自定义报警39
MINOR_ALARM_CUSTOM40 = 0x927 # 门禁自定义报警40
MINOR_ALARM_CUSTOM41 = 0x928 # 门禁自定义报警41
MINOR_ALARM_CUSTOM42 = 0x929 # 门禁自定义报警42
MINOR_ALARM_CUSTOM43 = 0x92a # 门禁自定义报警43
MINOR_ALARM_CUSTOM44 = 0x92b # 门禁自定义报警44
MINOR_ALARM_CUSTOM45 = 0x92c # 门禁自定义报警45
MINOR_ALARM_CUSTOM46 = 0x92d # 门禁自定义报警46
MINOR_ALARM_CUSTOM47 = 0x92e # 门禁自定义报警47
MINOR_ALARM_CUSTOM48 = 0x92f # 门禁自定义报警48
MINOR_ALARM_CUSTOM49 = 0x930 # 门禁自定义报警49
MINOR_ALARM_CUSTOM50 = 0x931 # 门禁自定义报警50
MINOR_ALARM_CUSTOM51 = 0x932 # 门禁自定义报警51
MINOR_ALARM_CUSTOM52 = 0x933 # 门禁自定义报警52
MINOR_ALARM_CUSTOM53 = 0x934 # 门禁自定义报警53
MINOR_ALARM_CUSTOM54 = 0x935 # 门禁自定义报警54
MINOR_ALARM_CUSTOM55 = 0x936 # 门禁自定义报警55
MINOR_ALARM_CUSTOM56 = 0x937 # 门禁自定义报警56
MINOR_ALARM_CUSTOM57 = 0x938 # 门禁自定义报警57
MINOR_ALARM_CUSTOM58 = 0x939 # 门禁自定义报警58
MINOR_ALARM_CUSTOM59 = 0x93a # 门禁自定义报警59
MINOR_ALARM_CUSTOM60 = 0x93b # 门禁自定义报警60
MINOR_ALARM_CUSTOM61 = 0x93c # 门禁自定义报警61
MINOR_ALARM_CUSTOM62 = 0x93d # 门禁自定义报警62
MINOR_ALARM_CUSTOM63 = 0x93e # 门禁自定义报警63
MINOR_ALARM_CUSTOM64 = 0x93f # 门禁自定义报警64
MINOR_LOCK_HIJIACK_FINGER_ALARM = 0x950 # 智能锁防劫持指纹报警
MINOR_LOCK_HIJIACK_PASSWORD_ALARM = 0x951 # 智能锁防劫持密码报警
MINOR_LOCK_PRY_DOOR_ALARM = 0x952 # 智能锁撬门报警
MINOR_LOCK_LOCKED_ALARM = 0x953 # 智能锁锁定报警
MINOR_LOCK_BATTERLOW_ALARM = 0x954 # 智能锁低电压报警
MINOR_LOCK_BLACKLIST_DOOR_ALARM = 0x955 # 智能锁黑名单报警
MINOR_LOCK_OFFLINE_ALARM = 0x956 # 智能锁离线报警
MINOR_LOCK_UNCLOSED_ALARM = 0x957 # 智能锁虚掩报警
MINOR_LOCK_NO_HOME_ALARM = 0x958 # 智能锁用户未回家报警
MINOR_LOCK_MAGNETOMETER_ALARM = 0x959 # 门磁探测器报警
MINOR_LOCK_IR_DETECTOR_ALARM = 0x95a # 红外探测器报警
MINOR_LOCK_FP_LOCKED_ALARM = 0x95b # 指纹锁定报警
MINOR_LOCK_PASSWORD_LOCKED_ALARM = 0x95c # 密码锁定报警
MINOR_LOCK_HIJIACK_ALARM = 0x95d # 智能锁防劫持报警

# 2018-04-23 通用物联网关报警日志类型
MINOR_ALARMHOST_SHORT_CIRCUIT = 0x1001 # 短路报警
MINOR_ALARMHOST_BROKEN_CIRCUIT = 0x1002 # 断路报警
MINOR_ALARMHOST_ALARM_RESET = 0x1003 # 报警复位
MINOR_ALARMHOST_ALARM_NORMAL = 0x1004 # 报警恢复正常
MINOR_ALARMHOST_PASSWORD_ERROR = 0x1005 # 密码错误（连续3次输入密码错误）
MINOR_ALARMHOST_ID_CARD_ILLEGALLY = 0x1006 # 非法感应卡ID
MINOR_ALARMHOST_KEYPAD_REMOVE = 0x1007 # 键盘防拆
MINOR_ALARMHOST_KEYPAD_REMOVE_RESTORE = 0x1008 # 键盘防拆复位

MINOR_ALARMHOST_BELOW_ALARM_LIMIT1 = 0x1011 # 模拟量低于报警限1
MINOR_ALARMHOST_BELOW_ALARM_LIMIT2 = 0x1012 # 模拟量低于报警限2
MINOR_ALARMHOST_BELOW_ALARM_LIMIT3 = 0x1013 # 模拟量低于报警限3
MINOR_ALARMHOST_BELOW_ALARM_LIMIT4 = 0x1014 # 模拟量低于报警限4
MINOR_ALARMHOST_ABOVE_ALARM_LIMIT1 = 0x1015 # 模拟量高于报警限1
MINOR_ALARMHOST_ABOVE_ALARM_LIMIT2 = 0x1016 # 模拟量高于报警限2
MINOR_ALARMHOST_ABOVE_ALARM_LIMIT3 = 0x1017 # 模拟量高于报警限3
MINOR_ALARMHOST_ABOVE_ALARM_LIMIT4 = 0x1018 # 模拟量高于报警限4

MINOR_ALARMHOST_VIRTUAL_DEFENCE_BANDIT = 0x1021 # 软防区匪警
MINOR_ALARMHOST_VIRTUAL_DEFENCE_FIRE = 0x1022 # 软防区火警
MINOR_ALARMHOST_VIRTUAL_DEFENCE_URGENT = 0x1023 # 软防区紧急

MINOR_UPS_ALARM = 0x1028 # UPS报警
MINOR_ELECTRICITY_METER_ALARM = 0x1029 # 智能电表报警
MINOR_SWITCH_POWER_ALARM = 0x1030 # 开关电源报警
MINOR_GAS_DETECT_SYS_ALARM = 0x1031 # 气体检测系统报警
MINOR_TRANSFORMER_TEMPRATURE_ALARM = 0x1032 # 变电器温显表报警
MINOR_TEMP_HUMI_ALARM = 0x1033 # 温湿度传感器报警
MINOR_UPS_ALARM_RESTORE = 0x1034# UPS报警恢复
MINOR_ELECTRICITY_METER_ALARM_RESTORE = 0x1035 # 智能电表报警恢复
MINOR_SWITCH_POWER_ALARM_RESTORE = 0x1036 # 开关电源报警恢复
MINOR_GAS_DETECT_SYS_ALARM_RESTORE = 0x1037 # 气体检测系统报警恢复
MINOR_TRANSFORMER_TEMPRATURE_ALARM_RESTORE = 0x1038 # 变电器温显表报警恢复
MINOR_TEMP_HUMI_ALARM_RESTORE = 0x1039# 温湿度传感器报警恢复
MINOR_WATER_LEVEL_SENSOR_ALARM = 0x1040 # 水位传感器报警
MINOR_WATER_LEVEL_SENSOR_ALARM_RESTORE = 0x1041 # 水位传感器报警恢复
MINOR_DUST_NOISE_ALARM = 0x1042 # 扬尘噪声传感器报警
MINOR_DUST_NOISE_ALARM_RESTORE = 0x1043 # 扬尘噪声传感器报警恢复
MINOR_ENVIRONMENTAL_LOGGER_ALARM = 0x1044 # 环境采集仪报警
MINOR_ENVIRONMENTAL_LOGGER_ALARM_RESTORE = 0x1045 # 环境采集仪报警恢复

MINOR_TRIGGER_TAMPER = 0x1046 # 探测器防拆
MINOR_TRIGGER_TAMPER_RESTORE = 0x1047 # 探测器防拆恢复
MINOR_EMERGENCY_CALL_HELP_ALARM = 0x1048 # 紧急呼叫求助报警
MINOR_EMERGENCY_CALL_HELP_ALARM_RESTORE = 0x1049 # 紧急呼叫求助报警恢复
MINOR_CONSULTING_ALARM = 0x1050 # 业务咨询报警
MINOR_CONSULTING_ALARM_RESTORE = 0x1051 # 业务咨询报警恢复
MINOR_ALARMHOST_ZONE_MODULE_REMOVE = 0x1052 # 防区模块防拆
MINOR_ALARMHOST_ZONE_MODULE_RESET = 0x1053 # 防区模块防拆复位

MINOR_ALARMHOST_ALARM_WIND_SPEED_ALARM = 0x1054 # 风速传感器告警
MINOR_ALARMHOST_ALARM_WIND_SPEED_ALARM_RESTORE = 0x1055 # 风速传感器告警恢复
MINOR_ALARMHOST_ALARM_GENERATE_OUTPUT_ALARM = 0x1056 # 通用扩展输出模块告警
MINOR_ALARMHOST_ALARM_GENERATE_OUTPUT_RESTORE = 0x1057 # 通用扩展输出模块告警恢复
MINOR_ALARMHOST_ALARM_SOAK_ALARM = 0x1058 # 水浸传感器告警
MINOR_ALARMHOST_ALARM_SOAK_ALARM_RESTORE = 0x1059 # 水浸传感器告警恢复
MINOR_ALARMHOST_ALARM_SOLAR_POWER_ALARM = 0x1060 # 太阳能传感器告警
MINOR_ALARMHOST_ALARM_SOLAR_POWER_ALARM_RESTORE = 0x1061 # 太阳能传感器告警恢复
MINOR_ALARMHOST_ALARM_SF6_ALARM = 0x1062 # SF6报警主机告警
MINOR_ALARMHOST_ALARM_SF6_ALARM_RESTORE = 0x1063 # SF6报警主机告警恢复
MINOR_ALARMHOST_ALARM_WEIGHT_ALARM = 0x1064 # 称重仪告警
MINOR_ALARMHOST_ALARM_WEIGHT_ALARM_RESTORE = 0x1065 # 称重仪告警恢复
MINOR_ALARMHOST_ALARM_WEATHER_ALARM = 0x1066 # 气象采集系统告警
MINOR_ALARMHOST_ALARM_WEATHER_ALARM_RESTORE = 0x1067 # 气象采集系统告警恢复
MINOR_ALARMHOST_ALARM_FUEL_GAS_ALARM = 0x1068 # 燃气监测系统告警
MINOR_ALARMHOST_ALARM_FUEL_GAS_ALARM_RESTORE = 0x1069 # 燃气监测系统告警恢
MINOR_ALARMHOST_ALARM_FIRE_ALARM = 0x1070 # 火灾报警系统告警
MINOR_ALARMHOST_ALARM_FIRE_ALARM_RESTORE = 0x1071 # 火灾报警系统告警恢复
MINOR_ALARMHOST_WIRELESS_OUTPUT_MODULE_REMOVE = 0x1072 # 无线输出模块防拆
MINOR_ALARMHOST_WIRELESS_OUTPUT_MODULE_RESET = 0x1073 # 无线输出模块防拆复位
MINOR_ALARMHOST_WIRELESS_REPEATER_MODULE_REMOVE = 0x1074 # 无线中继器防拆

MINOR_ALARMHOST_WIRELESS_SIREN_MODULE_REMOVE = 0x1075 # 无线警号防拆
MINOR_ALARMHOST_WIRELESS_SIREN_MODULE_RESET = 0x1076 # 无线警号防拆复位

MINOR_RS485_DEV_ALARM = 0x1077 # RS485外接设备报警（针对设备类型未知的设备）
MINOR_RS485_DEV_RESTORE = 0x1078 # RS485外接设备报警恢复（针对设备类型未知的设备）
MINOR_ALARMHOST_ALARM_HOST_ALARM = 0x1079 # 消防主机报警
MINOR_ALARMHOST_ALARM_HOST_RESTORE = 0x107a # 消防主机报警恢复

MINOR_AIR_CONDITION_DEV_ALARM = 0x107b # 空调控制器报警
MINOR_AIR_CONDITION_DEV_RESTORE = 0x107c # 空调控制器报警恢复

MINOR_ALARMHOST_WIRELESS_REPEATER_MODULE_RESET = 0x107d # 无线中继器防拆复位

MINOR_ALARM_ELEVATOR_BREAKDOWN = 0x107e # 电梯故障
MINOR_WATER_PRESSURE_SENSOR_ALARM = 0x107f # 水压传感器报警
MINOR_FLOW_SENSOR_ALARM = 0x1080 # 流量传感器报警
MINOR_SENSOR_LINKAGE_ALARM = 0x1081 # 传感器联动报警
MINOR_SENSOR_LINKAGE_ALARM_RESTORE = 0x1082 # 传感器联动报警恢复

# LED报警次类型 0x1201 ~ 0x1300
MINOR_SYSTEM_CHECK_ALARM = 0x1201 # 系统检测报警

#  异常
# 主类型
MAJOR_EXCEPTION = 0x2
# 次类型
MINOR_SUBSYSTEM_ERROR = 0x0a #  子系统异常
MINOR_RAID_ERROR = 0x20 #  阵列异常
MINOR_VI_LOST = 0x21 #  视频信号丢失
MINOR_ILLEGAL_ACCESS = 0x22 #  非法访问
MINOR_HD_FULL = 0x23 #  硬盘满
MINOR_HD_ERROR = 0x24 #  硬盘错误
MINOR_DCD_LOST = 0x25 #  MODEM 掉线(保留不使用)
MINOR_IP_CONFLICT = 0x26 #  IP地址冲突
MINOR_NET_BROKEN = 0x27 #  网络断开
MINOR_REC_ERROR = 0x28 #  录像出错
MINOR_IPC_NO_LINK = 0x29 #  IPC连接异常
MINOR_VI_EXCEPTION = 0x2a #  视频输入异常(只针对模拟通道)
MINOR_IPC_IP_CONFLICT = 0x2b # ipc ip 地址 冲突
MINOR_SENCE_EXCEPTION = 0x2c #  场景异常

MINOR_PIC_REC_ERROR = 0x2d #  抓图出错--获取图片文件失败
MINOR_VI_MISMATCH = 0x2e #  视频制式不匹配
MINOR_RESOLUTION_MISMATCH = 0x2f # 前端/录像分辨率不匹配

# 2009-12-16 增加视频综合平台日志类型
MINOR_FANABNORMAL = 0x31 #  视频综合平台：风扇状态异常
MINOR_FANRESUME = 0x32 #  视频综合平台：风扇状态恢复正常
MINOR_SUBSYSTEM_ABNORMALREBOOT = 0x33 #  视频综合平台：6467异常重启
MINOR_MATRIX_STARTBUZZER = 0x34 #  视频综合平台：dm6467异常，启动蜂鸣器

# 2010-01-22 增加视频综合平台异常日志次类型
MINOR_NET_ABNORMAL = 0x35 # 网络状态异常
MINOR_MEM_ABNORMAL = 0x36 # 内存状态异常
MINOR_FILE_ABNORMAL = 0x37 # 文件状态异常
MINOR_PANEL_ABNORMAL = 0x38 # 前面板连接异常
MINOR_PANEL_RESUME = 0x39 # 前面板恢复正常
MINOR_RS485_DEVICE_ABNORMAL = 0x3a # RS485连接状态异常
MINOR_RS485_DEVICE_REVERT = 0x3b # RS485连接状态异常恢复

# 2012-2-18 增加大屏控制器异常日志次类型
MINOR_SCREEN_SUBSYSTEM_ABNORMALREBOOT = 0x3c # 子板异常启动
MINOR_SCREEN_SUBSYSTEM_ABNORMALINSERT = 0x3d # 子板插入
MINOR_SCREEN_SUBSYSTEM_ABNORMALPULLOUT = 0x3e # 子板拔出
MINOR_SCREEN_ABNARMALTEMPERATURE = 0x3f # 温度异常
# 2012-07-26 视频综合平台v2.1
MINOR_HIGH_TEMPERATURE_PROTECT = 0x40 # 子板过热保护

# Netra 2.2.2
MINOR_RECORD_OVERFLOW = 0x41 # 缓冲区溢出
MINOR_DSP_ABNORMAL = 0x42 # DSP异常

# Netra 3.0.0
MINOR_ANR_RECORD_FAIED = 0x43 # ANR录像失败
MINOR_SPARE_WORK_DEVICE_EXCEPT = 0x44 # 热备设备工作机异常
MINOR_START_IPC_MAS_FAILED = 0x45 # 开启IPC MAS失败
# 高性能 256路NVR
MINOR_IPCM_CRASH = 0x46 # IPCM异常重启
MINOR_POE_POWER_EXCEPTION = 0x47 # POE 供电异常
MINOR_UPLOAD_DATA_CS_EXCEPTION = 0x48 # 云存储数据上传失败/
MINOR_DIAL_EXCEPTION = 0x49 # 拨号异常
MINOR_DEV_EXCEPTION_OFFLINE = 0x50 # 设备异常下线
MINOR_UPGRADEFAIL = 0x51 # 远程升级设备失败
MINOR_AI_LOST = 0x52 #  音频信号丢失
MINOR_SYNC_IPC_PASSWD = 0x53 #  同步IPC密码异常
MINOR_EZVIZ_OFFLINE = 0x54 #  萤石下线异常
MINOR_VQD_ABNORMAL = 0x55 # VQD异常
MINOR_ACCESSORIES_PLATE = 0x57 # 配件板异常
MINOR_KMS_EXPAMSION_DISK_LOST = 0x58 #  KMS扩容盘丢失
MINOR_ABNORMAL_PORT = 0x59 #  端口异常
MINOR_CAMERA_ANGLE_ANOMALY = 0x60 #   相机视角异常
MINOR_DATA_DISK_ERROE = 0x61 #   数据盘错误
MINOR_INTELLIGENT_SYSTEM_RUNNING_ERROR = 0x62 #   智能系统运行异常
MINOR_FACESNAP_RESOLUTION_OVERFLOW = 0x63 #   人脸抓拍码流分辨率超限
MINOR_SMD_RESOLUTION_OVERFLOW = 0x64 #   SMD码流分辨率超限
MINOR_AUDIO_LOSS_EXCEPTION = 0x65 #   音频丢失异常
MINOR_SAFETY_HELMET_EXCEPTION = 0x66 # 未佩戴安全帽检测异常
MINOR_VCA_PIC_LENGTH_OVERFLOW = 0x67 #  VCA图片长度过长（例如超过2M大小的图片）
MINOR_FACE_MODEL_EXCEPTION = 0x68 #   人脸库模型同步异常
MINOR_SSD_EXCEPTION = 0x69 #  SSD异常
# NVR集群
MINOR_CLUSTER_DEVICE_OFFLINE = 0x70 #  集群内设备下线
MINOR_CLUSTER_CONFIG_FAILED = 0x71 #  集群内设备配置失败
MINOR_CLUSTER_DISASTER_TOLERANCE_EXCEPT = 0x72 #  集群容灾异常:集群CM选举失败,集群存储周期不足,集群带宽不足,集群通道资源不足,集群设备不足等
MINOR_CLUSTER_STORFULL_EXCEPTION = 0x73 # 集群硬盘满
MINOR_CLUSTER_VERSION_EXCEPTION = 0x74 # 集群版本异常
MINOR_CLUSTER_OFFLINENODE_EXCEPTION = 0x75 # 集群掉线数超限
MINOR_CLUSTER_RECORDCYCLE_EXCEPTION = 0x76 # 集群录像周期不足
MINOR_CLUSTER_IPCTRANSFER_EXCEPTION = 0x77 # 集群IPC迁移失败
MINOR_CLUSTER_IPCONFLICT_EXCEPTION = 0x78 #  集群IP冲突，记录CM的IP地址

MINOR_GET_SUB_STREAM_FAILURE = 0x79 # 子码流取流失败
MINOR_HDD_SHM_DETECT_EXCEPTION = 0x7a # 硬盘SHM检测异常
MINOR_DEVICE_FORTIFY_FAILURE = 0x7b # 前端设备报警布防失败
MINOR_EVENT_UPLOAD_EXCEPTION = 0x7c # 事件发送异常（设备上传事件失败或者丢弃了）

MINOR_LORA_EXCEPTION = 0x7d # LoRa异常
MINOR_AK_OR_SK_IS_EMPTY = 0x7e # 云存储密码或加密密码为空

MINOR_HIGH_HD_TEMPERATURE = 0x80 # 硬盘温度过高
MINOR_LOW_HD_TEMPERATURE = 0x81 # 硬盘温度过低
MINOR_HD_IMPACT = 0x82 # 硬盘受到冲击
MINOR_HD_BAD_BLOCK = 0x83 # 硬盘出现坏块
MINOR_SEVERE_HD_FAILURE = 0x84 # 硬盘严重故障
MINOR_RELEASE_FAILED = 0x85 # 信息发布失败
MINOR_PORT_CONFLICT = 0x86 # 端口冲突
MINOR_MODULE_STARTUP_FAILED = 0x87 # 模块启动失败
MINIOR_VCA_RUNNING_EXCEPTION = 0x88 # 智能板运行异常

# 0x400-0x1000 门禁异常类型
MINOR_DEV_POWER_ON = 0x400 # 设备上电启动
MINOR_DEV_POWER_OFF = 0x401 # 设备掉电关闭
MINOR_WATCH_DOG_RESET = 0x402 # 看门狗复位
MINOR_LOW_BATTERY = 0x403 # 蓄电池电压低
MINOR_BATTERY_RESUME = 0x404 # 蓄电池电压恢复正常
MINOR_AC_OFF = 0x405 # 交流电断电
MINOR_AC_RESUME = 0x406 # 交流电恢复
MINOR_NET_RESUME = 0x407 # 网络恢复
MINOR_FLASH_ABNORMAL = 0x408 # FLASH读写异常
MINOR_CARD_READER_OFFLINE = 0x409 # 读卡器掉线
MINOR_CARD_READER_RESUME = 0x40a # 读卡器掉线恢复
MINOR_INDICATOR_LIGHT_OFF = 0x40b # 指示灯关闭
MINOR_INDICATOR_LIGHT_RESUME = 0x40c # 指示灯恢复
MINOR_CHANNEL_CONTROLLER_OFF = 0x40d # 通道控制器掉线
MINOR_CHANNEL_CONTROLLER_RESUME = 0x40e # 通道控制器恢复
MINOR_SECURITY_MODULE_OFF = 0x40f # 门控安全模块掉线
MINOR_SECURITY_MODULE_RESUME = 0x410 # 门控安全模块在线
MINOR_BATTERY_ELECTRIC_LOW = 0x411 # 电池电压低(仅人脸设备使用)
MINOR_BATTERY_ELECTRIC_RESUME = 0x412 # 电池电压恢复正常(仅人脸设备使用)
MINOR_LOCAL_CONTROL_NET_BROKEN = 0x413 # 就地控制器网络断开
MINOR_LOCAL_CONTROL_NET_RSUME = 0x414 # 就地控制器网络恢复
MINOR_MASTER_RS485_LOOPNODE_BROKEN = 0x415 # 主控RS485环路节点断开
MINOR_MASTER_RS485_LOOPNODE_RESUME = 0x416 # 主控RS485环路节点恢复
MINOR_LOCAL_CONTROL_OFFLINE = 0x417 # 就地控制器掉线
MINOR_LOCAL_CONTROL_RESUME = 0x418 # 就地控制器掉线恢复
MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN = 0x419 # 就地下行RS485环路断开
MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME = 0x41a # 就地下行RS485环路恢复
MINOR_DISTRACT_CONTROLLER_ONLINE = 0x41b # 分控器在线
MINOR_DISTRACT_CONTROLLER_OFFLINE = 0x41c # 分控器离线
MINOR_ID_CARD_READER_NOT_CONNECT = 0x41d # 身份证阅读器未连接（智能专用）
MINOR_ID_CARD_READER_RESUME = 0x41e # 身份证阅读器连接恢复（智能专用）
MINOR_FINGER_PRINT_MODULE_NOT_CONNECT = 0x41f # 指纹模组未连接（智能专用）
MINOR_FINGER_PRINT_MODULE_RESUME = 0x420 # 指纹模组连接恢复（智能专用）
MINOR_CAMERA_NOT_CONNECT = 0x421 # 摄像头未连接
MINOR_CAMERA_RESUME = 0x422 # 摄像头连接恢复
MINOR_COM_NOT_CONNECT = 0x423 # COM口未连接
MINOR_COM_RESUME = 0x424 # COM口连接恢复
MINOR_DEVICE_NOT_AUTHORIZE = 0x425 # 设备未授权
MINOR_PEOPLE_AND_ID_CARD_DEVICE_ONLINE = 0x426 # 人证设备在线
MINOR_PEOPLE_AND_ID_CARD_DEVICE_OFFLINE = 0x427 # 人证设备离线
MINOR_LOCAL_LOGIN_LOCK = 0x428 # 本地登录锁定
MINOR_LOCAL_LOGIN_UNLOCK = 0x429 # 本地登录解锁
MINOR_SUBMARINEBACK_COMM_BREAK = 0x42a # 与反潜回服务器通信断开
MINOR_SUBMARINEBACK_COMM_RESUME = 0x42b # 与反潜回服务器通信恢复
MINOR_MOTOR_SENSOR_EXCEPTION = 0x42c # 电机或传感器异常
MINOR_CAN_BUS_EXCEPTION = 0x42d # CAN总线异常
MINOR_CAN_BUS_RESUME = 0x42e # CAN总线恢复
MINOR_GATE_TEMPERATURE_OVERRUN = 0x42f # 闸机腔体温度超限
MINOR_IR_EMITTER_EXCEPTION = 0x430 # 红外对射异常
MINOR_IR_EMITTER_RESUME = 0x431 # 红外对射恢复
MINOR_LAMP_BOARD_COMM_EXCEPTION = 0x432 # 灯板通信异常
MINOR_LAMP_BOARD_COMM_RESUME = 0x433 # 灯板通信恢复
MINOR_IR_ADAPTOR_COMM_EXCEPTION = 0x434 # 红外转接板通信异常
MINOR_IR_ADAPTOR_COMM_RESUME = 0x435 # 红外转接板通信恢复
MINOR_PRINTER_ONLINE = 0x436 # 打印机在线
MINOR_PRINTER_OFFLINE = 0x437 # 打印机离线
MINOR_4G_MOUDLE_ONLINE = 0x438 # 4G模块在线
MINOR_4G_MOUDLE_OFFLINE = 0x439 # 4G模块离线
MINOR_DSP_START_FAILED = 0x43a # DSP启动失败
MINOR_SMART_REGULATION_NOT_ALLOWED = 0x43b # 智能规则不支持
MINOR_AUXILIARY_BOARD_OFFLINE = 0x43c # 辅助板掉线
MINOR_AUXILIARY_BOARD_RESUME = 0x43d # 辅助板掉线恢复
MINOR_IDCARD_SECURITY_MOUDLE_EXCEPTION = 0x43e # 身份证安全模块异常
MINOR_IDCARD_SECURITY_MOUDLE_RESUME = 0x43f # 身份证安全模块恢复
MINOR_FP_PERIPHERAL_EXCEPTION = 0x440 # 指纹采集外设异常
MINOR_FP_PERIPHERAL_RESUME = 0x441 # 指纹采集外设恢复


MINOR_EXCEPTION_CUSTOM1 = 0x900 # 门禁自定义异常1
MINOR_EXCEPTION_CUSTOM2 = 0x901 # 门禁自定义异常2
MINOR_EXCEPTION_CUSTOM3 = 0x902 # 门禁自定义异常3
MINOR_EXCEPTION_CUSTOM4 = 0x903 # 门禁自定义异常4
MINOR_EXCEPTION_CUSTOM5 = 0x904 # 门禁自定义异常5
MINOR_EXCEPTION_CUSTOM6 = 0x905 # 门禁自定义异常6
MINOR_EXCEPTION_CUSTOM7 = 0x906 # 门禁自定义异常7
MINOR_EXCEPTION_CUSTOM8 = 0x907 # 门禁自定义异常8
MINOR_EXCEPTION_CUSTOM9 = 0x908 # 门禁自定义异常9
MINOR_EXCEPTION_CUSTOM10 = 0x909 # 门禁自定义异常10
MINOR_EXCEPTION_CUSTOM11 = 0x90a # 门禁自定义异常11
MINOR_EXCEPTION_CUSTOM12 = 0x90b # 门禁自定义异常12
MINOR_EXCEPTION_CUSTOM13 = 0x90c # 门禁自定义异常13
MINOR_EXCEPTION_CUSTOM14 = 0x90d # 门禁自定义异常14
MINOR_EXCEPTION_CUSTOM15 = 0x90e # 门禁自定义异常15
MINOR_EXCEPTION_CUSTOM16 = 0x90f # 门禁自定义异常16
MINOR_EXCEPTION_CUSTOM17 = 0x910 # 门禁自定义异常17
MINOR_EXCEPTION_CUSTOM18 = 0x911 # 门禁自定义异常18
MINOR_EXCEPTION_CUSTOM19 = 0x912 # 门禁自定义异常19
MINOR_EXCEPTION_CUSTOM20 = 0x913 # 门禁自定义异常20
MINOR_EXCEPTION_CUSTOM21 = 0x914 # 门禁自定义异常21
MINOR_EXCEPTION_CUSTOM22 = 0x915 # 门禁自定义异常22
MINOR_EXCEPTION_CUSTOM23 = 0x916 # 门禁自定义异常23
MINOR_EXCEPTION_CUSTOM24 = 0x917 # 门禁自定义异常24
MINOR_EXCEPTION_CUSTOM25 = 0x918 # 门禁自定义异常25
MINOR_EXCEPTION_CUSTOM26 = 0x919 # 门禁自定义异常26
MINOR_EXCEPTION_CUSTOM27 = 0x91a # 门禁自定义异常27
MINOR_EXCEPTION_CUSTOM28 = 0x91b # 门禁自定义异常28
MINOR_EXCEPTION_CUSTOM29 = 0x91c # 门禁自定义异常29
MINOR_EXCEPTION_CUSTOM30 = 0x91d # 门禁自定义异常30
MINOR_EXCEPTION_CUSTOM31 = 0x91e # 门禁自定义异常31
MINOR_EXCEPTION_CUSTOM32 = 0x91f # 门禁自定义异常32
MINOR_EXCEPTION_CUSTOM33 = 0x920 # 门禁自定义异常33
MINOR_EXCEPTION_CUSTOM34 = 0x921 # 门禁自定义异常34
MINOR_EXCEPTION_CUSTOM35 = 0x922 # 门禁自定义异常35
MINOR_EXCEPTION_CUSTOM36 = 0x923 # 门禁自定义异常36
MINOR_EXCEPTION_CUSTOM37 = 0x924 # 门禁自定义异常37
MINOR_EXCEPTION_CUSTOM38 = 0x925 # 门禁自定义异常38
MINOR_EXCEPTION_CUSTOM39 = 0x926 # 门禁自定义异常39
MINOR_EXCEPTION_CUSTOM40 = 0x927 # 门禁自定义异常40
MINOR_EXCEPTION_CUSTOM41 = 0x928 # 门禁自定义异常41
MINOR_EXCEPTION_CUSTOM42 = 0x929 # 门禁自定义异常42
MINOR_EXCEPTION_CUSTOM43 = 0x92a # 门禁自定义异常43
MINOR_EXCEPTION_CUSTOM44 = 0x92b # 门禁自定义异常44
MINOR_EXCEPTION_CUSTOM45 = 0x92c # 门禁自定义异常45
MINOR_EXCEPTION_CUSTOM46 = 0x92d # 门禁自定义异常46
MINOR_EXCEPTION_CUSTOM47 = 0x92e # 门禁自定义异常47
MINOR_EXCEPTION_CUSTOM48 = 0x92f # 门禁自定义异常48
MINOR_EXCEPTION_CUSTOM49 = 0x930 # 门禁自定义异常49
MINOR_EXCEPTION_CUSTOM50 = 0x931 # 门禁自定义异常50
MINOR_EXCEPTION_CUSTOM51 = 0x932 # 门禁自定义异常51
MINOR_EXCEPTION_CUSTOM52 = 0x933 # 门禁自定义异常52
MINOR_EXCEPTION_CUSTOM53 = 0x934 # 门禁自定义异常53
MINOR_EXCEPTION_CUSTOM54 = 0x935 # 门禁自定义异常54
MINOR_EXCEPTION_CUSTOM55 = 0x936 # 门禁自定义异常55
MINOR_EXCEPTION_CUSTOM56 = 0x937 # 门禁自定义异常56
MINOR_EXCEPTION_CUSTOM57 = 0x938 # 门禁自定义异常57
MINOR_EXCEPTION_CUSTOM58 = 0x939 # 门禁自定义异常58
MINOR_EXCEPTION_CUSTOM59 = 0x93a # 门禁自定义异常59
MINOR_EXCEPTION_CUSTOM60 = 0x93b # 门禁自定义异常60
MINOR_EXCEPTION_CUSTOM61 = 0x93c # 门禁自定义异常61
MINOR_EXCEPTION_CUSTOM62 = 0x93d # 门禁自定义异常62
MINOR_EXCEPTION_CUSTOM63 = 0x93e # 门禁自定义异常63
MINOR_EXCEPTION_CUSTOM64 = 0x93f # 门禁自定义异常64
MINOR_SWITCH_WIRED_NETWORK = 0x950 # 切换有线网络
MINOR_SWITCH_WIRELESS_NETWORK = 0x951 # 切换无线网络
MINOR_LOCK_ONLINE_RESUME = 0x952 # 智能锁恢复上线

# 2018-04-23 通用物联网关异常日志类型
MINOR_ALARMHOST_WDT_RESET = 0x1003 # WDT 复位
MINOR_ALARMHOST_RTC_EXCEPTION = 0x1007 # RTC实时时钟异常

MINOR_ALARMHOST_TEL_LINE_CONNECT_FAILURE = 0x100a # 电话线连接断
MINOR_ALARMHOST_TEL_LINE_CONNECT_RESTORE = 0x100b # 电话线连接恢复
MINOR_ALARMHOST_EXPANDER_BUS_LOSS = 0x100c # 扩展总线模块掉线
MINOR_ALARMHOST_EXPANDER_BUS_RESTORE = 0x100d # 扩展总线模块掉线恢复
MINOR_ALARMHOST_KEYPAD_BUS_LOSS = 0x100e # 键盘总线模块掉线
MINOR_ALARMHOST_KEYPAD_BUS_RESTORE = 0x100f # 键盘总线模块掉线恢复
MINOR_ALARMHOST_SENSOR_FAILURE = 0x1010 # 模拟量传感器故障
MINOR_ALARMHOST_SENSOR_RESTORE = 0x1011 # 模拟量传感器恢复
MINOR_ALARMHOST_RS485_CONNECT_FAILURE = 0x1012 # RS485通道连接断
MINOR_ALARMHOST_RS485_CONNECT_RESTORE = 0x1013 # RS485通道连接断恢复

# “有线网络异常”和“有线网络异常恢复”这两个日志跟“网络连接断”“网络连接恢复”这两个日志时一样的，且没有设备支持“有线网络异常”和“有线网络异常恢复”这两种类型。
MINOR_ALARMHOST_WIRED_NETWORK_ABNORMAL = 0x1015 # 有线网络异常
MINOR_ALARMHOST_WIRED_NETWORK_RESTORE = 0x1016 # 有线网络恢复正常
MINOR_ALARMHOST_GPRS_ABNORMAL = 0x1017 # GPRS通信异常
MINOR_ALARMHOST_GPRS_RESTORE = 0x1018 # GPRS恢复正常
MINOR_ALARMHOST_3G_ABNORMAL = 0x1019 # 3G通信异常
MINOR_ALARMHOST_3G_RESTORE = 0x101a # 3G恢复正常
MINOR_ALARMHOST_SIM_CARD_ABNORMAL = 0x101b # SIM卡异常
MINOR_ALARMHOST_SIM_CARD_RESTORE = 0x101c # SIM卡恢复正常

MINOR_FORMAT_HDD_ERROR = 0x1026 # 远程格式化硬盘失败
MINOR_USB_ERROR = 0x1027 # USB通信故障
MINOR_USB_RESTORE = 0x1028 # USB通信故障恢复
MINOR_PRINT_ERROR = 0x1029 # 打印机故障
MINOR_PRINT_RESTORE = 0x1030 # 打印机故障恢复
MINOR_ALARMHOST_SUBSYSTEM_COMMUNICATION_ERROR = 0x1031 # 子板通讯错误

MINOR_MCU_RESTART = 0x1035 # MCU重启
MINOR_GPRS_MODULE_FAULT = 0x1036 # GPRS模块故障
MINOR_TELEPHONE_MODULE_FAULT = 0x1037 # 电话模块故障
MINOR_WIFI_ABNORMAL = 0x1038 # WIFI通信异常
MINOR_WIFI_RESTORE = 0x1039 # WIFI恢复正常
MINOR_RF_ABNORMAL = 0x103a # RF信号异常
MINOR_RF_RESTORE = 0x103b # RF信号恢复正常
MINOR_DETECTOR_ONLINE = 0x103c # 探测器在线
MINOR_DETECTOR_OFFLINE = 0x103d # 探测器离线
MINOR_DETECTOR_BATTERY_NORMAL = 0x103e # 探测器电量正常
MINOR_DETECTOR_BATTERY_LOW = 0x103f # 探测器电量欠压
MINOR_DATA_TRAFFIC_OVERFLOW = 0x1040 # 流量超额
MINOR_ALARMHOST_ZONE_MODULE_LOSS = 0x1041 # 防区模块掉线
MINOR_ALARMHOST_ZONE_MODULE_RESTORE = 0x1042 # 防区模块掉线恢复
MINOR_WIRELESS_OUTPUT_LOSS = 0x1043 # 无线输出模块离线
MINOR_WIRELESS_OUTPUT_RESTORE = 0x1044 # 无线输出模块恢复在线
MINOR_WIRELESS_REPEATER_LOSS = 0x1045 # 无线中继器离线
MINOR_WIRELESS_REPEATER_RESTORE = 0x1046 # 无线中继器恢复在线
MINOR_ALARMHOST_TRIGGER_MODULE_LOSS = 0x1047 # 触发器模块掉线
MINOR_ALARMHOST_TRIGGER_MODULE_RESTORE = 0x1048 # 触发器模块掉线恢复
MINOR_ALARMHOST_WIRELESS_SIREN_LOSS = 0x1049 # 无线警号离线
MINOR_ALARMHOST_WIRELESS_SIREN_RESTORE = 0x104a # 无线警号恢复在线
MINOR_TX1_SUB_SYSTEM_EXCEPTION = 0x1050 # TX1子系统异常
MINOR_TX1_REBOOT_EXCEPTION = 0x1051 # TX1系统异常重启
MINOR_TX1_SUB_SYSTEM_LOSS = 0x1052 # 智能子系统异常离线
MINOR_TX1_SUB_SYSTEM_RESTORE = 0x1053 # 智能子系统离线恢复
MINOR_WIRELESS_SPEED_EXCEPTION = 0x1054 # 无线传输速率异常

# LED 异常次类型 0x1201~0x1300
MINOR_LED_SYSTEM_EXCEPTION = 0x1201 # LED系统异常
MINOR_FLASH_NOTENOUGH_EXCEPTION = 0x1202 # FLASH空间不足

MINOR_LOG_EXCEPTION = 0x1301 # 日志盘异常

# [add]by silujie 2013-3-22 14:16
# 0x2000~0x3fff 为设备报警日志
# 0x4000~0x5000 为设备异常日志
MINOR_SUBSYSTEM_IP_CONFLICT = 0x4000 # 子板IP冲突
MINOR_SUBSYSTEM_NET_BROKEN = 0x4001 # 子板断网
MINOR_FAN_ABNORMAL = 0x4002 # 风扇异常
MINOR_BACKPANEL_TEMPERATURE_ABNORMAL = 0x4003 # 背板温度异常

MINOR_SDCARD_ABNORMAL = 0x4004 # SD卡不健康
MINOR_SDCARD_DAMAGE = 0x4005 # SD卡损坏
MINOR_POC_ABNORMAL = 0x4006 # 设备POC模块异常
MINOR_MAIN_POWER_FAULT = 0x4007 # 主电故障
MINOR_BACK_UP_POWER_FAULT = 0x4008 # 备电故障
MINOR_TAMPER_FAULT = 0x4009 # 防拆故障
MINOR_RS232_FAULT = 0x400a # 232总线故障
MINOR_RS485_FAULT = 0x400b # 485总线故障
MINOR_LAN_STATUS_FAULT = 0x400c # LAN网线接入状态故障
MINOR_LAN_LINK1_FAULT = 0x400d # LAN链路1故障
MINOR_LAN_LINK2_FAULT = 0x400e # LAN链路2故障
MINOR_SIM_CARD_STATUS_FAULT = 0x400f # 4G-SIM卡状态故障
MINOR_4G_LINK1_FAULT = 0x4010 # 4G链路1故障
MINOR_4G_LINK2_FAULT = 0x4011 # 4G链路2故障
MINOR_OTHER_FAULT = 0x4012 # 其他故障
MINOR_FIRE_CONTROL_CONNECT_FAULT = 0x4013 # 与消控主机连接故障
MINOR_SENSOR_SHORT_CIRCUIT = 0x4014 # 传感器短路
MINOR_SENSOR_OPEN_CIRCUIT = 0x4015 # 传感器断路
MINOR_SENSOR_MIS_CONNECT = 0x4016 # 传感器错接
MINOR_SENSOR_FAULT_RESTORE = 0x4017 # 传感器故障恢复
MINOR_DEVICE_FAULT = 0x4018 # 设备故障
MINOR_OVERVOLTAGE = 0X4019 # 电源电压过高
MINOR_UNDERVOLTAGE = 0X401a # 电源电压过低
MINOR_PANLOCKING = 0x401b # 云台水平堵转
MINOR_TILTLOCKING = 0x401c # 云台垂直堵转
MINOR_SUBBOARD_TEMPERATURE_ABNORMAL = 0x401d # 子板温度异常
MINOR_EZVIZ_UPGRADE_EXCEPTION = 0x401e # 萤石升级异常

# 萤石相关操作异常日志
MINOR_EZVIZ_OPERATION_ABNORMAL = 0x4020 # 萤石操作异常

#  操作
# 主类型
MAJOR_OPERATION = 0x3

# 次类型
MINOR_VCA_MOTIONEXCEPTION = 0x29 # 智能侦测异常
MINOR_START_DVR = 0x41 #  开机
MINOR_STOP_DVR = 0x42 #  关机
MINOR_STOP_ABNORMAL = 0x43 #  异常关机
MINOR_REBOOT_DVR = 0x44 # 本地重启设备

MINOR_LOCAL_LOGIN = 0x50 #  本地登陆
MINOR_LOCAL_LOGOUT = 0x51 #  本地注销登陆
MINOR_LOCAL_CFG_PARM = 0x52 #  本地配置参数
MINOR_LOCAL_PLAYBYFILE = 0x53 #  本地按文件回放或下载
MINOR_LOCAL_PLAYBYTIME = 0x54 #  本地按时间回放或下载
MINOR_LOCAL_START_REC = 0x55 #  本地开始录像
MINOR_LOCAL_STOP_REC = 0x56 #  本地停止录像
MINOR_LOCAL_PTZCTRL = 0x57 #  本地云台控制
MINOR_LOCAL_PREVIEW = 0x58 #  本地预览 (保留不使用)
MINOR_LOCAL_MODIFY_TIME = 0x59 #  本地修改时间(保留不使用)
MINOR_LOCAL_UPGRADE = 0x5a #  本地升级
MINOR_LOCAL_RECFILE_OUTPUT = 0x5b #  本地备份录象文件
MINOR_LOCAL_FORMAT_HDD = 0x5c #  本地初始化硬盘
MINOR_LOCAL_CFGFILE_OUTPUT = 0x5d #  导出本地配置文件
MINOR_LOCAL_CFGFILE_INPUT = 0x5e #  导入本地配置文件
MINOR_LOCAL_COPYFILE = 0x5f #  本地备份文件
MINOR_LOCAL_LOCKFILE = 0x60 #  本地锁定录像文件
MINOR_LOCAL_UNLOCKFILE = 0x61 #  本地解锁录像文件
MINOR_LOCAL_DVR_ALARM = 0x62 #  本地手动清除和触发报警
MINOR_IPC_ADD = 0x63 #  本地添加IPC
MINOR_IPC_DEL = 0x64 #  本地删除IPC
MINOR_IPC_SET = 0x65 #  本地设置IPC
MINOR_LOCAL_START_BACKUP = 0x66 #  本地开始备份
MINOR_LOCAL_STOP_BACKUP = 0x67 #  本地停止备份
MINOR_LOCAL_COPYFILE_START_TIME = 0x68 #  本地备份开始时间
MINOR_LOCAL_COPYFILE_END_TIME = 0x69 #  本地备份结束时间
MINOR_LOCAL_ADD_NAS = 0x6a # 本地添加网络硬盘 （nfs、iscsi）
MINOR_LOCAL_DEL_NAS = 0x6b #  本地删除nas盘 （nfs、iscsi）
MINOR_LOCAL_SET_NAS = 0x6c #  本地设置nas盘 （nfs、iscsi）
MINOR_LOCAL_RESET_PASSWD = 0x6d #  本地恢复管理员默认密码

MINOR_REMOTE_LOGIN = 0x70 #  远程登录
MINOR_REMOTE_LOGOUT = 0x71 #  远程注销登陆
MINOR_REMOTE_START_REC = 0x72 #  远程开始录像
MINOR_REMOTE_STOP_REC = 0x73 #  远程停止录像
MINOR_START_TRANS_CHAN = 0x74 #  开始透明传输
MINOR_STOP_TRANS_CHAN = 0x75 #  停止透明传输
MINOR_REMOTE_GET_PARM = 0x76 #  远程获取参数
MINOR_REMOTE_CFG_PARM = 0x77 #  远程配置参数
MINOR_REMOTE_GET_STATUS = 0x78 #  远程获取状态
MINOR_REMOTE_ARM = 0x79 #  远程布防
MINOR_REMOTE_DISARM = 0x7a #  远程撤防
MINOR_REMOTE_REBOOT = 0x7b #  远程重启
MINOR_START_VT = 0x7c #  开始语音对讲
MINOR_STOP_VT = 0x7d #  停止语音对讲
MINOR_REMOTE_UPGRADE = 0x7e #  远程升级
MINOR_REMOTE_PLAYBYFILE = 0x7f #  远程按文件回放
MINOR_REMOTE_PLAYBYTIME = 0x80 #  远程按时间回放
MINOR_REMOTE_PTZCTRL = 0x81 #  远程云台控制
MINOR_REMOTE_FORMAT_HDD = 0x82 #  远程格式化硬盘
MINOR_REMOTE_STOP = 0x83 #  远程关机
MINOR_REMOTE_LOCKFILE = 0x84 #  远程锁定文件
MINOR_REMOTE_UNLOCKFILE = 0x85 #  远程解锁文件
MINOR_REMOTE_CFGFILE_OUTPUT = 0x86 #  远程导出配置文件
MINOR_REMOTE_CFGFILE_INTPUT = 0x87 #  远程导入配置文件
MINOR_REMOTE_RECFILE_OUTPUT = 0x88 #  远程导出录象文件
MINOR_REMOTE_DVR_ALARM = 0x89 #  远程手动清除和触发报警
MINOR_REMOTE_IPC_ADD = 0x8a #  远程添加IPC
MINOR_REMOTE_IPC_DEL = 0x8b #  远程删除IPC
MINOR_REMOTE_IPC_SET = 0x8c #  远程设置IPC
MINOR_REBOOT_VCA_LIB = 0x8d # 重启智能库
MINOR_REMOTE_ADD_NAS = 0x8e #  远程添加nas盘 （nfs、iscsi）
MINOR_REMOTE_DEL_NAS = 0x8f #  远程删除nas盘 （nfs、iscsi）
MINOR_REMOTE_SET_NAS = 0x90 #  远程设置nas盘 （nfs、iscsi）
MINOR_LOCAL_OPERATE_LOCK = 0x9d #  本地操作锁定
MINOR_LOCAL_OPERATE_UNLOCK = 0x9e #  本地操作解除锁定
MINOR_REMOTE_DELETE_HDISK = 0x9a #  远程删除异常不存在的硬盘
MINOR_REMOTE_LOAD_HDISK = 0x9b #  远程加载硬盘
MINOR_REMOTE_UNLOAD_HDISK = 0x9c #  远程卸载硬盘
MINOR_SCHEDULE_ANGLECALIBRATION = 0x139 # 定期倾角校准
MINOR_OTHER_OPERATE = 0x200 #  其他操作

# 2010-05-26 增加审讯DVR日志类型
MINOR_LOCAL_START_REC_CDRW = 0x91 #  本地开始讯问
MINOR_LOCAL_STOP_REC_CDRW = 0x92 #  本地停止讯问
MINOR_REMOTE_START_REC_CDRW = 0x93 #  远程开始讯问
MINOR_REMOTE_STOP_REC_CDRW = 0x94 #  远程停止讯问

MINOR_LOCAL_PIC_OUTPUT = 0x95 #  本地备份图片文件
MINOR_REMOTE_PIC_OUTPUT = 0x96 #  远程备份图片文件

# 2011-07-26 增加81审讯DVR日志类型
MINOR_LOCAL_INQUEST_RESUME = 0x97 #  本地恢复审讯事件
MINOR_REMOTE_INQUEST_RESUME = 0x98 #  远程恢复审讯事件

# 2013-01-23 增加86高清审讯NVR操作日志
MINOR_LOCAL_ADD_FILE = 0x99 # 本地导入文件
MINOR_LOCAL_DEL_FILE = 0x9f # 本地删除审讯
MINOR_REMOTE_INQUEST_ADD_FILE = 0x100 # 远程导入文件

# 2009-12-16 增加视频综合平台日志类型
MINOR_SUBSYSTEMREBOOT = 0xa0 # 视频综合平台：dm6467 正常重启
MINOR_MATRIX_STARTTRANSFERVIDEO = 0xa1 # 视频综合平台：矩阵切换开始传输图像
MINOR_MATRIX_STOPTRANSFERVIDEO = 0xa2 # 视频综合平台：矩阵切换停止传输图像
MINOR_REMOTE_SET_ALLSUBSYSTEM = 0xa3 # 视频综合平台：设置所有6467子系统信息
MINOR_REMOTE_GET_ALLSUBSYSTEM = 0xa4 # 视频综合平台：获取所有6467子系统信息
MINOR_REMOTE_SET_PLANARRAY = 0xa5 # 视频综合平台：设置计划轮巡组
MINOR_REMOTE_GET_PLANARRAY = 0xa6 # 视频综合平台：获取计划轮巡组
MINOR_MATRIX_STARTTRANSFERAUDIO = 0xa7 # 视频综合平台：矩阵切换开始传输音频
MINOR_MATRIX_STOPRANSFERAUDIO = 0xa8 # 视频综合平台：矩阵切换停止传输音频
MINOR_LOGON_CODESPITTER = 0xa9 # 视频综合平台：登陆码分器
MINOR_LOGOFF_CODESPITTER = 0xaa # 视频综合平台：退出码分器

# 2010-01-22 增加视频综合平台中解码器操作日志
MINOR_START_DYNAMIC_DECODE = 0xb0 # 开始动态解码
MINOR_STOP_DYNAMIC_DECODE = 0xb1 # 停止动态解码
MINOR_GET_CYC_CFG = 0xb2 # 获取解码器通道轮巡配置
MINOR_SET_CYC_CFG = 0xb3 # 设置解码通道轮巡配置
MINOR_START_CYC_DECODE = 0xb4 # 开始轮巡解码
MINOR_STOP_CYC_DECODE = 0xb5 # 停止轮巡解码
MINOR_GET_DECCHAN_STATUS = 0xb6 # 获取解码通道状态
MINOR_GET_DECCHAN_INFO = 0xb7 # 获取解码通道当前信息
MINOR_START_PASSIVE_DEC = 0xb8 # 开始被动解码
MINOR_STOP_PASSIVE_DEC = 0xb9 # 停止被动解码
MINOR_CTRL_PASSIVE_DEC = 0xba # 控制被动解码
MINOR_RECON_PASSIVE_DEC = 0xbb # 被动解码重连
MINOR_GET_DEC_CHAN_SW = 0xbc # 获取解码通道总开关
MINOR_SET_DEC_CHAN_SW = 0xbd # 设置解码通道总开关
MINOR_CTRL_DEC_CHAN_SCALE = 0xbe # 解码通道缩放控制
MINOR_SET_REMOTE_REPLAY = 0xbf # 设置远程回放
MINOR_GET_REMOTE_REPLAY = 0xc0 # 获取远程回放状态
MINOR_CTRL_REMOTE_REPLAY = 0xc1 # 远程回放控制
MINOR_SET_DISP_CFG = 0xc2 # 设置显示通道
MINOR_GET_DISP_CFG = 0xc3 # 获取显示通道设置
MINOR_SET_PLANTABLE = 0xc4 # 设置计划轮巡表
MINOR_GET_PLANTABLE = 0xc5 # 获取计划轮巡表
MINOR_START_PPPPOE = 0xc6 # 开始PPPoE连接
MINOR_STOP_PPPPOE = 0xc7 # 结束PPPoE连接
MINOR_UPLOAD_LOGO = 0xc8 # 上传LOGO
# 推模式操作日志
MINOR_LOCAL_PIN = 0xc9 #  本地PIN功能操作
MINOR_LOCAL_DIAL = 0xca #  本地手动启动断开拨号
MINOR_SMS_CONTROL = 0xcb #  短信控制上下线
MINOR_CALL_ONLINE = 0xcc #  呼叫控制上线
MINOR_REMOTE_PIN = 0xcd #  远程PIN功能操作

# 2010-12-16 报警板日志
MINOR_REMOTE_BYPASS = 0xd0 # 远程旁路
MINOR_REMOTE_UNBYPASS = 0xd1 # 远程旁路恢复
MINOR_REMOTE_SET_ALARMIN_CFG = 0xd2 # 远程设置报警输入参数
MINOR_REMOTE_GET_ALARMIN_CFG = 0xd3 # 远程获取报警输入参数
MINOR_REMOTE_SET_ALARMOUT_CFG = 0xd4 # 远程设置报警输出参数
MINOR_REMOTE_GET_ALARMOUT_CFG = 0xd5 # 远程获取报警输出参数
MINOR_REMOTE_ALARMOUT_OPEN_MAN = 0xd6 # 远程手动开启报警输出
MINOR_REMOTE_ALARMOUT_CLOSE_MAN = 0xd7 # 远程手动关闭报警输出
MINOR_REMOTE_ALARM_ENABLE_CFG = 0xd8 # 远程设置报警主机的RS485串口使能状态
MINOR_DBDATA_OUTPUT = 0xd9 # 导出数据库记录
MINOR_DBDATA_INPUT = 0xda # 导入数据库记录
MINOR_MU_SWITCH = 0xdb # 级联切换
MINOR_MU_PTZ = 0xdc # 级联PTZ控制
MINOR_DELETE_LOGO = 0xdd # 删除logo
MINOR_REMOTE_INQUEST_DEL_FILE = 0xde # 远程删除文件

MINOR_LOCAL_CONF_REB_RAID = 0x101 # 本地配置自动重建
MINOR_LOCAL_CONF_SPARE = 0x102 # 本地配置热备
MINOR_LOCAL_ADD_RAID = 0x103 # 本地创建阵列
MINOR_LOCAL_DEL_RAID = 0x104 # 本地删除阵列
MINOR_LOCAL_MIG_RAID = 0x105 # 本地迁移阵列
MINOR_LOCAL_REB_RAID = 0x106 #  本地手动重建阵列
MINOR_LOCAL_QUICK_CONF_RAID = 0x107 # 本地一键配置
MINOR_LOCAL_ADD_VD = 0x108 # 本地创建虚拟磁盘
MINOR_LOCAL_DEL_VD = 0x109 # 本地删除虚拟磁盘
MINOR_LOCAL_RP_VD = 0x10a # 本地修复虚拟磁盘
MINOR_LOCAL_FORMAT_EXPANDVD = 0X10b # 本地扩展虚拟磁盘扩容
MINOR_LOCAL_RAID_UPGRADE = 0X10c # 本地raid卡升级
MINOR_LOCAL_STOP_RAID = 0x10d # 本地暂停RAID操作(即安全拔盘)
MINOR_REMOTE_CONF_REB_RAID = 0x111 # 远程配置自动重建
MINOR_REMOTE_CONF_SPARE = 0x112 # 远程配置热备
MINOR_REMOTE_ADD_RAID = 0x113 # 远程创建阵列
MINOR_REMOTE_DEL_RAID = 0x114 # 远程删除阵列
MINOR_REMOTE_MIG_RAID = 0x115 # 远程迁移阵列
MINOR_REMOTE_REB_RAID = 0x116 #  远程手动重建阵列
MINOR_REMOTE_QUICK_CONF_RAID = 0x117 # 远程一键配置
MINOR_REMOTE_ADD_VD = 0x118 # 远程创建虚拟磁盘
MINOR_REMOTE_DEL_VD = 0x119 # 远程删除虚拟磁盘
MINOR_REMOTE_RP_VD = 0x11a # 远程修复虚拟磁盘
MINOR_REMOTE_FORMAT_EXPANDVD = 0X11b # 远程虚拟磁盘扩容
MINOR_REMOTE_RAID_UPGRADE = 0X11c # 远程raid卡升级
MINOR_REMOTE_STOP_RAID = 0x11d # 远程暂停RAID操作(即安全拔盘)
MINOR_LOCAL_START_PIC_REC = 0x121 # 本地开始抓图
MINOR_LOCAL_STOP_PIC_REC = 0x122 # 本地停止抓图
MINOR_LOCAL_SET_SNMP = 0x125 # 本地配置SNMP
MINOR_LOCAL_TAG_OPT = 0x126 # 本地标签操作
MINOR_REMOTE_START_PIC_REC = 0x131 # 远程开始抓图
MINOR_REMOTE_STOP_PIC_REC = 0x132 # 远程停止抓图
MINOR_REMOTE_SET_SNMP = 0x135 # 远程配置SNMP
MINOR_REMOTE_TAG_OPT = 0x136 # 远程标签操作
MINOR_REMOTE_LOGIN_LOCK = 0x137 # 远程登录锁定
MINOR_REMOTE_LOGIN_UNLOCK = 0x138 # 远程登录解锁
#  9000 v2.2.0
MINOR_LOCAL_VOUT_SWITCH = 0x140 #  本地输出口切换操作
MINOR_STREAM_CABAC = 0x141 #  码流压缩性能选项配置操作

# Netra 3.0.0
MINOR_LOCAL_SPARE_OPT = 0x142 # 本地N+1 热备相关操作
MINOR_REMOTE_SPARE_OPT = 0x143 # 远程N+1 热备相关操作
MINOR_LOCAL_IPCCFGFILE_OUTPUT = 0x144 #  本地导出ipc配置文件
MINOR_LOCAL_IPCCFGFILE_INPUT = 0x145 #  本地导入ipc配置文件
MINOR_LOCAL_IPC_UPGRADE = 0x146 #  本地升级IPC
MINOR_REMOTE_IPCCFGFILE_OUTPUT = 0x147 #  远程导出ipc配置文件
MINOR_REMOTE_IPCCFGFILE_INPUT = 0x148 #  远程导入ipc配置文件
MINOR_REMOTE_IPC_UPGRADE = 0x149 #  远程升级IPC

MINOR_LOCAL_UNLOAD_HDISK = 0x150 # 本地卸载硬盘
MINOR_LOCAL_AUDIO_MIX = 0x151 # 本地配置音频混音参数
MINOR_REMOTE_AUDIO_MIX = 0x152 # 远程配置音频混音参数
MINOR_LOCAL_TRIAL_PAUSE = 0x153 # 本地暂停讯问
MINOR_LOCAL_TRIAL_RESUME = 0x154 # 本地继续讯问
MINOR_REMOTE_TRIAL_PAUSE = 0x155 # 远程暂停讯问
MINOR_REMOTE_TRIAL_RESUME = 0x156 # 远程继续讯问
MINOR_REMOTE_MODIFY_VERIFICATION_CODE = 0x157 # 修改平台的验证码

MINOR_LOCAL_MAKECALL = 0x180 # 本地呼叫
MINOR_LOCAL_REJECTCALL = 0x181 # 本地拒接
MINOR_LOCAL_ANSWERCALL = 0x182 # 本地接听
MINOR_LOCAL_HANGUPCALL = 0x183 # 本地挂断

MINOR_REMOTE_MAKECALL = 0x188 # 远程呼叫
MINOR_REMOTE_REJECTCALL = 0x189 # 远程拒接
MINOR_REMOTE_ANSWERCALL = 0x18a # 远程接听
MINOR_REMOTE_HANGUPCALL = 0x18b # 远程挂断

MINOR_LOCAL_CHANNEL_ORDERED	 = 0x19b # 本地通道排序

MINOR_SET_MULTI_MASTER = 0x201 # 设置大屏主屏
MINOR_SET_MULTI_SLAVE = 0x202 # 设置大屏子屏
MINOR_CANCEL_MULTI_MASTER = 0x203 # 取消大屏主屏
MINOR_CANCEL_MULTI_SLAVE = 0x204 # 取消大屏子屏

MINOR_DISPLAY_LOGO = 0x205 # 显示LOGO
MINOR_HIDE_LOGO = 0x206 # 隐藏LOGO
MINOR_SET_DEC_DELAY_LEVEL = 0x207 # 解码通道延时级别设置
MINOR_SET_BIGSCREEN_DIPLAY_AREA = 0x208 # 设置大屏显示区域
MINOR_CUT_VIDEO_SOURCE = 0x209 # 大屏视频源切割设置
MINOR_SET_BASEMAP_AREA = 0x210 # 大屏底图区域设置
MINOR_DOWNLOAD_BASEMAP = 0x211 # 下载大屏底图
MINOR_CUT_BASEMAP = 0x212 # 底图切割配置
MINOR_CONTROL_ELEC_ENLARGE = 0x213 # 电子放大操作(放大或还原)
MINOR_SET_OUTPUT_RESOLUTION = 0x214 # 显示输出分辨率设置
MINOR_SET_TRANCSPARENCY = 0X215 # 图层透明度设置
MINOR_SET_OSD = 0x216 # 显示OSD设置
MINOR_RESTORE_DEC_STATUS = 0x217 # 恢复初始状态(场景切换时，解码恢复初始状态)

# 2011-11-11 增加大屏控制器操作日志次类型
MINOR_SCREEN_OPEN_SCREEN = 0x218 # 打开屏幕
MINOR_SCREEN_CLOSE_SCREEN = 0x219 # 关闭屏幕
MINOR_SCREEN_SWITCH_SIGNAL = 0x21a # 信号源切换
MINOR_SCREEN_MODIFY_NETWORK = 0x21b # 配置网络参数
MINOR_SCREEN_MODIFY_LEDRES = 0x21c # 配置输出口LED分辨率
MINOR_SCREEN_SHOW_NORMAL = 0x21d # 配置窗口普通显示模式
MINOR_SCREEN_SHOW_TILE = 0x21e # 配置窗口平铺显示模式
MINOR_SCREEN_DEC_NORMAL = 0x21f # 配置普通解码模式
MINOR_SCREEN_DEC_LOWLATENCY = 0x220 # 配置低延时解码模式
MINOR_SCREEN_MODIFY_SELFRES = 0x221 # 配置信号源自定义分辨率
MINOR_SCREEN_OUTPUT_POSITION = 0x222 # 输出口关联屏幕
MINOR_SCREEN_IMAGE_ENHANCE = 0x223 # 图像增强
MINOR_SCREEN_JOIN_SIGNAL = 0x224 # 信号源拼接
MINOR_SCREEN_SIGNAL_OSD = 0x225 # 信号源字符叠加
MINOR_SCREEN_ASSOCIATED_INTERACTION = 0x226 # 信号源关联多屏互动服务器
MINOR_SCREEN_MODIFY_MATRIX = 0x227 # 配置矩阵参数
MINOR_SCREEN_WND_TOP_KEEP = 0x228 # 窗口置顶保持
MINOR_SCREEN_WND_OPEN_KEEP = 0x229 # 窗口打开保持
MINOR_SCREEN_WALL_MIRROR = 0x22a # 电视墙区域镜像
MINOR_SCREEN_UPLOAD_BASEMAP = 0x22b # 上传底图
MINOR_SCREEN_SHOW_BASEMAP = 0x22c # 显示底图
MINOR_SCREEN_HIDE_BASEMAP = 0x22d # 隐藏底图
MINOR_SCREEN_MODIFY_SERIAL = 0x22e # 配置串口参数

MINOR_SCREEN_SET_INPUT = 0x251 # 修改输入源
MINOR_SCREEN_SET_OUTPUT = 0x252 # 修改输出通道
MINOR_SCREEN_SET_OSD = 0x253 # 修改虚拟LED
MINOR_SCREEN_SET_LOGO = 0x254 # 修改LOGO
MINOR_SCREEN_SET_LAYOUT = 0x255 # 设置布局
MINOR_SCREEN_PICTUREPREVIEW = 0x256 # 回显操作


# 2012-06-14 CVCS2.0, 窗口设置等操作在V1.0， V1.1中已经有了，当时在设备日志中没有定义
MINOR_SCREEN_GET_OSD = 0x257 # 获取虚拟LED
MINOR_SCREEN_GET_LAYOUT = 0x258 # 获取布局
MINOR_SCREEN_LAYOUT_CTRL = 0x259 # 布局控制
MINOR_GET_ALL_VALID_WND = 0x260 # 获取所有有效窗口
MINOR_GET_SIGNAL_WND = 0x261 # 获取单个窗口信息
MINOR_WINDOW_CTRL = 0x262 # 窗口控制
MINOR_GET_LAYOUT_LIST = 0x263 # 获取布局列表
MINOR_LAYOUT_CTRL = 0x264 # 布局控制
MINOR_SET_LAYOUT = 0x265 # 设置布局
MINOR_GET_SIGNAL_LIST = 0x266 # 获取输入信号源列表
MINOR_GET_PLAN_LIST = 0x267 # 获取预案列表
MINOR_SET_PLAN = 0x268 # 修改预案
MINOR_CTRL_PLAN = 0x269 # 控制预案
MINOR_CTRL_SCREEN = 0x270 # 屏幕控制
MINOR_ADD_NETSIG = 0x271 # 添加信号源
MINOR_SET_NETSIG = 0x272 # 修改信号源
MINOR_SET_DECBDCFG = 0x273 # 设置解码板参数
MINOR_GET_DECBDCFG = 0x274 # 获取解码板参数
MINOR_GET_DEVICE_STATUS = 0x275 # 获取设备信息
MINOR_UPLOAD_PICTURE = 0x276 # 底图上传
MINOR_SET_USERPWD = 0x277 # 设置用户密码
MINOR_ADD_LAYOUT = 0x278 # 添加布局
MINOR_DEL_LAYOUT = 0x279 # 删除布局
MINOR_DEL_NETSIG = 0x280 # 删除信号源
MINOR_ADD_PLAN = 0x281 # 添加预案
MINOR_DEL_PLAN = 0x282 # 删除预案
MINOR_GET_EXTERNAL_MATRIX_CFG = 0x283 # 获取外接矩阵配置
MINOR_SET_EXTERNAL_MATRIX_CFG = 0x284 # 设置外接矩阵配置
MINOR_GET_USER_CFG = 0x285 # 获取用户配置
MINOR_SET_USER_CFG = 0x286 # 设置用户配置
MINOR_GET_DISPLAY_PANEL_LINK_CFG = 0x287 # 获取显示墙连接配置
MINOR_SET_DISPLAY_PANEL_LINK_CFG = 0x288 # 设置显示墙连接配置

MINOR_GET_WALLSCENE_PARAM = 0x289 # 获取电视墙场景
MINOR_SET_WALLSCENE_PARAM = 0x28a # 设置电视墙场景
MINOR_GET_CURRENT_WALLSCENE = 0x28b # 获取当前使用场景
MINOR_SWITCH_WALLSCENE = 0x28c # 场景切换
MINOR_SIP_LOGIN = 0x28d # SIP注册成功
MINOR_VOIP_START = 0x28e # VOIP对讲开始
MINOR_VOIP_STOP = 0x28f # VOIP对讲停止
MINOR_WIN_TOP = 0x290 # 电视墙窗口置顶
MINOR_WIN_BOTTOM = 0x291 # 电视墙窗口置底
MINOR_SET_USER_ADD_CFG = 0x292 # 增加用户
MINOR_SET_USER_MODF_CFG = 0x293 # 修改用户
MINOR_SET_USER_DEL_CFG = 0x294 # 删除用户

#  Netra 2.2.2
MINOR_LOCAL_LOAD_HDISK = 0x300 # 本地加载硬盘
MINOR_LOCAL_DELETE_HDISK = 0x301 # 本地删除异常不存在的硬盘

# KY2013 3.0.0
MINOR_LOCAL_MAIN_AUXILIARY_PORT_SWITCH = 0X302 # 本地主辅口切换
MINOR_LOCAL_HARD_DISK_CHECK = 0x303 # 本地物理硬盘自检

# Netra3.1.0
MINOR_LOCAL_CFG_DEVICE_TYPE = 0x310 # 本地配置设备类型
MINOR_REMOTE_CFG_DEVICE_TYPE = 0x311 # 远程配置设备类型
MINOR_LOCAL_CFG_WORK_HOT_SERVER = 0x312 # 本地配置工作机热备服务器
MINOR_REMOTE_CFG_WORK_HOT_SERVER = 0x313 # 远程配置工作机热备服务器
MINOR_LOCAL_DELETE_WORK = 0x314 # 本地删除工作机
MINOR_REMOTE_DELETE_WORK = 0x315 # 远程删除工作机
MINOR_LOCAL_ADD_WORK = 0x316 # 本地添加工作机
MINOR_REMOTE_ADD_WORK = 0x317 # 远程添加工作机
MINOR_LOCAL_IPCHEATMAP_OUTPUT = 0x318 #  本地导出热度图文件
MINOR_LOCAL_IPCHEATFLOW_OUTPUT = 0x319 #  本地导出热度流量文件
MINOR_REMOTE_SMS_SEND = 0x350 # 远程发送短信
MINOR_LOCAL_SMS_SEND = 0x351 # 本地发送短信
MINOR_ALARM_SMS_SEND = 0x352 # 发送短信报警
MINOR_SMS_RECV = 0x353 # 接收短信
# （备注：0x350、0x351是指人工在GUI或IE控件上编辑并发送短信）
MINOR_LOCAL_SMS_SEARCH = 0x354 # 本地搜索短信
MINOR_REMOTE_SMS_SEARCH = 0x355 # 远程搜索短信
MINOR_LOCAL_SMS_READ = 0x356 # 本地查看短信
MINOR_REMOTE_SMS_READ = 0x357 # 远程查看短信
MINOR_REMOTE_DIAL_CONNECT = 0x358 # 远程开启手动拨号
MINOR_REMOTE_DIAL_DISCONN = 0x359 # 远程停止手动拨号
MINOR_LOCAL_WHITELIST_SET = 0x35A # 本地配置白名单
MINOR_REMOTE_WHITELIST_SET = 0x35B # 远程配置白名单
MINOR_LOCAL_DIAL_PARA_SET = 0x35C # 本地配置拨号参数
MINOR_REMOTE_DIAL_PARA_SET = 0x35D # 远程配置拨号参数
MINOR_LOCAL_DIAL_SCHEDULE_SET = 0x35E # 本地配置拨号计划
MINOR_REMOTE_DIAL_SCHEDULE_SET = 0x35F # 远程配置拨号计划
MINOR_PLAT_OPER = 0x360 #  平台操作
MINOR_REMOTE_CFG_POE_WORK_MODE = 0x361 # 远程设置POE工作模式
MINOR_LOCAL_CFG_POE_WORK_MODE = 0x362 # 本地设置POE工作模式
MINOR_REMOTE_CFG_FACE_CONTRAST = 0x363 # 远程设置人脸比对配置
MINOR_LOCAL_CFG_FACE_CONTRAST = 0x364 # 本地设置人脸比对配置
MINOR_REMOTE_CFG_WHITELIST_FACE_CONTRAST = 0x365 # 远程设置白名单人脸比对配置
MINOR_LOCAL_CFG_WHITELIST_FACE_CONTRAST = 0x366 # 本地设置白名单人脸比对配置
MINOR_LOCAL_CHECK_TIME = 0x367 # 本地手动校时
MINOR_VCA_ONEKEY_EXPORT_PICTURE = 0x368 # 一键导出图片
MINOR_VCA_ONEKEY_DELETE_PICTURE = 0x369 # 一键删除图片
MINOR_VCA_ONEKEY_EXPORT_VIDEO = 0x36a # 一键导出录像
MINOR_VCA_ONEKEY_DELETE_VIDEO = 0x36b # 一键删除录像
MINOR_REMOTE_CFG_WIRELESS_DIALPARAM = 0x36c # 远程配置无线拨号参数
MINOR_LOCAL_CFG_WIRELESS_DIALPARAM = 0x36d # 本地配置无线拨号参数
MINOR_REMOTE_CFG_WIRELESS_SMSPARAM = 0x36e # 远程配置无线短信配置参数
MINOR_LOCAL_CFG_WIRELESS_SMSPARAM = 0x36f # 本地配置无线短信配置参数
MINOR_REMOTE_CFG_WIRELESS_SMSSElFHELP = 0x370 # 远程配置无线短信自助配置参数
MINOR_LOCAL_CFG_WIRELESS_SMSSElFHELP = 0x371 # 本地配置无线短信自助配置参数
MINOR_REMOTE_CFG_WIRELESS_NETFLOWPARAM = 0x372 # 远程配置无线流量配置参数
MINOR_LOCAL_CFG_WIRELESS_NETFLOWPARAM = 0x373 # 本地配置无线流量配置参数

# 0x400-0x1000 门禁操作类型
MINOR_REMOTE_OPEN_DOOR = 0x400 # 远程开门
MINOR_REMOTE_CLOSE_DOOR = 0x401 # 远程关门(受控)
MINOR_REMOTE_ALWAYS_OPEN = 0x402 # 远程常开(自由)
MINOR_REMOTE_ALWAYS_CLOSE = 0x403 # 远程常关(禁用)
MINOR_REMOTE_CHECK_TIME = 0x404 # 远程手动校时
MINOR_NTP_CHECK_TIME = 0x405 # NTP自动校时
MINOR_REMOTE_CLEAR_CARD = 0x406 # 远程清空卡号
MINOR_REMOTE_RESTORE_CFG = 0x407 # 远程恢复默认参数
MINOR_ALARMIN_ARM = 0x408 # 防区布防
MINOR_ALARMIN_DISARM = 0x409 # 防区撤防
MINOR_LOCAL_RESTORE_CFG = 0x40a # 本地恢复默认参数
MINOR_REMOTE_CAPTURE_PIC = 0x40b # 远程抓拍
MINOR_MOD_NET_REPORT_CFG = 0x40c # 修改网络中心参数配置
MINOR_MOD_GPRS_REPORT_PARAM = 0x40d # 修改GPRS中心参数配置
MINOR_MOD_REPORT_GROUP_PARAM = 0x40e # 修改中心组参数配置
MINOR_UNLOCK_PASSWORD_OPEN_DOOR = 0x40f # 解除码输入
MINOR_AUTO_RENUMBER = 0x410 # 自动重新编号
MINOR_AUTO_COMPLEMENT_NUMBER = 0x411 # 自动补充编号
MINOR_NORMAL_CFGFILE_INPUT = 0x412 # 导入普通配置文件
MINOR_NORMAL_CFGFILE_OUTTPUT = 0x413 # 导出普通配置文件
MINOR_CARD_RIGHT_INPUT = 0x414 # 导入卡权限参数
MINOR_CARD_RIGHT_OUTTPUT = 0x415 # 导出卡权限参数
MINOR_LOCAL_USB_UPGRADE = 0x416 # 本地U盘升级
MINOR_REMOTE_VISITOR_CALL_LADDER = 0x417 # 访客呼梯
MINOR_REMOTE_HOUSEHOLD_CALL_LADDER = 0x418 # 住户呼梯
MINOR_REMOTE_ACTUAL_GUARD = 0x419 # 远程实时布防
MINOR_REMOTE_ACTUAL_UNGUARD = 0x41a # 远程实时撤防
MINOR_REMOTE_CONTROL_NOT_CODE_OPER_FAILED = 0x41b # 遥控器未对码操作失败
MINOR_REMOTE_CONTROL_CLOSE_DOOR = 0x41c # 遥控器关门
MINOR_REMOTE_CONTROL_OPEN_DOOR = 0x41d # 遥控器开门
MINOR_REMOTE_CONTROL_ALWAYS_OPEN_DOOR = 0x41e # 遥控器常开门
MINOR_M1_CARD_ENCRYPT_VERIFY_OPEN = 0x41f # M1卡加密验证功能开启
MINOR_M1_CARD_ENCRYPT_VERIFY_CLOSE = 0x420 # M1卡加密验证功能关闭
MINOR_NFC_FUNCTION_OPEN = 0x421 # NFC开门功能开启
MINOR_NFC_FUNCTION_CLOSE = 0x422 # NFC开门功能关闭
MINOR_OFFLINE_DATA_OUTPUT = 0x423 # 离线采集数据导出
MINOR_CREATE_SSH_LINK = 0x42d # 建立SSH连接
MINOR_CLOSE_SSH_LINK = 0x42e # 断开SSH连接

MINOR_OPERATION_CUSTOM1 = 0x900 # 门禁自定义操作1
MINOR_OPERATION_CUSTOM2 = 0x901 # 门禁自定义操作2
MINOR_OPERATION_CUSTOM3 = 0x902 # 门禁自定义操作3
MINOR_OPERATION_CUSTOM4 = 0x903 # 门禁自定义操作4
MINOR_OPERATION_CUSTOM5 = 0x904 # 门禁自定义操作5
MINOR_OPERATION_CUSTOM6 = 0x905 # 门禁自定义操作6
MINOR_OPERATION_CUSTOM7 = 0x906 # 门禁自定义操作7
MINOR_OPERATION_CUSTOM8 = 0x907 # 门禁自定义操作8
MINOR_OPERATION_CUSTOM9 = 0x908 # 门禁自定义操作9
MINOR_OPERATION_CUSTOM10 = 0x909 # 门禁自定义操作10
MINOR_OPERATION_CUSTOM11 = 0x90a # 门禁自定义操作11
MINOR_OPERATION_CUSTOM12 = 0x90b # 门禁自定义操作12
MINOR_OPERATION_CUSTOM13 = 0x90c # 门禁自定义操作13
MINOR_OPERATION_CUSTOM14 = 0x90d # 门禁自定义操作14
MINOR_OPERATION_CUSTOM15 = 0x90e # 门禁自定义操作15
MINOR_OPERATION_CUSTOM16 = 0x90f # 门禁自定义操作16
MINOR_OPERATION_CUSTOM17 = 0x910 # 门禁自定义操作17
MINOR_OPERATION_CUSTOM18 = 0x911 # 门禁自定义操作18
MINOR_OPERATION_CUSTOM19 = 0x912 # 门禁自定义操作19
MINOR_OPERATION_CUSTOM20 = 0x913 # 门禁自定义操作20
MINOR_OPERATION_CUSTOM21 = 0x914 # 门禁自定义操作21
MINOR_OPERATION_CUSTOM22 = 0x915 # 门禁自定义操作22
MINOR_OPERATION_CUSTOM23 = 0x916 # 门禁自定义操作23
MINOR_OPERATION_CUSTOM24 = 0x917 # 门禁自定义操作24
MINOR_OPERATION_CUSTOM25 = 0x918 # 门禁自定义操作25
MINOR_OPERATION_CUSTOM26 = 0x919 # 门禁自定义操作26
MINOR_OPERATION_CUSTOM27 = 0x91a # 门禁自定义操作27
MINOR_OPERATION_CUSTOM28 = 0x91b # 门禁自定义操作28
MINOR_OPERATION_CUSTOM29 = 0x91c # 门禁自定义操作29
MINOR_OPERATION_CUSTOM30 = 0x91d # 门禁自定义操作30
MINOR_OPERATION_CUSTOM31 = 0x91e # 门禁自定义操作31
MINOR_OPERATION_CUSTOM32 = 0x91f # 门禁自定义操作32
MINOR_OPERATION_CUSTOM33 = 0x920 # 门禁自定义操作33
MINOR_OPERATION_CUSTOM34 = 0x921 # 门禁自定义操作34
MINOR_OPERATION_CUSTOM35 = 0x922 # 门禁自定义操作35
MINOR_OPERATION_CUSTOM36 = 0x923 # 门禁自定义操作36
MINOR_OPERATION_CUSTOM37 = 0x924 # 门禁自定义操作37
MINOR_OPERATION_CUSTOM38 = 0x925 # 门禁自定义操作38
MINOR_OPERATION_CUSTOM39 = 0x926 # 门禁自定义操作39
MINOR_OPERATION_CUSTOM40 = 0x927 # 门禁自定义操作40
MINOR_OPERATION_CUSTOM41 = 0x928 # 门禁自定义操作41
MINOR_OPERATION_CUSTOM42 = 0x929 # 门禁自定义操作42
MINOR_OPERATION_CUSTOM43 = 0x92a # 门禁自定义操作43
MINOR_OPERATION_CUSTOM44 = 0x92b # 门禁自定义操作44
MINOR_OPERATION_CUSTOM45 = 0x92c # 门禁自定义操作45
MINOR_OPERATION_CUSTOM46 = 0x92d # 门禁自定义操作46
MINOR_OPERATION_CUSTOM47 = 0x92e # 门禁自定义操作47
MINOR_OPERATION_CUSTOM48 = 0x92f # 门禁自定义操作48
MINOR_OPERATION_CUSTOM49 = 0x930 # 门禁自定义操作49
MINOR_OPERATION_CUSTOM50 = 0x931 # 门禁自定义操作50
MINOR_OPERATION_CUSTOM51 = 0x932 # 门禁自定义操作51
MINOR_OPERATION_CUSTOM52 = 0x933 # 门禁自定义操作52
MINOR_OPERATION_CUSTOM53 = 0x934 # 门禁自定义操作53
MINOR_OPERATION_CUSTOM54 = 0x935 # 门禁自定义操作54
MINOR_OPERATION_CUSTOM55 = 0x936 # 门禁自定义操作55
MINOR_OPERATION_CUSTOM56 = 0x937 # 门禁自定义操作56
MINOR_OPERATION_CUSTOM57 = 0x938 # 门禁自定义操作57
MINOR_OPERATION_CUSTOM58 = 0x939 # 门禁自定义操作58
MINOR_OPERATION_CUSTOM59 = 0x93a # 门禁自定义操作59
MINOR_OPERATION_CUSTOM60 = 0x93b # 门禁自定义操作60
MINOR_OPERATION_CUSTOM61 = 0x93c # 门禁自定义操作61
MINOR_OPERATION_CUSTOM62 = 0x93d # 门禁自定义操作62
MINOR_OPERATION_CUSTOM63 = 0x93e # 门禁自定义操作63
MINOR_OPERATION_CUSTOM64 = 0x93f # 门禁自定义操作64

MINOR_SET_WIFI_PARAMETER = 0x950 # 设置WIFI配置参数
MINOR_EZVIZ_LOGIN = 0x951 # 萤石云登陆
MINOR_EZVIZ_LOGINOUT = 0x952 # 萤石云登出
MINOR_LOCK_ADD = 0x953 # 智能锁添加
MINOR_LOCK_DELETE = 0x954 # 智能锁删除
MINOR_LOCK_GET_STATUS = 0x955 # 智能锁状态获取
MINOR_LOCK_SET_TMP_PASSWORD = 0x956 # 智能锁临时密码下发
MINOR_LOCK_SET_SILENT_MODE = 0x957 # 智能锁静音设置
MINOR_LOCK_SET_LATE_WARNING = 0x958 # 智能锁晚归提醒设置
MINOR_LOCK_IPC_ADD = 0x959 # 智能锁IPC关联
MINOR_LOCK_IPC_REMOVE = 0x95a # 智能锁IPC解除关联
MINOR_LOCK_DETECTOR_ADD = 0x95b # 智能锁探测器关联
MINOR_LOCK_DETECTOR_REMOVE = 0x95c # 智能锁探测器解除关联
MINOR_LOCK_MESSAGE_REMINDING_OPEN = 0x95d # 智能锁消息提醒打开
MINOR_LOCK_MESSAGE_REMINDING_CLOSE = 0x95e # 智能锁消息提醒关闭
MINOR_LOCK_SET_HEART_BEAT = 0x95f # 智能锁心跳设置
MINOR_LOCK_REBOOT = 0x960 # 智能锁重启
MINOR_LOCK_CLEAR_USER = 0x961 # 智能锁清空用户
MINOR_LOCK_FORMAT = 0x962 # 智能锁格式化
MINOR_LOCK_FINGER_CHANGE = 0x963 # 智能锁指纹改动
MINOR_LOCK_PASSWORD_CHANGE = 0x964 # 智能锁密码改动
MINOR_LOCK_CARD_CHANGE = 0x965 # 智能锁卡信息改动
MINOR_LOCK_USER_CHANGE = 0x966 # 智能锁用户信息改动
MINOR_LOCK_SYSTEM_CHANGE = 0x967 # 智能锁系统信息改动
MINOR_LOCK_CHANGE_ADD_UESR = 0x968 # 智能锁新增用户
MINOR_LOCK_CHANGE_DEL_UESR = 0x969 # 智能锁删除用户
MINOR_LOCK_CHANGE_CUSTOM_USER_NAME = 0x96a # 智能锁自定义用户用户名改动
MINOR_LOCK_CHANGE_REMOTE_DEVICE = 0x96b # 智能锁遥控器信息改动
MINOR_LOCK_CHANGE_ADD_FP = 0x96c # 智能锁新增指纹
MINOR_LOCK_CHANGE_DEL_FP = 0x96d # 智能锁删除指纹
MINOR_LOCK_CHANGE_ADD_PASSWORD = 0x96e # 智能锁新增密码
MINOR_LOCK_CHANGE_DEL_PASSWORD = 0x96f # 智能锁删除密码
MINOR_LOCK_CHANGE_ADD_CARD = 0x970 # 智能锁新增卡片
MINOR_LOCK_CHANGE_DEL_CARD = 0x971 # 智能锁删除卡片
MINOR_LOCK_NETWORK_SWITCH = 0x972 # 智能锁网络功能开关改动
MINOR_LOCK_CLEAR_NETWORK_DATA = 0x973 # 智能锁网络数据清空
MINOR_LOCK_CLEAR_HOST_USER = 0x974 # 智能锁清空主人用户
MINOR_LOCK_CLEAR_GUEST_USER = 0x975 # 智能锁清空客人用户
MINOR_LOCK_CLEAN_ALL_REMOTE_DEVICE = 0x976 # 遥控器用户信息清空
MINOR_LOCK_CLEAN_NORMAL_USER_FINGRT = 0x977 # 智能锁清空普通用户指纹
MINOR_LOCK_CLEAN_ALL_CARD = 0x978 # 智能锁清空所有卡片
MINOR_LOCK_CLEAN_ALL_PASSWORD = 0x979 # 智能锁清空所有密码
MINOR_START_WIRELESSSERVER = 0x97a # 开启设备热点
MINOR_STOP_WIRELESSSERVER = 0x97b # 关闭设备热点
MINOR_EMERGENCY_CARD_AUTH_NORMAL_CARD = 0x97c # 应急管理卡授权普通卡
MINOR_CHANGE_ALWAYS_OPEN_RIGHT = 0x97d # 通道模式改动
MINOR_LOCK_DOOR_BELL_EVENT = 0x97e # 门铃事件（操作锁触发）

# 传显信息发布操作日志
MINOR_BACKUP_DATA = 0xc41 # 数据备份
MINOR_TRANSFER_DATA = 0xc42 # 数据迁移
MINOR_RESTORE_DATA = 0xc43 # 数据还原
MINOR_SET_INPUT_PLAN = 0xc44 # 设置终端定时输入切换计划
MINOR_TERMINAL_ADB = 0xc45 # 终端ADB配置
MINOR_TERMINAL_VOLUME = 0xc46 # 终端音量配置
MINOR_TERMINAL_LOGO = 0xc47 # 终端LOGO配置
MINOR_TERMINAL_DEFAULT_SCHEDULE = 0xc48 # 垫片日程使能
MINOR_TERMINAL_PASSWORD = 0xc49 # 设置终端密码
MINOR_TERMINAL_IP = 0xc4a # 终端IP配置
MINOR_TERMINAL_RELATE_IPC = 0xc4b # 终端关联IPC
MINOR_TERMINAL_SERVER = 0xc4c # 终端关联服务器配置
MINOR_TERMINAL_SADP = 0xc4d # 终端SADP开关配置
MINOR_TERMINAL_TIMEZONE = 0xc4e # 终端时区配置
MINOR_TERMINAL_TEMP_PROTECT = 0xc4f # 终端温度保护配置
MINOR_ADD_ORGANIZATION = 0xc50 # 添加组织
MINOR_DELETE_ORGANIZATION = 0xc51 # 删除组织
MINOR_MODIFY_ORGANIZATION = 0xc52 # 修改组织
MINOR_WEATHER_FACTORY = 0xc53 # 天气厂商配置
MINOR_SADP_ENABLE = 0xc54 # sadp开关配置
MINOR_SSH_ENABLE = 0xc55 # SSH开关配置
MINOR_MODIFY_MATERIAL = 0xc56 # 素材参数修改
MINOR_INSERT_CHARACTER = 0xc57 # 插播文字消息
MINOR_TERMINAL_BACKLIGHT = 0xc58 # 终端背光配置
MINOR_DOWNLOAD_MATERIAL_THUMBNAIL = 0xc59 # 下载素材缩略图
MINOR_UPLOAD_PROGRAM_THUMBNAIL = 0xc5a # 上传节目缩略图
MINOR_TDOWNLOAD_PROGRAM_THUMBNAIL = 0xc5b # 下载节目缩略图
MINOR_BATCH_DELETE_SCHEDULE_PLAN = 0xc5c # 批量删除发布计划
MINOR_REPUBLISH = 0xc5d # 重新发布
MINOR_CLEAR_TERMINAL_PLAY_INFO = 0xc5e # 清空终端播放信息
MINOR_GET_TERMINAL_RESOLUTION = 0xc5f # 获取终端分辨率
MINOR_SET_TERMINAL_RESOLUTION = 0xc60 # 设置终端分辨率
MINOR_GET_BATCH_TERMINAL_UPGRATE_PROGRESS = 0xc61 # 批量获取终端升级进度
MINOR_GET_BATCH_PROGRESS = 0xc62 # 批量获取终端发布进度
MINOR_GET_TEMPLATE = 0xc64 # 获取模板
MINOR_INIT_TEMPLATE = 0xc65 # 初始化模板
MINOR_GET_TERMINAL_NTP_SERVERS = 0xc66 # 获取终端NTP服务
MINOR_SET_TERMINAL_NTP_SERVERS = 0xc67 # 设置终端NTP服务
MINOR_GET_RELEASE_DETAILS = 0xc68 # 获取发布详细信息
MINOR_UPLOAD_TEMPLATE_THUMBNAIL = 0xc69 # 上传模板缩略图
MINOR_DOWNLOAD_TEMPLATE_THUMBNAIL = 0xc6a # 下载模板缩略图
MINOR_ADD_TEMPLATE = 0xc6b # 添加模板
MINOR_DELETE_TEMPLATE = 0xc6c # 删除模板
MINOR_MODIFY_TEMPLATE = 0xc6d # 修改模板
MINOR_ADD_SCHEDULE_PLAN = 0xc6e # 添加发布计划
MINOR_MODIFY_SCHEDULE_PLAN = 0xc6f # 修改发布计划
MINOR_CANCEL_SCHEDULE_RELEASE = 0xc70 # 取消日程发布
MINOR_GET_SCHEDULE = 0xc71 # 获取日程
MINOR_ADD_INSERT = 0xc72 # 新建插播
MINOR_CANCEL_INSERT = 0xc73 # 取消插播
MINOR_SWITCH_LANGUAGE = 0xc74 # 切换语言
MINOR_SET_ADMIN_INITIAL_PASSWORD = 0xc75 # 设置admin初始密码
MINOR_MODIFY_PORT = 0xc76 # 修改端口
MINOR_MODIFY_STORAGE_PATH = 0xc77 # 修改存储路径
MINOR_EXIT_PROGRAM = 0xc78 # 退出程序
MINOR_MODULE_STARTUP_SUCCESS = 0xc79 # 模块启动成功
MINOR_APPROVE_SCHEDULE = 0xc80 # 日程审核
MINOR_GENERAL_DATA_SEND = 0xc81 # 第三方数据下发
MINOR_SET_SIGN_INTERFACE = 0xc82 # 配置签到界面参数
MINOR_GET_SIGN_INTERFACE = 0xc83 # 获取签到界面参数
MINOR_SET_SHOW_MODE = 0xc84 # 配置显示模式参数
MINOR_GET_SHOW_MODE = 0xc85 # 获取显示模式参数
MINOR_SET_SCREEN_DIRECTION = 0xc86 # 配置屏幕方向参数
MINOR_GET_SCREEN_DIRECTION = 0xc87 # 获取屏幕方向参数
MINOR_SET_LOCK_SCREEN = 0xc88 # 配置锁屏参数
MINOR_GET_LOCK_SCREEN = 0xc89 # 获取锁屏参数
MINOR_SET_FACE_DATA_LIB = 0xc8a # 配置人脸库参数
MINOR_DELETE_FACE_DATA_LIB = 0xc8b # 删除人脸库
MINOR_SET_SPEC_FACE_DATA_LIB = 0xc8c # 配置指定人脸库参数
MINOR_DELETE_SPEC_FACE_DATA_LIB = 0xc8d # 删除指定人脸库参数
MINOR_ADD_FACE_DATA = 0xc8e # 添加人脸数据
MINOR_SEARCH_FACE_DATA = 0xc8f # 查询人脸数据
MINOR_MODIFY_FACE_DATA = 0xc90 # 修改人脸数据
MINOR_DELETE_FACE_DATA = 0xc91 # 删除人脸数据
MINOR_DELETE_USERINFO_DETAIL = 0xc92 # 人员信息及权限删除
MINOR_ADD_USERINFO = 0xc93 # 添加人员信息
MINOR_MODIFY_USERINFO = 0xc94 # 修改人员信息
MINOR_DELETE_USERINFO = 0xc95 # 删除人员信息
MINOR_ADD_CARD_INFO = 0xc96 # 添加卡信息
MINOR_MODIFY_CARD_INFO = 0xc97 # 修改卡信息
MINOR_DELETE_CARD_INFO = 0xc98 # 删除卡信息
MINOR_SET_USER_RIGHT_WEEK = 0xc99 # 人员权限周计划设置
MINOR_SET_USER_RIGHT_HOLIDAY = 0xc9a # 人员权限节日计划设置
MINOR_SET_USER_RIGHT_HOLIDAYGROUP = 0xc9b # 人员权限假日组计划设置
MINOR_SET_USER_RIGHT_TEMPLATE = 0xc9c # 人员权限计划模板设置

# 2012-03-05 ITC操作日志类型
MINOR_SET_TRIGGERMODE_CFG = 0x1001 # 设置触发模式参数
MINOR_GET_TRIGGERMODE_CFG = 0x1002 # 获取触发模式参数
MINOR_SET_IOOUT_CFG = 0x1003 # 设置IO输出参数
MINOR_GET_IOOUT_CFG = 0x1004 # 获取IO输出参数
MINOR_GET_TRIGGERMODE_DEFAULT = 0x1005 # 获取触发模式推荐参数
MINOR_GET_ITCSTATUS = 0x1006 # 获取状态检测参数
MINOR_SET_STATUS_DETECT_CFG = 0x1007 # 设置状态检测参数
MINOR_GET_STATUS_DETECT_CFG = 0x1008 # 获取状态检测参数
MINOR_SET_VIDEO_TRIGGERMODE_CFG = 0x1009 # 设置视频触发模式参数
MINOR_GET_VIDEO_TRIGGERMODE_CFG = 0x100a # 获取视频触发模式参数

# 2018-04-23 通用物联网关操作日志类型
MINOR_ALARMHOST_GUARD = 0x1010 # 普通布防(外出布防)
MINOR_ALARMHOST_UNGUARD = 0x1011 # 普通撤防
MINOR_ALARMHOST_BYPASS = 0x1012 # 旁路
MINOR_ALARMHOST_DURESS_ACCESS = 0x1013 # 挟持

MINOR_ALARMHOST_RS485_PARAM = 0x1018 # 修改485配置参数
MINOR_ALARMHOST_ALARM_OUTPUT = 0x1019 # 控制触发器
MINOR_ALARMHOST_ACCESS_OPEN = 0x101a # 控制门禁开
MINOR_ALARMHOST_ACCESS_CLOSE = 0x101b # 控制门禁关
MINOR_ALARMHOST_SIREN_OPEN = 0x101c # 控制警号开
MINOR_ALARMHOST_SIREN_CLOSE = 0x101d # 控制警号关
MINOR_ALARMHOST_MOD_ZONE_CONFIG = 0x101e # 修改防区参数
MINOR_ALARMHOST_MOD_ALARMOUT_CONIFG = 0x101f # 修改触发器参数
MINOR_ALARMHOST_MOD_ANALOG_CONFIG = 0x1020 # 修改模拟量配置
MINOR_ALARMHOST_RS485_CONFIG = 0x1021 # 修改485通道配置
MINOR_ALARMHOST_PHONE_CONFIG = 0x1022 # 修改拨号配置
MINOR_ALARMHOST_ADD_ADMIN = 0x1023 # 增加管理员
MINOR_ALARMHOST_MOD_ADMIN_PARAM = 0x1024 # 修改管理员参数
MINOR_ALARMHOST_DEL_ADMIN = 0x1025 # 删除管理员
MINOR_ALARMHOST_ADD_NETUSER = 0x1026 # 增加后端操作员
MINOR_ALARMHOST_MOD_NETUSER_PARAM = 0x1027 # 修改后端操作员参数
MINOR_ALARMHOST_DEL_NETUSER = 0x1028 # 删除后端操作员
MINOR_ALARMHOST_ADD_OPERATORUSER = 0x1029 # 增加前端操作员
MINOR_ALARMHOST_MOD_OPERATORUSER_PW = 0x102a # 修改前端操作员密码
MINOR_ALARMHOST_DEL_OPERATORUSER = 0x102b # 删除前端操作员
MINOR_ALARMHOST_ADD_KEYPADUSER = 0x102c # 增加键盘/读卡器用户
MINOR_ALARMHOST_DEL_KEYPADUSER = 0x102d # 删除键盘/读卡器用户


MINOR_ALARMHOST_MOD_HOST_CONFIG = 0x1032 # 修改主机配置
MINOR_ALARMHOST_RESTORE_BYPASS = 0x1033 # 旁路恢复

MINOR_ALARMHOST_ALARMOUT_OPEN = 0x1034 # 触发器开启
MINOR_ALARMHOST_ALARMOUT_CLOSE = 0x1035 # 触发器关闭
MINOR_ALARMHOST_MOD_SUBSYSTEM_PARAM = 0x1036 # 修改子系统参数配置
MINOR_ALARMHOST_GROUP_BYPASS = 0x1037 # 组旁路
MINOR_ALARMHOST_RESTORE_GROUP_BYPASS = 0x1038 # 组旁路恢复
MINOR_ALARMHOST_MOD_GRPS_PARAM = 0x1039 # 修改GPRS参数

MINOR_ALARMHOST_MOD_REPORT_MOD = 0x103b # 修改上传方式配置
MINOR_ALARMHOST_MOD_GATEWAY_PARAM = 0x103c # 修改门禁参数配置

MINOR_STAY_ARM = 0x104c # 留守布防
MINOR_QUICK_ARM = 0x104d # 即时布防
MINOR_AUTOMATIC_ARM = 0x104e # 自动布防
MINOR_AUTOMATIC_DISARM = 0x104f # 自动撤防
MINOR_KEYSWITCH_ARM = 	0x1050 # 钥匙布撤防防区布防
MINOR_KEYSWITCH_DISARM = 0x1051 # 钥匙布撤防防区撤防
MINOR_CLEAR_ALARM = 0x1052 # 消警
MINOR_MOD_FAULT_CFG = 0x1053 # 修改系统故障配置
MINOR_MOD_EVENT_TRIGGER_ALARMOUT_CFG = 0x1054 # 修改事件触发触发器配置
MINOR_SEARCH_EXTERNAL_MODULE = 0x1055 # 搜索外接模块
MINOR_REGISTER_EXTERNAL_MODULE = 0x1056 # 重新注册外接模块
MINOR_CLOSE_KEYBOARD_ALARM = 0x1057 # 关闭键盘报警提示音
MINOR_MOD_3G_PARAM = 0x1058 # 修改3G参数
MINOR_MOD_PRINT_PARAM = 0x1059 # 修改打印机参数
MINOR_ALARMHOST_SD_CARD_FORMAT = 0x1060 # SD卡格式化
MINOR_ALARMHOST_SUBSYSTEM_UPGRADE = 0x1061 # 子板固件升级

MINOR_PLAN_ARM_CFG = 0x1062 # 计划布撤防参数配置
MINOR_PHONE_ARM = 0x1063 # 手机布防
MINOR_PHONE_STAY_ARM = 0x1064 # 手机留守布防
MINOR_PHONE_QUICK_ARM = 0x1065 # 手机即时布防
MINOR_PHONE_DISARM = 0x1066 # 手机撤防
MINOR_PHONE_CLEAR_ALARM = 0x1067 # 手机消警
MINOR_WHITELIST_CFG = 0x1068 # 白名单配置
MINOR_TIME_TRIGGER_CFG = 0x1069 # 定时开关触发器配置
MINOR_CAPTRUE_CFG = 0x106a # 抓图参数配置
MINOR_TAMPER_CFG = 0x106b # 防区防拆参数配置

MINOR_REMOTE_KEYPAD_UPGRADE = 0x106c # 远程升级键盘
MINOR_ONETOUCH_AWAY_ARMING = 0x106d # 一键外出布防
MINOR_ONETOUCH_STAY_ARMING = 0x106e # 一键留守布防
MINOR_SINGLE_PARTITION_ARMING_OR_DISARMING = 0x106f # 单防区布撤防
MINOR_CARD_CONFIGURATION = 0x1070 # 卡参数配置
MINOR_CARD_ARMING_OR_DISARMING = 0x1071 # 刷卡布撤防
MINOR_EXPENDING_NETCENTER_CONFIGURATION = 0x1072 # 扩展网络中心配置
MINOR_NETCARD_CONFIGURATION = 0x1073 # 网卡配置
MINOR_DDNS_CONFIGURATION = 0x1074 # DDNS配置
MINOR_RS485BUS_CONFIGURATION = 0x1075 #  485总线参数配置
MINOR_RS485BUS_RE_REGISTRATION = 0x1076 # 485总线重新注册

MINOR_REMOTE_OPEN_ELECTRIC_LOCK = 0x1077 # 远程打开电锁
MINOR_REMOTE_CLOSE_ELECTRIC_LOCK = 0x1078 # 远程关闭电锁
MINOR_LOCAL_OPEN_ELECTRIC_LOCK = 0x1079 # 本地打开电锁
MINOR_LOCAL_CLOSE_ELECTRIC_LOCK = 0x107a # 本地关闭电锁
MINOR_OPEN_ALARM_LAMP = 0x107b # 打开警灯(远程)
MINOR_CLOSE_ALARM_LAMP = 0x107c # 关闭警灯(远程)


MINOR_TEMPORARY_PASSWORD = 0x107d # 临时密码操作记录

MINOR_HIDDNS_CONFIG = 0x1082 #  HIDDNS配置
MINOR_REMOTE_KEYBOARD_UPDATA = 0x1083 # 远程键盘升级日志
MINOR_ZONE_ADD_DETECTOR = 0x1084 # 防区添加探测器
MINOR_ZONE_DELETE_DETECTOR = 0x1085 # 防区删除探测器
MINOR_QUERY_DETECTOR_SIGNAL = 0x1086 # 主机查询探测器信号强度
MINOR_QUERY_DETECTOR_BATTERY = 0x1087 # 主机查询探测器电量
MINOR_SET_DETECTOR_GUARD = 0x1088 # 探测器布防
MINOR_SET_DETECTOR_UNGUARD = 0x1089 # 探测器撤防
MINOR_WIRELESS_CONFIGURATION = 0x108a # 无线参数配置
MINOR_OPEN_VOICE = 0x108b # 打开语音
MINOR_CLOSE_VOICE = 0x108c # 关闭语音
MINOR_ENABLE_FUNCTION_KEY = 0x108d # 启用功能键
MINOR_DISABLE_FUNCTION_KEY = 0x108e # 关闭功能键
MINOR_READ_CARD = 0x108f # 巡更刷卡
MINOR_START_BROADCAST = 0x1090 # 打开语音广播
MINOR_STOP_BROADCAST = 0x1091 # 关闭语音广播
MINOR_REMOTE_ZONE_MODULE_UPGRADE = 0x1092 # 远程升级防区模块
MINOR_NETWORK_MODULE_EXTEND = 0x1093 # 网络模块参数配置
MINOR_ADD_CONTROLLER = 	0x1094 # 添加遥控器用户
MINOR_DELETE_CONTORLLER = 	0x1095 # 删除遥控器用户
MINOR_REMOTE_NETWORKMODULE_UPGRADE = 0x1096 # 远程升级网络模块
MINOR_WIRELESS_OUTPUT_ADD = 0x1097 # 注册无线输出模块
MINOR_WIRELESS_OUTPUT_DEL = 0x1098 # 删除无线输出模块
MINOR_WIRELESS_REPEATER_ADD = 0x1099 # 注册无线中继器
MINOR_WIRELESS_REPEATER_DEL = 0x109a # 删除无线中继器
MINOR_PHONELIST_CFG = 0x109b # 电话名单参数配置
MINOR_RF_SIGNAL_CHECK = 0x109c #  RF信号查询
MINOR_USB_UPGRADE = 0x109d #  USB升级
MINOR_DOOR_TIME_REMINDER_CFG = 0x109f # 门磁定时提醒参数配置
MINOR_WIRELESS_SIREN_ADD = 0x1100 # 注册无线警号
MINOR_WIRELESS_SIREN_DEL = 0x1101 # 删除无线警号
MINOR_OUT_SCALE_OPEN = 0x1102 # 辅电开启
MINOR_OUT_SCALE_CLOSE = 0x1103 # 辅电关闭

MINOR_ALARMHOST_4G_MODULS_START = 0x1108 # 4G模块启用
MINOR_ALARMHOST_4G_MODULS_STOP = 0x1109 # 4G模块停用

MINOR_EZVIZ_CLOUD_START = 0x1110 # 萤石云启用
MINOR_EZVIZ_CLOUD_STOP = 0x1111 # 萤石云停用
MINOR_SIPUA_GRID_START = 0x1112 # 国网B启用
MINOR_SIPUA_GRID_STOP = 0x1113 # 国网B停用

MINOR_MODBUS_FILE_DOWNLOAD = 0x1114 # 导出modbus协议配置文件
MINOR_MODBUS_FILE_UPLOAD = 0x1115 # 导入modbus协议配置文件

MINOR_RS485_DLL_FILE_DOWNLOAD = 0x1116 # 导出485协议库文件
MINOR_RS485_DLL_FLIE_UPLOAD = 0x1117 # 导入485协议库文件
MINOR_TX1_REBOOT = 0x1118 # TX1系统正常重启

MINOR_LORA_PARAM = 0x1119 # LoRa参数
MINOR_GB28181_PLATE_CFG_PARAM = 0x111a # 国标平台接入参数配置
MINOR_GB28181_SERVER_START = 0x111b # 国标服务启用
MINOR_GB28181_SERVER_STOP = 0x111c # 国标服务停用
MINOR_WEB_AUTHENTICATION = 0x111d # web认证方式配置
MINOR_SADP_ENABLED = 0x111e # SADP开关配置
MINOR_HTTPS_ENABLED = 0x111f # HTTPS开关配置
MINOR_EZVIZ_PARAM_CFG = 0x1120 # 萤石云配置
MINOR_SET_MOTION_DETECTION_CFG = 0x1121 # 设置移动侦测参数配置
MINOR_GET_MOTION_DETECTION_CFG = 0x1122 # 获取移动侦测参数配置
MINOR_SET_SHELTER_ALARM_CFG = 0x1123 # 设置遮挡报警参数配置
MINOR_GET_SHELTER_ALARM_CFG = 0x1124 # 获取遮挡报警参数配置
MINOR_SET_VIDEO_LOSS_CFG = 0x1125 # 设置视频丢失参数配置
MINOR_GET_VIDEO_LOSS_CFG = 0x1126 # 获取视频丢失参数配置
MINOR_SET_ABNORMAL_CFG = 0x1127 # 设置异常参数配置
MINOR_GET_ABNORMAL_CFG = 0x1128 # 获取异常参数配置
MINOR_SET_ALARM_LINKAGE_CFG = 0x1129 # 设置报警联动配置
MINOR_GET_ALARM_LINKAGE_CFG = 0x112a # 获取报警联动配置
MINOR_SET_NETWORK_CFG = 0x112b # 设置网络参数配置
MINOR_GET_NETWORK_CFG = 0x112c # 获取网络参数配置
MINOR_SET_VIDEO_MASK_CFG = 0x112d # 设置视频遮盖参数配置
MINOR_GET_VIDEO_MASK_CFG = 0x112e # 获取视频遮盖参数配置

MINOR_BASIC_OPERATION_CFG = 0x112f # 基本操作
MINOR_DISPLAY_EFFECT_ADJUST_CFG = 0x1130 # 显示效果调节
MINOR_DISPLAY_PROPERTY_CFG = 0x1131 # 显示屏属性配置
MINOR_SIGNAL_CABLE_CFG = 0x1132 # 信号线缆配置
MINOR_BASIC_CFG = 0x1133 # 基础配置
MINOR_IMAGE_ADJUST_CFG = 0x1134 # 图像调整配置
MINOR_IMAGE_ENHANCE_CFG = 0x1135 # 图像增强配置
MINOR_NOSIGN_SCREEN_SAVER_CFG = 0x1136 # 无信号屏保
MINOR_ADVANCED_OPERATION_CFG = 0x1137 # 高级操作
MINOR_RECEIVE_CARD_CFG = 0x1138 # 接收卡配置
MINOR_INPUT_SUPPORT_CFG = 0x1139 # 输入支持管理
MINOR_SYSTEM_MAINTAIN_CFG = 0x113a # 系统维护配置
MINOR_SYSTEM_TEST_CFG = 0x113b # 系统检测配置
MINOR_JOINT_CFG = 0x113c # 拼接配置
MINOR_SHOW_MODE_CFG = 0x113d # 显示模式配置
MINOR_ADVANCED_IMAGE_CFG = 0x113e # 高级图像配置


# 2013-04-19 ITS操作日志类型
MINOR_LOCAL_ADD_CAR_INFO = 0x2001 # 本地添加车辆信息
MINOR_LOCAL_MOD_CAR_INFO = 0x2002 # 本地修改车辆信息
MINOR_LOCAL_DEL_CAR_INFO = 0x2003 # 本地删除车辆信息
MINOR_LOCAL_FIND_CAR_INFO = 0x2004 # 本地查找车辆信息
MINOR_LOCAL_ADD_MONITOR_INFO = 0x2005 # 本地添加布控信息
MINOR_LOCAL_MOD_MONITOR_INFO = 0x2006 # 本地修改布控信息
MINOR_LOCAL_DEL_MONITOR_INFO = 0x2007 # 本地删除布控信息
MINOR_LOCAL_FIND_MONITOR_INFO = 0x2008 # 本地查询布控信息
MINOR_LOCAL_FIND_NORMAL_PASS_INFO = 0x2009 # 本地查询正常通行信息
MINOR_LOCAL_FIND_ABNORMAL_PASS_INFO = 0x200a # 本地查询异常通行信息
MINOR_LOCAL_FIND_PEDESTRIAN_PASS_INFO = 0x200b # 本地查询正常通行信息
MINOR_LOCAL_PIC_PREVIEW = 0x200c # 本地图片预览
MINOR_LOCAL_SET_GATE_PARM_CFG = 0x200d # 设置本地配置出入口参数
MINOR_LOCAL_GET_GATE_PARM_CFG = 0x200e # 获取本地配置出入口参数
MINOR_LOCAL_SET_DATAUPLOAD_PARM_CFG = 0x200f # 设置本地配置数据上传参数
MINOR_LOCAL_GET_DATAUPLOAD_PARM_CFG = 0x2010 # 获取本地配置数据上传参数

# 2013-11-19新增日志类型
MINOR_LOCAL_DEVICE_CONTROL = 0x2011 # 本地设备控制(本地开关闸)
MINOR_LOCAL_ADD_EXTERNAL_DEVICE_INFO = 0x2012 # 本地添加外接设备信息
MINOR_LOCAL_MOD_EXTERNAL_DEVICE_INFO = 0x2013 # 本地修改外接设备信息
MINOR_LOCAL_DEL_EXTERNAL_DEVICE_INFO = 0x2014 # 本地删除外接设备信息
MINOR_LOCAL_FIND_EXTERNAL_DEVICE_INFO = 0x2015 # 本地查询外接设备信息
MINOR_LOCAL_ADD_CHARGE_RULE = 0x2016 # 本地添加收费规则
MINOR_LOCAL_MOD_CHARGE_RULE = 0x2017 # 本地修改收费规则
MINOR_LOCAL_DEL_CHARGE_RULE = 0x2018 # 本地删除收费规则
MINOR_LOCAL_FIND_CHARGE_RULE = 0x2019 # 本地查询收费规则
MINOR_LOCAL_COUNT_NORMAL_CURRENTINFO = 0x2020 # 本地统计正常通行信息
MINOR_LOCAL_EXPORT_NORMAL_CURRENTINFO_REPORT = 0x2021 # 本地导出正常通行信息统计报表
MINOR_LOCAL_COUNT_ABNORMAL_CURRENTINFO = 0x2022 # 本地统计异常通行信息
MINOR_LOCAL_EXPORT_ABNORMAL_CURRENTINFO_REPORT = 0x2023 # 本地导出异常通行信息统计报表
MINOR_LOCAL_COUNT_PEDESTRIAN_CURRENTINFO = 0x2024 # 本地统计行人通行信息
MINOR_LOCAL_EXPORT_PEDESTRIAN_CURRENTINFO_REPORT = 0x2025 # 本地导出行人通行信息统计报表
MINOR_LOCAL_FIND_CAR_CHARGEINFO = 0x2026 # 本地查询过车收费信息
MINOR_LOCAL_COUNT_CAR_CHARGEINFO = 0x2027 # 本地统计过车收费信息
MINOR_LOCAL_EXPORT_CAR_CHARGEINFO_REPORT = 0x2028 # 本地导出过车收费信息统计报表
MINOR_LOCAL_FIND_SHIFTINFO = 0x2029 # 本地查询交接班信息
MINOR_LOCAL_FIND_CARDINFO = 0x2030 # 本地查询卡片信息
MINOR_LOCAL_ADD_RELIEF_RULE = 0x2031 # 本地添加减免规则
MINOR_LOCAL_MOD_RELIEF_RULE = 0x2032 # 本地修改减免规则
MINOR_LOCAL_DEL_RELIEF_RULE = 0x2033 # 本地删除减免规则
MINOR_LOCAL_FIND_RELIEF_RULE = 0x2034 # 本地查询减免规则
MINOR_LOCAL_GET_ENDETCFG = 0x2035 # 本地获取出入口控制机离线检测配置
MINOR_LOCAL_SET_ENDETCFG = 0x2036 # 本地设置出入口控制机离线检测配置
MINOR_LOCAL_SET_ENDEV_ISSUEDDATA = 0x2037 # 本地设置出入口控制机下发卡片信息
MINOR_LOCAL_DEL_ENDEV_ISSUEDDATA = 0x2038 # 本地清空出入口控制机下发卡片信息

MINOR_REMOTE_DEVICE_CONTROL = 0x2101 # 远程设备控制
MINOR_REMOTE_SET_GATE_PARM_CFG = 0x2102 # 设置远程配置出入口参数
MINOR_REMOTE_GET_GATE_PARM_CFG = 0x2103 # 获取远程配置出入口参数
MINOR_REMOTE_SET_DATAUPLOAD_PARM_CFG = 0x2104 # 设置远程配置数据上传参数
MINOR_REMOTE_GET_DATAUPLOAD_PARM_CFG = 0x2105 # 获取远程配置数据上传参数
MINOR_REMOTE_GET_BASE_INFO = 0x2106 # 远程获取终端基本信息
MINOR_REMOTE_GET_OVERLAP_CFG = 0x2107 # 远程获取字符叠加参数配置
MINOR_REMOTE_SET_OVERLAP_CFG = 0x2108 # 远程设置字符叠加参数配置
MINOR_REMOTE_GET_ROAD_INFO = 0x2109 # 远程获取路口信息
MINOR_REMOTE_START_TRANSCHAN = 0x210a # 远程建立同步数据服务器
MINOR_REMOTE_GET_ECTWORKSTATE = 0x210b # 远程获取出入口终端工作状态
MINOR_REMOTE_GET_ECTCHANINFO = 0x210c # 远程获取出入口终端通道状态

# 远程控制 2013-11-19
MINOR_REMOTE_ADD_EXTERNAL_DEVICE_INFO = 0x210d # 远程添加外接设备信息
MINOR_REMOTE_MOD_EXTERNAL_DEVICE_INFO = 0x210e # 远程修改外接设备信息
MINOR_REMOTE_GET_ENDETCFG = 0x210f # 远程获取出入口控制机离线检测配置
MINOR_REMOTE_SET_ENDETCFG = 0x2110 # 远程设置出入口控制机离线检测配置
MINOR_REMOTE_ENDEV_ISSUEDDATA = 0x2111 # 远程设置出入口控制机下发卡片信息
MINOR_REMOTE_DEL_ENDEV_ISSUEDDATA = 0x2112 # 远程清空出入口控制机下发卡片信息

# ITS 0x2115~0x2120 停车场车位项目
MINOR_REMOTE_ON_CTRL_LAMP = 0x2115 # 开启远程控制车位指示灯
MINOR_REMOTE_OFF_CTRL_LAMP = 0x2116 # 关闭远程控制车位指示灯
# Netra3.1.0
MINOR_SET_VOICE_LEVEL_PARAM = 0x2117 # 设置音量大小
MINOR_SET_VOICE_INTERCOM_PARAM = 0x2118 # 设置音量录音
MINOR_SET_INTELLIGENT_PARAM = 0x2119 # 智能配置
MINOR_LOCAL_SET_RAID_SPEED = 0x211a # 本地设置raid速度
MINOR_REMOTE_SET_RAID_SPEED = 0x211b # 远程设置raid速度
# Nerta3.1.2
MINOR_REMOTE_CREATE_STORAGE_POOL = 0x211c # 远程添加存储池
MINOR_REMOTE_DEL_STORAGE_POOL = 0x211d # 远程删除存储池

MINOR_REMOTE_DEL_PIC = 0x2120 # 远程删除图片数据
MINOR_REMOTE_DEL_RECORD = 0x2121 # 远程删除录像数据
MINOR_REMOTE_CLOUD_ENABLE = 0x2123 # 远程设置云系统启用
MINOR_REMOTE_CLOUD_DISABLE = 0x2124 # 远程设置云系统禁用
MINOR_REMOTE_CLOUD_MODIFY_PARAM = 0x2125 # 远程修改存储池参数
MINOR_REMOTE_CLOUD_MODIFY_VOLUME = 0x2126 # 远程修改存储池容量
MINOR_REMOTE_GET_GB28181_SERVICE_PARAM = 0x2127 # 远程获取GB28181服务参数
MINOR_REMOTE_SET_GB28181_SERVICE_PARAM = 0x2128 # 远程设置GB28181服务参数
MINOR_LOCAL_GET_GB28181_SERVICE_PARAM = 0x2129 # 本地获取GB28181服务参数
MINOR_LOCAL_SET_GB28181_SERVICE_PARAM = 0x212a # 本地配置B28181服务参数
MINOR_REMOTE_SET_SIP_SERVER = 0x212b # 远程配置SIP SERVER
MINOR_LOCAL_SET_SIP_SERVER = 0x212c # 本地配置SIP SERVER
MINOR_LOCAL_BLACKWHITEFILE_OUTPUT = 0x212d # 本地黑白名单导出
MINOR_LOCAL_BLACKWHITEFILE_INPUT = 0x212e # 本地黑白名单导入
MINOR_REMOTE_BALCKWHITECFGFILE_OUTPUT = 0x212f # 远程黑白名单导出
MINOR_REMOTE_BALCKWHITECFGFILE_INPUT = 0x2130 # 远程黑白名单导入


MINOR_REMOTE_CREATE_MOD_VIEWLIB_SPACE = 0x2200 # 远程创建/修改视图库空间
MINOR_REMOTE_DELETE_VIEWLIB_FILE = 0x2201 # 远程删除视图库文件
MINOR_REMOTE_DOWNLOAD_VIEWLIB_FILE = 0x2202 # 远程下载视图库文件
MINOR_REMOTE_UPLOAD_VIEWLIB_FILE = 0x2203 # 远程上传视图库文件
MINOR_LOCAL_CREATE_MOD_VIEWLIB_SPACE = 0x2204 # 本地创建/修改视图库空间

MINOR_LOCAL_SET_DEVICE_ACTIVE = 0x3000 # 本地激活设备
MINOR_REMOTE_SET_DEVICE_ACTIVE = 0x3001 # 远程激活设备
MINOR_LOCAL_PARA_FACTORY_DEFAULT = 0x3002 # 本地回复出厂设置
MINOR_REMOTE_PARA_FACTORY_DEFAULT = 0x3003 # 远程恢复出厂设置

# 信息发布服务器操作日志
MINOR_UPLAOD_STATIC_MATERIAL = 0x2401 # 静态素材上传
MINOR_UPLOAD_DYNAMIC_MATERIAL = 0x2402 # 动态素材上传
MINOR_DELETE_MATERIAL = 0x2403 # 删除素材
MINOR_DOWNLOAD_STATIC_MATERIAL = 0x2404 # 静态素材下载
MINOR_COVER_STATIC_MATERIAL = 0x2405 # 静态素材覆盖
MINOR_APPROVE_MATERIAL = 0x2406 # 素材审核
MINOR_UPLAOD_PROGRAM = 0x2407 # 上传节目
MINOR_DOWNLOAD_PROGRAM = 0x2408 # 下载节目
MINOR_DELETE_PROGRAM = 0x2409 # 删除节目
MINOR_MODIFY_PROGRAM = 0x240a # 节目属性修改
MINOR_APPROVE_PRAGRAM = 0x240b # 节目审核
MINOR_UPLAOD_SCHEDULE = 0x240c # 上传日程
MINOR_DOWNLOAD_SCHEDULE = 0x240d # 下载日程
MINOR_DELETE_SCHEDULE = 0x240e # 删除日程
MINOR_MODIFY_SCHEDULE = 0x240f # 修改日程属性
MINOR_RELEASE_SCHEDULE = 0x2410 # 发布日程
MINOR_ADD_TERMINAL = 0x2411 # 添加终端
MINOR_DELETE_TERMINAL = 0x2412 # 删除终端
MINOR_MODIFY_TERMIANL_PARAM = 0x2413 # 修改终端参数
MINOR_MODIFY_TERMIANL_PLAY_PARAM = 0x2414 # 配置终端播放参数
MINOR_ADD_TERMIANL_GROUP = 0x2415 # 添加终端组
MINOR_MODIFY_TERMINAL_GROUP_PARAM = 0x2416 # 修改终端组参数
MINOR_DELETE_TERMIANL_GROUP = 0x2417 # 删除终端组
MINOR_TERMINAL_PLAY_CONTROL = 0x2418 # 终端播放控制
MINOR_TERMINAL_ON_OFF_LINE = 0x2419 # 终端上下线
MINOR_SET_SWITCH_PLAN = 0x241a # 设置终端定时开关机计划
MINOR_SET_VOLUME_PLAN = 0x241b # 设置终端定时音量计划
MINOR_TERMINAL_SCREENSHOT = 0x241c # 终端截屏
MINOR_SYSTEM_TIME_CFG = 0x241d # 系统校时
MINOR_ADD_USER_CFG = 0x241e # 添加用户配置
MINOR_DEL_USER_CFG = 0x241f # 删除用户配置
MINOR_REMOTE_MANAGE_HDD = 0x2420 # 远程编辑硬盘
MINOR_TERMINAL_UPDATE_START = 0x2421 # 终端升级
MINOR_SVR_RESTORE_DEFAULT_PARAM = 0x2422 # 服务器远程恢复默认
MINOR_SVR_REMOTE_RESTORE_FACTORY = 0x2423 # 服务器远程恢复出厂设置
MINOR_SVR_REMOTE_REBOOT = 0x2424 # 服务器远程重启
MINOR_SVR_MODIFY_NETWORK_PARAM = 0x2425 # 服务器网络参数修改
MINOR_SVR_SOFTWARE_UPGRADE = 0x2426 # 服务器软件升级



MINOR_REMOTE_CONFERENCE_CONFIG = 0x2501 # MCU会议配置
MINOR_REMOTE_TERMINAL_CONFIG = 0x2502 # MCU终端配置
MINOR_REMOTE_GROUP_CONFIG = 0x2503 # MCU分组配置
MINOR_REMOTE_CONFERENCE_CTRL = 0x2504 # MCU会议控制
MINOR_REMOTE_TERMINAL_CTRL = 0x2505 # MCU终端控制

# NVR后端
MINOR_LOCAL_RESET_LOGIN_PASSWORD = 0x2600 #  本地重置admin登陆密码
MINOR_REMOTE_RESET_LOGIN_PASSWORD = 0x2601 #  远程重置admin登录密码
MINOR_LOCAL_FACE_BASE_CREATE = 0x2602 #  本地人脸对比库创建
MINOR_REMOTE_FACE_BASE_CREATE = 0x2603 #  远程人脸对比库创建
MINOR_LOCAL_FACE_BASE_MODIFY = 0x2604 #  本地人脸对比库修改
MINOR_REMOTE_FACE_BASE_MODIFY = 0x2605 #  远程人脸对比库修改
MINOR_LOCAL_FACE_BASE_DELETE = 0x2606 #  本地人脸对比库删除
MINOR_REMOTE_FACE_BASE_DELETE = 0x2607 #  远程人脸对比库删除
MINOR_LOCAL_FACE_DATA_APPEND = 0x2608 #  本地录入人脸数据
MINOR_REMOTE_FACE_DATA_APPEND = 0x2609 #  远程录入人脸数据
MINOR_LOCAL_FACE_DATA_SEARCH = 0x2610 #  本地人脸比对数据查找
MINOR_REMOTE_FACE_DATA_SEARCH = 0x2611 #  远程人脸比对数据查找
MINOR_LOCAL_FACE_DATA_ANALYSIS = 0x2612 #  本地图片分析操作
MINOR_REMOTE_FACE_DATA_ANALYSIS = 0x2613 #  远程图片分析操作
MINOR_LOCAL_FACE_DATA_EDIT = 0x2614 #  本地人脸数据修改
MINOR_REMOTE_FACE_DATA_EDIT = 0x2615 #  远程人脸数据修改

MINOR_LOCAL_FACE_DATA_DELETE = 0x2616 #  本地人脸数据删除
MINOR_REMOTE_FACE_DATA_DELET = 0x2617 #  远程人脸数据删除

MINOR_LOCAL_VCA_ANALYSIS_CFG = 0x2618 #  本地智能分析配置
MINOR_REMOTE_VCA_ANALYSIS_CFG = 0x2619 #  远程智能分析配置

MINOR_LOCAL_FACE_BASE_IMPORT = 0x261a #  本地导入人脸库
MINOR_LOCAL_FACE_BASE_EXPORT = 0x261b #  本地导出人脸库
# NVR集群
MINOR_REMOTE_CLUSTER_MODE_CONFIG = 0x261c #  远程集群模式配置操作
MINOR_LOCAL_CLUSTER_MODE_CONFIG = 0x261d #  本地集群模式配置操作
MINOR_REMOTE_CLUSTER_NETWORK_CONFIG = 0x261e #  远程集群组网配置操作
MINOR_LOCAL_CLUSTER_NETWORK_CONFIG = 0x261f #  本地集群组网配置操作
MINOR_REMOTE_CLUSTER_ADD_DEVICE = 0x2620 #  远程集群添加设备操作
MINOR_LOCAL_CLUSTER_ADD_DEVICE = 0x2621 #  本地集群添加设备操作
MINOR_REMOTE_CLUSTER_DEL_DEVICE = 0x2622 #  远程集群删除设备操作
MINOR_LOCAL_CLUSTER_DEL_DEVICE = 0x2623 #  本地集群删除设备操作
MINOR_REMOTE_HFPD_CFG = 0x2624 #  远程高频人员检测配置
MINOR_REMOTE_FACE_CONTRAST_TASK = 0x2625 #  远程人脸比对任务配置
MINOR_REMOTE_LFPD_CFG = 0x2626 #  远程低频人员检测配置
MINOR_REMOTE_IOTCFGFILE_INPUT = 0x2627 # 远程导入IOT配置文件
MINOR_REMOTE_IOTCFGFILE_OUTPUT = 0x2628 # 远程导出IOT配置文件
MINOR_LOCAL_IOT_ADD = 0x2629 # 本地添加IOT通道
MINOR_REMOTE_IOT_ADD = 0x262a # 远程添加IOT通道
MINOR_LOCAL_IOT_DEL = 0x262b # 本地删除IOT通道
MINOR_REMOTE_IOT_DEL = 0x262c # 远程删除IOT通道
MINOR_LOCAL_IOT_SET = 0x262d # 本地配置IOT通道
MINOR_REMOTE_IOT_SET = 0x262e # 远程配置IOT通道
MINOR_LOCAL_IOTCFGFILE_INPUT = 0x262f # 本地导入IOT配置文件
MINOR_LOCAL_IOTCFGFILE_OUTPUT = 0x2630 # 本地导出IOT配置文件
MINOR_LOCAL_VAD_CFG = 0x2631 #  本地语音活动检测配置
MINOR_REMOTE_VAD_CFG = 0x2632 #  远程语音活动检测配置
MINOR_LOCAL_ADDRESS_FILTER_CONFIG = 0x2633 #  本地地址过滤配置
MINOR_REMOTE_ADDRESS_FILTER_CONFIG = 0x2634 #  远程地址过滤配置
MINOR_LOCAL_POE_CFG = 0x2635 #  本地POE配置
MINOR_REMOTE_POE_CFG = 0x2636 #  远程POE配置
MINOR_LOCAL_RESET_CHANNEL_PASSWORD = 0x2637 #  本地重置通道密码
MINOR_REMOTE_RESET_CHANNEL_PASSWORD = 0x2638 #  远程重置通道密码
MINOR_LOCAL_SSD_UPGRADE_START = 0x2639 #  本地SSD文件系统升级开始
MINOR_LOCAL_SSD_UPGRADE_STOP = 0x2640 #  本地SSD文件系统升级结束
MINOR_REMOTE_SSD_UPGRADE_START = 0x2641 #  远程SSD文件系统升级开始
MINOR_REMOTE_SSD_UPGRADE_STOP = 0x2642 #  远程SSD文件系统升级结束
MINOR_LOCAL_SSD_FORMAT_START = 0x2643 # 本地SSD文件系统格式化开始
MINOR_LOCAL_SSD_FORMAT_STOP = 0x2644 # 本地SSD文件系统格式化结束
MINOR_REMOTE_SSD_FORMAT_START = 0x2645 # 远程SSD文件系统格式化开始
MINOR_REMOTE_SSD_FORMAT_STOP = 0x2646 # 远程SSD文件系统格式化结束
MINOR_LOCAL_AUTO_SWITCH_CONFIG = 0x2647 #  本地自动开关机配置
MINOR_REMOTE_AUTO_SWITCH_CONFIG = 0x2648 #  远程自动开关机配置

MINOR_LOCAL_SSD_INITIALIZATION_START = 0x264a #  本地SSD初始化开始
MINOR_LOCAL_SSD_INITIALIZATION_END = 0x264b #  本地SSD初始化结束
MINOR_REMOTE_SSD_INITIALIZATION_START = 0x264c #  远程SSD初始化开始
MINOR_REMOTE_SSD_INITIALIZATION_END = 0x264d #  远程SSD初始化结束


# 定义AI开放平台的操作日志
MINOR_REMOTE_AI_MODEL_ADD = 0x2650 # 模型包添加
MINOR_REMOTE_AI_MODEL_QUERY = 0x2651 # 模型包查询
MINOR_REMOTE_AI_MODEL_DELETE = 0x2652 # 模型包删除
MINOR_REMOTE_AI_MODEL_UPDATE = 0x2653 # 模型包更新
MINOR_REMOTE_AI_PICTURE_POLLING_TASK_ADD = 0x2654 # 图片轮询任务增加
MINOR_REMOTE_AI_PICTURE_POLLING_TASK_QUERY = 0x2655 # 图片轮询任务查询
MINOR_REMOTE_AI_PICTURE_POLLING_TASK_DELETE = 0x2656 # 图片轮询任务删除
MINOR_REMOTE_AI_PICTURE_POLLING_TASK_MODIFY = 0x2657 # 图片轮询任务修改
MINOR_REMOTE_AI_VIDEO_POLLING_TASK_ADD = 0x2658 # 视频轮询任务增加
MINOR_REMOTE_AI_VIDEO_POLLING_TASK_QUERY = 0x2659 # 视频轮询任务查询
MINOR_REMOTE_AI_VIDEO_POLLING_TASK_DELETE = 0x265A # 视频轮询任务删除
MINOR_REMOTE_AI_VIDEO_POLLING_TASK_MODIFY = 0x265B # 视频轮询任务修改
MINOR_REMOTE_AI_PICTURE_TASK_ADD = 0x265C # 图片任务增加
MINOR_REMOTE_AI_PICTURE_TASK_QUERY = 0x265D # 图片任务查询
MINOR_REMOTE_AI_PICTURE_TASK_DELETE = 0x265E # 图片任务删除
MINOR_REMOTE_AI_PICTURE_TASK_MODIFY = 0x265F # 图片任务修改
MINOR_REMOTE_AI_VIDEO_TASK_ADD = 0x2660 # 视频任务增加
MINOR_REMOTE_AI_VIDEO_TASK_QUERY = 0x2661 # 视频任务查询
MINOR_REMOTE_AI_VIDEO_TASK_DELETE = 0x2662 # 视频任务删除
MINOR_REMOTE_AI_VIDEO_TASK_MODIFY = 0x2663 # 视频任务修改
MINOR_REMOTE_AI_RULE_CONFIG = 0x2664 # AI规则配置

MINOR_REMOTE_LOG_STORAGE_CONFIG = 0x2665 # 日志存储配置
MINOR_REMOTE_LOG_SERVER_CONFIG = 0x2666 # 日志服务器参数配置

MINOR_REMOTE_RESET_IPC_PASSWORD = 0x2670 # NVR重置IPC密码日志

# 定义萤石平台操作日志
MINOR_LOCAL_EZVIZ_OPERATION = 0x2671 # 本地萤石操作(包括萤石参数配置和升级)
MINOR_REMOTE_EZVIZ_OPERATION = 0x2672 # 远程萤石操作(包括萤石参数配置和升级)

MINOR_EZVIZ_BITSTREAM_PARAMATERS_CONFIG = 0x2673 #  萤石码流参数配置
MINOR_EZVIZ_ALARM_PARAMATERS_CONFIG = 0x2674 #  萤石报警参数配置
MINOR_EZVIZ_UPGRADE = 0x2675 #  萤石升级
MINOR_EZVIZ_REGISTER = 0x2676 #  萤石注册
MINOR_EZVIZ_LOCAL_PARAMATERS_CONFIG = 0x2677 #  萤石本地参数配置
MINOR_EZVIZ_REMOTE_PARAMATERS_CONFIG = 0x2678 #  萤石远程参数配置


# 消防操作日志
MINOR_STOP_SOUND = 0x2700 # 消音
MINOR_SELF_CHECK = 0x2701 # 自检
MINOR_DUTY_CHECK = 0x2702 # 查岗
MINOR_SWITCH_SIMPLE_WORKMODE = 0x2703 # 切换至简易模式
MINOR_SWITCH_NORMAL_WORKMODE = 0x2704 # 切换至标准模式
MINOR_LOCAL_SSD_OPERATE_START = 0x2705 #  本地SSD操作开始
MINOR_LOCAL_SSD_OPERATE_STOP = 0x2706 #  本地SSD操作结束
MINOR_REMOTE_SSD_OPERATE_START = 0x2707 #  远程SSD操作开始
MINOR_REMOTE_SSD_OPERATE_STOP = 0x2708 #  远程SSD操作结束

# 日志附加信息
# 主类型
MAJOR_INFORMATION = 0x4 # 附加信息
# 次类型
MINOR_HDD_INFO = 0xa1 # 硬盘信息
MINOR_SMART_INFO = 0xa2 # SMART信息
MINOR_REC_START = 0xa3 # 开始录像
MINOR_REC_STOP = 0xa4 # 停止录像
MINOR_REC_OVERDUE = 0xa5 # 过期录像删除
MINOR_LINK_START = 0xa6 # 连接前端设备
MINOR_LINK_STOP = 0xa7 # 断开前端设备
MINOR_NET_DISK_INFO = 0xa8 # 网络硬盘信息
MINOR_RAID_INFO = 0xa9 # raid相关信息
MINOR_RUN_STATUS_INFO = 0xaa # 系统运行状态信息

# Netra3.0.0
MINOR_SPARE_START_BACKUP = 0xab # 热备系统开始备份指定工作机
MINOR_SPARE_STOP_BACKUP = 0xac # 热备系统停止备份指定工作机
MINOR_SPARE_CLIENT_INFO = 0xad # 热备客户机信息
MINOR_ANR_RECORD_START = 0xae # ANR录像开始
MINOR_ANR_RECORD_END = 0xaf # ANR录像结束
MINOR_ANR_ADD_TIME_QUANTUM = 0xb0 # ANR添加时间段
MINOR_ANR_DEL_TIME_QUANTUM = 0xb1 # ANR删除时间段

MINOR_PIC_REC_START = 0xb3 #  开始抓图
MINOR_PIC_REC_STOP = 0xb4 #  停止抓图
MINOR_PIC_REC_OVERDUE = 0xb5 #  过期图片文件删除
# Netra3.1.0
MINOR_CLIENT_LOGIN = 0xb6 # 登录服务器成功
MINOR_CLIENT_RELOGIN = 0xb7 # 重新登录服务器
MINOR_CLIENT_LOGOUT = 0xb8 # 退出服务器成功
MINOR_CLIENT_SYNC_START = 0xb9 # 录像同步开始
MINOR_CLIENT_SYNC_STOP = 0xba # 录像同步终止
MINOR_CLIENT_SYNC_SUCC = 0xbb # 录像同步成功
MINOR_CLIENT_SYNC_EXCP = 0xbc # 录像同步异常
MINOR_GLOBAL_RECORD_ERR_INFO = 0xbd # 全局错误记录信息
MINOR_BUFFER_STATE = 0xbe # 缓冲区状态日志记录
MINOR_DISK_ERRORINFO_V2 = 0xbf # 硬盘错误详细信息V2
MINOR_CS_DATA_EXPIRED = 0xc0 # 云存储数据过期
MINOR_PLAT_INFO = 0xc1 # 平台操作信息
MINOR_DIAL_STAT = 0xc2 # 拨号状态

MINOR_UNLOCK_RECORD = 0xc3 # 开锁记录
MINOR_VIS_ALARM = 0xc4 # 防区报警
MINOR_TALK_RECORD = 0xc5 # 通话记录
MINOR_ACCESSORIES_MESSAGE = 0xc6 # 配件板信息
MINOR_KMS_EXPAMSION_DISK_INSERT = 0xc7 #  KMS扩容盘插入
MINOR_IPC_CONNECT = 0xc8 #   IPC连接信息
MINOR_INTELLIGENT_BOARD_STATUS = 0xc9 #   智能板状态
MINOR_IPC_CONNECT_STATUS = 0xca #   IPC连接状态
MINOR_AUTO_TIMING = 0xcb # 自动校时
MINOR_EZVIZ_OPERATION = 0xcc # 萤石运行状态
# NVR集群
MINOR_CLUSTER_DEVICE_ONLINE = 0xcd # 集群设备上线
MINOR_CLUSTER_MGR_SERVICE_STARTUP = 0xce # 集群管理服务启动
MINOR_CLUSTER_BUSINESS_TRANSFER = 0xcf # 集群业务迁移
MINOR_CLUSTER_STATUS = 0xd0 # 集群状态信息
MINOR_CLUSTER_CS_STATUS = 0xd1 # 集群CS向CM发送设备状态失败，记录CS和CM的IP地址
MINOR_CLUSTER_CM_STATUS = 0xd2 # CM状态切换，记录CM转变的角色，如leader、follower、candidate
MINOR_VOICE_START_DETECTED = 0xd3 # 检测到语音开始
MINOR_VOICE_END_DETECTED = 0xd4 # 检测到语音结束
MINOR_DOUBLE_VERIFICATION_PASS = 0xd5 # 二次认证通过
MINOR_WIRELESS_RUNNING_STATUS = 0xd6 # 无线运行状态
MINOR_SYSTEM_DATA_SYNCHRONIZATION = 0xd7 # 系统数据同步
MINOR_HD_FORMAT_START = 0xd8 # 硬盘格式化开始
MINOR_HD_FORMAT_STOP = 0xd9 # 硬盘格式化结束

# 0x400-0x4ff 门禁附件信息日志类型
MINOR_LIVE_DETECT_OPEN = 0x400 # 真人检测开启
MINOR_LIVE_DETECT_CLOSE = 0x401 # 真人检测关闭
MINOR_CLEAR_DATA_COLLECTION = 0x402 # 采集数据清空
MINOR_DELETE_DATA_COLLECTION = 0x403 # 采集数据删除
MINOR_EXPORT_DATA_COLLECTION = 0x404 # 采集数据导出
MINOR_CARD_LEN_CONFIG = 0x405 # 卡长度配置
MINOR_DATA_BASE_INIT_FAILED = 0x406 # 数据库初始化失败
MINOR_DATA_BASE_PATCH_UPDATE = 0x407 # 数据库补丁升级
MINOR_PSAM_CARD_INSERT = 0x408 # Psam卡插入
MINOR_PSAM_CARD_REMOVE = 0x409 # Psam卡拔出
MINOR_HARD_FAULT_REBOOT = 0x40a # 硬件异常（hardfault）重启
MINOR_PSAM_CARD_OCP = 0x40b # Psam卡过流保护
MINOR_STACK_OVERFLOW = 0x40c # 堆栈溢出
MINOR_PARM_CFG = 0x40d # 参数配置
MINOR_CLR_USER = 0x40e # 清空所有用户
MINOR_CLR_CARD = 0x40f # 清空所有卡
MINOR_CLR_FINGER_BY_READER = 0x410 # 清空所有指纹(按读卡器)
MINOR_CLR_FINGER_BY_CARD = 0x411 # 清空所有指纹(按卡号)
MINOR_CLR_FINGER_BY_EMPLOYEE_ON = 0x412 # 清空所有指纹(按工号)
MINOR_DEL_FINGER = 0x413 # 删除一个指纹
MINOR_CLR_WEEK_PLAN = 0x414 # 清除权限周计划
MINOR_SET_WEEK_PLAN = 0x415 # 设置权限周计划
MINOR_SET_HOLIDAY_PLAN = 0x416 # 设置权限假日计划
MINOR_CLR_HOLIDAY_PLAN = 0x417 # 清除权限假日计划
MINOR_SET_HOLIDAY_GROUP = 0x418 # 设置权限假日组计划
MINOR_CLR_HOLIDAY_GROUP = 0x419 # 清除权限假日组计划
MINOR_CLR_TEMPLATE_PLAN = 0x41a # 清除权限计划
MINOR_SET_TEMPLATE_PLAN = 0x41b # 设置权限计划
MINOR_ADD_CARD = 0x41c # 新增卡
MINOR_MOD_CARD = 0x41d # 修改卡
MINOR_ADD_FINGER_BY_CARD = 0x41e # 新增指纹(按卡号)
MINOR_ADD_FINGER_BY_EMPLOYEE_NO = 0x41f # 新增指纹(按工号)
MINOR_MOD_FINGER_BY_CARD = 0x420 # 修改指纹(按卡号)
MINOR_MOD_FINGER_BY_EMPLOYEE_NO = 0x421 # 修改指纹(按工号)
MINOR_IMPORT_USER_LIST = 0x422 # 用户列表导入（离线采集）

# 802.1x认证操作日志
MINOR_802_1X_AUTH_SUCC = 0x320 # 802.1x认证成功
MINOR_802_1X_AUTH_FAIL = 0x321 # 802.1x认证失败

# 事件
# 主类型
MAJOR_EVENT = 0x5 # 事件
# 次类型
MINOR_LEGAL_CARD_PASS = 0x01 # 合法卡认证通过
MINOR_CARD_AND_PSW_PASS = 0x02 # 刷卡加密码认证通过
MINOR_CARD_AND_PSW_FAIL = 0x03 # 刷卡加密码认证失败
MINOR_CARD_AND_PSW_TIMEOUT = 0x04 # 数卡加密码认证超时
MINOR_CARD_AND_PSW_OVER_TIME = 0x05 # 刷卡加密码超次
MINOR_CARD_NO_RIGHT = 0x06 # 未分配权限
MINOR_CARD_INVALID_PERIOD = 0x07 # 无效时段
MINOR_CARD_OUT_OF_DATE = 0x08 # 卡号过期
MINOR_INVALID_CARD = 0x09 # 无此卡号
MINOR_ANTI_SNEAK_FAIL = 0x0a # 反潜回认证失败
MINOR_INTERLOCK_DOOR_NOT_CLOSE = 0x0b # 互锁门未关闭
MINOR_NOT_BELONG_MULTI_GROUP = 0x0c # 卡不属于多重认证群组
MINOR_INVALID_MULTI_VERIFY_PERIOD = 0x0d # 卡不在多重认证时间段内
MINOR_MULTI_VERIFY_SUPER_RIGHT_FAIL = 0x0e # 多重认证模式超级权限认证失败
MINOR_MULTI_VERIFY_REMOTE_RIGHT_FAIL = 0x0f # 多重认证模式远程认证失败
MINOR_MULTI_VERIFY_SUCCESS = 0x10 # 多重认证成功
MINOR_LEADER_CARD_OPEN_BEGIN = 0x11 # 首卡开门开始
MINOR_LEADER_CARD_OPEN_END = 0x12 # 首卡开门结束
MINOR_ALWAYS_OPEN_BEGIN = 0x13 # 常开状态开始
MINOR_ALWAYS_OPEN_END = 0x14 # 常开状态结束
MINOR_LOCK_OPEN = 0x15 # 门锁打开
MINOR_LOCK_CLOSE = 0x16 # 门锁关闭
MINOR_DOOR_BUTTON_PRESS = 0x17 # 开门按钮打开
MINOR_DOOR_BUTTON_RELEASE = 0x18 # 开门按钮放开
MINOR_DOOR_OPEN_NORMAL = 0x19 # 正常开门（门磁）
MINOR_DOOR_CLOSE_NORMAL = 0x1a # 正常关门（门磁）
MINOR_DOOR_OPEN_ABNORMAL = 0x1b # 门异常打开（门磁）
MINOR_DOOR_OPEN_TIMEOUT = 0x1c # 门打开超时（门磁）
MINOR_ALARMOUT_ON = 0x1d # 报警输出打开
MINOR_ALARMOUT_OFF = 0x1e # 报警输出关闭
MINOR_ALWAYS_CLOSE_BEGIN = 0x1f # 常关状态开始
MINOR_ALWAYS_CLOSE_END = 0x20 # 常关状态结束
MINOR_MULTI_VERIFY_NEED_REMOTE_OPEN = 0x21 # 多重多重认证需要远程开门
MINOR_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS = 0x22 # 多重认证超级密码认证成功事件
MINOR_MULTI_VERIFY_REPEAT_VERIFY = 0x23 # 多重认证重复认证事件
MINOR_MULTI_VERIFY_TIMEOUT = 0x24 # 多重认证重复认证事件
MINOR_DOORBELL_RINGING = 0x25 # 门铃响
MINOR_FINGERPRINT_COMPARE_PASS = 0x26 # 指纹比对通过
MINOR_FINGERPRINT_COMPARE_FAIL = 0x27 # 指纹比对失败
MINOR_CARD_FINGERPRINT_VERIFY_PASS = 0x28 # 刷卡加指纹认证通过
MINOR_CARD_FINGERPRINT_VERIFY_FAIL = 0x29 # 刷卡加指纹认证失败
MINOR_CARD_FINGERPRINT_VERIFY_TIMEOUT = 0x2a # 刷卡加指纹认证超时
MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_PASS = 0x2b # 刷卡加指纹加密码认证通过
MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL = 0x2c # 刷卡加指纹加密码认证失败
MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT = 0x2d # 刷卡加指纹加密码认证超时
MINOR_FINGERPRINT_PASSWD_VERIFY_PASS = 0x2e # 指纹加密码认证通过
MINOR_FINGERPRINT_PASSWD_VERIFY_FAIL = 0x2f # 指纹加密码认证失败
MINOR_FINGERPRINT_PASSWD_VERIFY_TIMEOUT = 0x30 # 指纹加密码认证超时
MINOR_FINGERPRINT_INEXISTENCE = 0x31 # 指纹不存在
MINOR_CARD_PLATFORM_VERIFY = 0x32 # 刷卡平台认证
MINOR_CALL_CENTER = 0x33 # 呼叫中心事件
MINOR_FIRE_RELAY_TURN_ON_DOOR_ALWAYS_OPEN = 0x34 # 消防继电器导通触发门常开
MINOR_FIRE_RELAY_RECOVER_DOOR_RECOVER_NORMAL = 0x35 # 消防继电器恢复门恢复正常
MINOR_FACE_AND_FP_VERIFY_PASS = 0x36 # 人脸加指纹认证通过
MINOR_FACE_AND_FP_VERIFY_FAIL = 0x37 # 人脸加指纹认证失败
MINOR_FACE_AND_FP_VERIFY_TIMEOUT = 0x38 # 人脸加指纹认证超时
MINOR_FACE_AND_PW_VERIFY_PASS = 0x39 # 人脸加密码认证通过
MINOR_FACE_AND_PW_VERIFY_FAIL = 0x3a # 人脸加密码认证失败
MINOR_FACE_AND_PW_VERIFY_TIMEOUT = 0x3b # 人脸加密码认证超时
MINOR_FACE_AND_CARD_VERIFY_PASS = 0x3c # 人脸加刷卡认证通过
MINOR_FACE_AND_CARD_VERIFY_FAIL = 0x3d # 人脸加刷卡认证失败
MINOR_FACE_AND_CARD_VERIFY_TIMEOUT = 0x3e # 人脸加刷卡认证超时
MINOR_FACE_AND_PW_AND_FP_VERIFY_PASS = 0x3f # 人脸加密码加指纹认证通过
MINOR_FACE_AND_PW_AND_FP_VERIFY_FAIL = 0x40 # 人脸加密码加指纹认证失败
MINOR_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT = 0x41 # 人脸加密码加指纹认证超时
MINOR_FACE_CARD_AND_FP_VERIFY_PASS = 0x42 # 人脸加刷卡加指纹认证通过
MINOR_FACE_CARD_AND_FP_VERIFY_FAIL = 0x43 # 人脸加刷卡加指纹认证失败
MINOR_FACE_CARD_AND_FP_VERIFY_TIMEOUT = 0x44 # 人脸加刷卡加指纹认证超时
MINOR_EMPLOYEENO_AND_FP_VERIFY_PASS = 0x45 # 工号加指纹认证通过
MINOR_EMPLOYEENO_AND_FP_VERIFY_FAIL = 0x46 # 工号加指纹认证失败
MINOR_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT = 0x47 # 工号加指纹认证超时
MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS = 0x48 # 工号加指纹加密码认证通过
MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL = 0x49 # 工号加指纹加密码认证失败
MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT = 0x4a # 工号加指纹加密码认证超时
MINOR_FACE_VERIFY_PASS = 0x4b # 人脸认证通过
MINOR_FACE_VERIFY_FAIL = 0x4c # 人脸认证失败
MINOR_EMPLOYEENO_AND_FACE_VERIFY_PASS = 0x4d # 工号加人脸认证通过
MINOR_EMPLOYEENO_AND_FACE_VERIFY_FAIL = 0x4e # 工号加人脸认证失败
MINOR_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT = 0x4f # 工号加人脸认证超时
MINOR_FACE_RECOGNIZE_FAIL = 0x50 # 人脸识别失败
MINOR_FIRSTCARD_AUTHORIZE_BEGIN = 0x51 # 首卡授权开始
MINOR_FIRSTCARD_AUTHORIZE_END = 0x52 # 首卡授权结束
MINOR_DOORLOCK_INPUT_SHORT_CIRCUIT = 0x53 # 门锁输入短路报警
MINOR_DOORLOCK_INPUT_BROKEN_CIRCUIT = 0x54 # 门锁输入断路报警
MINOR_DOORLOCK_INPUT_EXCEPTION = 0x55 # 门锁输入异常报警
MINOR_DOORCONTACT_INPUT_SHORT_CIRCUIT = 0x56 # 门磁输入短路报警
MINOR_DOORCONTACT_INPUT_BROKEN_CIRCUIT = 0x57 # 门磁输入断路报警
MINOR_DOORCONTACT_INPUT_EXCEPTION = 0x58 # 门磁输入异常报警
MINOR_OPENBUTTON_INPUT_SHORT_CIRCUIT = 0x59 # 开门按钮输入短路报警
MINOR_OPENBUTTON_INPUT_BROKEN_CIRCUIT = 0x5a # 开门按钮输入断路报警
MINOR_OPENBUTTON_INPUT_EXCEPTION = 0x5b # 开门按钮输入异常报警
MINOR_DOORLOCK_OPEN_EXCEPTION = 0x5c # 门锁异常打开
MINOR_DOORLOCK_OPEN_TIMEOUT = 0x5d # 门锁打开超时
MINOR_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE = 0x5e # 首卡未授权开门失败
MINOR_CALL_LADDER_RELAY_BREAK = 0x5f # 呼梯继电器断开
MINOR_CALL_LADDER_RELAY_CLOSE = 0x60 # 呼梯继电器闭合
MINOR_AUTO_KEY_RELAY_BREAK = 0x61 # 自动按键继电器断开
MINOR_AUTO_KEY_RELAY_CLOSE = 0x62 # 自动按键继电器闭合
MINOR_KEY_CONTROL_RELAY_BREAK = 0x63 # 按键梯控继电器断开
MINOR_KEY_CONTROL_RELAY_CLOSE = 0x64 # 按键梯控继电器闭合
MINOR_EMPLOYEENO_AND_PW_PASS = 0x65 # 工号加密码认证通过
MINOR_EMPLOYEENO_AND_PW_FAIL = 0x66 # 工号加密码认证失败
MINOR_EMPLOYEENO_AND_PW_TIMEOUT = 0x67 # 工号加密码认证超时
MINOR_HUMAN_DETECT_FAIL = 0x68 # 真人检测失败
MINOR_PEOPLE_AND_ID_CARD_COMPARE_PASS = 0x69 # 人证比对通过
MINOR_PEOPLE_AND_ID_CARD_COMPARE_FAIL = 0x70 # 人证比对失败
MINOR_CERTIFICATE_BLACK_LIST = 0x71 # 黑名单事件
MINOR_LEGAL_MESSAGE = 0x72 # 合法短信
MINOR_ILLEGAL_MESSAGE = 0x73 # 非法短信
MINOR_DOOR_OPEN_OR_DORMANT_FAIL = 0x75 # 门状态常闭或休眠状态认证失败
MINOR_AUTH_PLAN_DORMANT_FAIL = 0x76 # 认证计划休眠模式认证失败
MINOR_CARD_ENCRYPT_VERIFY_FAIL = 0x77 # 卡加密校验失败
MINOR_SUBMARINEBACK_REPLY_FAIL = 0x78 # 反潜回服务器应答失败
MINOR_DOOR_OPEN_OR_DORMANT_OPEN_FAIL = 0x82 # 门常闭或休眠时开门按钮开门失败
MINOR_HEART_BEAT = 0x83 # 心跳事件
MINOR_DOOR_OPEN_OR_DORMANT_LINKAGE_OPEN_FAIL = 0x84 # 门常闭或休眠时开门联动开门失败
MINOR_TRAILING = 0x85 # 尾随通行
MINOR_REVERSE_ACCESS = 0x86 # 反向闯入
MINOR_FORCE_ACCESS = 0x87 # 外力冲撞
MINOR_CLIMBING_OVER_GATE = 0x88 # 翻越
MINOR_PASSING_TIMEOUT = 0x89 # 通行超时
MINOR_INTRUSION_ALARM = 0x8a # 误闯报警
MINOR_FREE_GATE_PASS_NOT_AUTH = 0x8b # 闸机自由通行时未认证通过
MINOR_DROP_ARM_BLOCK = 0x8c # 摆臂被阻挡
MINOR_DROP_ARM_BLOCK_RESUME = 0x8d # 摆臂阻挡消除
MINOR_LOCAL_FACE_MODELING_FAIL = 0x8e # 设备升级本地人脸建模失败
MINOR_STAY_EVENT = 0x8f # 逗留事件
MINOR_PASSWORD_MISMATCH = 0x97 # 密码不匹配
MINOR_EMPLOYEE_NO_NOT_EXIST = 0x98 # 工号不存在
MINOR_COMBINED_VERIFY_PASS = 0x99 # 组合认证通过
MINOR_COMBINED_VERIFY_TIMEOUT = 0x9a # 组合认证超时
MINOR_VERIFY_MODE_MISMATCH = 0x9b # 认证方式不匹配

MINOR_PASSPORT_VERIFY_FAIL = 0xa1 # 护照信息校验失败
MINOR_INFORMAL_MIFARE_CARD_VERIFY_FAIL = 0xa2 # 非正规Mifare卡认证失败
MINOR_CPU_CARD_ENCRYPT_VERIFY_FAIL = 0xa3 # CPU卡加密校验失败
MINOR_NFC_DISABLE_VERIFY_FAIL = 0xa4 # NFC功能关闭验证失败

MINOR_LORA_MODULE_ONLINE = 0xa5 # LoRa模块上线
MINOR_LORA_MODULE_OFFLINE = 0xa6 # LoRa模块下线
MINOR_MQTT_STATUS = 0xa7 # Mqtt连接状态

MINOR_EM_CARD_RECOGNIZE_NOT_ENABLED = 0xa8 # EM卡识别未启用
MINOR_M1_CARD_RECOGNIZE_NOT_ENABLED = 0xa9 # M1卡识别未启用
MINOR_CPU_CARD_RECOGNIZE_NOT_ENABLED = 0xaa # CPU卡识别未启用
MINOR_ID_CARD_RECOGNIZE_NOT_ENABLED = 0xab # 身份证识别未启用
MINOR_CARD_SET_SECRET_KEY_FAIL = 0xac # 卡灌装密钥失败
MINOR_LOCAL_UPGRADE_FAIL = 0xad #  本地升级失败
MINOR_REMOTE_UPGRADE_FAIL = 0xae #  远程升级失败
MINOR_REMOTE_EXTEND_MODULE_UPGRADE_SUCC = 0xaf # 远程扩展模块升级成功
MINOR_REMOTE_EXTEND_MODULE_UPGRADE_FAIL = 0xb0 # 远程扩展模块升级失败
MINOR_REMOTE_FINGER_PRINT_MODULE_UPGRADE_SUCC = 0xb1 # 远程指纹模组升级成功
MINOR_REMOTE_FINGER_PRINT_MODULE_UPGRADE_FAIL = 0xb2 # 远程指纹模组升级失败
MINOR_PASSWD_VERIFY_PASS = 0xb5 # 密码认证通过


MINOR_EVENT_CUSTOM1 = 0x500 # 门禁自定义事件1
MINOR_EVENT_CUSTOM2 = 0x501 # 门禁自定义事件2
MINOR_EVENT_CUSTOM3 = 0x502 # 门禁自定义事件3
MINOR_EVENT_CUSTOM4 = 0x503 # 门禁自定义事件4
MINOR_EVENT_CUSTOM5 = 0x504 # 门禁自定义事件5
MINOR_EVENT_CUSTOM6 = 0x505 # 门禁自定义事件6
MINOR_EVENT_CUSTOM7 = 0x506 # 门禁自定义事件7
MINOR_EVENT_CUSTOM8 = 0x507 # 门禁自定义事件8
MINOR_EVENT_CUSTOM9 = 0x508 # 门禁自定义事件9
MINOR_EVENT_CUSTOM10 = 0x509 # 门禁自定义事件10
MINOR_EVENT_CUSTOM11 = 0x50a # 门禁自定义事件11
MINOR_EVENT_CUSTOM12 = 0x50b # 门禁自定义事件12
MINOR_EVENT_CUSTOM13 = 0x50c # 门禁自定义事件13
MINOR_EVENT_CUSTOM14 = 0x50d # 门禁自定义事件14
MINOR_EVENT_CUSTOM15 = 0x50e # 门禁自定义事件15
MINOR_EVENT_CUSTOM16 = 0x50f # 门禁自定义事件16
MINOR_EVENT_CUSTOM17 = 0x510 # 门禁自定义事件17
MINOR_EVENT_CUSTOM18 = 0x511 # 门禁自定义事件18
MINOR_EVENT_CUSTOM19 = 0x512 # 门禁自定义事件19
MINOR_EVENT_CUSTOM20 = 0x513 # 门禁自定义事件20
MINOR_EVENT_CUSTOM21 = 0x514 # 门禁自定义事件21
MINOR_EVENT_CUSTOM22 = 0x515 # 门禁自定义事件22
MINOR_EVENT_CUSTOM23 = 0x516 # 门禁自定义事件23
MINOR_EVENT_CUSTOM24 = 0x517 # 门禁自定义事件24
MINOR_EVENT_CUSTOM25 = 0x518 # 门禁自定义事件25
MINOR_EVENT_CUSTOM26 = 0x519 # 门禁自定义事件26
MINOR_EVENT_CUSTOM27 = 0x51a # 门禁自定义事件27
MINOR_EVENT_CUSTOM28 = 0x51b # 门禁自定义事件28
MINOR_EVENT_CUSTOM29 = 0x51c # 门禁自定义事件29
MINOR_EVENT_CUSTOM30 = 0x51d # 门禁自定义事件30
MINOR_EVENT_CUSTOM31 = 0x51e # 门禁自定义事件31
MINOR_EVENT_CUSTOM32 = 0x51f # 门禁自定义事件32
MINOR_EVENT_CUSTOM33 = 0x520 # 门禁自定义事件33
MINOR_EVENT_CUSTOM34 = 0x521 # 门禁自定义事件34
MINOR_EVENT_CUSTOM35 = 0x522 # 门禁自定义事件35
MINOR_EVENT_CUSTOM36 = 0x523 # 门禁自定义事件36
MINOR_EVENT_CUSTOM37 = 0x524 # 门禁自定义事件37
MINOR_EVENT_CUSTOM38 = 0x525 # 门禁自定义事件38
MINOR_EVENT_CUSTOM39 = 0x526 # 门禁自定义事件39
MINOR_EVENT_CUSTOM40 = 0x527 # 门禁自定义事件40
MINOR_EVENT_CUSTOM41 = 0x528 # 门禁自定义事件41
MINOR_EVENT_CUSTOM42 = 0x529 # 门禁自定义事件42
MINOR_EVENT_CUSTOM43 = 0x52a # 门禁自定义事件43
MINOR_EVENT_CUSTOM44 = 0x52b # 门禁自定义事件44
MINOR_EVENT_CUSTOM45 = 0x52c # 门禁自定义事件45
MINOR_EVENT_CUSTOM46 = 0x52d # 门禁自定义事件46
MINOR_EVENT_CUSTOM47 = 0x52e # 门禁自定义事件47
MINOR_EVENT_CUSTOM48 = 0x52f # 门禁自定义事件48
MINOR_EVENT_CUSTOM49 = 0x530 # 门禁自定义事件49
MINOR_EVENT_CUSTOM50 = 0x531 # 门禁自定义事件50
MINOR_EVENT_CUSTOM51 = 0x532 # 门禁自定义事件51
MINOR_EVENT_CUSTOM52 = 0x533 # 门禁自定义事件52
MINOR_EVENT_CUSTOM53 = 0x534 # 门禁自定义事件53
MINOR_EVENT_CUSTOM54 = 0x535 # 门禁自定义事件54
MINOR_EVENT_CUSTOM55 = 0x536 # 门禁自定义事件55
MINOR_EVENT_CUSTOM56 = 0x537 # 门禁自定义事件56
MINOR_EVENT_CUSTOM57 = 0x538 # 门禁自定义事件57
MINOR_EVENT_CUSTOM58 = 0x539 # 门禁自定义事件58
MINOR_EVENT_CUSTOM59 = 0x53a # 门禁自定义事件59
MINOR_EVENT_CUSTOM60 = 0x53b # 门禁自定义事件60
MINOR_EVENT_CUSTOM61 = 0x53c # 门禁自定义事件61
MINOR_EVENT_CUSTOM62 = 0x53d # 门禁自定义事件62
MINOR_EVENT_CUSTOM63 = 0x53e # 门禁自定义事件63
MINOR_EVENT_CUSTOM64 = 0x53f # 门禁自定义事件64

MINOR_LOCK_FINGER_OPEN_DOOR = 0x600 # 智能锁指纹开门
MINOR_LOCK_PASSWORD_OPEN_DOOR = 0x601 # 智能锁密码开门
MINOR_LOCK_CARD_OPEN_DOOR = 0x602 # 智能锁刷卡开门
MINOR_LOCK_CENTER_OPEN_DOOR = 0x603 # 智能锁中心开门
MINOR_LOCK_APP_OPEN_DOOR = 0x604 # 智能锁APP开门
MINOR_LOCK_KEY_OPEN_DOOR = 0x605 # 智能锁钥匙开门
MINOR_LOCK_REMOTE_DEVICE_OPEN_DOOR = 0x606 # 智能锁遥控器开门
MINOR_LOCK_TMP_PASSWORD_OPEN_DOOR = 0x607 # 智能锁临时密码开门
MINOR_LOCK_BLUETOOTH_OPEN_DOOR = 0x608 # 智能锁蓝牙开门
MINOR_LOCK_MULTI_OPEN_DOOR = 0x609 # 智能锁多重开门

# 2018-04-23 通用物联网关事件日志类型
MINOR_ALARMHOST_SCHOOLTIME_IRGI_B = 0x1001 # B码校时
MINOR_ALARMHOST_SCHOOLTIME_SDK = 0x1002 # SDK校时
MINOR_ALARMHOST_SCHOOLTIME_SELFTEST = 0x1003 # 定制自检校时
MINOR_ALARMHOST_SUBSYSTEM_ABNORMALINSERT = 0x1004 # 子板插入
MINOR_ALARMHOST_SUBSYSTEM_ABNORMALPULLOUT = 0x1005 # 子板拔出

MINOR_ALARMHOST_AUTO_ARM = 0x1006 # 自动布防
MINOR_ALARMHOST_AUTO_DISARM = 0x1007 # 自动撤防
MINOR_ALARMHOST_TIME_TIGGER_ON = 0x1008 # 定时开启触发器
MINOR_ALARMHOST_TIME_TIGGER_OFF = 0x1009 # 定时关闭触发器
MINOR_ALARMHOST_AUTO_ARM_FAILD = 0x100a # 自动布防失败
MINOR_ALARMHOST_AUTO_DISARM_FAILD = 0x100b # 自动撤防失败
MINOR_ALARMHOST_TIME_TIGGER_ON_FAILD = 0x100c # 定时开启触发器失败
MINOR_ALARMHOST_TIME_TIGGER_OFF_FAILD = 0x100d # 定时关闭触发器失败
MINOR_ALARMHOST_MANDATORY_ALARM = 0x100e # 强制布防
MINOR_ALARMHOST_KEYPAD_LOCKED = 0x100f # 键盘锁定
MINOR_ALARMHOST_USB_INSERT = 0x1010 # USB插入
MINOR_ALARMHOST_USB_PULLOUT = 0x1011 # USB拔出
MINOR_ALARMHOST_4G_MODULS_ONLINE = 0x1012 # 4G模块上线
MINOR_ALARMHOST_4G_MODULS_OFFLINE = 0x1013 # 4G模块下线

MINOR_EZVIZ_CLOUD_ONLINE = 0x1014 # 萤石云上线
MINOR_EZVIZ_CLOUD_OFFLINE = 0x1015 # 萤石云下线

MINOR_SIPUA_GRID_ONLINE = 0x1016 # 国网B上线
MINOR_SIPUA_GRID_OFFLINE = 0x1017 # 国网B下线

MINOR_INTERNET_ACCESS_CONNECTED = 0x1018 # 网口连接
MINOR_INTERNET_ACCESS_BREAK = 0x1019 # 网口断开

MINOR_WIRELESS_CONNECTED = 0x101a # 无线连接
MINOR_WIRELESS_BREAK = 0x101b # 无线断开
MINOR_PORT_LINK_DOWN = 0x101c # 端口网络down
MINOR_PORT_LINK_UP = 0x101d # 端口网络up
MINOR_POE_PORT_POWER_ON = 0x101e # POE端口power on
MINOR_POE_PORT_POWER_OFF = 0x101f # POE端口power off
MINOR_POE_TOTAL_POWER_MAX = 0x1020 # POE总功率达到poe-max
MINNOR_POE_TOTAL_POWER_RESUME = 0x1021 # POE总功率恢复正常


MAX_FILE_PATH_LEN = 256 # 文件路径长度

####################################################
### Structures to be used in the library         ###
####################################################
# 校时结构参数
class NET_DVR_TIME(Structure):
    _fields_ = [
        ("dwYear", DWORD), # 年
        ("dwMonth", DWORD), # 月
        ("dwDay", DWORD), # 日
        ("dwHour", DWORD), # 时
        ("dwMinute", DWORD), # 分
        ("dwSecond", DWORD) # 秒
    ]


LPNET_DVR_TIME = POINTER(NET_DVR_TIME)


class NET_DVR_TIME_V30(Structure):
    _fields_ = [
        ("wYear", WORD),
        ("byMonth", BYTE),
        ("byDay", BYTE),
        ("byHour", BYTE),
        ("byMinute", BYTE),
        ("bySecond", BYTE),
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("wMilliSec", WORD), # 毫秒，精度不够，默认为0
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
        ("cTimeDifferenceM", CHAR) # 与UTC的时差（分钟），-30, 30, 45，+表示东区，byISO8601为1时有效
    ]


LPNET_DVR_TIME_V30 = POINTER(NET_DVR_TIME_V30)


class NET_DVR_TIME_SEARCH(Structure):
    _fields_ = [
        ("wYear", WORD), # 年，设备OSD时间
        ("byMonth", BYTE), # 月，设备OSD时间
        ("byDay", BYTE), # 日，设备OSD时间
        ("byHour", BYTE), # 时，设备OSD时间
        ("byMinute", BYTE), # 分，设备OSD时间
        ("bySecond", BYTE), # 秒，设备OSD时间
        ("cTimeDifferenceH", CHAR), # 与国际标准时间的时差（小时），-12 ... +14
        ("cTimeDifferenceM", CHAR), # 与国际标准时间的时差（分钟），-30, 0, 30, 45
        ("byLocalOrUTC", BYTE), # 0-时差无效，设备本地时间，即设备OSD时间  1-时差有效
        ("wMillisecond", WORD), # 毫秒，精度不够，默认为0
    ]


LPNET_DVR_TIME_SEARCH = POINTER(NET_DVR_TIME_SEARCH)


class NET_DVR_TIME_SEARCH_COND(Structure):
    _fields_ = [
        ("wYear", WORD), # 年
        ("byMonth", BYTE), # 月
        ("byDay", BYTE), # 日
        ("byHour", BYTE), # 时
        ("byMinute", BYTE), # 分
        ("bySecond", BYTE), # 秒
        ("byLocalOrUTC", BYTE), # 0-时差无效，设备本地时间，即设备OSD时间  1-时差有效
        ("wMillisecond", WORD), # 毫秒，精度不够，默认为0
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14，+表示东区，byLocalOrUTC为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 0, 30, 45，+表示东区，byLocalOrUTC为1时有效
    ]


LPNET_DVR_TIME_SEARCH_COND = POINTER(NET_DVR_TIME_SEARCH_COND)


class NET_DVR_TIME_V50(Structure):
    _fields_ = [
        ("wYear", WORD), # 年
        ("byMonth", BYTE), # 月
        ("byDay", BYTE), # 日
        ("byHour", BYTE), # 时
        ("byMinute", BYTE), # 分
        ("bySecond", BYTE), # 秒
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("wMillisecond", WORD), # 毫秒，精度不够，默认为0
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14，+表示东区，byISO8601为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 0, 30, 45，+表示东区，byISO8601为1时有效
    ]


LPNET_DVR_TIME_V50 = POINTER(NET_DVR_TIME_V50)


class NET_DVR_CALIBRATE_TIME(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTime", NET_DVR_TIME),
        ("wMilliSec", WORD),
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_CALIBRATE_TIME = POINTER(NET_DVR_CALIBRATE_TIME)


MAX_TIMESIGN_LEN = 32 # 自定义校时标记信息长度
class NET_DVR_TIMESIGN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCustomSetTimeSign", BYTE * MAX_TIMESIGN_LEN), # 自定义校时标记
        ("byRes", BYTE * 96),
    ]


LPNET_DVR_TIMESIGN_CFG = POINTER(NET_DVR_TIMESIGN_CFG)


class NET_DVR_TIME_EX(Structure):
    _fields_ = [
        ("wYear", WORD),
        ("byMonth", BYTE),
        ("byDay", BYTE),
        ("byHour", BYTE),
        ("byMinute", BYTE),
        ("bySecond", BYTE),
        ("byRes", BYTE),
    ]


LPNET_DVR_TIME_EX = POINTER(NET_DVR_TIME_EX)


# 时间段(子结构)
class NET_DVR_SCHEDTIME(Structure):
    _fields_ = [
        # 开始时间
        ("byStartHour", BYTE),
        ("byStartMin", BYTE),
        # 结束时间
        ("byStopHour", BYTE),
        ("byStopMin", BYTE),
    ]


LPNET_DVR_SCHEDTIME = POINTER(NET_DVR_SCHEDTIME)


# 设备报警和异常处理方式
NOACTION = 0x0 # 无响应
WARNONMONITOR = 0x1 # 监视器上警告
WARNONAUDIOOUT = 0x2 # 声音警告
UPTOCENTER = 0x4 # 上传中心
TRIGGERALARMOUT = 0x8 # 触发报警输出
TRIGGERCATPIC = 0x10 # 触发抓图并上传E-mail
SEND_PIC_FTP = 0x200 # 抓图并上传ftp

class NET_DVR_STRUCTHEAD(Structure):
    _fields_ = [
        ("wLength", WORD), # 结构长度
        ("byVersion", BYTE), # 高低4位分别代表高低版本，后续根据版本和长度进行扩展，不同的版本的长度进行限制
        ("byRes", BYTE),
    ]


LPNET_DVR_STRUCTHEAD = POINTER(NET_DVR_STRUCTHEAD)


class NET_DVR_HANDLEEXCEPTION_V41(Structure):
    _fields_ = [
        ("dwHandleType", DWORD), # 异常处理,异常处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: 触发JPRG抓图并上传Email
        # 0x20: 无线声光报警器联动
        # 0x40: 联动电子地图(目前只有PCNVR支持)
        # 0x200: 抓图并上传FTP
        # 0x400: 虚交侦测 联动 聚焦模式（提供可配置项，原先设备自动完成）IPC5.1.0
        # 0x800: PTZ联动跟踪(球机跟踪目标)
        # 0x4000:白光灯报警
        # 0x10000:短信报警
        ("dwMaxRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数（只读）最大支持数
        ("dwRelAlarmOut", DWORD * MAX_ALARMOUT_V40), # 触发报警通道
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_HANDLEEXCEPTION_V41 = POINTER(NET_DVR_HANDLEEXCEPTION_V41)


class NET_DVR_HANDLEEXCEPTION_V40(Structure):
    _fields_ = [
        ("dwHandleType", DWORD), # 异常处理,异常处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: 触发JPRG抓图并上传Email
        # 0x20: 无线声光报警器联动
        # 0x40: 联动电子地图(目前只有PCNVR支持)
        # 0x80: 报警触发录像(目前只有PCNVR支持)
        # 0x100: 报警触发云台预置点 (目前只有PCNVR支持)
        # 0x200: 抓图并上传FTP
        # 0x400: 虚交侦测 联动 聚焦模式（提供可配置项，原先设备自动完成）IPC5.1.0
        # 0x800: PTZ联动跟踪(球机跟踪目标)
        # 0x1000:抓图上传到云
        # 0x2000:短信报警
        # 0x4000:白光灯报警
        # 0x8000:语音报警
        ("dwMaxRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数（只读）最大支持数量
        ("dwRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数 实际支持数
        ("dwRelAlarmOut", DWORD * MAX_CHANNUM_V30), # 触发报警通道
        ("byWhiteLightDurationTime", BYTE), # 白光灯闪烁持续时长，1~60s(当开启了白光灯报警时生效)
        ("byBrightness", BYTE), # 白光灯亮度，范围0-100，默认50
        ("byAudioType", BYTE), # 声音报警类型
        ("byTimes", BYTE), # 声音报警次数，范围：0-9，默认2, 0xff-持续
        ("byRes", BYTE * 60), # 保留
    ]


LPNET_DVR_HANDLEEXCEPTION_V40 = POINTER(NET_DVR_HANDLEEXCEPTION_V40)


# 报警和异常处理结构(子结构)(多处使用)(9000扩展)
class NET_DVR_HANDLEEXCEPTION_V30(Structure):
    _fields_ = [
        ("dwHandleType", DWORD), # 处理方式,处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: 触发JPRG抓图并上传Email
        # 0x20: 无线声光报警器联动
        # 0x40: 联动电子地图(目前只有PCNVR支持)
        # 0x200: 抓图并上传FTP
        # 0x2000:短信报警
        ("byRelAlarmOut", BYTE * MAX_ALARMOUT_V30),
        # 报警触发的输出通道,报警触发的输出,为1表示触发该输出
    ]


LPNET_DVR_HANDLEEXCEPTION_V30 = POINTER(NET_DVR_HANDLEEXCEPTION_V30)


# 报警和异常处理结构(子结构)(多处使用)
class NET_DVR_HANDLEEXCEPTION(Structure):
    _fields_ = [
        ("dwHandleType", DWORD), # 处理方式,处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: Jpeg抓图并上传EMail
        ("byRelAlarmOut", BYTE * MAX_ALARMOUT), # 报警触发的输出通道,报警触发的输出,为1表示触发该输出
    ]


LPNET_DVR_HANDLEEXCEPTION = POINTER(NET_DVR_HANDLEEXCEPTION)


# DVR设备参数
class NET_DVR_DEVICECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sDVRName", BYTE * NAME_LEN), # DVR名称
        ("dwDVRID", DWORD), # DVR ID,用于遥控器 V1.4(0-99), V1.5(0-255)
        ("dwRecycleRecord", DWORD), # 是否循环录像,0:不是 1:是
        # 以下不可更改
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号
        ("dwSoftwareVersion", DWORD), # 软件版本号,高16位是主版本,低16位是次版本
        ("dwSoftwareBuildDate", DWORD), # 软件生成日期,0xYYYYMMDD
        ("dwDSPSoftwareVersion", DWORD), # DSP软件版本,高16位是主版本,低16位是次版本
        ("dwDSPSoftwareBuildDate", DWORD), #  DSP软件生成日期,0xYYYYMMDD
        ("dwPanelVersion", DWORD), #  前面板版本,高16位是主版本,低16位是次版本
        ("dwHardwareVersion", DWORD), #  硬件版本,高16位是主版本,低16位是次版本
        ("byAlarmInPortNum", BYTE), # DVR报警输入个数
        ("byAlarmOutPortNum", BYTE), # DVR报警输出个数
        ("byRS232Num", BYTE), # DVR 232串口个数
        ("byRS485Num", BYTE), # DVR 485串口个数
        ("byNetworkPortNum", BYTE), # 网络口个数
        ("byDiskCtrlNum", BYTE), # DVR 硬盘控制器个数
        ("byDiskNum", BYTE), # DVR 硬盘个数
        ("byDVRType", BYTE), # DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
        ("byChanNum", BYTE), # DVR 通道个数
        ("byStartChan", BYTE), # 起始通道号,例如DVS-1,DVR - 1
        ("byDecordChans", BYTE), # DVR 解码路数
        ("byVGANum", BYTE), # VGA口的个数
        ("byUSBNum", BYTE), # USB口的个数
        ("byAuxoutNum", BYTE), # 辅口的个数
        ("byAudioNum", BYTE), # 语音口的个数
        ("byIPChanNum", BYTE), # 最大数字通道数
    ]


LPNET_DVR_DEVICECFG = POINTER(NET_DVR_DEVICECFG)


# IP地址
class NET_DVR_IPADDR(Structure):
    _fields_ = [
        ("sIpV4", CHAR * 16), #  IPv4地址
        ("byIPv6", BYTE * 128), #  保留
    ]


LPNET_DVR_IPADDR = POINTER(NET_DVR_IPADDR)


class NET_DVR_ADDRESS(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), # IP地址
        ("wPort", WORD), # 端口号
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_ADDRESS = POINTER(NET_DVR_ADDRESS)


# 网络数据结构(子结构)(9000扩展)
class NET_DVR_ETHERNET_V30(Structure):
    _fields_ = [
        ("struDVRIP", NET_DVR_IPADDR), # DVR IP地址
        ("struDVRIPMask", NET_DVR_IPADDR), # DVR IP地址掩码
        ("dwNetInterface", DWORD), # 网络接口1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M自适应
        ("wDVRPort", WORD), # 端口号
        ("wMTU", WORD), # 增加MTU设置，默认1500。
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
        ("byEthernetPortNo", BYTE), # 网口号，0-无效，1-网口0，2-网口1以此类推，只读
        ("byRes", BYTE * 1), # 保留
    ]


LPNET_DVR_ETHERNET_V30 = POINTER(NET_DVR_ETHERNET_V30)


# 网络数据结构(子结构)
class NET_DVR_ETHERNET(Structure):
    _fields_ = [
        ("sDVRIP", CHAR * 16), # DVR IP地址
        ("sDVRIPMask", CHAR * 16), # DVR IP地址掩码
        ("dwNetInterface", DWORD), # 网络接口 1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M自适应
        ("wDVRPort", WORD), # 端口号
        ("byMACAddr", BYTE * MACADDR_LEN), # 服务器的物理地址
    ]


# pppoe结构
class NET_DVR_PPPOECFG(Structure):
    _fields_ = [
        ("dwPPPOE", DWORD), # 0-不启用,1-启用
        ("sPPPoEUser", BYTE * NAME_LEN), # PPPoE用户名
        ("sPPPoEPassword", CHAR * PASSWD_LEN), #  PPPoE密码
        ("struPPPoEIP", NET_DVR_IPADDR), # PPPoE IP地址
    ]


LPNET_DVR_PPPOECFG = POINTER(NET_DVR_PPPOECFG)


# 网络配置结构(9000扩展)
class NET_DVR_NETCFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struEtherNet", NET_DVR_ETHERNET_V30 * MAX_ETHERNET), # 以太网口
        ("struRes1", NET_DVR_IPADDR * 2), # 保留
        ("struAlarmHostIpAddr", NET_DVR_IPADDR), #  报警主机IP地址
        ("byRes2", BYTE * 4), #  保留
        ("wAlarmHostIpPort", WORD), #  报警主机端口号
        ("byUseDhcp", BYTE), #  是否启用DHCP 0xff-无效 0-不启用 1-启用
        ("byIPv6Mode", BYTE), # IPv6分配方式，0-路由公告，1-手动设置，2-启用DHCP分配
        ("struDnsServer1IpAddr", NET_DVR_IPADDR), #  域名服务器1的IP地址
        ("struDnsServer2IpAddr", NET_DVR_IPADDR), #  域名服务器2的IP地址
        ("byIpResolver", BYTE * MAX_DOMAIN_NAME), #  IP解析服务器域名或IP地址
        ("wIpResolverPort", WORD), #  IP解析服务器端口号
        ("wHttpPortNo", WORD), #  HTTP端口号
        ("struMulticastIpAddr", NET_DVR_IPADDR), #  多播组地址
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关地址
        ("struPPPoE", NET_DVR_PPPOECFG),
        ("byEnablePrivateMulticastDiscovery", BYTE), # 私有多播搜索，0~默认，1~启用，2-禁用
        ("byEnableOnvifMulticastDiscovery", BYTE), # Onvif多播搜索，0~默认，1~启用，2-禁用
        ("byEnableDNS", BYTE), # DNS自动使能, 0-保留，1-打开，2-关闭
        ("byRes", BYTE * 61),
    ]


LPNET_DVR_NETCFG_V30 = POINTER(NET_DVR_NETCFG_V30)


# 多网卡配置网卡结构
class NET_DVR_ETHERNET_MULTI(Structure):
    _fields_ = [
        ("struDVRIP", NET_DVR_IPADDR), # DVR IP地址
        ("struDVRIPMask", NET_DVR_IPADDR), # DVR IP地址掩码
        ("dwNetInterface", DWORD), # 网络接口1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M/1000M自适应
        ("byCardType", BYTE), # 网卡类型，0-普通网卡，1-内网网卡，2-外网网卡
        ("byEnableDNS", BYTE), # DNS是否自动使能，0-保留，1-打开, 0-关闭
        ("wMTU", WORD), # 增加MTU设置，默认1500。
        ("byMACAddr", BYTE * MACADDR_LEN), # 物理地址，只用于显示
        ("byEthernetPortNo", BYTE), # 网口号，0-无效，1-网口0，2-网口1以此类推，只读
        ("bySilkScreen", BYTE), # 丝印信息，0-无效，1-GE1，2-GE2，3-G1，4-G2，只读
        ("byUseDhcp", BYTE), #  是否启用DHCP
        ("byRes3", BYTE * 3),
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关地址
        ("struDnsServer1IpAddr", NET_DVR_IPADDR), #  域名服务器1的IP地址
        ("struDnsServer2IpAddr", NET_DVR_IPADDR), #  域名服务器2的IP地址
    ]


LPNET_DVR_ETHERNET_MULTI = POINTER(NET_DVR_ETHERNET_MULTI)


# 多网卡网络配置结构
class NET_DVR_NETCFG_MULTI(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDefaultRoute", BYTE), # 默认路由，0表示struEtherNet[0]，1表示struEtherNet[1]
        ("byNetworkCardNum", BYTE), # 设备实际可配置的网卡数目
        ("byWorkMode", BYTE), # 0-普通多网卡模式，1-内外网隔离模式
        ("byRes", BYTE), # 保留
        ("struEtherNet", NET_DVR_ETHERNET_MULTI * MAX_NETWORK_CARD), # 以太网口
        ("struManageHost1IpAddr", NET_DVR_IPADDR), #  主管理主机IP地址
        ("struManageHost2IpAddr", NET_DVR_IPADDR), #  辅管理主机IP地址
        ("struAlarmHostIpAddr", NET_DVR_IPADDR), #  报警主机IP地址
        ("wManageHost1Port", WORD), #  主管理主机端口号
        ("wManageHost2Port", WORD), #  辅管理主机端口号
        ("wAlarmHostIpPort", WORD), #  报警主机端口号
        ("byIpResolver", BYTE * MAX_DOMAIN_NAME), #  IP解析服务器域名或IP地址
        ("wIpResolverPort", WORD), #  IP解析服务器端口号
        ("wDvrPort", WORD), # 通讯端口 默认8000
        ("wHttpPortNo", WORD), #  HTTP端口号
        ("wDvrPort2", WORD), # 通讯端口2
        ("byRes2", BYTE * 4),
        ("struMulticastIpAddr", NET_DVR_IPADDR), #  多播组地址
        ("struPPPoE", NET_DVR_PPPOECFG),
        ("byRes3", BYTE * 24),
    ]


LPNET_DVR_NETCFG_MULTI = POINTER(NET_DVR_NETCFG_MULTI)


# 网络配置结构
class NET_DVR_NETCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struEtherNet", NET_DVR_ETHERNET * MAX_ETHERNET), #  以太网口
        ("sManageHostIP", CHAR * 16), # 远程管理主机地址
        ("wManageHostPort", WORD), # 远程管理主机端口号
        ("sIPServerIP", CHAR * 16), # IPServer服务器地址
        ("sMultiCastIP", CHAR * 16), # 多播组地址
        ("sGatewayIP", CHAR * 16), # 网关地址
        ("sNFSIP", CHAR * 16), # NFS主机IP地址
        ("sNFSDirectory", BYTE * PATHNAME_LEN), # NFS目录
        ("dwPPPOE", DWORD), # 0-不启用,1-启用
        ("sPPPoEUser", BYTE * NAME_LEN), # PPPoE用户名
        ("sPPPoEPassword", CHAR * PASSWD_LEN), #  PPPoE密码
        ("sPPPoEIP", CHAR * 16), # PPPoE IP地址(只读)
        ("wHttpPort", WORD), # HTTP端口号
    ]


LPNET_DVR_NETCFG = POINTER(NET_DVR_NETCFG)


# 网络配置结构(V50)
class NET_DVR_NETCFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struEtherNet", NET_DVR_ETHERNET_V30 * MAX_ETHERNET), # 以太网口
        ("struRes1", NET_DVR_IPADDR * 2), # 保留
        ("struAlarmHostIpAddr", NET_DVR_IPADDR), #  报警主机IP地址
        ("byRes2", BYTE * 4), #  保留
        ("wAlarmHostIpPort", WORD), #  报警主机端口号
        ("byUseDhcp", BYTE), #  是否启用DHCP 0xff-无效 0-不启用 1-启用
        ("byIPv6Mode", BYTE), # IPv6分配方式，0-路由公告，1-手动设置，2-启用DHCP分配
        ("struDnsServer1IpAddr", NET_DVR_IPADDR), #  域名服务器1的IP地址
        ("struDnsServer2IpAddr", NET_DVR_IPADDR), #  域名服务器2的IP地址
        ("byIpResolver", BYTE * MAX_DOMAIN_NAME), #  IP解析服务器域名或IP地址
        ("wIpResolverPort", WORD), #  IP解析服务器端口号
        ("wHttpPortNo", WORD), #  HTTP端口号
        ("struMulticastIpAddr", NET_DVR_IPADDR), #  多播组地址
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关地址
        ("struPPPoE", NET_DVR_PPPOECFG),
        ("byEnablePrivateMulticastDiscovery", BYTE), # 私有多播搜索，0~默认，1~启用，2-禁用
        ("byEnableOnvifMulticastDiscovery", BYTE), # Onvif多播搜索，0~默认，1~启用，2-禁用
        ("wAlarmHost2IpPort", WORD), #  报警主机2端口号
        ("struAlarmHost2IpAddr", NET_DVR_IPADDR), #  报警主机2 IP地址
        ("byEnableDNS", BYTE), # DNS使能, 0-关闭，1-打开
        ("byRes", BYTE * 599),
    ]


LPNET_DVR_NETCFG_V50 = POINTER(NET_DVR_NETCFG_V50)


# sip配置
class NET_DVR_SIP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableAutoLogin", BYTE), # 使能自动注册，0-不使能，1-使能
        ("byLoginStatus", BYTE), # 注册状态，0-未注册，1-已注册，此参数只能获取
        ("byRes1", BYTE * 2),
        ("stuServerIP", NET_DVR_IPADDR), # SIP服务器IP
        ("wServerPort", WORD), # SIP服务器端口
        ("byRes2", BYTE * 2),
        ("byUserName", BYTE * NAME_LEN), # 注册用户名
        ("byPassWord", BYTE * PASSWD_LEN), # 注册密码
        ("byLocalNo", BYTE * MAX_NUMBER_LEN),
        ("byDispalyName", BYTE * MAX_NAME_LEN), # 设备显示名称
        ("wLocalPort", WORD), # 本地端口
        ("byLoginCycle", BYTE), # 注册周期，1-99分钟
        ("byType", BYTE), # 0-IP/IPV6,1-域名
        ("byDomainName", BYTE * MAX_DOMAIN_NAME), # 域名
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SIP_CFG = POINTER(NET_DVR_SIP_CFG)


class NET_DVR_SIP_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableAutoLogin", BYTE), # 使能自动注册，0-不使能，1-使能
        ("byLoginStatus", BYTE), # 注册状态，0-未注册，1-已注册，此参数只能获取
        ("byRes1", BYTE * 2),
        ("stuServerIP", NET_DVR_IPADDR), # SIP服务器IP
        ("wServerPort", WORD), # SIP服务器端口
        ("byRes2", BYTE * 2),
        ("byUserName", BYTE * NAME_LEN), # 注册用户名
        ("byPassWord", BYTE * PASSWD_LEN), # 注册密码
        ("byLocalNo", BYTE * MAX_NUMBER_LEN),
        ("byDispalyName", BYTE * MAX_NAME_LEN), # 设备显示名称
        ("wLocalPort", WORD), # 本地端口
        ("byLoginCycle", BYTE), # 注册周期，1-99分钟
        ("byRes3", BYTE),
        ("bySIPServerDomain", BYTE * MAX_DOMAIN_NAME), # sip服务器域名（IP和域名只需要填其一，都有值时IP优先）
        ("stuSTUNServerIP", NET_DVR_IPADDR), #  STUN服务器IP
        ("bySTUNServerDomain", BYTE * MAX_DOMAIN_NAME), # STUN服务器域名 （IP和域名只需要填其一，都有值时IP优先）
        ("wSTUNServerPort", WORD), #  STUN服务器端口
        ("byRes4", BYTE * 2),
        ("stuProxyServerIP", NET_DVR_IPADDR), # 代理服务器IP
        ("byProxyServerDomain", BYTE * MAX_DOMAIN_NAME), # 代理服务器域名 （IP和域名只需要填其一，都有值时IP优先）
        ("wProxyServerPort", WORD), #  代理服务器端口
        ("byNetWork", BYTE), # 表示网络类型，0-无效，1-有线网络1， 2-有线网络2，3-无线网络
        ("byRes5", BYTE),
        ("byCalledTargetName", BYTE * NET_SDK_MAX_CALLEDTARGET_NAME),
        ("byRes", BYTE * 224),
    ]


LPNET_DVR_SIP_CFG_V50 = POINTER(NET_DVR_SIP_CFG_V50)


# IP可视对讲分机配置
class NET_DVR_IP_VIEW_DEVCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDefaultRing", BYTE), # 默认铃音，范围1-6
        ("byRingVolume", BYTE), # 铃音音量，范围0-9
        ("byInputVolume", BYTE), # 输入音量值，范围0-6
        ("byOutputVolume", BYTE), # 输出音量值，范围0-9
        ("wRtpPort", WORD), # Rtp端口
        ("byRes1", BYTE * 2),
        ("dwPreviewDelayTime", DWORD), # 预览延时配置，0-30秒
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_IP_VIEW_DEVCFG = POINTER(NET_DVR_IP_VIEW_DEVCFG)


# Ip可视对讲音频相关参数配置
class NET_DVR_IP_VIEW_AUDIO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAudioEncPri1", BYTE), # 音频编码优先级1，0-G722，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
        ("byAudioEncPri2", BYTE), # 音频编码优先级2，当sip服务器不支持音频编码1时会使用音频编码2，0-G722，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
        ("wAudioPacketLen1", WORD), # 音频编码1数据包长度
        ("wAudioPacketLen2", WORD), # 音频编码2数据包长度
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_IP_VIEW_AUDIO_CFG = POINTER(NET_DVR_IP_VIEW_AUDIO_CFG)


# IP分机呼叫对讲参数配置结构体
class NET_DVR_IP_VIEW_CALL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableAutoResponse", BYTE), # 使能自动应答,0-不使能，1-使能
        ("byAudoResponseTime", BYTE), # 自动应答时间，0-30秒
        ("byRes1", BYTE * 2),
        ("byEnableAlarmNumber1", BYTE), # 启动报警号码1，0-不启动，1-启动
        ("byRes2", BYTE * 3),
        ("byAlarmNumber1", BYTE * MAX_NUMBER_LEN), # 呼叫号码1
        ("byEnableAlarmNumber2", BYTE), # 启动报警号码2，0-不启动，1-启动
        ("byRes3", BYTE * 3),
        ("byAlarmNumber2", BYTE * MAX_NUMBER_LEN), # 呼叫号码2，呼叫号码1失败会尝试呼叫号码2
        ("byRes4", BYTE * 72),
    ]


LPNET_DVR_IP_VIEW_CALL_CFG = POINTER(NET_DVR_IP_VIEW_CALL_CFG)


# 通道图象结构
# 移动侦测(子结构)(按组方式扩展)
class NET_DVR_RECORDCHAN(Structure):
    _fields_ = [
        ("dwMaxRecordChanNum", DWORD), # 设备支持的最大关联录像通道数-只读
        ("dwCurRecordChanNum", DWORD), # 当前实际已配置的关联录像通道数
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V30), #  实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - MAX_CHANNUM_V30-1有效，如果中间遇到0xffffffff,则后续无效
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_RECORDCHAN = POINTER(NET_DVR_RECORDCHAN)


# 移动侦测(子结构)(9000扩展)
class NET_DVR_MOTION_V30(Structure):
    _fields_ = [
        ("byMotionScope", BYTE * 64), # 侦测区域,0-96位,表示64行,共有96*64个小宏块,为1表示是移动侦测区域,0-表示不是
        ("byMotionSensitive", BYTE), # 移动侦测灵敏度, 0 - 5,越高越灵敏,oxff关闭
        ("byEnableHandleMotion", BYTE), #  是否处理移动侦测 0－否 1－是
        ("byEnableDisplay", BYTE), # 启用移动侦测高亮显示，0-否，1-是
        ("reservedData", CHAR),
        ("struMotionHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), #  报警触发的录象通道
    ]


LPNET_DVR_MOTION_V30 = POINTER(NET_DVR_MOTION_V30)


# 移动侦测(子结构)
class NET_DVR_MOTION(Structure):
    _fields_ = [
        ("byMotionScope", BYTE * 18), # 侦测区域,共有22*18个小宏块,为1表示改宏块是移动侦测区域,0-表示不是
        ("byMotionSensitive", BYTE), # 移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
        ("byEnableHandleMotion", BYTE), #  是否处理移动侦测
        ("byEnableDisplay", BYTE), # 启用移动侦测高亮显示，0-否，1-是
        ("reservedData", CHAR),
        ("strMotionHandleType", NET_DVR_HANDLEEXCEPTION), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRelRecordChan", BYTE * MAX_CHANNUM), # 报警触发的录象通道,为1表示触发该通道
    ]


LPNET_DVR_MOTION = POINTER(NET_DVR_MOTION)


# 遮挡报警(子结构)(9000扩展)  区域大小704*576
class NET_DVR_HIDEALARM_V30(Structure):
    _fields_ = [
        ("dwEnableHideAlarm", DWORD), #  是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度
        ("wHideAlarmAreaTopLeftX", WORD), #  遮挡区域的x坐标
        ("wHideAlarmAreaTopLeftY", WORD), #  遮挡区域的y坐标
        ("wHideAlarmAreaWidth", WORD), #  遮挡区域的宽
        ("wHideAlarmAreaHeight", WORD), # 遮挡区域的高
        ("strHideAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
    ]


LPNET_DVR_HIDEALARM_V30 = POINTER(NET_DVR_HIDEALARM_V30)


# 遮挡报警(子结构)  区域大小704*576
class NET_DVR_HIDEALARM(Structure):
    _fields_ = [
        ("dwEnableHideAlarm", DWORD), #  是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度
        ("wHideAlarmAreaTopLeftX", WORD), #  遮挡区域的x坐标
        ("wHideAlarmAreaTopLeftY", WORD), #  遮挡区域的y坐标
        ("wHideAlarmAreaWidth", WORD), #  遮挡区域的宽
        ("wHideAlarmAreaHeight", WORD), # 遮挡区域的高
        ("strHideAlarmHandleType", NET_DVR_HANDLEEXCEPTION), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
    ]


LPNET_DVR_HIDEALARM = POINTER(NET_DVR_HIDEALARM)


# 信号丢失报警(子结构)(9000扩展)
class NET_DVR_VILOST_V30(Structure):
    _fields_ = [
        ("byEnableHandleVILost", BYTE), #  是否处理信号丢失报警
        ("strVILostHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
    ]


LPNET_DVR_VILOST_V30 = POINTER(NET_DVR_VILOST_V30)


# 信号丢失报警(子结构)
class NET_DVR_VILOST(Structure):
    _fields_ = [
        ("byEnableHandleVILost", BYTE), #  是否处理信号丢失报警
        ("strVILostHandleType", NET_DVR_HANDLEEXCEPTION), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
    ]


LPNET_DVR_VILOST = POINTER(NET_DVR_VILOST)



# 遮挡区域(子结构)
class NET_DVR_SHELTER(Structure):
    _fields_ = [
        ("wHideAreaTopLeftX", WORD), #  遮挡区域的x坐标
        ("wHideAreaTopLeftY", WORD), #  遮挡区域的y坐标
        ("wHideAreaWidth", WORD), #  遮挡区域的宽
        ("wHideAreaHeight", WORD), # 遮挡区域的高
    ]


LPNET_DVR_SHELTER = POINTER(NET_DVR_SHELTER)


class NET_DVR_COLOR(Structure):
    _fields_ = [
        ("byBrightness", BYTE), # 亮度,0-255
        ("byContrast", BYTE), # 对比度,0-255
        ("bySaturation", BYTE), # 饱和度,0-255
        ("byHue", BYTE), # 色调,0-255
    ]


LPNET_DVR_COLOR = POINTER(NET_DVR_COLOR)


class NET_DVR_RGB_COLOR(Structure):
    _fields_ = [
        ("byRed", BYTE), # RGB颜色三分量中的红色
        ("byGreen", BYTE), # RGB颜色三分量中的绿色
        ("byBlue", BYTE), # RGB颜色三分量中的蓝色
        ("byRes", BYTE), # 保留
    ]


LPNET_DVR_RGB_COLOR = POINTER(NET_DVR_RGB_COLOR)


# 坐标值归一化,浮点数值为当前画面的百分比大小, 精度为小数点后三位
# 点坐标结构
class NET_VCA_POINT(Structure):
    _fields_ = [
        ("fX", DOUBLE), #  X轴坐标, 0.000~1
        ("fY", DOUBLE), # Y轴坐标, 0.000~1
    ]


LPNET_VCA_POINT = POINTER(NET_VCA_POINT)


# 通道图象结构(9000扩展)
class NET_DVR_PICCFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sChanName", BYTE * NAME_LEN),
        ("dwVideoFormat", DWORD), #  只读 视频制式 1-NTSC 2-PAL
        ("byReservedData", BYTE * 64), # 保留
        ("dwShowChanName", DWORD), #  预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
        ("wShowNameTopLeftX", WORD), #  通道名称显示位置的x坐标
        ("wShowNameTopLeftY", WORD), #  通道名称显示位置的y坐标
        #视频信号丢失报警
        ("struVILost", NET_DVR_VILOST_V30),
        ("struRes", NET_DVR_VILOST_V30), # 保留
        #BYTE byRes1[328];
        #移动侦测
        ("struMotion", NET_DVR_MOTION_V30),
        #遮挡报警
        ("struHideAlarm", NET_DVR_HIDEALARM_V30),
        #遮挡  区域大小704*576
        ("dwEnableHide", DWORD), #  是否启动遮挡 ,0-否,1-是
        ("struShelter", NET_DVR_SHELTER * MAX_SHELTERNUM),
        #OSD
        ("dwShowOsd", DWORD), #  预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
        ("wOSDTopLeftX", WORD), #  OSD的x坐标
        ("wOSDTopLeftY", WORD), #  OSD的y坐标
        ("byOSDType", BYTE), #  OSD类型(主要是年月日格式)
        #0: XXXX-XX-XX 年月日
        #1: XX-XX-XXXX 月日年
        #2: XXXX年XX月XX日
        #3: XX月XX日XXXX年
        #4: XX-XX-XXXX 日月年
        #5: XX日XX月XXXX年
        #6: xx/xx/xxxx(月/日/年)
        #7: xxxx/xx/xx(年/月/日)
        #8: xx/xx/xxxx(日/月/年)
        ("byDispWeek", BYTE), #  是否显示星期
        ("byOSDAttrib", BYTE), #  OSD属性:透明，闪烁
        #1: 透明,闪烁
        #2: 透明,不闪烁
        #3: 闪烁,不透明
        #4: 不透明,不闪烁
        ("byHourOSDType", BYTE), #  OSD小时制:0-24小时制,1-12小时制
        ("byFontSize", BYTE), # 字体大小，16*16(中)/8*16(英)，1-32*32(中)/16*32(英)，2-64*64(中)/32*64(英)  3-48*48(中)/24*48(英) 4-24*24(中)/12*24(英) 5-96*96(中)/48*96(英) 6-128*128(中)/64*128(英) 7-80*80(中)/40*80(英) 8-112*112(中)/56*112(英) 0xff-自适应(adaptive)
        ("byOSDColorType", BYTE), # 0-默认（黑白）；1-自定义
        #当对齐方式选择国标模式时，可以分别对右下角、左下角两个区域做字符叠加。
        #右下角区域：
        #共支持6行字符叠加，可以通过NET_DVR_SET_SHOWSTRING_V30字符叠加接口，对应NET_DVR_SHOWSTRINGINFO结构体数组中的第0至第5个下标的值。叠加字符的方式为从下到上的方式。
        #左下角区域：
        #共支持2行字符叠加，可以通过NET_DVR_SET_SHOWSTRING_V30字符叠加接口，对应NET_DVR_SHOWSTRINGINFO结构体数组中的第6和第7个下标的值。叠加字符的方式为从下到上的方式。
        #
        ("byAlignment", BYTE), # 对齐方式 0-自适应，1-右对齐, 2-左对齐,3-国标模式, 4-全部右对齐(包含叠加字符、时间以及标题等所有OSD字符)，5-全部左对齐(包含叠加字符、时间以及标题等所有OSD字符)
        ("byOSDMilliSecondEnable", BYTE), # 视频叠加时间支持毫秒；0~不叠加, 1-叠加
        ("struOsdColor", NET_DVR_RGB_COLOR), # OSD颜色
        ("dwBoundary", DWORD), # 边界值，左对齐，右对齐以及国标模式的边界值，0-表示默认值，单位：像素
        ("struOsdBkColor", NET_DVR_RGB_COLOR), # 自定义OSD背景色
        ("byOSDBkColorMode", BYTE), # OSD背景色模式，0-默认，1-自定义OSD背景色
        ("byUpDownBoundary", BYTE), # 上下最小边界值选项，单位为字符个数（范围是，0,1,2）, 国标模式下无效。byAlignment=3该字段无效，通过dwBoundary进行边界配置，.byAlignment不等于3的情况下， byUpDownBoundary/byLeftRightBoundary配置成功后，dwBoundary值将不生效
        ("byLeftRightBoundary", BYTE), # 左右最小边界值选项，单位为字符个数（范围是，0,1,2）, 国标模式下无效。byAlignment=3该字段无效，通过dwBoundary进行边界配置，.byAlignment不等于3的情况下， byUpDownBoundary/byLeftRightBoundary配置成功后，dwBoundary值将不生效
        ("byAngleEnabled", BYTE), # OSD是否叠加俯仰角信息,0~不叠加, 1-叠加
        ("wTiltAngleTopLeftX", WORD), #  俯仰角信息显示位置的x坐标
        ("wTiltAngleTopLeftY", WORD), #  俯仰角信息显示位置的y坐标
        ("byRes", BYTE * 40),
    ]


LPNET_DVR_PICCFG_V30 = POINTER(NET_DVR_PICCFG_V30)


# 通道图象结构SDK_V14扩展
class NET_DVR_PICCFG_EX(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sChanName", BYTE * NAME_LEN),
        ("dwVideoFormat", DWORD), #  只读 视频制式 1-NTSC 2-PAL
        ("byBrightness", BYTE), # 亮度,0-255
        ("byContrast", BYTE), # 对比度,0-255
        ("bySaturation", BYTE), # 饱和度,0-255
        ("byHue", BYTE), # 色调,0-255
        #显示通道名
        ("dwShowChanName", DWORD), #  预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
        ("wShowNameTopLeftX", WORD), #  通道名称显示位置的x坐标
        ("wShowNameTopLeftY", WORD), #  通道名称显示位置的y坐标
        #信号丢失报警
        ("struVILost", NET_DVR_VILOST),
        #移动侦测
        ("struMotion", NET_DVR_MOTION),
        #遮挡报警
        ("struHideAlarm", NET_DVR_HIDEALARM),
        #遮挡  区域大小704*576
        ("dwEnableHide", DWORD), #  是否启动遮挡 ,0-否,1-是
        ("struShelter", NET_DVR_SHELTER * MAX_SHELTERNUM),
        #OSD
        ("dwShowOsd", DWORD), #  预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
        ("wOSDTopLeftX", WORD), #  OSD的x坐标
        ("wOSDTopLeftY", WORD), #  OSD的y坐标
        ("byOSDType", BYTE), #  OSD类型(主要是年月日格式)
        #0: XXXX-XX-XX 年月日
        #1: XX-XX-XXXX 月日年
        #2: XXXX年XX月XX日
        #3: XX月XX日XXXX年
        #4: XX-XX-XXXX 日月年
        #5: XX日XX月XXXX年
        #6: xx/xx/xxxx(月/日/年)
        #7: xxxx/xx/xx(年/月/日)
        #8: xx/xx/xxxx(日/月/年)
        ("byDispWeek", BYTE), #  是否显示星期
        ("byOSDAttrib", BYTE), #  OSD属性:透明，闪烁
        #1: 透明,闪烁
        #2: 透明,不闪烁
        #3: 闪烁,不透明
        #4: 不透明,不闪烁
        ("byHourOsdType", BYTE), #  OSD小时制:0-24小时制,1-12小时制
    ]


LPNET_DVR_PICCFG_EX = POINTER(NET_DVR_PICCFG_EX)


# 通道图象结构(SDK_V13及之前版本)
class NET_DVR_PICCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sChanName", BYTE * NAME_LEN),
        ("dwVideoFormat", DWORD), #  只读 视频制式 1-NTSC 2-PAL
        ("byBrightness", BYTE), # 亮度,0-255
        ("byContrast", BYTE), # 对比度,0-255
        ("bySaturation", BYTE), # 饱和度,0-255
        ("byHue", BYTE), # 色调,0-255
        #显示通道名
        ("dwShowChanName", DWORD), #  预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
        ("wShowNameTopLeftX", WORD), #  通道名称显示位置的x坐标
        ("wShowNameTopLeftY", WORD), #  通道名称显示位置的y坐标
        #信号丢失报警
        ("struVILost", NET_DVR_VILOST),
        #移动侦测
        ("struMotion", NET_DVR_MOTION),
        #遮挡报警
        ("struHideAlarm", NET_DVR_HIDEALARM),
        #遮挡  区域大小704*576
        ("dwEnableHide", DWORD), #  是否启动遮挡 ,0-否,1-是
        ("wHideAreaTopLeftX", WORD), #  遮挡区域的x坐标
        ("wHideAreaTopLeftY", WORD), #  遮挡区域的y坐标
        ("wHideAreaWidth", WORD), #  遮挡区域的宽
        ("wHideAreaHeight", WORD), # 遮挡区域的高
        #OSD
        ("dwShowOsd", DWORD), #  预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
        ("wOSDTopLeftX", WORD), #  OSD的x坐标
        ("wOSDTopLeftY", WORD), #  OSD的y坐标
        ("byOSDType", BYTE), #  OSD类型(主要是年月日格式)
        #0: XXXX-XX-XX 年月日
        #1: XX-XX-XXXX 月日年
        #2: XXXX年XX月XX日
        #3: XX月XX日XXXX年
        #4: XX-XX-XXXX 日月年
        #5: XX日XX月XXXX年
        #6: xx/xx/xxxx(月/日/年)
        #7: xxxx/xx/xx(年/月/日)
        #8: xx/xx/xxxx(日/月/年)
        ("byDispWeek", BYTE), #  是否显示星期
        ("byOSDAttrib", BYTE), #  OSD属性:透明，闪烁
        #1: 透明,闪烁
        #2: 透明,不闪烁
        #3: 闪烁,不透明
        #4: 不透明,不闪烁
        ("reservedData2", CHAR),
    ]


LPNET_DVR_PICCFG = POINTER(NET_DVR_PICCFG)

BITRATE_ENCODE_def = 0
BITRATE_ENCODE_8kps = 1
BITRATE_ENCODE_16kps = 2
BITRATE_ENCODE_32kps = 3
BITRATE_ENCODE_64kps = 4
BITRATE_ENCODE_128kps = 5
BITRATE_ENCODE_192kps = 6
BITRATE_ENCODE_40kps = 7
BITRATE_ENCODE_48kps = 8
BITRATE_ENCODE_56kps = 9
BITRATE_ENCODE_80kps = 10
BITRATE_ENCODE_96kps = 11
BITRATE_ENCODE_112kps = 12
BITRATE_ENCODE_144kps = 13
BITRATE_ENCODE_160kps = 14
BITRATE_ENCODE_224kps = 15
BITRATE_ENCODE_256kps = 16
BITRATE_ENCODE_320kps = 17

# 码流压缩参数(子结构)(9000扩展)
class NET_DVR_COMPRESSION_INFO_V30(Structure):
    _fields_ = [
        ("byStreamType", BYTE), # 码流类型 0-视频流, 1-复合流, 表示事件压缩参数时最高位表示是否启用压缩参数
        # 分辨率0-DCIF                      1-CIF,                     2-QCIF,                 3-4CIF,
        # 4-2CIF                      5（保留）,                 6-QVGA(320*240),        7-QQVGA(160*120),
        # 12-384*288                  13-576*576,
        # 16-VGA（640*480）,          17-UXGA（1600*1200）,      18-SVGA(800*600),       19-HD720p(1280*720）,
        # 20-XVGA,                    21-HD900p,                 22-1360*1024,           23-1536*1536,
        # 24-1920*1920,               27-HD1080i,
        # 28-2560*1920,               29-1600*304,               30-2048*1536,           31-2448*2048,
        # 32-2448*1200,               33-2448*800,               34-XGA（1024*768），    35-SXGA（1280*1024）,
        # 36-WD1(960*576/960*480),    37-1080i,                  38-WSXGA(1440*900),     39-HD_F(1920*1080/1280*720),
        # 40-HD_H(1920*540/1280*360), 41-HD_Q(960*540/630*360),  42-2336*1744,           43-1920*1456,
        # 44-2592*2048,               45-3296*2472,              46-1376*768,            47-1366*768,
        # 48-1360*768,                49-WSXGA+,                 50-720*720,             51-1280*1280,
        # 52-2048*768,                53-2048*2048,              54-2560*2048,           55-3072*2048,
        # 56-2304*1296                57-WXGA(1280*800),         58-1600*600,               59-1600*900,
        # 60-2752*2208,                61-保留,                   62-4000*3000,           63-4096*2160,
        # 64-3840*2160,                65-4000*2250,              66-3072*1728,           67-2592*1944,
        # 68-2464*1520,               69-1280*1920,              70-2560*1440,           71-1024*1024,
        # 72-160*128,                 73-324*240,                74-324*256,             75-336*256,
        # 76-640*512,                 77-2720*2048,              78-384*256,             79-384*216,
        # 80-320*256,                 81-320*180,                82-320*192,             83-512*384,
        # 84-325*256,                 85-256*192,                86-640*360,               87-1776x1340,
        # 88-1936x1092,                89-2080x784,               90-2144x604,            91-1920*1200,
        # 92-4064*3040,               93-3040*3040,              94-3072*2304,           95-3072*1152,
        # 96-2560*2560,               97-2688*1536,              98-2688*1520,           99-3072*3072,
        # 100-3392*2008,              101-4000*3080,             102-960*720,            103-1024*1536,
        # 104-704*1056,               105-352*528,               106-2048*1530,          107-2560*1600,
        # 108-2800*2100,              109-4088*4088,             110-4000*3072,           111-960*1080(1080p Lite)
        # 112-640*720(half 720p),     113-640*960,               114-320*480,             115-3840*2400,
        # 116-3840*1680,              117-2560*1120,             118-704*320,             119-1200*1920,
        # 120-480*768,                121-768*480,               122-320*512,             123-512*320,
        # 124-4096*1800,              125-1280*560,              126-2400*3840,          127-480*272,
        # 128-512*272,                129-2592*2592,             130-1792*2880,          131-1600*2560,
        # 132-2720*1192,              133-3MP(1920*1536/2048*1536)，                     134-5MP(2560*1944)，
        # 135-2560*960,               136-2064*1544              137-4096*1200,
        # 138-3840*1080               139-2720*800               140-512*232             141-704*200,
        # 142-512*152,                143-2048*896               144-2048*600            145-1280*376,
        # 146-2592*1520,              147-2592*1536,             148-3072*8192,          149-768*2048,
        # 150-8208*3072,              151-4096*1536,             152-6912*2800,          153-3456*1400
        # 154-480*720,                155-800*450,               156-480*270,            157-2560*1536,
        # 160-3264*2448,              161-288*320,               162-144*176,            163-480*640,
        # 164-240*320,                165-120*160,               166-576*720,            167-720*1280,
        # 168-576*960,                169-2944*1656,             170-432*240,            171-2160*3840,
        # 172-1080*1920,              173-7008*1080,             174-3504*540,           175-1752*270,
        # 176-876*135,                177-4096*1440,             178-4096*1080,          179-1536*864,
        # 180-180*240,                181-360*480,               182-540*720,            183-720*960,
        # 184-960*1280,               185-1080*1440,
        # 186-3200*1800,              187-1752*272,              188-872*136,            189-1280*1440,
        # 190-3520*544,               191-1728*256,              192-864*128,            193-5470*3684,
        # 194-2560*750,               195-1600*480,              196-1024*300,           197-848*480,
        # 198-8160*3616,				199-8160*2304,             200-4064*2560,          201-1400*1050,
        # 202-2688*1512,              203-704*288,               204-1560*656,           205-3072*1280,
        # 206-4320*1808,              207-6120*2560,              208-1280*960,          209-3000*3000,
        # 210-2032*3616,              211-7680*4320,             212-5760*3240,          213-3264*1836,
        # 214-2712*1536,              215-1080*720(占位，未测试),  216-360x640(占位，未测试),217-1440*812,
        # 218-8160*2416,              219-5760*1712,               220-4080*1200,          221-6144*2560,
        # 222-1568*656,               223-4096*1808,               224-2720*1200,          225-2896*848
        # 226-2048*608                227-3840*1120                228-2720*784            229-1920*560,
        # 230-1360*400                231-704*208                  232-496*144             233-352*128,
        # 234-512*240                 235-512*160                  236-368*128            237-256*128
        # 238-2048*592                239-1456*416                 240-1024*304            241-1280*368
        # 242-912*256                 243-640*192                  244-252*112 （未使用）            245-(576*704[P制]/480*704[N制])
        #
        # 254-表示超出该字段范围，使用NET_DVR_MULTI_STREAM_COMPRESSIONCFG中的dwResolution表示分辨率
        # 0xff-Auto(使用当前码流分辨率)
        # 256-3888*1696                257-2784*1200               258-496*224              259-352*160
        # 260-912*400                  261-640*288                 262-1456*640             263-1024*448
        # 264-2896*1280                265-2544*1080               266-2736*768             267-1920*544
        # 268-3840*1696                269-2880*848                270-5424*2400            271-5520*1600
        # 272-848*376                  273-912*272                 274-1360*600             275-1456*432
        # 276-2736*1200                277-5760*1696               278-8160*2400            279-5520*2400
        # 280-4608*2592                281-4944*3280               282-6016*4008            283-720*480
        # 284-3200*2400                285-2784*800                286-1968*848             287-1392*608
        # 288-2736*1184                289-1920*848                290-2560*2880            291-1944*1212
        # 292-1920*2400                293-384*384                 294-768*768              295-4800*2688
        # 296-6480*1080                297-8640*1440               298-4800*800             299-6720*1200
        # 300-3600*600                 301-4800*840                302-2400*400             303-3072*540
        # 304-1440*810                 305-1920*320                306-2688*480             307-1440*240
        # 308-4800*1792                309-3360*1264               310-2304*880             311-3840*1440
        # 312-2688*1008                313-1824*704                314-1248*496             315-1920*720
        # 316-1344*496                 317-912*336                 318-1280*480             319-864*336
        # 320-576*224                  321-2704*1008               322-1904*704             323-1808*672
        # 324-1264*464                 325-944*336                 326-2400*1344            327-2032*1440
        # 328-4064*1792                329-304*112                 330-960*360              331-672*240
        # 332-464*160                  333-896*336                 334-624*224              335-640*240
        # 336-448*160                  337-4976*1452               338-1968*560             339-2736*784
        # 340-3888*1136                341-6120*1800               342-4320*1280            343-3056*896
        # 344-1776*528                 345-1392*400                346-7256*1520            347-512*288
        # 348-1936*1210                349-640*400                 350-2688*1792            351-2464*2056
        # 352-2720*1600                353-4800*1600               354-3600*1200            355-未定义
        # 356-2400*800                 357-1200*400
        #
        ("byResolution", BYTE),
        ("byBitrateType", BYTE), # 码率类型 0:变码率, 1:定码率,0xfe:自动，和源一致
        ("byPicQuality", BYTE), # 图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差,自动，和源一致
        # 视频码率:0-保留，1-16K(保留)，2-32K，3-48k，4-64K，5-80K，6-96K，7-128K，8-160k，9-192K，10-224K，
        # 11-256K，12-320K，13-384K，14-448K，15-512K，16-640K，17-768K，18-896K，19-1024K，20-1280K，21-1536K，22-1792K，23-2048K，
        # 24-3072K，25-4096K，26-8192K，27-16384K。最高位(31位)置成1表示是自定义码流，0～30位表示码流值，最小值16k,0xfffffffe，自动，和源一致
        ("dwVideoBitrate", DWORD),
        ("dwVideoFrameRate", DWORD), # 帧率 0-全部 1-1/16 2-1/8 3-1/4 4-1/2 5-1 6-2 7-4 8-6 9-8 10-10 11-12 12-16 13-20 V2.0版本中新加14-15 15-18 16-22
        # 17-25；18-30；19-35；20-40；21-45；22-50；23-55；24-60；25-3;26-5;27-7;28-9;29-100; 30-120;31-24;32-48,33-8.3,0xfffffffe-自动，和源一致
        ("wIntervalFrameI", WORD), # I帧间隔,0xfffe 自动，和源一致
        ("byIntervalBPFrame", BYTE), # 0-BBP帧 1-BP帧 2-单P帧(2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题)；0xfe-自动，和源一致
        ("byres1", BYTE), # 保留
        ("byVideoEncType", BYTE), # 视频编码类型 0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，8-MPEG2，9-SVAC, 10-标准h265, 0xfe-自动（和源一致），0xff-无效
        ("byAudioEncType", BYTE), # 音频编码类型 0-G7221-G711_U2-G711_A5-MP2L26-G2767-AAC8-PCM12-AAC_LC13-AAC_LD14-Opus15-MP30xff-无效
        ("byVideoEncComplexity", BYTE), # 视频编码复杂度，0-低，1-中，2高,0xfe:自动，和源一致
        ("byEnableSvc", BYTE), # 0 - 不启用SVC功能；1- 启用SVC功能 2-自动启用SVC功能
        ("byFormatType", BYTE), # 封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP,9-RTP+PS（国标：GB28181），0xff-无效
        ("byAudioBitRate", BYTE), # 音频码率 参考 BITRATE_ENCODE_INDEX
        ("byStreamSmooth", BYTE), # 码流平滑 1～100（1等级表示清晰(Clear)，100表示平滑(Smooth)）
        ("byAudioSamplingRate", BYTE), # 音频采样率0-默认,1- 16kHZ, 2-32kHZ, 3-48kHZ, 4- 44.1kHZ,5-8kHZ
        ("bySmartCodec", BYTE), # bit0-高性能编码 0-关闭，1-打开，bit1 - 低码率模式 0 - 关闭，1 - 打开
        ("byDepthMapEnable", BYTE), #  深度图使能开关，0-关闭，1-打开；如果开启后，第二通道的子码流（双目）的视频参数都不能配置，默认输出 960*540 的深度图；
        # 平均码率（在SmartCodec使能开启下生效）, 0-0K 1-16K 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K 24-2560K 25-3072K 26-4096K 27-5120K 28-6144K 29-7168K 30-8192K
        # 最高位(15位)置成1表示是自定义码流, 0-14位表示码流值(MIN- 0 K)。
        ("wAverageVideoBitrate", WORD),
    ]


LPNET_DVR_COMPRESSION_INFO_V30 = POINTER(NET_DVR_COMPRESSION_INFO_V30)


# 通道压缩参数(9000扩展)
class NET_DVR_COMPRESSIONCFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNormHighRecordPara", NET_DVR_COMPRESSION_INFO_V30), # 录像 对应8000的普通
        ("struRes", NET_DVR_COMPRESSION_INFO_V30), # 保留 char reserveData[28]
        ("struEventRecordPara", NET_DVR_COMPRESSION_INFO_V30), # 事件触发压缩参数
        ("struNetPara", NET_DVR_COMPRESSION_INFO_V30), # 网传(子码流)
    ]


LPNET_DVR_COMPRESSIONCFG_V30 = POINTER(NET_DVR_COMPRESSIONCFG_V30)


# 码流压缩参数(子结构)
class NET_DVR_COMPRESSION_INFO(Structure):
    _fields_ = [
        ("byStreamType", BYTE), # 码流类型0-视频流,1-复合流,表示压缩参数时最高位表示是否启用压缩参数
        ("byResolution", BYTE), # 分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
        ("byBitrateType", BYTE), # 码率类型0:变码率，1:定码率，2：低码率
        ("byPicQuality", BYTE), # 图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
        ("dwVideoBitrate", DWORD), # 视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
        # 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
        # 最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
        ("dwVideoFrameRate", DWORD), # 帧率 0-全部 1-1/16 2-1/8 3-1/4 4-1/2 5-1 6-2 7-4 8-6 9-8 10-10 11-12 12-16 13-20
    ]


LPNET_DVR_COMPRESSION_INFO = POINTER(NET_DVR_COMPRESSION_INFO)


# 通道压缩参数
class NET_DVR_COMPRESSIONCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRecordPara", NET_DVR_COMPRESSION_INFO), # 录像/事件触发录像
        ("struNetPara", NET_DVR_COMPRESSION_INFO), # 网传/保留
    ]


LPNET_DVR_COMPRESSIONCFG = POINTER(NET_DVR_COMPRESSIONCFG)


# 码流压缩参数(子结构)(扩展) 增加I帧间隔
class NET_DVR_COMPRESSION_INFO_EX(Structure):
    _fields_ = [
        ("byStreamType", BYTE), # 码流类型0-视频流, 1-复合流
        ("byResolution", BYTE), # 分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
        ("byBitrateType", BYTE), # 码率类型0:变码率，1:定码率，2：低码率
        ("byPicQuality", BYTE), # 图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
        ("dwVideoBitrate", DWORD), # 视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
        # 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
        # 最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
        ("dwVideoFrameRate", DWORD), # 帧率 0-全部 1-1/16 2-1/8 3-1/4 4-1/2 5-1 6-2 7-4 8-6 9-8 10-10 11-12 12-16 13-20, V2.0增加14-15, 15-18, 16-22
        ("wIntervalFrameI", WORD), # I帧间隔
        # 2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题
        ("byIntervalBPFrame", BYTE), # 0-BBP帧 1-BP帧 2-单P帧
        ("byRes", BYTE),
    ]


LPNET_DVR_COMPRESSION_INFO_EX = POINTER(NET_DVR_COMPRESSION_INFO_EX)


# 通道压缩参数(扩展)
class NET_DVR_COMPRESSIONCFG_EX(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRecordPara", NET_DVR_COMPRESSION_INFO_EX), # 录像
        ("struNetPara", NET_DVR_COMPRESSION_INFO_EX), # 网传
    ]


LPNET_DVR_COMPRESSIONCFG_EX = POINTER(NET_DVR_COMPRESSIONCFG_EX)


# 时间段录像参数配置(子结构)
class NET_DVR_RECORDSCHED(Structure):
    _fields_ = [
        ("struRecordTime", NET_DVR_SCHEDTIME),
        ("byRecordType", BYTE), # 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警, 5:命令触发, 6: 智能录像,10-PIR报警，11-无线报警，12-呼救报警，13-所有报警,14-智能交通事件，15越界侦测，16区域入侵侦测，17音频异常侦测
        ("reservedData", CHAR * 3),
    ]


LPNET_DVR_RECORDSCHED = POINTER(NET_DVR_RECORDSCHED)


# 全天录像参数配置(子结构)
class NET_DVR_RECORDDAY(Structure):
    _fields_ = [
        ("wAllDayRecord", WORD), #  是否全天录像 0-否 1-是
        ("byRecordType", BYTE), #  录象类型 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 6: 智能录像,
        # 10-PIR报警，11-无线报警，12-呼救报警，13-移动|报警输入|PIR|无线报警|呼救报警,14-智能交通事件,15-越界侦测,16-区域入侵,17-声音异常,
        # 18-场景变更侦测,19-智能侦测（越界侦测|区域入侵|进入区域|离开区域|人脸识别）,20－人脸侦测, 21-POS录像
        ("reservedData", CHAR),
    ]


LPNET_DVR_RECORDDAY = POINTER(NET_DVR_RECORDDAY)


# 通道录像参数配置(9000扩展)
class NET_DVR_RECORD_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRecord", DWORD), # 是否录像 0-否 1-是
        ("struRecAllDay", NET_DVR_RECORDDAY * MAX_DAYS),
        ("struRecordSched", NET_DVR_RECORDSCHED * MAX_DAYS),
        ("dwRecordTime", DWORD), #  录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟
        ("dwPreRecordTime", DWORD), #  预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录)
        ("dwRecorderDuration", DWORD), #  录像保存的最长时间
        ("byRedundancyRec", BYTE), # 是否冗余录像,重要数据双备份：0/1
        ("byAudioRec", BYTE), # 录像时复合流编码时是否记录音频数据：国外有此法规
        ("byStreamType", BYTE), #  0-主码流，1-子码流，2-主子码流同时 3-三码流
        ("byPassbackRecord", BYTE), #  0:不回传录像 1：回传录像
        ("wLockDuration", WORD), #  录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
        ("byRecordBackup", BYTE), #  0:录像不存档 1：录像存档
        ("bySVCLevel", BYTE), # SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
        ("byRecordManage", BYTE), # 录像调度，0-启用， 1-不启用 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
        ("byExtraSaveAudio", BYTE), # 音频单独另存0-非单独另存，1-单独另存
        # 开启智能录像功能后，算法库是自动启用智能录像算法，其功能为若录像中无目标出现，会降低码率、帧率，而目标出现时又恢复全码率及帧率，从而达到减少资源消耗的目的
        ("byIntelligentRecord", BYTE), # 是否开启智能录像功能 0-否 1-是
        ("byReserve", BYTE),
    ]


LPNET_DVR_RECORD_V30 = POINTER(NET_DVR_RECORD_V30)


# 时间段录像参数配置(子结构)
class NET_DVR_RECORDSCHED_V40(Structure):
    _fields_ = [
        ("struRecordTime", NET_DVR_SCHEDTIME),
        # 录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发,
        # 6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件,
        # 15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
        # 19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
        # 22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
        # 28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
        # 35-船只检测, 36-测温预警，37-测温报警，38-温差报警，39-离线测温报警,40-防区报警，41-紧急求助,42-业务咨询,43-起身检测,44-折线攀高,45-如厕超时，46-人脸抓拍，47-非法摆摊,48-目标抓拍,
        # 49-剧烈运动，50离岗检测，51-起立，52人数变化 53-废气排放监测 54-灰度报警
        ("byRecordType", BYTE),
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_RECORDSCHED_V40 = POINTER(NET_DVR_RECORDSCHED_V40)


# 全天录像参数配置(子结构)
class NET_DVR_RECORDDAY_V40(Structure):
    _fields_ = [
        ("byAllDayRecord", BYTE), #  是否全天录像 0-否 1-是
        # 录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发,
        # 6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件,
        # 15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
        # 19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
        # 22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
        # 28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
        # 35-船只检测, 36-测温预警，37-测温报警，38-温差报警，39-离线测温报警,40-防区报警，41-紧急求助,42-业务咨询,43-起身检测,44-折线攀高,45-如厕超时,46-人脸抓拍,47-非法摆摊,48-目标抓拍,
        # 49-剧烈运动，50离岗检测，51-起立，52人数变化  53-废气排放监测  54-灰度报警
        ("byRecordType", BYTE),
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_RECORDDAY_V40 = POINTER(NET_DVR_RECORDDAY_V40)


class NET_DVR_RECORD_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRecord", DWORD), # 是否录像 0-否 1-是
        ("struRecAllDay", NET_DVR_RECORDDAY_V40 * MAX_DAYS),
        ("struRecordSched", NET_DVR_RECORDSCHED_V40 * MAX_DAYS),
        ("dwRecordTime", DWORD), #  录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟
        ("dwPreRecordTime", DWORD), #  预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录)
        ("dwRecorderDuration", DWORD), #  录像保存的最长时间
        ("byRedundancyRec", BYTE), # 是否冗余录像,重要数据双备份：0/1
        ("byAudioRec", BYTE), # 录像时复合流编码时是否记录音频数据：国外有此法规
        ("byStreamType", BYTE), #  0-主码流，1-子码流，2-主子码流同时 3-三码流
        ("byPassbackRecord", BYTE), #  0:不回传录像 1：回传录像
        ("wLockDuration", WORD), #  录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
        ("byRecordBackup", BYTE), #  0:录像不存档 1：录像存档
        ("bySVCLevel", BYTE), # SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
        ("byRecordManage", BYTE), # 录像调度，0-启用， 1-不启用 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
        ("byExtraSaveAudio", BYTE), # 音频单独存储
        # 开启智能录像功能后，算法库是自动启用智能录像算法，其功能为若录像中无目标出现，会降低码率、帧率，而目标出现时又恢复全码率及帧率，从而达到减少资源消耗的目的
        ("byIntelligentRecord", BYTE), # 是否开启智能录像功能 0-否 1-是
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_RECORD_V40 = POINTER(NET_DVR_RECORD_V40)


# 通道录像参数配置
class NET_DVR_RECORD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRecord", DWORD), # 是否录像 0-否 1-是
        ("struRecAllDay", NET_DVR_RECORDDAY * MAX_DAYS),
        ("struRecordSched", NET_DVR_RECORDSCHED * MAX_DAYS),
        ("dwRecordTime", DWORD), #  录象时间长度
        ("dwPreRecordTime", DWORD), #  预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录)
    ]


LPNET_DVR_RECORD = POINTER(NET_DVR_RECORD)


# 云台协议表结构配置
class NET_DVR_PTZ_PROTOCOL(Structure):
    _fields_ = [
        ("dwType", DWORD), # 解码器类型值
        ("byDescribe", BYTE * DESC_LEN), # 解码器的描述符，和8000中的一致
    ]


class NET_DVR_PTZCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struPtz", NET_DVR_PTZ_PROTOCOL * PTZ_PROTOCOL_NUM), # 最大200中PTZ协议
        ("dwPtzNum", DWORD), # 有效的ptz协议数目，从0开始(即计算时加1)
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_PTZCFG = POINTER(NET_DVR_PTZCFG)


class NET_DVR_SERIALSTART_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwSerialType", DWORD), # 串口号（1-232串口，2-485串口）
        ("bySerialNum", BYTE), # 串口编号
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_SERIALSTART_V40 = POINTER(NET_DVR_SERIALSTART_V40)


# 通道解码器(云台)参数配置 扩展
class NET_DVR_DECODERCFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwBaudRate", DWORD), # 波特率 0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k
        ("byDataBit", BYTE), # 数据有几位 0－5位，1－6位，2－7位，3－8位
        ("byStopBit", BYTE), # 停止位 0－1位，1－2位
        ("byParity", BYTE), # 校验 0－无校验，1－奇校验，2－偶校验
        ("byFlowcontrol", BYTE), # 0－无，1－软流控,2-硬流控
        ("wDecoderType", WORD), # 解码器类型
        ("wDecoderAddress", WORD), # 解码器地址，0-255
        ("bySetPreset", BYTE), # 预置点是否设置,0-没有设置,1-设置
        ("bySetCruise", BYTE * MAX_CRUISE_V30), # 巡航是否设置: 0-没有设置,1-设置
        ("bySetTrack", BYTE), # 轨迹是否设置,0-没有设置,1-设置
        ("bySerialNO", BYTE), # 串口编号
        ("byWorkMode", BYTE), # 工作模式， 1-矩阵串口控制，2-屏幕控制，3-透明通道模式 4-PPP模式 5-控制台模式 6-串口直连 7-键盘控制 8-监控板管理 9-控制云台 12-LED显示，13-触发抓拍数据传输
        ("byRes", BYTE * 254), # 保留
    ]


LPNET_DVR_DECODERCFG_V40 = POINTER(NET_DVR_DECODERCFG_V40)


class NET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO(Structure):
    _fields_ = [
        ("fMaxTemperature", DOUBLE), # 最高温，精确到小数点后一位
        ("fMinTemperature", DOUBLE), # 最低温，精确到小数点后一位
        ("fAverageTemperature", DOUBLE), # 平均温，精确到小数点后一位
        ("struHighestPoint", NET_VCA_POINT), # 最高温度位置坐标
        ("struLowestPoint", NET_VCA_POINT), # 最低温度位置坐标
        ("byIsFreezedata", BYTE), # 是否数据冻结 0-否 1-是
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO = POINTER(NET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO)


# 通道解码器(云台)参数配置(9000扩展)
class NET_DVR_DECODERCFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwBaudRate", DWORD), # 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k
        ("byDataBit", BYTE), #  数据有几位 0－5位，1－6位，2－7位，3－8位
        ("byStopBit", BYTE), #  停止位 0－1位，1－2位
        ("byParity", BYTE), #  校验 0－无校验，1－奇校验，2－偶校验
        ("byFlowcontrol", BYTE), #  0－无，1－软流控,2-硬流控
        ("wDecoderType", WORD), # 解码器类型, 从0开始，对应ptz协议列表从NET_DVR_IPC_PROTO_LIST得到
        ("wDecoderAddress", WORD), # 解码器地址:0 - 255
        ("bySetPreset", BYTE * MAX_PRESET_V30), #  预置点是否设置,0-没有设置,1-设置
        ("bySetCruise", BYTE * MAX_CRUISE_V30), #  巡航是否设置: 0-没有设置,1-设置
        ("bySetTrack", BYTE * MAX_TRACK_V30), #  轨迹是否设置,0-没有设置,1-设置
    ]


LPNET_DVR_DECODERCFG_V30 = POINTER(NET_DVR_DECODERCFG_V30)


# 通道解码器(云台)参数配置
class NET_DVR_DECODERCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwBaudRate", DWORD), # 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k
        ("byDataBit", BYTE), #  数据有几位 0－5位，1－6位，2－7位，3－8位
        ("byStopBit", BYTE), #  停止位 0－1位，1－2位
        ("byParity", BYTE), #  校验 0－无校验，1－奇校验，2－偶校验
        ("byFlowcontrol", BYTE), #  0－无，1－软流控,2-硬流控
        ("wDecoderType", WORD), # 解码器类型  NET_DVR_IPC_PROTO_LIST中得到
        ("wDecoderAddress", WORD), # 解码器地址:0 - 255
        ("bySetPreset", BYTE * MAX_PRESET), #  预置点是否设置,0-没有设置,1-设置
        ("bySetCruise", BYTE * MAX_CRUISE), #  巡航是否设置: 0-没有设置,1-设置
        ("bySetTrack", BYTE * MAX_TRACK), #  轨迹是否设置,0-没有设置,1-设置
    ]


LPNET_DVR_DECODERCFG = POINTER(NET_DVR_DECODERCFG)


# ppp参数配置(子结构)
class NET_DVR_PPPCFG_V30(Structure):
    _fields_ = [
        ("struRemoteIP", NET_DVR_IPADDR), # 远端IP地址
        ("struLocalIP", NET_DVR_IPADDR), # 本地IP地址
        ("sLocalIPMask", CHAR * 16), # 本地IP地址掩码
        ("sUsername", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("byPPPMode", BYTE), # PPP模式, 0－主动，1－被动
        ("byRedial", BYTE), # 是否回拨 ：0-否,1-是
        ("byRedialMode", BYTE), # 回拨模式,0-由拨入者指定,1-预置回拨号码
        ("byDataEncrypt", BYTE), # 数据加密,0-否,1-是
        ("dwMTU", DWORD), # MTU
        ("sTelephoneNumber", CHAR * PHONENUMBER_LEN), # 电话号码
    ]


LPNET_DVR_PPPCFG_V30 = POINTER(NET_DVR_PPPCFG_V30)


# ppp参数配置(子结构)
class NET_DVR_PPPCFG(Structure):
    _fields_ = [
        ("sRemoteIP", CHAR * 16), # 远端IP地址
        ("sLocalIP", CHAR * 16), # 本地IP地址
        ("sLocalIPMask", CHAR * 16), # 本地IP地址掩码
        ("sUsername", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("byPPPMode", BYTE), # PPP模式, 0－主动，1－被动
        ("byRedial", BYTE), # 是否回拨 ：0-否,1-是
        ("byRedialMode", BYTE), # 回拨模式,0-由拨入者指定,1-预置回拨号码
        ("byDataEncrypt", BYTE), # 数据加密,0-否,1-是
        ("dwMTU", DWORD), # MTU
        ("sTelephoneNumber", CHAR * PHONENUMBER_LEN), # 电话号码
    ]


LPNET_DVR_PPPCFG = POINTER(NET_DVR_PPPCFG)


# RS232串口参数配置(9000扩展)
class NET_DVR_SINGLE_RS232(Structure):
    _fields_ = [
        ("dwBaudRate", DWORD), # 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k
        ("byDataBit", BYTE), #  数据有几位 0－5位，1－6位，2－7位，3－8位
        ("byStopBit", BYTE), #  停止位 0－1位，1－2位
        ("byParity", BYTE), #  校验 0－无校验，1－奇校验，2－偶校验
        ("byFlowcontrol", BYTE), #  0－无，1－软流控,2-硬流控
        ("dwWorkMode", DWORD), # 工作模式，0－232串口用于PPP拨号，1－232串口用于参数控制，2－透明通道 3- ptz模式,审讯温湿度传感器, 4-报警盒模式  5-矩阵串口控制 6-屏幕控制 7-串口直连 8-键盘控制 9-监控板管理 10-控制云台
    ]


class NET_DVR_USB_RS232(Structure):
    _fields_ = [
        ("dwBaudRate", DWORD), # 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k
        ("byDataBit", BYTE), #  数据有几位 0－5位，1－6位，2－7位，3－8位
        ("byStopBit", BYTE), #  停止位 0－1位，1－2位
        ("byParity", BYTE), #  校验 0－无校验，1－奇校验，2－偶校验
        ("byFlowcontrol", BYTE), #  0－无，1－软流控,2-硬流控
        ("byVirtualSerialPort", BYTE), # 虚拟串口编号
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_USB_RS232 = POINTER(NET_DVR_USB_RS232)


# RS232串口参数配置(9000扩展)
class NET_DVR_RS232CFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRs232", NET_DVR_SINGLE_RS232 * MAX_SERIAL_PORT), # 注意：此结构修改了，原来是单个结构，现在修改为了数组结构
        ("struPPPConfig", NET_DVR_PPPCFG_V30),
    ]


LPNET_DVR_RS232CFG_V30 = POINTER(NET_DVR_RS232CFG_V30)


# RS232串口参数配置
class NET_DVR_RS232CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwBaudRate", DWORD), # 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k
        ("byDataBit", BYTE), #  数据有几位 0－5位，1－6位，2－7位，3－8位
        ("byStopBit", BYTE), #  停止位 0－1位，1－2位
        ("byParity", BYTE), #  校验 0－无校验，1－奇校验，2－偶校验
        ("byFlowcontrol", BYTE), #  0－无，1－软流控,2-硬流控
        ("dwWorkMode", DWORD), #  工作模式，0－窄带传输(232串口用于PPP拨号)，1－控制台(232串口用于参数控制)，2－透明通道
        ("struPPPConfig", NET_DVR_PPPCFG),
    ]


LPNET_DVR_RS232CFG = POINTER(NET_DVR_RS232CFG)


class NET_DVR_PRESETCHAN_INFO(Structure):
    _fields_ = [
        ("dwEnablePresetChan", DWORD), # 启用预置点的通道, 0xfffffff表示不调用预置点
        ("dwPresetPointNo", DWORD), # 调用预置点通道对应的预置点序号, 0xfffffff表示不调用预置点。
    ]


LPNET_DVR_PRESETCHAN_INFO = POINTER(NET_DVR_PRESETCHAN_INFO)


class NET_DVR_CRUISECHAN_INFO(Structure):
    _fields_ = [
        ("dwEnableCruiseChan", DWORD), # 启用巡航的通道
        ("dwCruiseNo", DWORD), # 巡航通道对应的巡航编号, 0xfffffff表示无效
    ]


LPNET_DVR_CRUISECHAN_INFO = POINTER(NET_DVR_CRUISECHAN_INFO)


class NET_DVR_PTZTRACKCHAN_INFO(Structure):
    _fields_ = [
        ("dwEnablePtzTrackChan", DWORD), # 启用云台轨迹的通道
        ("dwPtzTrackNo", DWORD), # 云台轨迹通道对应的编号, 0xfffffff表示无效
    ]


LPNET_DVR_PTZTRACKCHAN_INFO = POINTER(NET_DVR_PTZTRACKCHAN_INFO)


class NET_DVR_PTZ_NOTIFICATION_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        #
        # 0-facedetection,
        # 1-vehicleDetection,
        # 2-scenechangedetection,
        # 3-LineDetection,
        # 4-regionEntrance,
        # 5-regionExiting,
        # 6-loitering,
        # 7-group,
        # 8-rapidMove,
        # 9-parking,
        # 10-unattendedBaggage,
        # 11-attendedBaggage,
        # 12-audioDetection,
        # 13-PIR,
        # 14-defocusDetection
        # 15-temperature,
        # 16-fireDetection,
        # 17-thermometry,
        # 18-shipsDetection
        # 19-fieldDetection
        # 20-blackListFaceContrast
        # 21-whiteListFaceContrast
        # 22- humanRecognition
        # 23- faceContrast
        #
        ("byEventType", WORD),
        ("byRes", BYTE * 2),
        ("dwChannel", DWORD),
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_PTZ_NOTIFICATION_COND = POINTER(NET_DVR_PTZ_NOTIFICATION_COND)


class NET_DVR_PTZ_NOTIFICATION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEnablePresetChanNum", DWORD), # 当前已启用预置点的数目
        ("struPresetChanInfo", NET_DVR_PRESETCHAN_INFO * MAX_CHANNUM_V40), # 启用的预置点信息(关联联动类型 ptz)
        ("dwEnableCruiseChanNum", DWORD), # 当前已启用巡航的通道数目
        ("struCruiseChanInfo", NET_DVR_CRUISECHAN_INFO * MAX_CHANNUM_V40), # 启用巡航功能通道的信息(关联联动类型 ptz)
        ("dwEnablePtzTrackChanNum", DWORD), # 当前已启用云台轨迹的通道数目
        ("struPtzTrackInfo", NET_DVR_PTZTRACKCHAN_INFO * MAX_CHANNUM_V40), # 调用云台轨迹的通道信息(关联联动类型 ptz)
        ("byRes1", BYTE * 1024),
    ]


LPNET_DVR_PTZ_NOTIFICATION_CFG = POINTER(NET_DVR_PTZ_NOTIFICATION_CFG)


class NET_DVR_PTZ_NOTIFICATION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        #
        # 0-facedetection,
        # 1-vehicleDetection,
        # 2-scenechangedetection,
        # 3-LineDetection,
        # 4-regionEntrance,
        # 5-regionExiting,
        # 6-loitering,
        # 7-group,
        # 8-rapidMove,
        # 9-parking,
        # 10-unattendedBaggage,
        # 11-attendedBaggage,
        # 12-audioDetection,
        # 13-PIR,
        # 14-defocusDetection，
        # 15-temperature,
        # 16-fireDetection,
        # 17-thermometry,
        # 18-shipsDetection
        # 19-fieldDetection
        # 20-blackListFaceContrast
        # 21-whiteListFaceContrast
        # 22- humanRecognition
        #
        ("byEventType", WORD),
        ("byRes", BYTE * 62),
        ("dwEnablePresetChanNum", DWORD), # 当前已启用预置点的数目
        ("struPresetChanInfo", NET_DVR_PRESETCHAN_INFO * MAX_CHANNUM_V40), # 启用的预置点信息(关联联动类型 ptz)
        ("dwEnableCruiseChanNum", DWORD), # 当前已启用巡航的通道数目
        ("struCruiseChanInfo", NET_DVR_CRUISECHAN_INFO * MAX_CHANNUM_V40), # 启用巡航功能通道的信息(关联联动类型 ptz)
        ("dwEnablePtzTrackChanNum", DWORD), # 当前已启用云台轨迹的通道数目
        ("struPtzTrackInfo", NET_DVR_PTZTRACKCHAN_INFO * MAX_CHANNUM_V40), # 调用云台轨迹的通道信息(关联联动类型 ptz)
        ("byRes1", BYTE * 1024),
    ]


LPNET_DVR_PTZ_NOTIFICATION = POINTER(NET_DVR_PTZ_NOTIFICATION)


NET_SDK_MAX_EVENT_NUM = 64 # 组合事件最大支持个数
# 报警输入参数配置(256路NVR扩展)
class NET_DVR_ALARMINCFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sAlarmInName", BYTE * NAME_LEN), #  名称
        ("byAlarmType", BYTE), # 报警器类型,0：常开,1：常闭
        ("byAlarmInHandle", BYTE), #  是否处理 0-不处理 1-处理
        ("byChannel", BYTE), #  报警输入触发智能识别通道
        ("byInputType", BYTE), # 输入类型  0-开关量方式  1-信号量方式
        ("dwHandleType", DWORD), # 异常处理,异常处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: 触发JPRG抓图并上传Email
        # 0x20: 无线声光报警器联动
        # 0x40: 联动电子地图(目前只有PCNVR支持)
        # 0x200: 抓图并上传FTP
        # 0x1000:抓图上传到云
        # 0x2000:短信报警
        ("dwMaxRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数（只读）最大支持数量
        ("dwRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数 实际支持数
        ("dwRelAlarmOut", DWORD * MAX_ALARMOUT_V40), # 触发报警通道
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        # 触发的录像通道
        ("dwMaxRecordChanNum", DWORD), # 设备支持的最大关联录像通道数-只读
        ("dwCurRecordChanNum", DWORD), # 当前实际已配置的关联录像通道数
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V40), #  实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwCurRecordChanNum -1有效，如果中间遇到0xffffffff,则后续无效
        ("dwMaxEnablePtzCtrlNun", DWORD), # 最大可启用的云台控制总数(只读)
        ("dwEnablePresetChanNum", DWORD), # 当前已启用预置点的数目
        ("struPresetChanInfo", NET_DVR_PRESETCHAN_INFO * MAX_CHANNUM_V40), # 启用的预置点信息
        ("byPresetDurationTime", BYTE * MAX_CHANNUM_V40), # 预置点停留时间 范围0-20s，默认10s；
        ("byRes2", BYTE * 4), # 保留
        ("dwEnableCruiseChanNum", DWORD), # 当前已启用巡航的通道数目
        ("struCruiseChanInfo", NET_DVR_CRUISECHAN_INFO * MAX_CHANNUM_V40), # 启用巡航功能通道的信息
        ("dwEnablePtzTrackChanNum", DWORD), # 当前已启用巡航的通道数目
        ("struPtzTrackInfo", NET_DVR_PTZTRACKCHAN_INFO * MAX_CHANNUM_V40), # 调用云台轨迹的通道信息
        ("wEventType", WORD * NET_SDK_MAX_EVENT_NUM), # 组合事件类型，每一个位对应一个事件类型
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ALARMINCFG_V40 = POINTER(NET_DVR_ALARMINCFG_V40)


# 报警输入参数配置(9000扩展)
class NET_DVR_ALARMINCFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sAlarmInName", BYTE * NAME_LEN), #  名称
        ("byAlarmType", BYTE), # 报警器类型,0：常开,1：常闭
        ("byAlarmInHandle", BYTE), #  是否处理 0-不处理 1-处理
        ("byChannel", BYTE), #  报警输入触发智能识别通道
        ("byInputType", BYTE), # 输入类型  0-开关量方式  1-信号量方式
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("byEnablePreset", BYTE * MAX_CHANNUM_V30), #  是否调用预置点 0-否,1-是
        ("byPresetNo", BYTE * MAX_CHANNUM_V30), #  调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。
        ("byRes2", BYTE * 192), # 保留
        ("byEnableCruise", BYTE * MAX_CHANNUM_V30), #  是否调用巡航 0-否,1-是
        ("byCruiseNo", BYTE * MAX_CHANNUM_V30), #  巡航
        ("byEnablePtzTrack", BYTE * MAX_CHANNUM_V30), #  是否调用轨迹 0-否,1-是
        ("byPTZTrack", BYTE * MAX_CHANNUM_V30), #  调用的云台的轨迹序号
        ("byRes3", BYTE * 16),
    ]


LPNET_DVR_ALARMINCFG_V30 = POINTER(NET_DVR_ALARMINCFG_V30)


# 报警输入参数配置
class NET_DVR_ALARMINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sAlarmInName", BYTE * NAME_LEN), #  名称
        ("byAlarmType", BYTE), # 报警器类型,0：常开,1：常闭
        ("byAlarmInHandle", BYTE), #  是否处理 0-不处理 1-处理
        ("byChannel", BYTE), #  报警输入触发智能识别通道
        ("byRes", BYTE),
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRelRecordChan", BYTE * MAX_CHANNUM), # 报警触发的录象通道,为1表示触发该通道
        ("byEnablePreset", BYTE * MAX_CHANNUM), #  是否调用预置点 0-否,1-是
        ("byPresetNo", BYTE * MAX_CHANNUM), #  调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。
        ("byEnableCruise", BYTE * MAX_CHANNUM), #  是否调用巡航 0-否,1-是
        ("byCruiseNo", BYTE * MAX_CHANNUM), #  巡航
        ("byEnablePtzTrack", BYTE * MAX_CHANNUM), #  是否调用轨迹 0-否,1-是
        ("byPTZTrack", BYTE * MAX_CHANNUM), #  调用的云台的轨迹序号
    ]


LPNET_DVR_ALARMINCFG = POINTER(NET_DVR_ALARMINCFG)


# 模拟报警输入参数配置
class NET_DVR_ANALOG_ALARMINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableAlarmHandle", BYTE), # 处理报警输入
        ("byRes1", BYTE * 3),
        ("byAlarmInName", BYTE * NAME_LEN), # 模拟报警输入名称
        ("wAlarmInUpper", WORD), # 模拟输入电压上限，实际值乘10，范围0~360
        ("wAlarmInLower", WORD), # 模拟输入电压下限，实际值乘10，范围0~360
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 被触发的录像通道
        ("byRes2", BYTE * 100),
    ]


LPNET_DVR_ANALOG_ALARMINCFG = POINTER(NET_DVR_ANALOG_ALARMINCFG)


# 上传报警信息(9000扩展)
class NET_DVR_ALARMINFO_V30(Structure):
    _fields_ = [
        ("dwAlarmType", DWORD), # 0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常,
        # 10-录像异常,11- 智能场景变化,12-阵列异常,13-前端/录像分辨率不匹配,14-申请解码资源失败,15-智能侦测, 16-POE供电异常报警,17-闪光灯异常,
        # 18-磁盘满负荷异常报警,19-音频丢失，20-开启录像，21-关闭录像，22-车辆检测算法异常，23-脉冲报警,24-人脸库硬盘异常,25-人脸库变更,26-人脸库图片变更,27-POC异常
        # 28-相机视角异常,29-电量低，30-缺少SD卡
        ("dwAlarmInputNumber", DWORD), # 报警输入端口
        ("byAlarmOutputNumber", BYTE * MAX_ALARMOUT_V30), # 触发的输出端口，为1表示对应输出
        ("byAlarmRelateChannel", BYTE * MAX_CHANNUM_V30), # 触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道
        ("byChannel", BYTE * MAX_CHANNUM_V30), # dwAlarmType为2或3,6,9,10,14,19,28时，表示哪个通道，dwChannel[0]对应第1个通道
        ("byDiskNumber", BYTE * MAX_DISKNUM_V30), # dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘
    ]


LPNET_DVR_ALARMINFO_V30 = POINTER(NET_DVR_ALARMINFO_V30)


class NET_DVR_ALARM_HOT_SPARE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体
        ("dwExceptionCase", DWORD), # 报警原因   0-网络异常
        ("struDeviceIP", NET_DVR_IPADDR), # 产生异常的设备IP地址
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_ALARM_HOT_SPARE = POINTER(NET_DVR_ALARM_HOT_SPARE)


class NET_DVR_ALARMINFO(Structure):
    _fields_ = [
        ("dwAlarmType", DWORD), # 0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化
        ("dwAlarmInputNumber", DWORD), # 报警输入端口
        ("dwAlarmOutputNumber", DWORD * MAX_ALARMOUT), # 触发的输出端口，哪一位为1表示对应哪一个输出
        ("dwAlarmRelateChannel", DWORD * MAX_CHANNUM), # 触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道
        ("dwChannel", DWORD * MAX_CHANNUM), # dwAlarmType为2或3,6,9,10时，表示哪个通道，dwChannel[0]位对应第1个通道
        ("dwDiskNumber", DWORD * MAX_DISKNUM), # dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘
    ]


LPNET_DVR_ALARMINFO = POINTER(NET_DVR_ALARMINFO)


# IPC接入参数配置
#  IP设备结构
class NET_DVR_IPDEVINFO(Structure):
    _fields_ = [
        ("dwEnable", DWORD), #  该IP设备是否启用
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("struIP", NET_DVR_IPADDR), #  IP地址
        ("wDVRPort", WORD), #  端口号
        ("byRes", BYTE * 34), #  保留
    ]


LPNET_DVR_IPDEVINFO = POINTER(NET_DVR_IPDEVINFO)


DEV_ID_LEN = 32 # 设备ID长度
# ipc接入设备信息扩展，支持ip设备的域名添加
class NET_DVR_IPDEVINFO_V31(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 该IP设备是否有效
        ("byProType", BYTE), # 协议类型，0-私有协议，1-松下协议，2-索尼
        ("byEnableQuickAdd", BYTE), #  0 不支持快速添加  1 使用快速添加
        # 快速添加需要设备IP和协议类型，其他信息由设备默认指定
        ("byCameraType", BYTE), # 通道接入的相机类型，值为 0-无意义，1-老师跟踪，2-学生跟踪，3-老师全景，4-学生全景，5-多媒体，6–教师定位,7-学生定位,8-板书定位,9-板书相机
        ("sUserName", BYTE * NAME_LEN), # 用户名
        ("sPassword", BYTE * PASSWD_LEN), # 密码
        ("byDomain", BYTE * MAX_DOMAIN_NAME), # 设备域名
        ("struIP", NET_DVR_IPADDR), # IP地址
        ("wDVRPort", WORD), #  端口号
        ("szDeviceID", BYTE * DEV_ID_LEN), # 设备ID
        ("byEnableTiming", BYTE), # 0-保留，1-不启用NVR对IPC自动校时，2-启用NVR对IPC自动校时
        ("byCertificateValidation", BYTE), # 证书验证
        # byCertificateValidation:bit0: 0-不启用证书验证 1-启用证书验证
        # byCertificateValidation:bit1: 0-不启用默认通信端口 1-启用默认通信端口
    ]


LPNET_DVR_IPDEVINFO_V31 = POINTER(NET_DVR_IPDEVINFO_V31)


#  IP通道匹配参数
class NET_DVR_IPCHANINFO(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  该通道是否在线
        ("byIPID", BYTE), # IP设备ID低8位，当设备ID为0时表示通道不可用
        ("byChannel", BYTE), #  通道号
        ("byIPIDHigh", BYTE), #  IP设备ID的高8位
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP/auto(具体有设备决定)，1-UDP 2-多播 3-仅TCP 4-auto
        ("byGetStream", BYTE), #  是否对该通道取流，0-是，1-否
        ("byres", BYTE * 30), #  保留
    ]


LPNET_DVR_IPCHANINFO = POINTER(NET_DVR_IPCHANINFO)


#  IP接入配置结构
class NET_DVR_IPPARACFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struIPDevInfo", NET_DVR_IPDEVINFO * MAX_IP_DEVICE), #  IP设备
        ("byAnalogChanEnable", BYTE * MAX_ANALOG_CHANNUM), #  模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效
        ("struIPChanInfo", NET_DVR_IPCHANINFO * MAX_IP_CHANNEL), #  IP通道
    ]


LPNET_DVR_IPPARACFG = POINTER(NET_DVR_IPPARACFG)


#  扩展IP接入配置结构
class NET_DVR_IPPARACFG_V31(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struIPDevInfo", NET_DVR_IPDEVINFO_V31 * MAX_IP_DEVICE), #  IP设备
        ("byAnalogChanEnable", BYTE * MAX_ANALOG_CHANNUM), #  模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效
        ("struIPChanInfo", NET_DVR_IPCHANINFO * MAX_IP_CHANNEL), #  IP通道
    ]


LPNET_DVR_IPPARACFG_V31 = POINTER(NET_DVR_IPPARACFG_V31)


class NET_DVR_IPSERVER_STREAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否在线
        ("byRes", BYTE * 3), #  保留字节
        ("struIPServer", NET_DVR_IPADDR), # IPServer 地址
        ("wPort", WORD), # IPServer 端口
        ("wDvrNameLen", WORD), #  DVR 名称长度
        ("byDVRName", BYTE * NAME_LEN), #  DVR名称
        ("wDVRSerialLen", WORD), #  序列号长度
        ("byRes1", WORD * 2), #  保留字节
        ("byDVRSerialNumber", BYTE * SERIALNO_LEN), #  DVR序列号长度
        ("byUserName", BYTE * NAME_LEN), #  DVR 登陆用户名
        ("byPassWord", BYTE * PASSWD_LEN), #  DVR登陆密码
        ("byChannel", BYTE), #  DVR 通道
        ("byRes2", BYTE * 11), #   保留字节
    ]


LPNET_DVR_IPSERVER_STREAM = POINTER(NET_DVR_IPSERVER_STREAM)


# 流媒体服务器基本配置
class NET_DVR_STREAM_MEDIA_SERVER_CFG(Structure):
    _fields_ = [
        ("byValid", BYTE), # 是否可用
        ("byRes1", BYTE * 3),
        ("struDevIP", NET_DVR_IPADDR),
        ("wDevPort", WORD), # 流媒体服务器端口
        ("byTransmitType", BYTE), # 传输协议类型 0-TCP，1-UDP
        ("byRes2", BYTE * 69),
    ]


LPNET_DVR_STREAM_MEDIA_SERVER_CFG = POINTER(NET_DVR_STREAM_MEDIA_SERVER_CFG)


# 设备通道信息
class NET_DVR_DEV_CHAN_INFO(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), # DVR IP地址
        ("wDVRPort", WORD), # 端口号
        ("byChannel", BYTE), # 通道号
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP，1-UDP
        ("byTransMode", BYTE), # 传输码流模式 0－主码流 1－子码流
        ("byFactoryType", BYTE), # 前端设备厂家类型,通过接口获取
        ("byDeviceType", BYTE), # 设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
        ("byDispChan", BYTE), # 显示通道号,智能配置使用
        ("bySubDispChan", BYTE), # 显示通道子通道号，智能配置时使用
        ("byResolution", BYTE), #  1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
        ("byRes", BYTE * 2),
        ("byDomain", BYTE * MAX_DOMAIN_NAME), # 设备域名
        ("sUserName", BYTE * NAME_LEN), # 监控主机登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), # 监控主机密码
    ]


LPNET_DVR_DEV_CHAN_INFO = POINTER(NET_DVR_DEV_CHAN_INFO)


# 直接通过流媒体取流
class NET_DVR_PU_STREAM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamMediaSvrCfg", NET_DVR_STREAM_MEDIA_SERVER_CFG),
        ("struDevChanInfo", NET_DVR_DEV_CHAN_INFO),
    ]


LPNET_DVR_PU_STREAM_CFG = POINTER(NET_DVR_PU_STREAM_CFG)


class NET_DVR_DDNS_STREAM_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否启用
        ("byRes1", BYTE * 3),
        ("struStreamServer", NET_DVR_IPADDR), # 流媒体服务器地址
        ("wStreamServerPort", WORD), # 流媒体服务器端口
        ("byStreamServerTransmitType", BYTE), # 流媒体传输协议类型 0-TCP，1-UDP
        ("byRes2", BYTE),
        ("struIPServer", NET_DVR_IPADDR), # IPSERVER地址
        ("wIPServerPort", WORD), # IPserver端口号
        ("byRes3", BYTE * 2),
        ("sDVRName", BYTE * NAME_LEN), # DVR名称
        ("wDVRNameLen", WORD), #  DVR名称长度
        ("wDVRSerialLen", WORD), #  序列号长度
        ("sDVRSerialNumber", BYTE * SERIALNO_LEN), #  DVR序列号
        ("sUserName", BYTE * NAME_LEN), #  DVR 登陆用户名
        ("sPassWord", BYTE * PASSWD_LEN), #  DVR登陆密码
        ("wDVRPort", WORD), # DVR端口号
        ("byRes4", BYTE * 2),
        ("byChannel", BYTE), #  DVR 通道
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP，1-UDP
        ("byTransMode", BYTE), # 传输码流模式 0－主码流 1－子码流
        ("byFactoryType", BYTE), # 前端设备厂家类型,通过接口获取
    ]


LPNET_DVR_DDNS_STREAM_CFG = POINTER(NET_DVR_DDNS_STREAM_CFG)


URL_LEN = 240 # URL长度
class NET_DVR_PU_STREAM_URL(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("strURL", BYTE * URL_LEN),
        ("byTransPortocol", BYTE), #  传输协议类型 0-tcp  1-UDP
        ("wIPID", WORD), # 设备ID号，wIPID = iDevInfoIndex + iGroupNO*64 +1
        ("byChannel", BYTE), # 通道号
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_PU_STREAM_URL = POINTER(NET_DVR_PU_STREAM_URL)


class NET_DVR_HKDDNS_STREAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否在线
        ("byRes", BYTE * 3), #  保留字节
        ("byDDNSDomain", BYTE * 64), #  hiDDNS服务器
        ("wPort", WORD), #  hiDDNS 端口
        ("wAliasLen", WORD), #  别名长度
        ("byAlias", BYTE * NAME_LEN), #  别名
        ("wDVRSerialLen", WORD), #  序列号长度
        ("byRes1", BYTE * 2), #  保留字节
        ("byDVRSerialNumber", BYTE * SERIALNO_LEN), #  DVR序列号
        ("byUserName", BYTE * NAME_LEN), #  DVR 登陆用户名
        ("byPassWord", BYTE * PASSWD_LEN), #  DVR登陆密码
        ("byChannel", BYTE), #  DVR通道
        ("byRes2", BYTE * 11), #  保留字
    ]


LPNET_DVR_HKDDNS_STREAM = POINTER(NET_DVR_HKDDNS_STREAM)


class NET_DVR_IPCHANINFO_V40(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  该通道是否在线
        ("byRes1", BYTE),
        ("wIPID", WORD), # IP设备ID
        ("dwChannel", DWORD), # 通道号
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP，1-UDP，2- 多播，3-RTSP，0xff- auto(自动)
        ("byTransMode", BYTE), # 传输码流模式 0－主码流 1－子码流
        ("byFactoryType", BYTE), # 前端设备厂家类型,通过接口获取
        ("byRes", BYTE),
        ("strURL", BYTE * URL_LEN), # RTSP协议取流URL （仅RTSP协议时有效）
    ]


LPNET_DVR_IPCHANINFO_V40 = POINTER(NET_DVR_IPCHANINFO_V40)


#  邦诺CVR
MAX_ID_COUNT = 256
MAX_STREAM_ID_COUNT = 1024
STREAM_ID_LEN = 32
PLAN_ID_LEN = 32
DEVICE_NO_LEN = 24
MAX_VOLUMENAME_LEN = 32 # 录像卷名称
MAX_VAG_CHANNO_LEN = 32 # VAG协议取流时通道号编码长度
MAX_STREAM_ID_NUM = 30 # 最大流ID数目
#  流信息 - 72字节长
class NET_DVR_STREAM_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byID", BYTE * STREAM_ID_LEN), # ID数据
        ("dwChannel", DWORD), # 关联设备通道，等于0xffffffff时，表示不关联
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_DVR_STREAM_INFO = POINTER(NET_DVR_STREAM_INFO)


class NET_DVR_RTSP_PROTOCAL_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byLocalBackUp", BYTE), # 是否本地备份
        ("byRes", BYTE * 2),
        ("strURL", BYTE * URL_LEN_V40),
        ("dwProtocalType", DWORD), # 协议类型
        ("sUserName", BYTE * NAME_LEN), # 设备登陆用户名
        ("sPassWord", BYTE * PASSWD_LEN), #  设备登陆密码
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # 前端IP或者域名,需要设备解析
        # 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
        ("wPort", WORD),
        ("byRes1", BYTE * 122), # 保留
    ]


LPNET_DVR_RTSP_PROTOCAL_CFG = POINTER(NET_DVR_RTSP_PROTOCAL_CFG)


class NET_DVR_GET_STREAM_UNION(Union):
    _fields_ = [
        ("struChanInfo", NET_DVR_IPCHANINFO), # IP通道信息
        ("struIPServerStream", NET_DVR_IPSERVER_STREAM), #  IPServer去流
        ("struPUStream", NET_DVR_PU_STREAM_CFG), #   通过前端设备获取流媒体去流
        ("struDDNSStream", NET_DVR_DDNS_STREAM_CFG), # 通过IPServer和流媒体取流
        ("struStreamUrl", NET_DVR_PU_STREAM_URL), # 通过流媒体到url取流
        ("struHkDDNSStream", NET_DVR_HKDDNS_STREAM), # 通过hiDDNS去取流
        ("struIPChan", NET_DVR_IPCHANINFO_V40), # 直接从设备取流（扩展）
    ]


LPNET_DVR_GET_STREAM_UNION = POINTER(NET_DVR_GET_STREAM_UNION)

NET_SDK_IP_DEVICE = 0
NET_SDK_STREAM_MEDIA = 1
NET_SDK_IPSERVER = 2
NET_SDK_DDNS_STREAM_CFG = 3
NET_SDK_STREAM_MEDIA_URL = 4
NET_SDK_HKDDNS = 5
NET_SDK_IP_DEVICE_ADV = 6
NET_SDK_IP_DEVICE_V40 = 7
NET_SDK_RTSP = 8

class NET_DVR_STREAM_MODE(Structure):
    _fields_ = [
        ("byGetStreamType", BYTE), # 取流方式GET_STREAM_TYPE，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流,3.通过IPServer找到设备，再通过流媒体去设备的流
        # 4-通过流媒体由URL去取流,5-通过hkDDNS取流，6-直接从设备取流(扩展)，使用NET_DVR_IPCHANINFO_V40结构, 7-通过RTSP协议方式进行取流
        ("byRes", BYTE * 3), # 保留字节
        ("uGetStream", NET_DVR_GET_STREAM_UNION), #  不同取流方式结构体
    ]


LPNET_DVR_STREAM_MODE = POINTER(NET_DVR_STREAM_MODE)


# 扩展IP接入配置设备
class NET_DVR_IPPARACFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("dwGroupNum", DWORD), #      设备支持的总组数
        ("dwAChanNum", DWORD), # 最大模拟通道个数
        ("dwDChanNum", DWORD), # 数字通道个数
        ("dwStartDChan", DWORD), # 起始数字通道
        ("byAnalogChanEnable", BYTE * MAX_CHANNUM_V30), #  模拟通道是否启用，从低到高表示1-64通道，0表示无效 1有效
        ("struIPDevInfo", NET_DVR_IPDEVINFO_V31 * MAX_IP_DEVICE_V40), #  IP设备
        ("struStreamMode", NET_DVR_STREAM_MODE * MAX_CHANNUM_V30),
        ("byRes2", BYTE * 20), #  保留字节
    ]


LPNET_DVR_IPPARACFG_V40 = POINTER(NET_DVR_IPPARACFG_V40)


# 为CVR扩展的报警类型
class NET_DVR_ALARMINFO_DEV(Structure):
    _fields_ = [
        ("dwAlarmType", DWORD), # 0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；
        # 3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；
        # 6-编码器(通道)移动侦测报警；7-编码器(通道)遮挡报警。；8-录像丢失报警; 9-视频实时监测报警; 10-资源使用率告警; 11- CVR自动修复异常， 12-录像异常
        ("struTime", NET_DVR_TIME), # 报警时间
        ("byRes", BYTE * 32), # 保留
        ("dwNumber", DWORD), # 数目
        ("*pNO", WORD), # dwNumber个WORD 每个WORD表示一个通道号，或者磁盘号, 无效时为0
    ]


LPNET_DVR_ALARMINFO_DEV = POINTER(NET_DVR_ALARMINFO_DEV)


#  报警输出参数
class NET_DVR_IPALARMOUTINFO(Structure):
    _fields_ = [
        ("byIPID", BYTE), #  IP设备ID取值1- MAX_IP_DEVICE
        ("byAlarmOut", BYTE), #  报警输出号
        ("byRes", BYTE * 18), #  保留
    ]


LPNET_DVR_IPALARMOUTINFO = POINTER(NET_DVR_IPALARMOUTINFO)


#  IP报警输出配置结构
class NET_DVR_IPALARMOUTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struIPAlarmOutInfo", NET_DVR_IPALARMOUTINFO * MAX_IP_ALARMOUT), #  IP报警输出
    ]


LPNET_DVR_IPALARMOUTCFG = POINTER(NET_DVR_IPALARMOUTCFG)


#  IP报警输出参数
class NET_DVR_IPALARMOUTINFO_V40(Structure):
    _fields_ = [
        ("dwIPID", DWORD), #  IP设备ID
        ("dwAlarmOut", DWORD), #  IP设备ID对应的报警输出号
        ("byRes", BYTE * 32), #  保留
    ]


LPNET_DVR_IPALARMOUTINFO_V40 = POINTER(NET_DVR_IPALARMOUTINFO_V40)


class NET_DVR_IPALARMOUTCFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("dwCurIPAlarmOutNum", DWORD),
        ("struIPAlarmOutInfo", NET_DVR_IPALARMOUTINFO_V40 * MAX_IP_ALARMOUT_V40), # IP报警输出
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_IPALARMOUTCFG_V40 = POINTER(NET_DVR_IPALARMOUTCFG_V40)


#  报警输入参数
class NET_DVR_IPALARMININFO(Structure):
    _fields_ = [
        ("byIPID", BYTE), #  IP设备ID取值1- MAX_IP_DEVICE
        ("byAlarmIn", BYTE), #  报警输入号
        ("byRes", BYTE * 18), #  保留
    ]


LPNET_DVR_IPALARMININFO = POINTER(NET_DVR_IPALARMININFO)


#  IP报警输入配置结构
class NET_DVR_IPALARMINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struIPAlarmInInfo", NET_DVR_IPALARMININFO * MAX_IP_ALARMIN), #  IP报警输入
    ]


LPNET_DVR_IPALARMINCFG = POINTER(NET_DVR_IPALARMINCFG)


#  IP报警输入参数
class NET_DVR_IPALARMININFO_V40(Structure):
    _fields_ = [
        ("dwIPID", DWORD), #  IP设备ID
        ("dwAlarmIn", DWORD), #  IP设备ID对应的报警输入号
        ("byRes", BYTE * 32), #  保留
    ]


LPNET_DVR_IPALARMININFO_V40 = POINTER(NET_DVR_IPALARMININFO_V40)


class NET_DVR_IPALARMINCFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("dwCurIPAlarmInNum", DWORD), # 当前报警输入口数
        ("struIPAlarmInInfo", NET_DVR_IPALARMININFO_V40 * MAX_IP_ALARMIN_V40), #  IP报警输入
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_IPALARMINCFG_V40 = POINTER(NET_DVR_IPALARMINCFG_V40)


# ipc alarm info
class NET_DVR_IPALARMINFO(Structure):
    _fields_ = [
        ("struIPDevInfo", NET_DVR_IPDEVINFO * MAX_IP_DEVICE), #  IP设备
        ("byAnalogChanEnable", BYTE * MAX_ANALOG_CHANNUM), #  模拟通道是否启用，0-未启用 1-启用
        ("struIPChanInfo", NET_DVR_IPCHANINFO * MAX_IP_CHANNEL), #  IP通道
        ("struIPAlarmInInfo", NET_DVR_IPALARMININFO * MAX_IP_ALARMIN), #  IP报警输入
        ("struIPAlarmOutInfo", NET_DVR_IPALARMOUTINFO * MAX_IP_ALARMOUT), #  IP报警输出
    ]


LPNET_DVR_IPALARMINFO = POINTER(NET_DVR_IPALARMINFO)


# ipc配置改变报警信息扩展 9000_1.1
class NET_DVR_IPALARMINFO_V31(Structure):
    _fields_ = [
        ("struIPDevInfo", NET_DVR_IPDEVINFO_V31 * MAX_IP_DEVICE), #  IP设备
        ("byAnalogChanEnable", BYTE * MAX_ANALOG_CHANNUM), #  模拟通道是否启用，0-未启用 1-启用
        ("struIPChanInfo", NET_DVR_IPCHANINFO * MAX_IP_CHANNEL), #  IP通道
        ("struIPAlarmInInfo", NET_DVR_IPALARMININFO * MAX_IP_ALARMIN), #  IP报警输入
        ("struIPAlarmOutInfo", NET_DVR_IPALARMOUTINFO * MAX_IP_ALARMOUT), #  IP报警输出
    ]


LPNET_DVR_IPALARMINFO_V31 = POINTER(NET_DVR_IPALARMINFO_V31)


class NET_DVR_IPALARMINFO_V40(Structure):
    _fields_ = [
        ("struIPDevInfo", NET_DVR_IPDEVINFO_V31 * MAX_IP_DEVICE_V40), #  IP设备
        ("byAnalogChanEnable", BYTE * MAX_CHANNUM_V30), #  模拟通道是否启用，0-未启用 1-启用
        ("struIPChanInfo", NET_DVR_IPCHANINFO * MAX_CHANNUM_V30), #  IP通道
        ("struIPAlarmInInfo", NET_DVR_IPALARMININFO * MAX_IP_ALARMIN), #  IP报警输入
        ("struIPAlarmOutInfo", NET_DVR_IPALARMOUTINFO * MAX_IP_ALARMOUT), #  IP报警输出
        ("byRes", BYTE * 20), #  保留字节
    ]


LPNET_DVR_IPALARMINFO_V40 = POINTER(NET_DVR_IPALARMINFO_V40)

HD_STAT_OK = 0 # 正常
HD_STAT_UNFORMATTED = 1 # 未格式化
HD_STAT_ERROR = 2 # 错误
HD_STAT_SMART_FAILED = 3 # SMART状态
HD_STAT_MISMATCH = 4 # 不匹配
HD_STAT_IDLE = 5 # 休眠
NET_HD_STAT_OFFLINE = 6 # 网络盘处于未连接状态
HD_RIADVD_EXPAND = 7 # 虚拟磁盘可扩容
HD_STAT_REPARING = 10 # 硬盘正在修复(9000 2.0)
HD_STAT_FORMATING = 11 # 硬盘正在格式化(9000 2.0)

# 本地硬盘信息配置
class NET_DVR_SINGLE_HD(Structure):
    _fields_ = [
        ("dwHDNo", DWORD), # 硬盘号, 取值0~MAX_DISKNUM_V30-1
        ("dwCapacity", DWORD), # 硬盘容量(不可设置)
        ("dwFreeSpace", DWORD), # 硬盘剩余空间(不可设置)
        ("dwHdStatus", DWORD), # 硬盘状态(不可设置) HD_STAT 0-正常, 1-未格式化, 2-错误, 3-SMART状态,
        # 4-不匹配, 5-休眠 6-网络硬盘不在线 7-虚拟磁盘可扩容 10-硬盘正在修复
        # 11-硬盘正在格式化 12-硬盘正在等待格式化 13-硬盘已卸载 14-本地硬盘不存在
        # 15-正在删除(网络硬盘),16-已锁定
        ("byHDAttr", BYTE), # 0-普通, 1-冗余 2-只读 3-存档（CVR专用），4-不可读写
        ("byHDType", BYTE), # 0-本地硬盘,1-ESATA硬盘,2-NAS硬盘,3-iSCSI硬盘 4-Array虚拟磁盘,5-SD卡,6-minSAS
        ("byDiskDriver", BYTE), #  值 代表其ASCII字符
        ("byRes1", BYTE),
        ("dwHdGroup", DWORD), # 属于哪个盘组 1-MAX_HD_GROUP
        ("byRecycling", BYTE), #  是否循环利用 0：不循环利用，1：循环利用
        ("bySupportFormatType", BYTE), # 当前硬盘所支持的格式化类型,只读。当前该节点仅支持byHDType=5(SD卡)时
        # 若bySupportFormatType=0,则代表设备将以自身的默认类型来格式化硬盘
        # bySupportFormatType:bit0: 0-代表不支持FAT32格式化类型,1-代表支持
        # bySupportFormatType:bit1: 0-代表不支持EXT4格式化类型,1-代表支持
        ("byFormatType", BYTE), # 当前硬盘格式化类型配置: 0-设备默认格式化类型,1-指定FAT32格式化(byHDType=5(SD卡)时生效),
        # 2-指定EXT4格式化(byHDType=5(SD卡)时生效)
        ("byRes2", BYTE),
        ("dwStorageType", DWORD), # 按位表示 0-不支持 非0-支持
        # dwStorageType & 0x1 表示是否是普通录像专用存储盘
        # dwStorageType & 0x2  表示是否是抽帧录像专用存储盘
        # dwStorageType & 0x4 表示是否是图片录像专用存储盘
        #
        ("dwPictureCapacity", DWORD), # 硬盘图片容量(不可设置)，单位:MB
        ("dwFreePictureSpace", DWORD), # 剩余图片空间(不可设置)，单位:MB
        ("byRes3", BYTE * 104),
    ]


LPNET_DVR_SINGLE_HD = POINTER(NET_DVR_SINGLE_HD)


class NET_DVR_HDCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwHDCount", DWORD), # 硬盘数(不可设置)
        ("struHDInfo", NET_DVR_SINGLE_HD * MAX_DISKNUM_V30), # 硬盘相关操作都需要重启才能生效；
    ]


LPNET_DVR_HDCFG = POINTER(NET_DVR_HDCFG)


# 本地硬盘信息配置
class NET_DVR_SINGLE_HD_V50(Structure):
    _fields_ = [
        ("dwHDNo", DWORD), # 硬盘号, 取值0~MAX_DISKNUM_V30-1
        ("dwCapacity", DWORD), # 硬盘容量(不可设置)
        ("dwFreeSpace", DWORD), # 硬盘剩余空间(不可设置)
        ("dwHdStatus", DWORD), # 硬盘状态(不可设置) HD_STAT 0-正常, 1-未格式化, 2-错误, 3-SMART状态,
        # 4-不匹配, 5-休眠 6-网络硬盘不在线 7-虚拟磁盘可扩容 10-硬盘正在修复
        # 11-硬盘正在格式化 12-硬盘正在等待格式化 13-硬盘已卸载 14-本地硬盘不存在
        # 15-正在删除(网络硬盘),16-已锁定,17-警告（随时会变成坏盘）,18-坏盘（已经损坏的硬盘）,19-隐患盘（出现异常被踢出阵列，比如出现坏扇区）,20-未认证（未检测，需要到CVR中对磁盘进行检测）
        # 21-未在录播主机中格式化
        ("byHDAttr", BYTE), # 0-普通, 1-冗余 2-只读，3-存档，4-不可读写
        ("byHDType", BYTE), # 0-本地硬盘,1-ESATA硬盘,2-NAS硬盘,3-iSCSI硬盘 4-Array虚拟磁盘,5-SD卡,6-minSAS
        ("byDiskDriver", BYTE), #  值 代表其ASCII字符
        ("byGenusGruop", BYTE), # 属组：0-保留，1-阵列，2-存储池，3-阵列踢盘，4-未初始化，5-无效盘，6-区域热备，7-全局热备，只读
        ("dwHdGroup", DWORD), # 属于哪个盘组 1-MAX_HD_GROUP
        ("byRecycling", BYTE), #  是否循环利用 0：不循环利用，1：循环利用
        ("bySupportFormatType", BYTE), # 当前硬盘所支持的格式化类型,只读。当前该节点仅支持byHDType=5(SD卡)时
        # 若bySupportFormatType=0,则代表设备将以自身的默认类型来格式化硬盘
        # bySupportFormatType:bit0: 0-代表不支持FAT32格式化类型,1-代表支持
        # bySupportFormatType:bit1: 0-代表不支持EXT4格式化类型,1-代表支持
        ("byFormatType", BYTE), # 当前硬盘格式化类型配置: 0-设备默认格式化类型,1-指定FAT32格式化(byHDType=5(SD卡)时生效),
        # 2-指定EXT4格式化(byHDType=5(SD卡)时生效)
        ("byRes2", BYTE),
        ("dwStorageType", DWORD), # 按位表示 0-不支持 非0-支持
        # dwStorageType & 0x1 表示是否是普通录像专用存储盘
        # dwStorageType & 0x2  表示是否是抽帧录像专用存储盘
        # dwStorageType & 0x4 表示是否是图片录像专用存储盘
        #
        ("dwPictureCapacity", DWORD), # 硬盘图片容量(不可设置)，单位:MB
        ("dwFreePictureSpace", DWORD), # 剩余图片空间(不可设置)，单位:MB
        ("byDiskLocation", BYTE * NET_SDK_DISK_LOCATION_LEN), # 硬盘位置，具体格式见备注，只读
        ("bySupplierName", BYTE * NET_SDK_SUPPLIER_NAME_LEN), # 供应商名称，只读
        ("byDiskModel", BYTE * NET_SDK_DISK_MODEL_LEN), # 硬盘型号，只读
        ("szHDLocateIP", CHAR * SDK_MAX_IP_LEN), # 磁盘所在IP信息
        ("byRes3", BYTE * 80),
    ]


LPNET_DVR_SINGLE_HD_V50 = POINTER(NET_DVR_SINGLE_HD_V50)


class NET_DVR_HDCFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwHDCount", DWORD), # 硬盘数(不可设置)
        ("struHDInfoV50", NET_DVR_SINGLE_HD_V50 * MAX_DISKNUM_V30), # 硬盘相关操作都需要重启才能生效；
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_HDCFG_V50 = POINTER(NET_DVR_HDCFG_V50)


class NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byHDVolumeNo", BYTE), # 硬盘卷ID(不可设置)
        ("byType", BYTE), # 硬盘卷类型:0-录像卷（用于保存录像），1-存档卷（用于存档录像，下发录像计划时，不能关联存档卷）,
        # 2-文件卷（只用于存储客户端上传的文件，下发录像计划时，不能关联文件卷，需要过滤掉）3-图片卷（只用于存储客户端上传的图片）
        ("byRes1", BYTE * 2),
        ("dwCapacity", DWORD), # 硬盘卷容量，单位MB(不可设置)
        ("dwFreeSpace", DWORD), # 硬盘卷剩余空间，单位MB(不可设置)
        ("byHDVolumeName", BYTE * NET_SDK_DISK_VOLUME_LEN), # 硬盘卷名称(不可设置)
        ("byLoopCover", BYTE), # 是否循环覆盖：0-非循环覆盖，1-循环覆盖（硬盘卷满了之后，循环覆盖最老的录像）
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_HARD_DISK_SINGLE_VOLUME_INFO = POINTER(NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO)


class NET_DVR_HARD_DISK_VOLUME_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwHDVolumeCount", DWORD), # 当前硬盘卷总数(不可设置)
        ("struSingleVolumeInfo", NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO * NET_SDK_MAX_DISK_VOLUME), # 单个硬盘卷信息
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_HARD_DISK_VOLUME_INFO = POINTER(NET_DVR_HARD_DISK_VOLUME_INFO)


# 本地盘组信息配置扩展
class NET_DVR_SINGLE_HDGROUP_V40(Structure):
    _fields_ = [
        ("dwHDGroupNo", DWORD), # 盘组号(不可设置) 1-MAX_HD_GROUP
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V40), # 触发的录像通道，按值表示，遇到0xffffffff时后续视为无效
        ("byRes", BYTE * 64), #  保留
    ]


LPNET_DVR_SINGLE_HDGROUP_V40 = POINTER(NET_DVR_SINGLE_HDGROUP_V40)


class NET_DVR_HDGROUP_CFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwMaxHDGroupNum", DWORD), # 设备支持的最大盘组数-只读
        ("dwCurHDGroupNum", DWORD), # 当前配置的盘组数
        ("struHDGroupAttr", NET_DVR_SINGLE_HDGROUP_V40 * MAX_HD_GROUP), # 硬盘相关操作都需要重启才能生效；
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_HDGROUP_CFG_V40 = POINTER(NET_DVR_HDGROUP_CFG_V40)


# 本地盘组信息配置
class NET_DVR_SINGLE_HDGROUP(Structure):
    _fields_ = [
        ("dwHDGroupNo", DWORD), # 盘组号(不可设置) 1-MAX_HD_GROUP
        ("byHDGroupChans", BYTE * MAX_CHANNUM_V30), # 盘组对应的录像通道, 0-表示该通道不录象到该盘组，1-表示录象到该盘组
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_SINGLE_HDGROUP = POINTER(NET_DVR_SINGLE_HDGROUP)


class NET_DVR_HDGROUP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwHDGroupCount", DWORD), # 盘组总数(不可设置)
        ("struHDGroupAttr", NET_DVR_SINGLE_HDGROUP * MAX_HD_GROUP), # 硬盘相关操作都需要重启才能生效；
    ]


LPNET_DVR_HDGROUP_CFG = POINTER(NET_DVR_HDGROUP_CFG)


# 配置缩放参数的结构
class NET_DVR_SCALECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMajorScale", DWORD), #  主显示 0-不缩放，1-缩放
        ("dwMinorScale", DWORD), #  辅显示 0-不缩放，1-缩放
        ("dwRes", DWORD * 2),
    ]


LPNET_DVR_SCALECFG = POINTER(NET_DVR_SCALECFG)


# DVR报警输出(9000扩展)
class NET_DVR_ALARMOUTCFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sAlarmOutName", BYTE * NAME_LEN), #  名称
        ("dwAlarmOutDelay", DWORD), #  输出保持时间(-1为无限，手动关闭)
        # 0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动,8-1秒,9-2秒,10-3秒,11-4秒
        ("struAlarmOutTime", NET_DVR_SCHEDTIME * MAX_DAYS), #  报警输出激活时间段
        ("byAlarmOutHandle", BYTE), #  是否处理 0-处理 1-不处理
        ("byNormalSatus", BYTE), #  常态 0-常开 1-常闭
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_ALARMOUTCFG_V30 = POINTER(NET_DVR_ALARMOUTCFG_V30)


# DVR报警输出
class NET_DVR_ALARMOUTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sAlarmOutName", BYTE * NAME_LEN), #  名称
        ("dwAlarmOutDelay", DWORD), #  输出保持时间(-1为无限，手动关闭)
        # 0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动, 8-1秒, 9-3秒
        ("struAlarmOutTime", NET_DVR_SCHEDTIME * MAX_DAYS), #  报警输出激活时间段
    ]


LPNET_DVR_ALARMOUTCFG = POINTER(NET_DVR_ALARMOUTCFG)


# DVR本地预览参数(9000扩展)
# 切换是指在当前预览模式下切换显示画面，而不是切换预览模式。比如byPreviewNumber为0（1画面），bySwitchSeq[0][0] = 1,bySwitchSeq[0][1] = 2,bySwitchSeq[0][2] = 3
# 则本地画面一直是1画面，然后在输出画面按1,2,3通道顺序切换
class NET_DVR_PREVIEWCFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPreviewNumber", BYTE), # 预览模式,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
        ("byEnableAudio", BYTE), # 是否声音预览,0-不预览,1-预览
        ("wSwitchTime", WORD), # 切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
        ("bySwitchSeq", BYTE * MAX_PREVIEW_MODE), # 切换顺序,如果lSwitchSeq[i]为 0xff表示不用
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_PREVIEWCFG_V30 = POINTER(NET_DVR_PREVIEWCFG_V30)


# DVR本地预览参数
class NET_DVR_PREVIEWCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPreviewNumber", BYTE), # 预览数目,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
        ("byEnableAudio", BYTE), # 是否声音预览,0-不预览,1-预览
        ("wSwitchTime", WORD), # 切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
        ("bySwitchSeq", BYTE * MAX_WINDOW), # 切换顺序,如果lSwitchSeq[i]为 0xff表示不用
    ]


LPNET_DVR_PREVIEWCFG = POINTER(NET_DVR_PREVIEWCFG)


# DVR视频输出
class NET_DVR_VGAPARA(Structure):
    _fields_ = [
        ("wResolution", WORD), #  分辨率
        ("wFreq", WORD), #  刷新频率
        ("dwBrightness", DWORD), #  亮度
    ]


# MATRIX输出参数结构
class NET_DVR_MATRIXPARA_V30(Structure):
    _fields_ = [
        ("wOrder", WORD * MAX_ANALOG_CHANNUM), #  预览顺序, 0xff表示相应的窗口不预览
        ("wSwitchTime", WORD), #  预览切换时间
        ("res", BYTE * 14),
    ]


LPNET_DVR_MATRIXPARA_V30 = POINTER(NET_DVR_MATRIXPARA_V30)


class NET_DVR_MATRIXPARA(Structure):
    _fields_ = [
        ("wDisplayLogo", WORD), #  显示视频通道号
        ("wDisplayOsd", WORD), #  显示时间
    ]


class NET_DVR_VOOUT(Structure):
    _fields_ = [
        ("byVideoFormat", BYTE), #  输出制式,0-PAL,1-NTSC
        ("byMenuAlphaValue", BYTE), #  菜单与背景图象对比度
        ("wScreenSaveTime", WORD), #  屏幕保护时间 0-从不,1-1分钟,2-2分钟,3-5分钟,4-10分钟,5-20分钟,6-30分钟
        ("wVOffset", WORD), #  视频输出偏移
        ("wBrightness", WORD), #  视频输出亮度
        ("byStartMode", BYTE), #  启动后视频输出模式(0:菜单,1:预览)
        ("byEnableScaler", BYTE), #  是否启动缩放 (0-不启动, 1-启动)
    ]


# DVR视频输出(9000扩展)
class NET_DVR_VIDEOOUT_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struVOOut", NET_DVR_VOOUT * MAX_VIDEOOUT_V30),
        ("struVGAPara", NET_DVR_VGAPARA * MAX_VGA_V30), #  VGA参数
        ("struMatrixPara", NET_DVR_MATRIXPARA_V30 * MAX_MATRIXOUT), #  MATRIX参数
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_VIDEOOUT_V30 = POINTER(NET_DVR_VIDEOOUT_V30)


# DVR视频输出
class NET_DVR_VIDEOOUT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struVOOut", NET_DVR_VOOUT * MAX_VIDEOOUT),
        ("struVGAPara", NET_DVR_VGAPARA * MAX_VGA), #  VGA参数
        ("struMatrixPara", NET_DVR_MATRIXPARA), #  MATRIX参数
    ]


LPNET_DVR_VIDEOOUT = POINTER(NET_DVR_VIDEOOUT)


# 单用户参数(子结构)(扩展)
class NET_DVR_USER_INFO_V40(Structure):
    _fields_ = [
        ("sUserName", BYTE * NAME_LEN), #  用户名只能用16字节
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("byLocalRight", BYTE * MAX_RIGHT), #  本地权限
        # 数组0: 本地控制云台
        # 数组1: 本地手动录象
        # 数组2: 本地回放
        # 数组3: 本地设置参数
        # 数组4: 本地查看状态、日志
        # 数组5: 本地高级操作(升级，格式化，重启，关机)
        # 数组6: 本地查看参数
        # 数组7: 本地管理模拟和IP camera
        # 数组8: 本地备份
        # 数组9: 本地关机/重启
        ("byRemoteRight", BYTE * MAX_RIGHT), #  远程权限
        # 数组0: 远程控制云台
        # 数组1: 远程手动录象
        # 数组2: 远程回放
        # 数组3: 远程设置参数
        # 数组4: 远程查看状态、日志
        # 数组5: 远程高级操作(升级，格式化，重启，关机)
        # 数组6: 远程发起语音对讲
        # 数组7: 远程预览
        # 数组8: 远程请求报警上传、报警输出
        # 数组9: 远程控制，本地输出
        # 数组10: 远程控制串口
        # 数组11: 远程查看参数
        # 数组12: 远程管理模拟和IP camera
        # 数组13: 远程关机/重启
        ("dwNetPreviewRight", DWORD * MAX_CHANNUM_V40), #  远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalRecordRight", DWORD * MAX_CHANNUM_V40), #  本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetRecordRight", DWORD * MAX_CHANNUM_V40), #  远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalPlaybackRight", DWORD * MAX_CHANNUM_V40), #  本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetPlaybackRight", DWORD * MAX_CHANNUM_V40), #  远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalPTZRight", DWORD * MAX_CHANNUM_V40), #  本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetPTZRight", DWORD * MAX_CHANNUM_V40), #  远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalBackupRight", DWORD * MAX_CHANNUM_V40), #  本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("struUserIP", NET_DVR_IPADDR), #  用户IP地址(为0时表示允许任何地址)
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
        ("byPriority", BYTE), #  优先级，0xff-无，0--低，1--中，2--高
        # 无……表示不支持优先级的设置
        # 低……默认权限:包括本地和远程回放,本地和远程查看日志和
        # 状态,本地和远程关机/重启
        # 中……包括本地和远程控制云台,本地和远程手动录像,本地和
        # 远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启
        # 高……管理员
        ("byAlarmOnRight", BYTE), #  报警输入口布防权限 1-有权限，0-无权限
        ("byAlarmOffRight", BYTE), #  报警输入口撤防权限 1-有权限，0-无权限
        ("byBypassRight", BYTE), #  报警输入口旁路权限 1-有权限，0-无权限
        ("byRes1", BYTE * 2), # 四字节对齐
        ("byPublishRight", BYTE * MAX_RIGHT), # 信息发布专有权限
        # 数组0: 素材审核权限
        # 数组1: 节目审核权限
        # 数组2: 日程审核权限
        # 数组3: 上传素材权限
        # 数组4: 新建节目权限
        # 数组5: 新建日程权限
        # 数组6: 信息播放权限
        # 数组7: 终端管理权限
        # 数组8: 商业智能权限
        ("byRes", BYTE * 84),
    ]


LPNET_DVR_USER_INFO_V40 = POINTER(NET_DVR_USER_INFO_V40)


# 单用户参数(子结构)(扩展)
class NET_DVR_USER_INFO_V51(Structure):
    _fields_ = [
        ("sUserName", BYTE * NAME_LEN), #  用户名只能用16字节
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("byLocalRight", BYTE * MAX_RIGHT), #  本地权限
        # 数组0: 本地控制云台
        # 数组1: 本地手动录象
        # 数组2: 本地回放
        # 数组3: 本地设置参数
        # 数组4: 本地查看状态、日志
        # 数组5: 本地高级操作(升级，格式化，重启，关机)
        # 数组6: 本地查看参数
        # 数组7: 本地管理模拟和IP camera
        # 数组8: 本地备份
        # 数组9: 本地关机/重启
        # 数组10: 本地预览
        ("byRemoteRight", BYTE * MAX_RIGHT), #  远程权限
        # 数组0: 远程控制云台
        # 数组1: 远程手动录象
        # 数组2: 远程回放
        # 数组3: 远程设置参数
        # 数组4: 远程查看状态、日志
        # 数组5: 远程高级操作(升级，格式化，重启，关机)
        # 数组6: 远程发起语音对讲
        # 数组7: 远程预览
        # 数组8: 远程请求报警上传、报警输出
        # 数组9: 远程控制，本地输出
        # 数组10: 远程控制串口
        # 数组11: 远程查看参数
        # 数组12: 远程管理模拟和IP camera
        # 数组13: 远程关机/重启
        ("dwNetPreviewRight", DWORD * MAX_CHANNUM_V40), #  远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalRecordRight", DWORD * MAX_CHANNUM_V40), #  本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetRecordRight", DWORD * MAX_CHANNUM_V40), #  远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalPlaybackRight", DWORD * MAX_CHANNUM_V40), #  本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetPlaybackRight", DWORD * MAX_CHANNUM_V40), #  远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalPTZRight", DWORD * MAX_CHANNUM_V40), #  本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetPTZRight", DWORD * MAX_CHANNUM_V40), #  远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalBackupRight", DWORD * MAX_CHANNUM_V40), #  本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalPreviewRight", DWORD * MAX_CHANNUM_V40), #  本地预览权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("struUserIP", NET_DVR_IPADDR), #  用户IP地址(为0时表示允许任何地址)
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
        ("byPriority", BYTE), #  优先级，0xff-无，0--低，1--中，2--高
        # 无……表示不支持优先级的设置
        # 低……默认权限:包括本地和远程回放,本地和远程查看日志和
        # 状态,本地和远程关机/重启
        # 中……包括本地和远程控制云台,本地和远程手动录像,本地和
        # 远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启高……管理员
        ("byAlarmOnRight", BYTE), #  报警输入口布防权限 1-有权限，0-无权限
        ("byAlarmOffRight", BYTE), #  报警输入口撤防权限 1-有权限，0-无权限
        ("byBypassRight", BYTE), #  报警输入口旁路权限 1-有权限，0-无权限
        ("byRes1", BYTE * 2), # 四字节对齐
        ("byPublishRight", BYTE * MAX_RIGHT), # 信息发布专有权限
        # 数组0: 素材审核权限
        # 数组1: 节目审核权限
        # 数组2: 日程审核权限
        # 数组3: 上传素材权限
        # 数组4: 新建节目权限
        # 数组5: 新建日程权限
        # 数组6: 信息播放权限
        # 数组7: 终端管理权限
        # 数组8: 商业智能权限
        ("dwPasswordValidity", DWORD), # 密码有效期,仅管理员用户可以修改,单位：天，填0表示永久生效
        ("byKeypadPassword", BYTE * PASSWD_LEN), # 键盘密码
        ("byUserOperateType", BYTE), # 用户操作类型，1-网络用户，2-键盘用户，3-网络用户+键盘用户
        ("byRes", BYTE * 1007),
    ]


LPNET_DVR_USER_INFO_V51 = POINTER(NET_DVR_USER_INFO_V51)


class NET_DVR_USER_V51(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwMaxUserNum", DWORD), # 设备支持的最大用户数-只读
        ("struUser", NET_DVR_USER_INFO_V51 * MAX_USERNUM_V30), #  用户参数
        ("sloginPassword", CHAR * PASSWD_LEN), #  登陆密码确认
        ("byRes", BYTE * 240), # 保留
    ]


LPNET_DVR_USER_V51 = POINTER(NET_DVR_USER_V51)


# 单用户参数(子结构)(扩展)
class NET_DVR_USER_INFO_V52(Structure):
    _fields_ = [
        ("sUserName", BYTE * NAME_LEN), #  用户名只能用16字节
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("byLocalRight", BYTE * MAX_RIGHT), #  本地权限
        # 数组0: 本地控制云台
        # 数组1: 本地手动录象
        # 数组2: 本地回放
        # 数组3: 本地设置参数
        # 数组4: 本地查看状态、日志
        # 数组5: 本地高级操作(升级，格式化，重启，关机)
        # 数组6: 本地查看参数
        # 数组7: 本地管理模拟和IP camera
        # 数组8: 本地备份
        # 数组9: 本地关机/重启
        # 数组10: 本地预览
        ("byRemoteRight", BYTE * MAX_RIGHT), #  远程权限
        # 数组0: 远程控制云台
        # 数组1: 远程手动录象
        # 数组2: 远程回放
        # 数组3: 远程设置参数
        # 数组4: 远程查看状态、日志
        # 数组5: 远程高级操作(升级，格式化，重启，关机)
        # 数组6: 远程发起语音对讲
        # 数组7: 远程预览
        # 数组8: 远程请求报警上传、报警输出
        # 数组9: 远程控制，本地输出
        # 数组10: 远程控制串口
        # 数组11: 远程查看参数
        # 数组12: 远程管理模拟和IP camera
        # 数组13: 远程关机/重启
        ("dwNetPreviewRight", DWORD * MAX_CHANNUM_V40), #  远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalRecordRight", DWORD * MAX_CHANNUM_V40), #  本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetRecordRight", DWORD * MAX_CHANNUM_V40), #  远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalPlaybackRight", DWORD * MAX_CHANNUM_V40), #  本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetPlaybackRight", DWORD * MAX_CHANNUM_V40), #  远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalPTZRight", DWORD * MAX_CHANNUM_V40), #  本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetPTZRight", DWORD * MAX_CHANNUM_V40), #  远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalBackupRight", DWORD * MAX_CHANNUM_V40), #  本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalPreviewRight", DWORD * MAX_CHANNUM_V40), #  本地预览权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalDoubleVerificationPlaybackRight", DWORD * MAX_CHANNUM_V40), #  本地可以二次认证回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwLocalDoubleVerificationBackupRight", DWORD * MAX_CHANNUM_V40), #  本地可以二次认证备份的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("dwNetDoubleVerificationPlaybackRight", DWORD * MAX_CHANNUM_V40), #  远程可以二次认证回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
        ("struUserIP", NET_DVR_IPADDR), #  用户IP地址(为0时表示允许任何地址)
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
        ("byPriority", BYTE), #  优先级，0xff-无，0--低，1--中，2--高
        # 无……表示不支持优先级的设置
        # 低……默认权限:包括本地和远程回放,本地和远程查看日志和
        # 状态,本地和远程关机/重启
        # 中……包括本地和远程控制云台,本地和远程手动录像,本地和
        # 远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启高……管理员
        ("byAlarmOnRight", BYTE), #  报警输入口布防权限 1-有权限，0-无权限
        ("byAlarmOffRight", BYTE), #  报警输入口撤防权限 1-有权限，0-无权限
        ("byBypassRight", BYTE), #  报警输入口旁路权限 1-有权限，0-无权限
        ("byRes1", BYTE * 2), # 四字节对齐
        ("byPublishRight", BYTE * MAX_RIGHT), # 信息发布专有权限
        # 数组0: 素材审核权限
        # 数组1: 节目审核权限
        # 数组2: 日程审核权限
        # 数组3: 上传素材权限
        # 数组4: 新建节目权限
        # 数组5: 新建日程权限
        # 数组6: 信息播放权限
        # 数组7: 终端管理权限
        # 数组8: 商业智能权限
        ("dwPasswordValidity", DWORD), # 密码有效期,仅管理员用户可以修改,单位：天，填0表示永久生效
        ("byKeypadPassword", BYTE * PASSWD_LEN), # 键盘密码
        ("byUserOperateType", BYTE), # 用户操作类型，1-网络用户，2-键盘用户，3-网络用户+键盘用户
        ("byRes", BYTE * 1007),
    ]


LPNET_DVR_USER_INFO_V52 = POINTER(NET_DVR_USER_INFO_V52)


class NET_DVR_USER_V52(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwMaxUserNum", DWORD), # 设备支持的最大用户数-只读
        ("struUser", NET_DVR_USER_INFO_V52 * MAX_USERNUM_V30), #  用户参数
        ("sloginPassword", CHAR * PASSWD_LEN), #  登陆密码确认
        ("byRes", BYTE * 240), # 保留
    ]


LPNET_DVR_USER_V52 = POINTER(NET_DVR_USER_V52)


# 单用户参数(子结构)(9000扩展)
class NET_DVR_USER_INFO_V30(Structure):
    _fields_ = [
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("byLocalRight", BYTE * MAX_RIGHT), #  本地权限
        # 数组0: 本地控制云台
        # 数组1: 本地手动录象
        # 数组2: 本地回放
        # 数组3: 本地设置参数
        # 数组4: 本地查看状态、日志
        # 数组5: 本地高级操作(升级，格式化，重启，关机)
        # 数组6: 本地查看参数
        # 数组7: 本地管理模拟和IP camera
        # 数组8: 本地备份
        # 数组9: 本地关机/重启
        ("byRemoteRight", BYTE * MAX_RIGHT), #  远程权限
        # 数组0: 远程控制云台
        # 数组1: 远程手动录象
        # 数组2: 远程回放
        # 数组3: 远程设置参数
        # 数组4: 远程查看状态、日志
        # 数组5: 远程高级操作(升级，格式化，重启，关机)
        # 数组6: 远程发起语音对讲
        # 数组7: 远程预览
        # 数组8: 远程请求报警上传、报警输出
        # 数组9: 远程控制，本地输出
        # 数组10: 远程控制串口
        # 数组11: 远程查看参数
        # 数组12: 远程管理模拟和IP camera
        # 数组13: 远程关机/重启
        ("byNetPreviewRight", BYTE * MAX_CHANNUM_V30), #  远程可以预览的通道 0-有权限，1-无权限
        ("byLocalPlaybackRight", BYTE * MAX_CHANNUM_V30), #  本地可以回放的通道 0-有权限，1-无权限
        ("byNetPlaybackRight", BYTE * MAX_CHANNUM_V30), #  远程可以回放的通道 0-有权限，1-无权限
        ("byLocalRecordRight", BYTE * MAX_CHANNUM_V30), #  本地可以录像的通道 0-有权限，1-无权限
        ("byNetRecordRight", BYTE * MAX_CHANNUM_V30), #  远程可以录像的通道 0-有权限，1-无权限
        ("byLocalPTZRight", BYTE * MAX_CHANNUM_V30), #  本地可以PTZ的通道 0-有权限，1-无权限
        ("byNetPTZRight", BYTE * MAX_CHANNUM_V30), #  远程可以PTZ的通道 0-有权限，1-无权限
        ("byLocalBackupRight", BYTE * MAX_CHANNUM_V30), #  本地备份权限通道 0-有权限，1-无权限
        ("struUserIP", NET_DVR_IPADDR), #  用户IP地址(为0时表示允许任何地址)
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
        ("byPriority", BYTE), #  优先级，0xff-无，0--低，1--中，2--高
        #
        # 无……表示不支持优先级的设置
        # 低……默认权限:包括本地和远程回放,本地和远程查看日志和状态,本地和远程关机/重启
        # 中……包括本地和远程控制云台,本地和远程手动录像,本地和远程回放,语音对讲和远程预览
        # 本地备份,本地/远程关机/重启
        # 高……管理员
        #
        ("byAlarmOnRight", BYTE), #  报警输入口布防权限
        ("byAlarmOffRight", BYTE), #  报警输入口撤防权限
        ("byBypassRight", BYTE), #  报警输入口旁路权限
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_USER_INFO_V30 = POINTER(NET_DVR_USER_INFO_V30)


# 单用户参数(SDK_V15扩展)(子结构)
class NET_DVR_USER_INFO_EX(Structure):
    _fields_ = [
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("dwLocalRight", DWORD * MAX_RIGHT), #  权限
        # 数组0: 本地控制云台
        # 数组1: 本地手动录象
        # 数组2: 本地回放
        # 数组3: 本地设置参数
        # 数组4: 本地查看状态、日志
        # 数组5: 本地高级操作(升级，格式化，重启，关机)
        ("dwLocalPlaybackRight", DWORD), #  本地可以回放的通道 bit0 -- channel 1
        ("dwRemoteRight", DWORD * MAX_RIGHT), #  权限
        # 数组0: 远程控制云台
        # 数组1: 远程手动录象
        # 数组2: 远程回放
        # 数组3: 远程设置参数
        # 数组4: 远程查看状态、日志
        # 数组5: 远程高级操作(升级，格式化，重启，关机)
        # 数组6: 远程发起语音对讲
        # 数组7: 远程预览
        # 数组8: 远程请求报警上传、报警输出
        # 数组9: 远程控制，本地输出
        # 数组10: 远程控制串口
        ("dwNetPreviewRight", DWORD), #  远程可以预览的通道 bit0 -- channel 1
        ("dwNetPlaybackRight", DWORD), #  远程可以回放的通道 bit0 -- channel 1
        ("sUserIP", CHAR * 16), #  用户IP地址(为0时表示允许任何地址)
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
    ]


LPNET_DVR_USER_INFO_EX = POINTER(NET_DVR_USER_INFO_EX)


# 单用户参数(子结构)
class NET_DVR_USER_INFO(Structure):
    _fields_ = [
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("dwLocalRight", DWORD * MAX_RIGHT), #  权限
        # 数组0: 本地控制云台
        # 数组1: 本地手动录象
        # 数组2: 本地回放
        # 数组3: 本地设置参数
        # 数组4: 本地查看状态、日志
        # 数组5: 本地高级操作(升级，格式化，重启，关机)
        ("dwRemoteRight", DWORD * MAX_RIGHT), #  权限
        # 数组0: 远程控制云台
        # 数组1: 远程手动录象
        # 数组2: 远程回放
        # 数组3: 远程设置参数
        # 数组4: 远程查看状态、日志
        # 数组5: 远程高级操作(升级，格式化，重启，关机)
        # 数组6: 远程发起语音对讲
        # 数组7: 远程预览
        # 数组8: 远程请求报警上传、报警输出
        # 数组9: 远程控制，本地输出
        # 数组10: 远程控制串口
        ("sUserIP", CHAR * 16), #  用户IP地址(为0时表示允许任何地址)
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
    ]


LPNET_DVR_USER_INFO = POINTER(NET_DVR_USER_INFO)


# DVR用户参数(扩展)
class NET_DVR_USER_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwMaxUserNum", DWORD), # 设备支持的最大用户数-只读
        ("struUser", NET_DVR_USER_INFO_V40 * MAX_USERNUM_V30), #  用户参数
    ]


LPNET_DVR_USER_V40 = POINTER(NET_DVR_USER_V40)


class NET_DVR_USER_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwMaxUserNum", DWORD), # 设备支持的最大用户数-只读
        ("struUser", NET_DVR_USER_INFO_V40 * MAX_USERNUM_V30), #  用户参数
        ("sloginPassword", CHAR * PASSWD_LEN), #  登陆密码确认
        ("byRes", BYTE * 240), # 保留
    ]


LPNET_DVR_USER_V50 = POINTER(NET_DVR_USER_V50)


# DVR用户参数(9000扩展)
class NET_DVR_USER_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struUser", NET_DVR_USER_INFO_V30 * MAX_USERNUM_V30),
    ]


LPNET_DVR_USER_V30 = POINTER(NET_DVR_USER_V30)


# DVR用户参数(SDK_V15扩展)
class NET_DVR_USER_EX(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struUser", NET_DVR_USER_INFO_EX * MAX_USERNUM),
    ]


LPNET_DVR_USER_EX = POINTER(NET_DVR_USER_EX)


# DVR用户参数
class NET_DVR_USER(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struUser", NET_DVR_USER_INFO * MAX_USERNUM),
    ]


LPNET_DVR_USER = POINTER(NET_DVR_USER)


class NET_DVR_EXCEPTION_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwMaxGroupNum", DWORD), # 设备支持的最大组数
        ("struExceptionHandle", NET_DVR_HANDLEEXCEPTION_V41 * MAX_EXCEPTIONNUM_V30),
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_EXCEPTION_V40 = POINTER(NET_DVR_EXCEPTION_V40)


# DVR异常参数(9000扩展)
class NET_DVR_EXCEPTION_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struExceptionHandleType", NET_DVR_HANDLEEXCEPTION_V30 * MAX_EXCEPTIONNUM_V30),
        # 数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突, 4-非法访问, 5-输入/输出视频制式不匹配, 6-视频信号异常, 7-录像异常 8-阵列异常，9-前端/录像分辨率不匹配异常，10-行车超速(车载专用) 11-热备异常（N+1使用）12-温度，13-子系统异常，14-风扇异常, 15-POE供电异常, 16-POC异常,数组17-电源电压波动异常
    ]


LPNET_DVR_EXCEPTION_V30 = POINTER(NET_DVR_EXCEPTION_V30)


# DVR异常参数
class NET_DVR_EXCEPTION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struExceptionHandleType", NET_DVR_HANDLEEXCEPTION * MAX_EXCEPTIONNUM),
        # 数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突,4-非法访问, 5-输入/输出视频制式不匹配, 6-视频信号异常
    ]


LPNET_DVR_EXCEPTION = POINTER(NET_DVR_EXCEPTION)


# 通道状态(9000扩展)
class NET_DVR_CHANNELSTATE_V30(Structure):
    _fields_ = [
        ("byRecordStatic", BYTE), # 通道是否在录像,0-不录像,1-录像
        ("bySignalStatic", BYTE), # 连接的信号状态,0-正常,1-信号丢失
        ("byHardwareStatic", BYTE), # 通道硬件状态,0-正常,1-异常,例如DSP死掉
        ("byRes1", BYTE), # 保留
        ("dwBitRate", DWORD), # 实际码率
        ("dwLinkNum", DWORD), # 客户端连接的个数
        ("struClientIP", NET_DVR_IPADDR * MAX_LINK), # 客户端的IP地址
        ("dwIPLinkNum", DWORD), # 如果该通道为IP接入，那么表示IP接入当前的连接数
        ("byExceedMaxLink", BYTE), #  是否超出了单路6路连接数 0 - 未超出, 1-超出
        ("byRes", BYTE * 3), #  保留字节
        ("dwAllBitRate", DWORD), # 所有实际码率之和
        ("dwChannelNo", DWORD), # 当前的通道号，0xffffffff表示无效
    ]


LPNET_DVR_CHANNELSTATE_V30 = POINTER(NET_DVR_CHANNELSTATE_V30)


# 通道状态
class NET_DVR_CHANNELSTATE(Structure):
    _fields_ = [
        ("byRecordStatic", BYTE), # 通道是否在录像,0-不录像,1-录像
        ("bySignalStatic", BYTE), # 连接的信号状态,0-正常,1-信号丢失
        ("byHardwareStatic", BYTE), # 通道硬件状态,0-正常,1-异常,例如DSP死掉
        ("reservedData", CHAR), # 保留
        ("dwBitRate", DWORD), # 实际码率
        ("dwLinkNum", DWORD), # 客户端连接的个数
        ("dwClientIP", DWORD * MAX_LINK), # 客户端的IP地址
    ]


LPNET_DVR_CHANNELSTATE = POINTER(NET_DVR_CHANNELSTATE)


# 硬盘状态
class NET_DVR_DISKSTATE(Structure):
    _fields_ = [
        ("dwVolume", DWORD), # 硬盘的容量
        ("dwFreeSpace", DWORD), # 硬盘的剩余空间
        ("dwHardDiskStatic", DWORD), # 硬盘的状态,按位:1-休眠,2-不正常,3-休眠硬盘出错,4-未格式化, 5-未连接状态(网络硬盘),6-硬盘正在格式化,7-硬盘满(未开启循环覆盖的情况下),8-其他异常（待设备端统计）
    ]


LPNET_DVR_DISKSTATE = POINTER(NET_DVR_DISKSTATE)


class NET_DVR_WORKSTATE_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwDeviceStatic", DWORD), # 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
        ("struHardDiskStatic", NET_DVR_DISKSTATE * MAX_DISKNUM_V30), # 硬盘状态,一次最多只能获取33个硬盘信息
        ("struChanStatic", NET_DVR_CHANNELSTATE_V30 * MAX_CHANNUM_V40), # 通道的状态，从前往后顺序排列
        ("dwHasAlarmInStatic", DWORD * MAX_ALARMIN_V40), # 有报警的报警输入口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
        ("dwHasAlarmOutStatic", DWORD * MAX_ALARMOUT_V40), # 有报警输出的报警输出口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
        ("dwLocalDisplay", DWORD), # 本地显示状态,0-正常,1-不正常
        ("byAudioInChanStatus", BYTE * MAX_AUDIO_V30), # 按位表示语音通道的状态 0-未使用，1-使用中，第0位表示第1个语音通道
        ("byRes1", BYTE * 2),
        ("fHumidity", DOUBLE), # 传感器获知的湿度,范围:0.0 ~100.0
        ("fTemperature", DOUBLE), # 传感器获知的温度，范围：-20.0 ~ 90.0
        ("byRes", BYTE * 116), # 保留
    ]


LPNET_DVR_WORKSTATE_V40 = POINTER(NET_DVR_WORKSTATE_V40)


class NET_DVR_GETWORKSTATE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("byFindHardByCond", BYTE), # 0-查找全部磁盘(但一次最多只能查找33个)，此时dwFindHardStatusNum无效
        ("byFindChanByCond", BYTE), # 0-查找全部通道，此时dwFindChanNum无效
        ("byRes1", BYTE * 2), # 保留
        ("dwFindHardStatus", DWORD * MAX_DISKNUM_V30), # 要查找的硬盘号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效
        ("dwFindChanNo", DWORD * MAX_CHANNUM_V40), # 要查找的通道号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_GETWORKSTATE_COND = POINTER(NET_DVR_GETWORKSTATE_COND)


# DVR工作状态(9000扩展)
class NET_DVR_WORKSTATE_V30(Structure):
    _fields_ = [
        ("dwDeviceStatic", DWORD), # 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
        ("struHardDiskStatic", NET_DVR_DISKSTATE * MAX_DISKNUM_V30),
        ("struChanStatic", NET_DVR_CHANNELSTATE_V30 * MAX_CHANNUM_V30), # 通道的状态
        ("byAlarmInStatic", BYTE * MAX_ALARMIN_V30), # 报警端口的状态,0-没有报警,1-有报警
        ("byAlarmOutStatic", BYTE * MAX_ALARMOUT_V30), # 报警输出端口的状态,0-没有输出,1-有报警输出
        ("dwLocalDisplay", DWORD), # 本地显示状态,0-正常,1-不正常
        ("byAudioChanStatus", BYTE * MAX_AUDIO_V30), # 表示语音通道的状态 0-未使用，1-使用中, 0xff无效
        ("byRes", BYTE * 10),
    ]


LPNET_DVR_WORKSTATE_V30 = POINTER(NET_DVR_WORKSTATE_V30)


# DVR工作状态
class NET_DVR_WORKSTATE(Structure):
    _fields_ = [
        ("dwDeviceStatic", DWORD), # 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
        ("struHardDiskStatic", NET_DVR_DISKSTATE * MAX_DISKNUM),
        ("struChanStatic", NET_DVR_CHANNELSTATE * MAX_CHANNUM), # 通道的状态
        ("byAlarmInStatic", BYTE * MAX_ALARMIN), # 报警端口的状态,0-没有报警,1-有报警
        ("byAlarmOutStatic", BYTE * MAX_ALARMOUT), # 报警输出端口的状态,0-没有输出,1-有报警输出
        ("dwLocalDisplay", DWORD), # 本地显示状态,0-正常,1-不正常
    ]


LPNET_DVR_WORKSTATE = POINTER(NET_DVR_WORKSTATE)


# 日志信息(9000扩展)
class NET_DVR_LOG_V30(Structure):
    _fields_ = [
        ("strLogTime", NET_DVR_TIME),
        ("dwMajorType", DWORD), # 主类型 1-报警 2-异常 3-操作 0xff-全部
        ("dwMinorType", DWORD), # 次类型 0-全部
        ("sPanelUser", BYTE * MAX_NAMELEN), # 操作面板的用户名
        ("sNetUser", BYTE * MAX_NAMELEN), # 网络操作的用户名
        ("struRemoteHostAddr", NET_DVR_IPADDR), # 远程主机地址
        ("dwParaType", DWORD), # 参数类型,9000设备MINOR_START_VT/MINOR_STOP_VT时，表示语音对讲的端子号
        ("dwChannel", DWORD), # 通道号
        ("dwDiskNumber", DWORD), # 硬盘号
        ("dwAlarmInPort", DWORD), # 报警输入端口
        ("dwAlarmOutPort", DWORD), # 报警输出端口
        ("dwInfoLen", DWORD),
        ("sInfo", CHAR * LOG_INFO_LEN),
    ]


LPNET_DVR_LOG_V30 = POINTER(NET_DVR_LOG_V30)


# 日志信息
class NET_DVR_LOG(Structure):
    _fields_ = [
        ("strLogTime", NET_DVR_TIME),
        ("dwMajorType", DWORD), # 主类型 1-报警 2-异常 3-操作 0xff-全部
        ("dwMinorType", DWORD), # 次类型 0-全部
        ("sPanelUser", BYTE * MAX_NAMELEN), # 操作面板的用户名
        ("sNetUser", BYTE * MAX_NAMELEN), # 网络操作的用户名
        ("sRemoteHostAddr", CHAR * 16), # 远程主机地址
        ("dwParaType", DWORD), # 参数类型
        ("dwChannel", DWORD), # 通道号
        ("dwDiskNumber", DWORD), # 硬盘号
        ("dwAlarmInPort", DWORD), # 报警输入端口
        ("dwAlarmOutPort", DWORD), # 报警输出端口
    ]


LPNET_DVR_LOG = POINTER(NET_DVR_LOG)


class NET_DVR_FIND_LOG_COND(Structure):
    _fields_ = [
        ("dwSelectMode", DWORD), #  0－全部；1－按类型；2－按时间；3－按时间和类型
        ("dwMainType", DWORD), # 日志主类型
        ("dwSubType", DWORD), # 日志次类型
        ("struStartTime", NET_DVR_TIME_V50), # 开始时间
        ("struEndTime", NET_DVR_TIME_V50), # 结束时间
        ("bOnlySmart", BOOL), # 是否只搜索带S.M.A.R.T信息的日志
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_FIND_LOG_COND = POINTER(NET_DVR_FIND_LOG_COND)


class NET_DVR_LOG_V50(Structure):
    _fields_ = [
        ("struLogTime", NET_DVR_TIME_V50), # 日志发生的时间
        ("dwMajorType", DWORD), # 主类型 1-报警 2-异常 3-操作 0xff-全部
        ("dwMinorType", DWORD), # 次类型 0-全部
        ("sPanelUser", BYTE * MAX_NAMELEN), # 操作面板的用户名
        ("sNetUser", BYTE * MAX_NAMELEN), # 网络操作的用户名
        ("struRemoteHostAddr", NET_DVR_IPADDR), # 远程主机地址
        ("dwParaType", DWORD), # 参数类型,9000设备MINOR_START_VT/MINOR_STOP_VT时，表示语音对讲的端子号
        ("dwChannel", DWORD), # 通道号
        ("dwDiskNumber", DWORD), # 硬盘号
        ("dwAlarmInPort", DWORD), # 报警输入端口
        ("dwAlarmOutPort", DWORD), # 报警输出端口
        ("dwInfoLen", DWORD),
        ("sInfo", CHAR * LOG_INFO_LEN),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_LOG_V50 = POINTER(NET_DVR_LOG_V50)


# 动环报警管理主机日志查找
class NET_DVR_ALARMHOST_SEARCH_LOG_PARAM(Structure):
    _fields_ = [
        ("wMajorType", WORD), #  主类型
        ("wMinorType", WORD), #  次类型
        ("struStartTime", NET_DVR_TIME), #  开始时间
        ("struEndTime", NET_DVR_TIME), #  结束时间
        ("byRes", BYTE * 8), #  保留字节
    ]


LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM = POINTER(NET_DVR_ALARMHOST_SEARCH_LOG_PARAM)


class NET_DVR_ALARMHOST_LOG_RET(Structure):
    _fields_ = [
        ("struLogTime", NET_DVR_TIME), #   日志时间
        ("sUserName", BYTE * NAME_LEN), #  操作用户
        ("struIPAddr", NET_DVR_IPADDR), #  操作IP地址
        ("wMajorType", WORD), #  主类型
        ("wMinorType", WORD), #  次类型
        ("wParam", WORD), #  操作参数
        ("byRes", BYTE * 10),
        ("dwInfoLen", DWORD), #  描述信息长度
        ("sInfo", CHAR * LOG_INFO_LEN), #  描述信息
    ]


LPNET_DVR_ALARMHOST_LOG_RET = POINTER(NET_DVR_ALARMHOST_LOG_RET)


# 报警输出状态(9000扩展)
class NET_DVR_ALARMOUTSTATUS_V30(Structure):
    _fields_ = [
        ("Output", BYTE * MAX_ALARMOUT_V30),
    ]


LPNET_DVR_ALARMOUTSTATUS_V30 = POINTER(NET_DVR_ALARMOUTSTATUS_V30)


# 报警输出状态
class NET_DVR_ALARMOUTSTATUS(Structure):
    _fields_ = [
        ("Output", BYTE * MAX_ALARMOUT),
    ]


LPNET_DVR_ALARMOUTSTATUS = POINTER(NET_DVR_ALARMOUTSTATUS)


# 交易信息
class NET_DVR_TRADEINFO(Structure):
    _fields_ = [
        ("m_Year", WORD),
        ("m_Month", WORD),
        ("m_Day", WORD),
        ("m_Hour", WORD),
        ("m_Minute", WORD),
        ("m_Second", WORD),
        ("DeviceName", BYTE * 24), # 设备名称
        ("dwChannelNumer", DWORD), # 通道号
        ("CardNumber", BYTE * 32), # 卡号
        ("cTradeType", CHAR * 12), # 交易类型
        ("dwCash", DWORD), # 交易金额
    ]


LPNET_DVR_TRADEINFO = POINTER(NET_DVR_TRADEINFO)


# ATM专用
NCR = 0
DIEBOLD = 1
WINCOR_NIXDORF = 2
SIEMENS = 3
OLIVETTI = 4
FUJITSU = 5
HITACHI = 6
SMI = 7
IBM = 8
BULL = 9
YiHua = 10
LiDe = 11
GDYT = 12
Mini_Banl = 13
GuangLi = 14
DongXin = 15
ChenTong = 16
NanTian = 17
XiaoXing = 18
GZYY = 19
QHTLT = 20
DRS918 = 21
KALATEL = 22
NCR_2 = 23
NXS = 24
# 帧格式
class NET_DVR_FRAMETYPECODE(Structure):
    _fields_ = [
        ("code", BYTE * 12), #  代码
    ]


# ATM参数
class NET_DVR_FRAMEFORMAT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sATMIP", CHAR * 16), #  ATM IP地址
        ("dwATMType", DWORD), #  ATM类型
        ("dwInputMode", DWORD), #  输入方式    0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入
        ("dwFrameSignBeginPos", DWORD), #  报文标志位的起始位置
        ("dwFrameSignLength", DWORD), #  报文标志位的长度
        ("byFrameSignContent", BYTE * 12), #  报文标志位的内容
        ("dwCardLengthInfoBeginPos", DWORD), #  卡号长度信息的起始位置
        ("dwCardLengthInfoLength", DWORD), #  卡号长度信息的长度
        ("dwCardNumberInfoBeginPos", DWORD), #  卡号信息的起始位置
        ("dwCardNumberInfoLength", DWORD), #  卡号信息的长度
        ("dwBusinessTypeBeginPos", DWORD), #  交易类型的起始位置
        ("dwBusinessTypeLength", DWORD), #  交易类型的长度
        ("frameTypeCode", NET_DVR_FRAMETYPECODE * 10), #  类型
    ]


LPNET_DVR_FRAMEFORMAT = POINTER(NET_DVR_FRAMEFORMAT)


# ATM参数(9000扩展)
class NET_DVR_FRAMEFORMAT_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struATMIP", NET_DVR_IPADDR), #  ATM IP地址
        ("dwATMType", DWORD), #  ATM类型
        ("dwInputMode", DWORD), #  输入方式    0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入
        ("dwFrameSignBeginPos", DWORD), #  报文标志位的起始位置
        ("dwFrameSignLength", DWORD), #  报文标志位的长度
        ("byFrameSignContent", BYTE * 12), #  报文标志位的内容
        ("dwCardLengthInfoBeginPos", DWORD), #  卡号长度信息的起始位置
        ("dwCardLengthInfoLength", DWORD), #  卡号长度信息的长度
        ("dwCardNumberInfoBeginPos", DWORD), #  卡号信息的起始位置
        ("dwCardNumberInfoLength", DWORD), #  卡号信息的长度
        ("dwBusinessTypeBeginPos", DWORD), #  交易类型的起始位置
        ("dwBusinessTypeLength", DWORD), #  交易类型的长度
        ("frameTypeCode", NET_DVR_FRAMETYPECODE * 10), #  类型
        ("wATMPort", WORD), #  卡号捕捉端口号(网络协议方式) (保留)0xffff表示该值无效
        ("wProtocolType", WORD), #  网络协议类型(保留) 0xffff表示该值无效
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_FRAMEFORMAT_V30 = POINTER(NET_DVR_FRAMEFORMAT_V30)


# SDK_V31 ATM
# 过滤设置
class NET_DVR_FILTER(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 0,不启用1,启用
        ("byMode", BYTE), # 0,ASCII1,HEX
        ("byFrameBeginPos", BYTE), #  需要过滤目标字符串起始位置
        ("byRes", BYTE), #  保留字节
        ("byFilterText", BYTE * 16), # 过滤字符串
        ("byRes2", BYTE * 12), #  保留字节
    ]


LPNET_DVR_FILTER = POINTER(NET_DVR_FILTER)


# 数据包分析 数据包标识
class NET_DVR_IDENTIFICAT(Structure):
    _fields_ = [
        ("byStartMode", BYTE), # 起始字符模式:0,ASCII1,HEX
        ("byEndMode", BYTE), # 结束字符模式：0,ASCII1,HEX
        ("byRes", BYTE * 2), # 保留字节
        ("struStartCode", NET_DVR_FRAMETYPECODE), # 数据包起始标识字符
        ("struEndCode", NET_DVR_FRAMETYPECODE), # 数据包结束标识字符
        ("byRes1", BYTE * 12), # 保留字节
    ]


LPNET_DVR_IDENTIFICAT = POINTER(NET_DVR_IDENTIFICAT)


class NET_DVR_PACKAGE_LOCATION(Structure):
    _fields_ = [
        ("byOffsetMode", BYTE), # 报文位置信息模式 0,token(字符标志模式)1,fix（固定模式）
        ("byRes1", BYTE * 3), #  保留字节
        ("dwOffsetPos", DWORD), # mode为1的时候使用,固定偏移大小
        ("struTokenCode", NET_DVR_FRAMETYPECODE), # 标志位
        ("byMultiplierValue", BYTE), # 标志位多少次出现
        ("byEternOffset", BYTE), # 附加字符偏移量
        ("byCodeMode", BYTE), # 0,ASCII1,HEX
        ("byRes2", BYTE * 9), # 保留字节
    ]


LPNET_DVR_PACKAGE_LOCATION = POINTER(NET_DVR_PACKAGE_LOCATION)


class NET_DVR_PACKAGE_LENGTH(Structure):
    _fields_ = [
        ("byLengthMode", BYTE), # 长度类型，0,可变长度1,固定长度2,自助长度(从卡号中获取)
        ("byRes1", BYTE * 3), #  保留字节
        ("dwFixLength", DWORD), # mode为1的时候使用,固定长度大小
        ("dwMaxLength", DWORD), # 报文信息最大长度  byLengthMode为0时使用
        ("dwMinLength", DWORD), # 报文信息最小长度  byLengthMode为0时使用
        ("byEndMode", BYTE), # 可变长度 终结符模式 0,ASCII1,HEX
        ("byRes2", BYTE * 3), # 保留字节
        ("struEndCode", NET_DVR_FRAMETYPECODE), # 可变长度终结符
        ("dwLengthPos", DWORD), # lengthMode为2的时候使用，卡号长度在报文中的位置
        ("dwLengthLen", DWORD), # lengthMode为2的时候使用，卡号长度的长度
        ("byRes3", BYTE * 8), #  保留字节
    ]


LPNET_DVR_PACKAGE_LENGTH = POINTER(NET_DVR_PACKAGE_LENGTH)


class NET_DVR_OSD_POSITION(Structure):
    _fields_ = [
        ("byPositionMode", BYTE), # 叠加风格，共2种；0，不显示；1，自定义
        ("byRes1", BYTE * 3), #  保留字节
        ("dwPosX", DWORD), # x坐标，叠加风格为自定义时使用
        ("dwPosY", DWORD), # y坐标，叠加风格为自定义时使用
        ("byRes2", BYTE * 8), # 保留字节
    ]


LPNET_DVR_OSD_POSITION = POINTER(NET_DVR_OSD_POSITION)


class NET_DVR_DATE_FORMAT(Structure):
    _fields_ = [
        ("byMonth", BYTE), # Month,0.mm1.mmm2.mmmm
        ("byDay", BYTE), # Day,0.dd
        ("byYear", BYTE), # Year,0.yy1.yyyy
        ("byDateForm", BYTE), # 0~5，年月日的排列组合
        ("byRes", BYTE * 20), #  保留字节
        ("chSeprator", CHAR * 4), # 分隔符
        ("chDisplaySeprator", CHAR * 4), # 显示分隔符
        ("byDisplayForm", BYTE), # 0~5，3个item的排列组合
        ("res", BYTE * 27), #  保留字节
    ]


LPNET_DVR_DATE_FORMAT = POINTER(NET_DVR_DATE_FORMAT)


class NET_DVR_TIME_FORMAT(Structure):
    _fields_ = [
        ("byTimeForm", BYTE), # 1. HH MM SS0. HH MM
        ("byRes1", BYTE * 23), #  保留字节
        ("byHourMode", BYTE), # 0,121,24
        ("byRes2", BYTE * 3), #  保留字节
        ("chSeprator", CHAR * 4), # 报文分隔符，暂时没用
        ("chDisplaySeprator", CHAR * 4), # 显示分隔符
        ("byDisplayForm", BYTE), # 0~5，3个item的排列组合
        ("byRes3", BYTE * 3), #  保留字节
        ("byDisplayHourMode", BYTE), # 0,121,24
        ("byRes4", BYTE * 19), #  保留字节
    ]


LPNET_DVR_TIME_FORMAT = POINTER(NET_DVR_TIME_FORMAT)


class NET_DVR_OVERLAY_CHANNEL(Structure):
    _fields_ = [
        ("byChannel", BYTE * 64), # 叠加的通道 每个字节标识一个通道， 例如byChannel[0]值为1对应叠加通道1，0表示不叠加通道1。
        ("dwDelayTime", DWORD), # 叠加延时时间
        ("byEnableDelayTime", BYTE), # 是否启用叠加延时
        ("byRes", BYTE * 11), #  保留字节
    ]


LPNET_DVR_OVERLAY_CHANNEL = POINTER(NET_DVR_OVERLAY_CHANNEL)


#  ATM 报文行为信息
class NET_DVR_ATM_PACKAGE_ACTION(Structure):
    _fields_ = [
        ("struPackageLocation", NET_DVR_PACKAGE_LOCATION), #  报文位置信息
        ("struOsdPosition", NET_DVR_OSD_POSITION), #  OSD 叠加位置
        ("struActionCode", NET_DVR_FRAMETYPECODE), # 交易类型行为码
        ("struPreCode", NET_DVR_FRAMETYPECODE), # 叠加字符前的字符
        ("byActionCodeMode", BYTE), # 交易类型行为码模式0,ASCII1,HEX
        ("byRes", BYTE * 7), #  保留字节
    ]


LPNET_DVR_ATM_PACKAGE_ACTION = POINTER(NET_DVR_ATM_PACKAGE_ACTION)


#  ATM 报文DATA信息
class NET_DVR_ATM_PACKAGE_DATE(Structure):
    _fields_ = [
        ("struPackageLocation", NET_DVR_PACKAGE_LOCATION), #  日期在报文中的位置信息
        ("struDateForm", NET_DVR_DATE_FORMAT), # 日期显示格式
        ("struOsdPosition", NET_DVR_OSD_POSITION), #  OSD叠加位置信息
        ("res", BYTE * 8), #  保留字节
    ]


LPNET_DVR_ATM_PACKAGE_DATE = POINTER(NET_DVR_ATM_PACKAGE_DATE)


# ATM报文时间信息
class NET_DVR_ATM_PACKAGE_TIME(Structure):
    _fields_ = [
        ("location", NET_DVR_PACKAGE_LOCATION), #  时间在报文中的位置信息
        ("struTimeForm", NET_DVR_TIME_FORMAT), #  时间显示格式
        ("struOsdPosition", NET_DVR_OSD_POSITION), #  OSD 叠加位置信息
        ("byRes", BYTE * 8), #  保留字节
    ]


LPNET_DVR_ATM_PACKAGE_TIME = POINTER(NET_DVR_ATM_PACKAGE_TIME)


#  ATM 其他报文信息（卡号，交易金额，交易序号）
class NET_DVR_ATM_PACKAGE_OTHERS(Structure):
    _fields_ = [
        ("struPackageLocation", NET_DVR_PACKAGE_LOCATION), # 报文位置信息
        ("struPackageLength", NET_DVR_PACKAGE_LENGTH), # 长度信息
        ("struOsdPosition", NET_DVR_OSD_POSITION), #  OSD叠加位置信息
        ("struPreCode", NET_DVR_FRAMETYPECODE), # 叠加字符前的字符
        ("res", BYTE * 8), # 保留字节
    ]


LPNET_DVR_ATM_PACKAGE_OTHERS = POINTER(NET_DVR_ATM_PACKAGE_OTHERS)


# 用户自定义协议
class NET_DVR_ATM_USER_DEFINE_PROTOCOL(Structure):
    _fields_ = [
        ("struIdentification", NET_DVR_IDENTIFICAT), # 报文标志
        ("struFilter", NET_DVR_FILTER), # 数据包过滤设置
        ("struCardNoPara", NET_DVR_ATM_PACKAGE_OTHERS), # 叠加卡号设置
        ("struTradeActionPara", NET_DVR_ATM_PACKAGE_ACTION * MAX_ACTION_TYPE), # 叠加交易行为设置 0-9 依次对应InCard OutCard OverLay SetTime GetStatus Query WithDraw Deposit ChanPass Transfer
        ("struAmountPara", NET_DVR_ATM_PACKAGE_OTHERS), # 叠加交易金额设置
        ("struSerialNoPara", NET_DVR_ATM_PACKAGE_OTHERS), # 叠加交易序号设置
        ("struOverlayChan", NET_DVR_OVERLAY_CHANNEL), # 叠加通道设置
        ("struRes1", NET_DVR_ATM_PACKAGE_DATE), # 叠加日期，保留
        ("struRes2", NET_DVR_ATM_PACKAGE_TIME), # 叠加时间，保留
        ("byRes3", BYTE * 124), # 保留
    ]


LPNET_DVR_ATM_USER_DEFINE_PROTOCOL = POINTER(NET_DVR_ATM_USER_DEFINE_PROTOCOL)


class NET_DVR_ATM_FRAMEFORMAT_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byEnable", BYTE), # 是否启用0,不启用1,启用
        ("byInputMode", BYTE), # *输入方式:0-网络监听、1网络协议、2-串口监听、3-串口协议
        ("byRes1", BYTE * 34), # 保留字节
        ("struAtmIp", NET_DVR_IPADDR), # ATM 机IP 网络监听时使用
        ("wAtmPort", WORD), #  网络协议方式时是使用
        ("byRes2", BYTE * 2), #  保留字节
        ("dwAtmType", DWORD), # ATM协议类型，从NET_DVR_ATM_PROTOCOL结构中获取，如果类型为自定义时使用用户自定义协议
        ("struAtmUserDefineProtocol", NET_DVR_ATM_USER_DEFINE_PROTOCOL), # 用户自定义协议，当ATM类型为自定时需要使用该定义
        ("byRes3", BYTE * 8),
    ]


LPNET_DVR_ATM_FRAMEFORMAT_V30 = POINTER(NET_DVR_ATM_FRAMEFORMAT_V30)

ATM_PROTO_NCR = 0 # NCR
ATM_PROTO_DIEBOLD = 1 # DIEBOLD
ATM_PROTO_WINCOR_NIXDORF = 2 # WINCOR - NIXDORF
ATM_PROTO_SIEMENS = 4 # SIEMENS
ATM_PROTO_OLIVETTI = 5 # OLIVETTI
ATM_PROTO_FUJITSU = 6 # FUJITSU
ATM_PROTO_HITACHI = 7 # HITACHI
ATM_PROTO_SMI = 8 # SMI
ATM_PROTO_BULL = 9 # BULL
ATM_PROTO_YIHUA = 10 # 怡化
ATM_PROTO_LIDE = 11 # 立德
ATM_PROTO_GDYT = 12 # 广电运通
ATM_PROTO_MINI_BANL = 13 # Mini - Banl
ATM_PROTO_GUANGLI = 14 # 广利
ATM_PROTO_DONGXIN = 15 # 东信
ATM_PROTO_CHENTONG = 16 # 辰通
ATM_PROTO_NANTIAN = 17 # 南天
ATM_PROTO_XIAOXING = 18 # 晓星
ATM_PROTO_GZYY = 19 # 广州御银
ATM_PROTO_QHTLT = 20 # 青湖泰利特
ATM_PROTO_DRS918 = 21 # DRS918
ATM_PROTO_KALATEL = 22 # KALATEL
ATM_PROTO_NCR_2 = 23 # NCR_2
ATM_PROTO_NXS = 24 # NXS
ATM_PROTO_ICBC = 25 # 工商银行
ATM_PROTO_PSBC = 26 # 中国邮政储蓄银行
ATM_PROTO_CUSTOM = 1025 # 自定义

class NET_DVR_ATM_PROTO_TYPE(Structure):
    _fields_ = [
        ("dwAtmType", DWORD), # ATM协议类型，同时作为索引序号 ATM 配置中的dwAtmType 自定义时为1025
        ("chDesc", CHAR * ATM_DESC_LEN), # ATM协议简单描述
    ]


LPNET_DVR_ATM_PROTO_TYPE = POINTER(NET_DVR_ATM_PROTO_TYPE)


class NET_DVR_ATM_PROTO_LIST(Structure):
    _fields_ = [
        ("dwAtmProtoNum", DWORD), #  协议列表的个数
        ("struAtmProtoType", NET_DVR_ATM_PROTO_TYPE * MAX_ATM_PROTOCOL_NUM), # 协议列表信息
    ]


LPNET_DVR_ATM_PROTO_LIST = POINTER(NET_DVR_ATM_PROTO_LIST)


class NET_DVR_ATM_PROTOCOL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNetListenList", NET_DVR_ATM_PROTO_LIST), #  网络监听协议描述
        ("struSerialListenList", NET_DVR_ATM_PROTO_LIST), # 串口监听协议描述
        ("struNetProtoList", NET_DVR_ATM_PROTO_LIST), # 网络协议描述
        ("struSerialProtoList", NET_DVR_ATM_PROTO_LIST), # 串口协议描述
        ("struCustomProto", NET_DVR_ATM_PROTO_TYPE), # 自定义协议
    ]


LPNET_DVR_ATM_PROTOCOL = POINTER(NET_DVR_ATM_PROTOCOL)


#  SDK_V31
# DS-6001D Decoder
class NET_DVR_DECODERINFO(Structure):
    _fields_ = [
        ("byEncoderIP", BYTE * 16), # 解码设备连接的服务器IP
        ("byEncoderUser", BYTE * 16), # 解码设备连接的服务器的用户名
        ("byEncoderPasswd", BYTE * 16), # 解码设备连接的服务器的密码
        ("bySendMode", BYTE), # 解码设备连接服务器的连接模式
        ("byEncoderChannel", BYTE), # 解码设备连接的服务器的通道号
        ("wEncoderPort", WORD), # 解码设备连接的服务器的端口号
        ("reservedData", BYTE * 4), # 保留
    ]


LPNET_DVR_DECODERINFO = POINTER(NET_DVR_DECODERINFO)


class NET_DVR_DECODERSTATE(Structure):
    _fields_ = [
        ("byEncoderIP", BYTE * 16), # 解码设备连接的服务器IP
        ("byEncoderUser", BYTE * 16), # 解码设备连接的服务器的用户名
        ("byEncoderPasswd", BYTE * 16), # 解码设备连接的服务器的密码
        ("byEncoderChannel", BYTE), # 解码设备连接的服务器的通道号
        ("bySendMode", BYTE), # 解码设备连接的服务器的连接模式
        ("wEncoderPort", WORD), # 解码设备连接的服务器的端口号
        ("dwConnectState", DWORD), # 解码设备连接服务器的状态
        ("reservedData", BYTE * 4), # 保留
    ]


LPNET_DVR_DECODERSTATE = POINTER(NET_DVR_DECODERSTATE)


# 解码设备控制码定义
NET_DEC_STARTDEC = 1
NET_DEC_STOPDEC = 2
NET_DEC_STOPCYCLE = 3
NET_DEC_CONTINUECYCLE = 4
# 连接的通道配置
class NET_DVR_DECCHANINFO(Structure):
    _fields_ = [
        ("sDVRIP", CHAR * 16), #  DVR IP地址
        ("wDVRPort", WORD), #  端口号
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("byChannel", BYTE), #  通道号
        ("byLinkMode", BYTE), #  连接模式
        ("byLinkType", BYTE), #  连接类型 0－主码流 1－子码流
    ]


LPNET_DVR_DECCHANINFO = POINTER(NET_DVR_DECCHANINFO)


# 每个解码通道的配置
class NET_DVR_DECINFO(Structure):
    _fields_ = [
        ("byPoolChans", BYTE), # 每路解码通道上的循环通道数量, 最多4通道 0表示没有解码
        ("struchanConInfo", NET_DVR_DECCHANINFO * MAX_DECPOOLNUM),
        ("byEnablePoll", BYTE), # 是否轮巡 0-否 1-是
        ("byPoolTime", BYTE), # 轮巡时间 0-保留 1-10秒 2-15秒 3-20秒 4-30秒 5-45秒 6-1分钟 7-2分钟 8-5分钟
    ]


LPNET_DVR_DECINFO = POINTER(NET_DVR_DECINFO)


# 整个设备解码配置
class NET_DVR_DECCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDecChanNum", DWORD), # 解码通道的数量
        ("struDecInfo", NET_DVR_DECINFO * MAX_DECNUM),
    ]


LPNET_DVR_DECCFG = POINTER(NET_DVR_DECCFG)


# 2005-08-01
#  解码设备透明通道设置
class NET_DVR_PORTINFO(Structure):
    _fields_ = [
        ("dwEnableTransPort", DWORD), #  是否启动透明通道 0－不启用 1－启用
        ("sDecoderIP", CHAR * 16), #  DVR IP地址
        ("wDecoderPort", WORD), #  端口号
        ("wDVRTransPort", WORD), #  配置前端DVR是从485/232输出，1表示232串口,2表示485串口
        ("cReserve", CHAR * 4),
    ]


LPNET_DVR_PORTINFO = POINTER(NET_DVR_PORTINFO)


class NET_DVR_PORTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTransPortInfo", NET_DVR_PORTINFO * MAX_TRANSPARENTNUM), #  数组0表示232 数组1表示485
    ]


LPNET_DVR_PORTCFG = POINTER(NET_DVR_PORTCFG)


# 单字符参数(子结构)
class NET_DVR_SHOWSTRINGINFO(Structure):
    _fields_ = [
        ("wShowString", WORD), #  预览的图象上是否显示字符,0-不显示,1-显示 整个预览画面大小704*576,单个字符的大小为32*32
        ("wStringSize", WORD), #  该行字符的长度，不能大于44个字符
        ("wShowStringTopLeftX", WORD), #  字符显示位置的x坐标
        ("wShowStringTopLeftY", WORD), #  字符名称显示位置的y坐标
        ("sString", CHAR * 44), #  要显示的字符内容
    ]


LPNET_DVR_SHOWSTRINGINFO = POINTER(NET_DVR_SHOWSTRINGINFO)


# 叠加字符(9000扩展)
class NET_DVR_SHOWSTRING_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStringInfo", NET_DVR_SHOWSTRINGINFO * MAX_STRINGNUM_V30), #  要显示的字符内容
    ]


LPNET_DVR_SHOWSTRING_V30 = POINTER(NET_DVR_SHOWSTRING_V30)


# 叠加字符扩展(8条字符)
class NET_DVR_SHOWSTRING_EX(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStringInfo", NET_DVR_SHOWSTRINGINFO * MAX_STRINGNUM_EX), #  要显示的字符内容
    ]


LPNET_DVR_SHOWSTRING_EX = POINTER(NET_DVR_SHOWSTRING_EX)


# 叠加字符
class NET_DVR_SHOWSTRING(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStringInfo", NET_DVR_SHOWSTRINGINFO * MAX_STRINGNUM), #  要显示的字符内容
    ]


LPNET_DVR_SHOWSTRING = POINTER(NET_DVR_SHOWSTRING)


# DS9000新增结构
# DVR实现巡航数据结构
class NET_DVR_CRUISE_PARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPresetNo", BYTE * CRUISE_MAX_PRESET_NUMS), #  预置点号
        ("byCruiseSpeed", BYTE * CRUISE_MAX_PRESET_NUMS), #  巡航速度
        ("wDwellTime", WORD * CRUISE_MAX_PRESET_NUMS), #  停留时间
        ("byEnableThisCruise", BYTE), #  是否启用
        ("res", BYTE * 15),
    ]


LPNET_DVR_CRUISE_PARA = POINTER(NET_DVR_CRUISE_PARA)


# 时间点
class NET_DVR_TIMEPOINT(Structure):
    _fields_ = [
        ("dwMonth", DWORD), # 月 0-11表示1-12个月
        ("dwWeekNo", DWORD), # 第几周 0－第1周 1－第2周 2－第3周 3－第4周 4－最后一周
        ("dwWeekDate", DWORD), # 星期几 0－星期日 1－星期一 2－星期二 3－星期三 4－星期四 5－星期五 6－星期六
        ("dwHour", DWORD), # 小时    开始时间0－23 结束时间1－23
        ("dwMin", DWORD), # 分    0－59
    ]


# 夏令时参数
class NET_DVR_ZONEANDDST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwZoneIndex", DWORD), # 应用层软件使用NET_DVR_NTPPARA 中的cTimeDifferenceH 或cTimeDifferenceM 来设置时区，此处用获取的值填充，不对用户提供输入编辑框
        ("byRes1", BYTE * 12), # 保留
        ("dwEnableDST", DWORD), # 是否启用夏时制 0－不启用 1－启用
        ("byDSTBias", BYTE), # 夏令时偏移值，30min, 60min, 90min, 120min, 以分钟计，传递原始数值
        ("byRes2", BYTE * 3),
        ("struBeginPoint", NET_DVR_TIMEPOINT), # 夏时制开始时间
        ("struEndPoint", NET_DVR_TIMEPOINT), # 夏时制停止时间
    ]


LPNET_DVR_ZONEANDDST = POINTER(NET_DVR_ZONEANDDST)


# 图片质量
class NET_DVR_JPEGPARA(Structure):
    _fields_ = [
        # 注意：当图像压缩分辨率为VGA时，支持0=CIF, 1=QCIF, 2=D1抓图，
        # 当分辨率为3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p
        # 仅支持当前分辨率的抓图
        #
        # 可以通过能力集获取
        # 0-CIF，           1-QCIF，           2-D1，         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)，
        # 6-VGA，           7-XVGA，           8-HD900p，     9-HD1080，     10-2560*1920，
        # 11-1600*304，     12-2048*1536，     13-2448*2048,  14-2448*1200， 15-2448*800，
        # 16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576，
        # 21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
        # 26-1280*1280,     27-1600*600,       28-2048*768,   29-160*120,    55-3072*2048,
        # 64-3840*2160,     70-2560*1440,      75-336*256,
        # 78-384*256,         79-384*216,        80-320*256,    82-320*192,    83-512*384,
        # 127-480*272,      128-512*272,       161-288*320,   162-144*176,   163-480*640,
        # 164-240*320,      165-120*160,       166-576*720,   167-720*1280,  168-576*960,
        # 180-180*240,      181-360*480,       182-540*720,    183-720*960,  184-960*1280,
        # 185-1080*1440,      215-1080*720(占位，未测试),  216-360x640(占位，未测试),245-576*704(占位，未测试)
        # 500-384*288,
        # 0xff-Auto(使用当前码流分辨率)
        #
        ("wPicSize", WORD),
        ("wPicQuality", WORD), #  图片质量系数 0-最好 1-较好 2-一般
    ]


LPNET_DVR_JPEGPARA = POINTER(NET_DVR_JPEGPARA)


# 区域框结构
class NET_VCA_RECT(Structure):
    _fields_ = [
        ("fX", DOUBLE), # 边界框左上角点的X轴坐标, 0.000~1
        ("fY", DOUBLE), # 边界框左上角点的Y轴坐标, 0.000~1
        ("fWidth", DOUBLE), # 边界框的宽度, 0.000~1
        ("fHeight", DOUBLE), # 边界框的高度, 0.000~1
    ]


LPNET_VCA_RECT = POINTER(NET_VCA_RECT)


class NET_DVR_JPEGPICTURE_WITH_APPENDDATA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("dwJpegPicLen", DWORD), # Jpeg图片长度
        ("*pJpegPicBuff", CHAR), # Jpeg图片指针
        ("dwJpegPicWidth", DWORD), #  图像宽度
        ("dwJpegPicHeight", DWORD), # 图像高度
        ("dwP2PDataLen", DWORD), # 全屏测温数据长度
        ("*pP2PDataBuff", CHAR), # 全屏测温数据指针
        ("byIsFreezedata", BYTE), # 是否数据冻结 0-否 1-是
        ("byRes1", BYTE * 3),
        ("dwVisiblePicLen", DWORD), # 可见光图片长度
        # #if (defined(OS_WINDOWS64) || defined(OS_POSIX64))win64及linux64下指针为8字节
        ("*pVisiblePicBuff", CHAR), # 可见光图片指针
        # #else
        ("*pVisiblePicBuff", CHAR), # 可见光图片指针
        ("byRes2", BYTE * 4),
        # #endif
        ("struThermalValidRect", NET_VCA_RECT), # 热成像有效区域
        ("struVisibleValidRect", NET_VCA_RECT), # 可见光有效区域
        ("byRes", BYTE * 208),
    ]


LPNET_DVR_JPEGPICTURE_WITH_APPENDDATA = POINTER(NET_DVR_JPEGPICTURE_WITH_APPENDDATA)


# 抓图参数
class NET_DVR_PICPARAM_V50(Structure):
    _fields_ = [
        ("struParam", NET_DVR_JPEGPARA),
        ("byPicFormat", BYTE), #  设备抓图图片格式 0-Jpeg
        ("byCapturePicType", BYTE), #  设备抓图类型 0-设备通用抓图，1-鹰眼标定图片（FPJA重启刷新获取图片 最长超时3min）,2-从Flash中获取已存在鹰眼标定图片,3-获取鱼眼相机圆形图片
        ("bySceneID", BYTE), # 0-不支持，1-场景1，2-场景2 ……
        ("byRes", BYTE * 253),
    ]


LPNET_DVR_PICPARAM_V50 = POINTER(NET_DVR_PICPARAM_V50)


#  aux video out parameter
# 辅助输出参数配置
class NET_DVR_AUXOUTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwAlarmOutChan", DWORD), #  选择报警弹出大报警通道切换时间：1画面的输出通道: 0:主输出/1:辅1/2:辅2/3:辅3/4:辅4
        ("dwAlarmChanSwitchTime", DWORD), #  :1秒 - 10:10秒
        ("dwAuxSwitchTime", DWORD * MAX_AUXOUT), #  辅助输出切换时间: 0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
        ("byAuxOrder", BYTE * MAX_AUXOUT), #  辅助输出预览顺序, 0xff表示相应的窗口不预览
    ]


LPNET_DVR_AUXOUTCFG = POINTER(NET_DVR_AUXOUTCFG)


# ntp
class NET_DVR_NTPPARA(Structure):
    _fields_ = [
        ("sNTPServer", BYTE * 64), #  Domain Name or IP addr of NTP server
        ("wInterval", WORD), #  adjust time interval(hours)
        ("byEnableNTP", BYTE), #  enable NPT client 0-no，1-yes
        ("cTimeDifferenceH", CHAR), #  与国际标准时间的 小时偏移-12 ... +13
        ("cTimeDifferenceM", CHAR), #  与国际标准时间的 分钟偏移0, 30, 45
        ("res1", BYTE),
        ("wNtpPort", WORD), #  ntp server port 9000新增 设备默认为123
        ("res2", BYTE * 8),
    ]


LPNET_DVR_NTPPARA = POINTER(NET_DVR_NTPPARA)


# ddns
class NET_DVR_DDNSPARA(Structure):
    _fields_ = [
        ("sUsername", BYTE * NAME_LEN), #  DDNS账号用户名/密码
        ("sPassword", BYTE * PASSWD_LEN),
        ("sDomainName", BYTE * 64), #  域名
        ("byEnableDDNS", BYTE), # 是否应用 0-否，1-是
        ("res", BYTE * 15),
    ]


LPNET_DVR_DDNSPARA = POINTER(NET_DVR_DDNSPARA)


class NET_DVR_DDNSPARA_EX(Structure):
    _fields_ = [
        ("byHostIndex", BYTE), #  0-私有DDNS 1－Dyndns 2－PeanutHull(花生壳)
        ("byEnableDDNS", BYTE), # 是否应用DDNS 0-否，1-是
        ("wDDNSPort", WORD), #  DDNS端口号
        ("sUsername", BYTE * NAME_LEN), #  DDNS用户名
        ("sPassword", BYTE * PASSWD_LEN), #  DDNS密码
        ("sDomainName", BYTE * MAX_DOMAIN_NAME), #  设备配备的域名地址
        ("sServerName", BYTE * MAX_DOMAIN_NAME), #  DDNS 对应的服务器地址，可以是IP地址或域名
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_DDNSPARA_EX = POINTER(NET_DVR_DDNSPARA_EX)


# email
class NET_DVR_EMAILPARA(Structure):
    _fields_ = [
        ("sUsername", BYTE * 64), #  邮件账号/密码
        ("sPassword", BYTE * 64),
        ("sSmtpServer", BYTE * 64),
        ("sPop3Server", BYTE * 64),
        ("sMailAddr", BYTE * 64), #  email
        ("sEventMailAddr1", BYTE * 64), #  上传报警/异常等的email
        ("sEventMailAddr2", BYTE * 64),
        ("res", BYTE * 16),
    ]


LPNET_DVR_EMAILPARA = POINTER(NET_DVR_EMAILPARA)


# 网络参数配置
class NET_DVR_NETAPPCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sDNSIp", CHAR * 16), #  DNS服务器地址
        ("struNtpClientParam", NET_DVR_NTPPARA), #  NTP参数
        ("struDDNSClientParam", NET_DVR_DDNSPARA), #  DDNS参数
        ("res", BYTE * 464), #  保留
    ]


LPNET_DVR_NETAPPCFG = POINTER(NET_DVR_NETAPPCFG)


# nfs结构配置
class NET_DVR_SINGLE_NFS(Structure):
    _fields_ = [
        ("sNfsHostIPAddr", CHAR * 16),
        ("sNfsDirectory", BYTE * PATHNAME_LEN), #  PATHNAME_LEN = 128
    ]


LPNET_DVR_SINGLE_NFS = POINTER(NET_DVR_SINGLE_NFS)


class NET_DVR_NFSCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNfsDiskParam", NET_DVR_SINGLE_NFS * MAX_NFS_DISK),
    ]


LPNET_DVR_NFSCFG = POINTER(NET_DVR_NFSCFG)


class NET_DVR_ISCSI_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("wVrmPort", WORD), #  VRM 监听端口
        ("byEnable", BYTE), #  是否启用 ISCSI存储
        ("byRes", BYTE * 69), #  保留字节
        ("struVrmAddr", NET_DVR_IPADDR), #  VRM ip地址 16位
        ("chNvtIndexCode", CHAR * 64), # nvt index Code
    ]


LPNET_DVR_ISCSI_CFG = POINTER(NET_DVR_ISCSI_CFG)


# 巡航点配置(私有IP快球专用)
class NET_DVR_CRUISE_POINT(Structure):
    _fields_ = [
        ("PresetNum", BYTE), # 预置点
        ("Dwell", BYTE), # 停留时间
        ("Speed", BYTE), # 速度
        ("Reserve", BYTE), # 保留
    ]


LPNET_DVR_CRUISE_POINT = POINTER(NET_DVR_CRUISE_POINT)


class NET_DVR_CRUISE_RET(Structure):
    _fields_ = [
        ("struCruisePoint", NET_DVR_CRUISE_POINT * 32), # 最大支持32个巡航点
    ]


LPNET_DVR_CRUISE_RET = POINTER(NET_DVR_CRUISE_RET)


# 多路解码器
class NET_DVR_NETCFG_OTHER(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sFirstDNSIP", CHAR * 16),
        ("sSecondDNSIP", CHAR * 16),
        ("sRes", CHAR * 32),
    ]


LPNET_DVR_NETCFG_OTHER = POINTER(NET_DVR_NETCFG_OTHER)


class NET_DVR_MATRIX_DECINFO(Structure):
    _fields_ = [
        ("sDVRIP", CHAR * 16), #  DVR IP地址
        ("wDVRPort", WORD), #  端口号
        ("byChannel", BYTE), #  通道号
        ("byTransProtocol", BYTE), #  传输协议类型 0-TCP, 1-UDP
        ("byTransMode", BYTE), #  传输码流模式 0－主码流 1－子码流
        ("byRes", BYTE * 3),
        ("sUserName", BYTE * NAME_LEN), #  监控主机登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), #  监控主机密码
    ]


LPNET_DVR_MATRIX_DECINFO = POINTER(NET_DVR_MATRIX_DECINFO)


# 启动/停止动态解码
class NET_DVR_MATRIX_DYNAMIC_DEC(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDecChanInfo", NET_DVR_MATRIX_DECINFO), #  动态解码通道信息
    ]


LPNET_DVR_MATRIX_DYNAMIC_DEC = POINTER(NET_DVR_MATRIX_DYNAMIC_DEC)


class NET_DVR_MATRIX_DEC_CHAN_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwIsLinked", DWORD), #  解码通道状态 0－休眠 1－正在连接 2－已连接 3-正在解码
        ("dwStreamCpRate", DWORD), #  Stream copy rate, X kbits/second
        ("cRes", CHAR * 64), #  保留
    ]


LPNET_DVR_MATRIX_DEC_CHAN_STATUS = POINTER(NET_DVR_MATRIX_DEC_CHAN_STATUS)


class NET_DVR_MATRIX_DEC_CHAN_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDecChanInfo", NET_DVR_MATRIX_DECINFO), #  解码通道信息
        ("dwDecState", DWORD), #  0-动态解码 1－循环解码 2－按时间回放 3－按文件回放
        ("StartTime", NET_DVR_TIME), #  按时间回放开始时间
        ("StopTime", NET_DVR_TIME), #  按时间回放停止时间
        ("sFileName", CHAR * 128), #  按文件回放文件名
    ]


LPNET_DVR_MATRIX_DEC_CHAN_INFO = POINTER(NET_DVR_MATRIX_DEC_CHAN_INFO)


# 连接的通道配置 2007-11-05
class NET_DVR_MATRIX_DECCHANINFO(Structure):
    _fields_ = [
        ("dwEnable", DWORD), #  是否启用 0－否 1－启用
        ("struDecChanInfo", NET_DVR_MATRIX_DECINFO), #  轮巡解码通道信息
    ]


LPNET_DVR_MATRIX_DECCHANINFO = POINTER(NET_DVR_MATRIX_DECCHANINFO)


# 2007-11-05 新增每个解码通道的配置
class NET_DVR_MATRIX_LOOP_DECINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPoolTime", DWORD), # 轮巡时间
        ("struchanConInfo", NET_DVR_MATRIX_DECCHANINFO * MAX_CYCLE_CHAN),
    ]


LPNET_DVR_MATRIX_LOOP_DECINFO = POINTER(NET_DVR_MATRIX_LOOP_DECINFO)


# 2007-12-22
class TTY_CONFIG(Structure):
    _fields_ = [
        ("baudrate", BYTE), #  波特率
        ("databits", BYTE), #  数据位
        ("stopbits", BYTE), #  停止位
        ("parity", BYTE), #  奇偶校验位
        ("flowcontrol", BYTE), #  流控
        ("res", BYTE * 3),
    ]


LPTTY_CONFIG = POINTER(TTY_CONFIG)


class NET_DVR_MATRIX_TRAN_CHAN_INFO(Structure):
    _fields_ = [
        ("byTranChanEnable", BYTE), #  当前透明通道是否打开 0：关闭 1：打开
        #
        # *    多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
        # *    0 RS485
        # *    1 RS232 Console
        #
        ("byLocalSerialDevice", BYTE), #  Local serial device
        #
        # *    远程串口输出还是两个,一个RS232，一个RS485
        # *    1表示232串口
        # *    2表示485串口
        #
        ("byRemoteSerialDevice", BYTE), #  Remote output serial device
        ("res1", BYTE), #  保留
        ("sRemoteDevIP", CHAR * 16), #  Remote Device IP
        ("wRemoteDevPort", WORD), #  Remote Net Communication Port
        ("res2", BYTE * 2), #  保留
        ("RemoteSerialDevCfg", TTY_CONFIG),
    ]


LPNET_DVR_MATRIX_TRAN_CHAN_INFO = POINTER(NET_DVR_MATRIX_TRAN_CHAN_INFO)


class NET_DVR_MATRIX_TRAN_CHAN_CONFIG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("by232IsDualChan", BYTE), #  设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM
        ("by485IsDualChan", BYTE), #  设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM
        ("res", BYTE * 2), #  保留
        ("struTranInfo", NET_DVR_MATRIX_TRAN_CHAN_INFO * MAX_SERIAL_NUM), # 同时支持建立MAX_SERIAL_NUM个透明通道
    ]


LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG = POINTER(NET_DVR_MATRIX_TRAN_CHAN_CONFIG)


# 2007-12-24 Merry Christmas Eve...
class NET_DVR_MATRIX_DEC_REMOTE_PLAY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sDVRIP", CHAR * 16), #  DVR IP地址
        ("wDVRPort", WORD), #  端口号
        ("byChannel", BYTE), #  通道号
        ("byReserve", BYTE),
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("dwPlayMode", DWORD), #  0－按文件 1－按时间
        ("StartTime", NET_DVR_TIME),
        ("StopTime", NET_DVR_TIME),
        ("sFileName", CHAR * 128),
    ]


LPNET_DVR_MATRIX_DEC_REMOTE_PLAY = POINTER(NET_DVR_MATRIX_DEC_REMOTE_PLAY)


#  文件播放命令
NET_DVR_PLAYSTART = 1 # 开始播放
NET_DVR_PLAYSTOP = 2 # 停止播放
NET_DVR_PLAYPAUSE = 3 # 暂停播放
NET_DVR_PLAYRESTART = 4 # 恢复播放
NET_DVR_PLAYFAST = 5 # 快放
NET_DVR_PLAYSLOW = 6 # 慢放
NET_DVR_PLAYNORMAL = 7 # 正常速度
NET_DVR_PLAYSTARTAUDIO = 9 # 打开声音
NET_DVR_PLAYSTOPAUDIO = 10 # 关闭声音
NET_DVR_PLAYSETPOS = 12 # 改变文件回放的进度
NET_DVR_RESETBUFFER	 = 37 # 清空矩阵解码缓冲区（远程回放文件）
class NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPlayCmd", DWORD), #  播放命令 见文件播放命令
        ("dwCmdParam", DWORD), #  播放命令参数
    ]


LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL = POINTER(NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL)


class NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCurMediaFileLen", DWORD), #  当前播放的媒体文件长度
        ("dwCurMediaFilePosition", DWORD), #  当前播放文件的播放位置
        ("dwCurMediaFileDuration", DWORD), #  当前播放文件的总时间
        ("dwCurPlayTime", DWORD), #  当前已经播放的时间
        ("dwCurMediaFIleFrames", DWORD), #  当前播放文件的总帧数
        ("dwCurDataType", DWORD), #  当前传输的数据类型，19-文件头，20-流数据， 21-播放结束标志
        ("res", BYTE * 72),
    ]


LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS = POINTER(NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS)


# 2009-4-11 added by likui 多路解码器new
class NET_DVR_MATRIX_PASSIVEMODE(Structure):
    _fields_ = [
        ("wTransProtol", WORD), # 传输协议，0-TCP, 1-UDP, 2-MCAST
        ("wPassivePort", WORD), # UDP端口, TCP时默认
        ("struMcastIP", NET_DVR_IPADDR), # TCP,UDP时无效, MCAST时为多播地址
        ("byStreamType", BYTE), #  数据播放模式:REAL_TIME_STREAM(1)实时流,RECORD_STREAM(2)文件流
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_MATRIX_PASSIVEMODE = POINTER(NET_DVR_MATRIX_PASSIVEMODE)


class NET_DVR_MATRIX_TRAN_CHAN_INFO_V30(Structure):
    _fields_ = [
        ("byTranChanEnable", BYTE), #  当前透明通道是否打开 0：关闭 1：打开
        ("byLocalSerialDevice", BYTE), #  Local serial device
        #
        # *  多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
        # *  0 RS485
        # *  1 RS232 Console
        # *  2 Dual Scom
        #
        ("byRemoteSerialDevice", BYTE), #  Remote output serial device
        #
        # *  远程串口输出还是两个,一个RS232，一个RS485
        # *  1 表示232串口
        # *  2 表示485串口
        #
        ("byRes1", BYTE), #  保留
        ("struRemoteDevIP", NET_DVR_IPADDR), #  Remote Device IP
        ("wRemoteDevPort", WORD), #  Remote Net Communication Port
        ("byIsEstablished", BYTE), #  透明通道建立成功标志，0-没有成功，1-建立成功
        ("byRes2", BYTE), #  保留
        ("RemoteSerialDevCfg", TTY_CONFIG),
        ("byUsername", BYTE * NAME_LEN),
        ("byPassword", BYTE * PASSWD_LEN),
        ("dwLocalSerialNo", DWORD), #  本地串口
        ("dwRemoteSerialNo", DWORD), #  远程串口
        ("byRes3", BYTE * 8),
    ]


LPNET_DVR_MATRIX_TRAN_CHAN_INFO_V30 = POINTER(NET_DVR_MATRIX_TRAN_CHAN_INFO_V30)


class NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("by232IsDualChan", BYTE), #  设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM
        ("by485IsDualChan", BYTE), #  设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM
        ("byRes", BYTE * 2), #  保留
        ("struTranInfo", NET_DVR_MATRIX_TRAN_CHAN_INFO_V30 * MAX_SERIAL_NUM), # 同时支持建立MAX_SERIAL_NUM个透明通道
    ]


LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 = POINTER(NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30)


class NET_DVR_MATRIX_CHAN_INFO_V30(Structure):
    _fields_ = [
        ("dwEnable", DWORD), #  是否启用 0－否 1－启用
        ("streamMediaServerCfg", NET_DVR_STREAM_MEDIA_SERVER_CFG),
        ("struDevChanInfo", NET_DVR_DEV_CHAN_INFO), #  轮巡解码通道信息
    ]


LPNET_DVR_MATRIX_CHAN_INFO_V30 = POINTER(NET_DVR_MATRIX_CHAN_INFO_V30)


class NET_DVR_MATRIX_LOOP_DECINFO_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPoolTime", DWORD), # 轮巡间隔
        ("struchanConInfo", NET_DVR_MATRIX_CHAN_INFO_V30 * MAX_CYCLE_CHAN_V30),
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_MATRIX_LOOP_DECINFO_V30 = POINTER(NET_DVR_MATRIX_LOOP_DECINFO_V30)


class NET_DVR_MATRIX_DEC_CHAN_INFO_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("streamMediaServerCfg", NET_DVR_STREAM_MEDIA_SERVER_CFG), # 流媒体服务器配置
        ("struDevChanInfo", NET_DVR_DEV_CHAN_INFO), #  解码通道信息
        ("dwDecState", DWORD), #  0-动态解码 1－循环解码 2－按时间回放 3－按文件回放
        ("StartTime", NET_DVR_TIME), #  按时间回放开始时间
        ("StopTime", NET_DVR_TIME), #  按时间回放停止时间
        ("sFileName", CHAR * 128), #  按文件回放文件名
        ("dwGetStreamMode", DWORD), # 取流模式:1-主动，2-被动
        ("struPassiveMode", NET_DVR_MATRIX_PASSIVEMODE),
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30 = POINTER(NET_DVR_MATRIX_DEC_CHAN_INFO_V30)


MAX_RESOLUTIONNUM = 64 # 支持的最大分辨率数目
class NET_DVR_MATRIX_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDecNums", BYTE),
        ("byStartChan", BYTE),
        ("byVGANums", BYTE),
        ("byBNCNums", BYTE),
        ("byVGAWindowMode", BYTE * 8), # VGA支持的窗口模式，VGA1可能由混合输出
        ("byBNCWindowMode", BYTE * 4), # BNC支持的窗口模式
        ("byDspNums", BYTE),
        ("byHDMINums", BYTE), # HDMI显示通道个数（从25开始）
        ("byDVINums", BYTE), # DVI显示通道个数（从29开始）
        ("byRes1", BYTE * 13),
        ("bySupportResolution", BYTE * MAX_RESOLUTIONNUM), # 按照上面的枚举定义,一个字节代表一个分辨率是否支持，1：支持，0：不支持
        ("byHDMIWindowMode", BYTE * 4), # HDMI支持的窗口模式
        ("byDVIWindowMode", BYTE * 4), # DVI支持的窗口模式
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_MATRIX_ABILITY = POINTER(NET_DVR_MATRIX_ABILITY)


# 上传logo结构
class NET_DVR_DISP_LOGOCFG(Structure):
    _fields_ = [
        ("dwCorordinateX", DWORD), # 图片显示区域X坐标
        ("dwCorordinateY", DWORD), # 图片显示区域Y坐标
        ("wPicWidth", WORD), # 图片宽
        ("wPicHeight", WORD), # 图片高
        ("byRes1", BYTE * 4),
        ("byFlash", BYTE), # 是否闪烁1-闪烁，0-不闪烁
        ("byTranslucent", BYTE), # 是否半透明1-半透明，0-不半透明
        ("byRes2", BYTE * 6), # 保留
        ("dwLogoSize", DWORD), # LOGO大小，包括BMP的文件头
    ]


LPNET_DVR_DISP_LOGOCFG = POINTER(NET_DVR_DISP_LOGOCFG)


# 编码类型
NET_DVR_ENCODER_UNKOWN = 0 # 未知编码格式
NET_DVR_ENCODER_H264 = 1 # 私有 264
NET_DVR_ENCODER_S264 = 2 # Standard H264
NET_DVR_ENCODER_MPEG4 = 3 # MPEG4
NET_DVR_ORIGINALSTREAM = 4 # Original Stream
NET_DVR_PICTURE = 5 # Picture
NET_DVR_ENCODER_MJPEG = 6
NET_DVR_ENCODER_MPEG2 = 7
NET_DVR_ENCODER_H265 = 8
NET_DVR_ENCODER_SVAC = 9
NET_DVR_ENCODER_SMART264 = 10 # Smart 264
NET_DVR_ENCODER_SMART265 = 11 # Smart 265
#  打包格式
NET_DVR_STREAM_TYPE_UNKOWN = 0 # 未知打包格式
NET_DVR_STREAM_TYPE_PRIVT = 1 # 私有格式
NET_DVR_STREAM_TYPE_TS = 7 #  TS打包
NET_DVR_STREAM_TYPE_PS = 8 #  PS打包
NET_DVR_STREAM_TYPE_RTP = 9 #  RTP打包
NET_DVR_STREAM_TYPE_ORIGIN = 10 # 未打包(视频综合平台解码子系统用)
# 解码通道状态
class NET_DVR_MATRIX_CHAN_STATUS(Structure):
    _fields_ = [
        ("byDecodeStatus", BYTE), # 当前状态:0:未启动，1：启动解码
        ("byStreamType", BYTE), # 码流类型
        ("byPacketType", BYTE), # 打包方式
        ("byRecvBufUsage", BYTE), # 接收缓冲使用率
        ("byDecBufUsage", BYTE), # 解码缓冲使用率
        ("byFpsDecV", BYTE), # 视频解码帧率
        ("byFpsDecA", BYTE), # 音频解码帧率
        ("byCpuLoad", BYTE), # DSP CPU使用率
        ("byRes1", BYTE * 4),
        ("dwDecodedV", DWORD), # 解码的视频帧
        ("dwDecodedA", DWORD), # 解码的音频帧
        ("wImgW", WORD), # 解码器当前的图像大小,宽
        ("wImgH", WORD), # 高
        ("byVideoFormat", BYTE), # 视频制式:0-NON,NTSC--1,PAL--2
        ("byRes2", BYTE * 3),
        ("dwDecChan", DWORD), # 获取全部解码通道状态时有效，设置时可填0
        ("byRes3", BYTE * 20),
    ]


LPNET_DVR_MATRIX_CHAN_STATUS = POINTER(NET_DVR_MATRIX_CHAN_STATUS)


# 显示通道状态
NET_DVR_MAX_DISPREGION = 16 # 每个显示通道最多可以显示的窗口
# 分辨率
#
class VGA_MODE(Structure):
    _fields_ = [
        # VGA
        # VGA_NOT_AVALIABLE,
        # VGA_THS8200_MODE_SVGA_60HZ,    (800*600)
        # VGA_THS8200_MODE_SVGA_75HZ,    (800*600)
        # VGA_THS8200_MODE_XGA_60HZ,     (1024*768)
        # VGA_THS8200_MODE_XGA_75HZ,     (1024*768)
        # VGA_THS8200_MODE_SXGA_60HZ,    (1280*1024)
        # VGA_THS8200_MODE_720P_60HZ,    (1280*720)
        # VGA_THS8200_MODE_1080I_60HZ,   (1920*1080)
        # VGA_THS8200_MODE_1080P_30HZ,   (1920*1080)
        # VGA_THS8200_MODE_UXGA_30HZ,    (1600*1200)
        # HDMI
        # HDMI_SII9134_MODE_XGA_60HZ,       (1024*768)
        # HDMI_SII9134_MODE_SXGA_60HZ,   (1280*1024)
        # HDMI_SII9134_MODE_SXGA2_60HZ,  (1280*960)
        # HDMI_SII9134_MODE_720P_60HZ,   (1280*720)
        # HDMI_SII9134_MODE_720P_50HZ,   (1280*720)
        # HDMI_SII9134_MODE_1080I_60HZ,  (1920*1080)
        # HDMI_SII9134_MODE_1080I_50HZ,  (1920*1080)
        # HDMI_SII9134_MODE_1080P_25HZ,  (1920*1080)
        # HDMI_SII9134_MODE_1080P_30HZ,  (1920*1080)
        # HDMI_SII9134_MODE_1080P_50HZ,  (1920*1080)
        # HDMI_SII9134_MODE_1080P_60HZ,  (1920*1080)
        # HDMI_SII9134_MODE_UXGA_60HZ,   (1600*1200)
        # DVI
        # DVI_SII9134_MODE_XGA_60HZ,       (1024*768)
        # DVI_SII9134_MODE_SXGA_60HZ,       (1280*1024)
        # DVI_SII9134_MODE_SXGA2_60HZ,   (1280*960)
        # DVI_SII9134_MODE_720P_60HZ,       (1280*720)
        # DVI_SII9134_MODE_720P_50HZ,    (1280*720)
        # DVI_SII9134_MODE_1080I_60HZ,   (1920*1080)
        # DVI_SII9134_MODE_1080I_50HZ,   (1920*1080)
        # DVI_SII9134_MODE_1080P_25HZ,   (1920*1080)
        # DVI_SII9134_MODE_1080P_30HZ,   (1920*1080)
        # DVI_SII9134_MODE_1080P_50HZ,   (1920*1080)
        # DVI_SII9134_MODE_1080P_60HZ,   (1920*1080)
        # DVI_SII9134_MODE_UXGA_60HZ,     (1600*1200)
        # VGA_DECSVR_MODE_SXGA2_60HZ,
        # HDMI_DECSVR_MODE_1080P_24HZ,
        # DVI_DECSVR_MODE_1080P_24HZ,
        # YPbPr_DECSVR_MODE_720P_60HZ,
        # YPbPr_DECSVR_MODE_1080I_60HZ
    ]


# 低帧率定义
LOW_DEC_FPS_1_2 = 51
LOW_DEC_FPS_1_4 = 52
LOW_DEC_FPS_1_8 = 53
LOW_DEC_FPS_1_16 = 54
# 视频制式标准
class VIDEO_STANDARD(Structure):
    _fields_ = [
        # VS_NON = 0,
        # VS_NTSC = 1,
        # VS_PAL = 2
    ]


# 显示通道状态
NET_DVR_MAX_DISPREGION = 16 # 每个显示通道最多可以显示的窗口
class NET_DVR_DISP_CHAN_STATUS(Structure):
    _fields_ = [
        ("byDispStatus", BYTE), # 显示状态：0：未显示，1：启动显示
        ("byBVGA", BYTE), # 0-BNC，1-VGA， 2-HDMI，3-DVI
        ("byVideoFormat", BYTE), # 视频制式:1:NTSC,2:PAL,0-NON
        ("byWindowMode", BYTE), # 当前画面模式
        ("byJoinDecChan", BYTE * MAX_WINDOWS), # 各个子窗口关联的解码通道
        ("byFpsDisp", BYTE * NET_DVR_MAX_DISPREGION), # 每个子画面的显示帧率
        ("byScreenMode", BYTE), # 屏幕模式0-普通 1-大屏
        ("byRes2", BYTE * 31),
    ]


LPNET_DVR_DISP_CHAN_STATUS = POINTER(NET_DVR_DISP_CHAN_STATUS)


MAX_DECODECHANNUM = 32 # 多路解码器最大解码通道数
MAX_DISPCHANNUM = 24 # 多路解码器最大显示通道数
# 解码器设备状态
class NET_DVR_DECODER_WORK_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDecChanStatus", NET_DVR_MATRIX_CHAN_STATUS * MAX_DECODECHANNUM), # 解码通道状态
        ("struDispChanStatus", NET_DVR_DISP_CHAN_STATUS * MAX_DISPCHANNUM), # 显示通道状态
        ("byAlarmInStatus", BYTE * MAX_ANALOG_ALARMIN), # 报警输入状态
        ("byAlarmOutStatus", BYTE * MAX_ANALOG_ALARMOUT), # 报警输出状态
        ("byAudioInChanStatus", BYTE), # 语音对讲状态
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_DECODER_WORK_STATUS = POINTER(NET_DVR_DECODER_WORK_STATUS)


# 2009-12-1 增加被动解码播放控制
class NET_DVR_PASSIVEDECODE_CONTROL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPlayCmd", DWORD), #  播放命令 见文件播放命令
        ("dwCmdParam", DWORD), #  播放命令参数
        ("byRes", BYTE * 16), # Reverse
    ]


LPNET_DVR_PASSIVEDECODE_CONTROL = POINTER(NET_DVR_PASSIVEDECODE_CONTROL)


PASSIVE_DEC_PAUSE = 1 # 被动解码暂停(仅文件流有效)
PASSIVE_DEC_RESUME = 2 # 恢复被动解码(仅文件流有效)
PASSIVE_DEC_FAST = 3 # 快速被动解码(仅文件流有效)
PASSIVE_DEC_SLOW = 4 # 慢速被动解码(仅文件流有效)
PASSIVE_DEC_NORMAL = 5 # 正常被动解码(仅文件流有效)
PASSIVE_DEC_ONEBYONE = 6 # 被动解码单帧播放(保留)
PASSIVE_DEC_AUDIO_ON = 7 # 音频开启
PASSIVE_DEC_AUDIO_OFF = 8 # 音频关闭
PASSIVE_DEC_RESETBUFFER = 9 # 清空缓冲区
# 2009-12-16 增加控制解码器解码通道缩放
class NET_DVR_MATRIX_DECCHAN_CONTROL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDecChanScaleStatus", BYTE), # 解码通道显示缩放控制,1表示缩放显示，0表示真实显示
        ("byDecodeDelay", BYTE), # 解码延时，0-默认，1-实时性好，2-实时性较好，3-实时性中，流畅性中，4-流畅性较好，5-流畅性好，0xff-自动调整
        ("byEnableSpartan", BYTE), # 畅显使能，0-关，1-开
        ("byLowLight", BYTE), # 低照度。0-关，1-8代表低照度等级，等级越高强度越大
        ("byNoiseReduction", BYTE), # 3D降噪，0-关，1-开，2-自动
        ("byDefog", BYTE), # 透雾，0-关，1-7代表透雾等级，等级越高强度越大
        ("byEnableVcaDec", BYTE), # 是否启用智能解码，0-不启用，非0-启用
        ("byEnableAudio", BYTE), # 是否开启音频，0-无效，1-开启，2-关闭
        ("dwAllCtrlType", DWORD), # 所有子窗口一起操作的类型，设置时有效，按位表示
        # dwAllCtrlType & 0x01,开启关闭智能解码
        ("byVolume", BYTE), # volume,[0-100]
        ("byRes", BYTE * 55),
    ]


LPNET_DVR_MATRIX_DECCHAN_CONTROL = POINTER(NET_DVR_MATRIX_DECCHAN_CONTROL)


# 2009-8-19 视频综合平台接口函数
# 视频综合平台
MAX_SUBSYSTEM_NUM = 80 # 一个矩阵系统中最多子系统数量
MAX_SERIALLEN = 36 # 最大序列号长度
MAX_LOOPPLANNUM = 16 # 最大计划切换组
DECODE_TIMESEGMENT = 4 # 计划解码每天时间段数
class NET_DVR_SUBSYSTEMINFO(Structure):
    _fields_ = [
        ("bySubSystemType", BYTE), # 子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，0-NULL（此参数只能获取）
        ("byChan", BYTE), # 子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
        ("byLoginType", BYTE), # 注册类型，1-直连，2-DNS，3-花生壳
        ("byRes1", BYTE * 5),
        ("struSubSystemIP", NET_DVR_IPADDR), # IP地址（可修改）
        ("wSubSystemPort", WORD), # 子系统端口号（可修改）
        ("byRes2", BYTE * 6),
        ("struSubSystemIPMask", NET_DVR_IPADDR), # 子网掩码
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关地址
        ("sUserName", BYTE * NAME_LEN), #  用户名 （此参数只能获取）
        ("sPassword", BYTE * PASSWD_LEN), # 密码（此参数只能获取）
        ("sDomainName", CHAR * MAX_DOMAIN_NAME), # 域名(可修改)
        ("sDnsAddress", CHAR * MAX_DOMAIN_NAME), # DNS域名或IP地址
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号（此参数只能获取）
    ]


LPNET_DVR_SUBSYSTEMINFO = POINTER(NET_DVR_SUBSYSTEMINFO)


class NET_DVR_ALLSUBSYSTEMINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSubSystemInfo", NET_DVR_SUBSYSTEMINFO * MAX_SUBSYSTEM_NUM),
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_ALLSUBSYSTEMINFO = POINTER(NET_DVR_ALLSUBSYSTEMINFO)


class NET_DVR_LOOPPLAN_SUBCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPoolTime", DWORD), # 轮巡间隔，单位：秒
        ("struChanConInfo", NET_DVR_MATRIX_CHAN_INFO_V30 * MAX_CYCLE_CHAN_V30),
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_LOOPPLAN_SUBCFG = POINTER(NET_DVR_LOOPPLAN_SUBCFG)


class NET_DVR_ALARMMODECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAlarmMode", BYTE), # 报警触发类型，1-轮巡，2-保持
        ("wLoopTime", WORD), # 轮巡时间, 单位：秒
        ("byRes", BYTE * 9),
    ]


LPNET_DVR_ALARMMODECFG = POINTER(NET_DVR_ALARMMODECFG)


class NET_DVR_CODESPLITTERINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIP", NET_DVR_IPADDR), # 码分器IP地址
        ("wPort", WORD), # 码分器端口号
        ("byRes1", BYTE * 6),
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), # 密码
        ("byChan", BYTE), # 码分器485号
        ("by485Port", BYTE), # 485口地址
        ("byRes2", BYTE * 14),
    ]


LPNET_DVR_CODESPLITTERINFO = POINTER(NET_DVR_CODESPLITTERINFO)


class NET_DVR_ASSOCIATECFG(Structure):
    _fields_ = [
        ("byAssociateType", BYTE), # 关联类型，1-报警
        ("wAlarmDelay", WORD), # 报警延时，0－5秒；1－10秒；2－30秒；3－1分钟；4－2分钟；5－5分钟；6－10分钟；
        ("byAlarmNum", BYTE), # 报警号，具体的值由应用赋，相同的报警赋相同的值
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_ASSOCIATECFG = POINTER(NET_DVR_ASSOCIATECFG)


class NET_DVR_DYNAMICDECODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAssociateCfg", NET_DVR_ASSOCIATECFG), # 触发动态解码关联结构
        ("struPuStreamCfg", NET_DVR_PU_STREAM_CFG), # 动态解码结构
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_DYNAMICDECODE = POINTER(NET_DVR_DYNAMICDECODE)


class NET_DVR_DECODESCHED(Structure):
    _fields_ = [
        ("struSchedTime", NET_DVR_SCHEDTIME),
        ("byDecodeType", BYTE), # 0-无，1-轮巡解码，2-动态解码
        ("byLoopGroup", BYTE), # 轮巡组号
        ("byRes", BYTE * 6),
        ("struDynamicDec", NET_DVR_PU_STREAM_CFG), # 动态解码
    ]


LPNET_DVR_DECODESCHED = POINTER(NET_DVR_DECODESCHED)


class NET_DVR_PLANDECODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDecodeSched", NET_DVR_DECODESCHED * MAX_DAYS), # 周一作为开始，和9000一致
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_PLANDECODE = POINTER(NET_DVR_PLANDECODE)


class NET_DVR_EMAILCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sUserName", CHAR * 32),
        ("sPassWord", CHAR * 32),
        ("sFromName", CHAR * 32), #  Sender 字符串中的第一个字符和最后一个字符不能是"@",并且字符串中要有"@"字符
        ("sFromAddr", CHAR * 48), #  Sender address
        ("sToName1", CHAR * 32), #  Receiver1
        ("sToName2", CHAR * 32), #  Receiver2
        ("sToAddr1", CHAR * 48), #  Receiver address1
        ("sToAddr2", CHAR * 48), #  Receiver address2
        ("sEmailServer", CHAR * 32), #  Email server address
        ("byServerType", BYTE), #  Email server type: 0-SMTP, 1-POP, 2-IMTP…
        ("byUseAuthen", BYTE), #  Email server authentication method: 1-enable, 0-disable
        ("byAttachment", BYTE), #  enable attachment
        ("byMailinterval", BYTE), #  mail interval 0-2s, 1-3s, 2-4s. 3-5s
    ]


LPNET_DVR_EMAILCFG = POINTER(NET_DVR_EMAILCFG)


class NET_DVR_COMPRESSIONCFG_NEW(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struLowCompression", NET_DVR_COMPRESSION_INFO_EX), # 定时录像
        ("struEventCompression", NET_DVR_COMPRESSION_INFO_EX), # 事件触发录像
    ]


LPNET_DVR_COMPRESSIONCFG_NEW = POINTER(NET_DVR_COMPRESSIONCFG_NEW)


# 球机位置信息
class NET_DVR_PTZPOS(Structure):
    _fields_ = [
        ("wAction", WORD), # 获取时该字段无效
        ("wPanPos", WORD), # 水平参数
        ("wTiltPos", WORD), # 垂直参数
        ("wZoomPos", WORD), # 变倍参数
    ]


LPNET_DVR_PTZPOS = POINTER(NET_DVR_PTZPOS)


# 球机范围信息
class NET_DVR_PTZSCOPE(Structure):
    _fields_ = [
        ("wPanPosMin", WORD), # 水平参数min
        ("wPanPosMax", WORD), # 水平参数max
        ("wTiltPosMin", WORD), # 垂直参数min
        ("wTiltPosMax", WORD), # 垂直参数max
        ("wZoomPosMin", WORD), # 变倍参数min
        ("wZoomPosMax", WORD), # 变倍参数max
    ]


LPNET_DVR_PTZSCOPE = POINTER(NET_DVR_PTZSCOPE)


# rtsp配置 ipcamera专用
class NET_DVR_RTSPCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 长度
        ("wPort", WORD), # rtsp服务器侦听端口
        ("byReserve1", BYTE * 40), # 预留
        ("wRtspsPort", WORD), # rtsps服务器侦听端口
        ("byReserve", BYTE * 12),
    ]


LPNET_DVR_RTSPCFG = POINTER(NET_DVR_RTSPCFG)


# 接口参数结构
# NET_DVR_Login()参数结构
class NET_DVR_DEVICEINFO(Structure):
    _fields_ = [
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号
        ("byAlarmInPortNum", BYTE), # DVR报警输入个数
        ("byAlarmOutPortNum", BYTE), # DVR报警输出个数
        ("byDiskNum", BYTE), # DVR硬盘个数
        ("byDVRType", BYTE), # DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
        ("byChanNum", BYTE), # DVR 通道个数
        ("byStartChan", BYTE), # 起始通道号,例如DVS-1,DVR - 1
    ]


LPNET_DVR_DEVICEINFO = POINTER(NET_DVR_DEVICEINFO)


# NET_DVR_Login_V30()参数结构
class NET_DVR_DEVICEINFO_V30(Structure):
    _fields_ = [
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号
        ("byAlarmInPortNum", BYTE), # 报警输入个数
        ("byAlarmOutPortNum", BYTE), # 报警输出个数
        ("byDiskNum", BYTE), # 硬盘个数
        ("byDVRType", BYTE), # 设备类型, 1:DVR 2:ATM DVR 3:DVS ......
        ("byChanNum", BYTE), # 模拟通道个数
        ("byStartChan", BYTE), # 起始通道号,例如DVS-1,DVR - 1
        ("byAudioChanNum", BYTE), # 语音通道数
        ("byIPChanNum", BYTE), # 最大数字通道个数，低位
        ("byZeroChanNum", BYTE), # 零通道编码个数 2010-01-16
        ("byMainProto", BYTE), # 主码流传输协议类型 0-private, 1-rtsp,2-同时支持private和rtsp
        ("bySubProto", BYTE), # 子码流传输协议类型0-private, 1-rtsp,2-同时支持private和rtsp
        ("bySupport", BYTE), # 能力，位与结果为0表示不支持，1表示支持，
        # bySupport & 0x1, 表示是否支持智能搜索
        # bySupport & 0x2, 表示是否支持备份
        # bySupport & 0x4, 表示是否支持压缩参数能力获取
        # bySupport & 0x8, 表示是否支持多网卡
        # bySupport & 0x10, 表示支持远程SADP
        # bySupport & 0x20, 表示支持Raid卡功能
        # bySupport & 0x40, 表示支持IPSAN 目录查找
        # bySupport & 0x80, 表示支持rtp over rtsp
        ("bySupport1", BYTE), #  能力集扩充，位与结果为0表示不支持，1表示支持
        # bySupport1 & 0x1, 表示是否支持snmp v30
        # bySupport1 & 0x2, 支持区分回放和下载
        # bySupport1 & 0x4, 是否支持布防优先级
        # bySupport1 & 0x8, 智能设备是否支持布防时间段扩展
        # bySupport1 & 0x10, 表示是否支持多磁盘数（超过33个）
        # bySupport1 & 0x20, 表示是否支持rtsp over http
        # bySupport1 & 0x80, 表示是否支持车牌新报警信息2012-9-28, 且还表示是否支持NET_DVR_IPPARACFG_V40结构体
        ("bySupport2", BYTE), # 能力，位与结果为0表示不支持，非0表示支持
        # bySupport2 & 0x1, 表示解码器是否支持通过URL取流解码
        # bySupport2 & 0x2,  表示支持FTPV40
        # bySupport2 & 0x4,  表示支持ANR
        # bySupport2 & 0x8,  表示支持CCD的通道参数配置
        # bySupport2 & 0x10,  表示支持布防报警回传信息（仅支持抓拍机报警 新老报警结构）
        # bySupport2 & 0x20,  表示是否支持单独获取设备状态子项
        # bySupport2 & 0x40,  表示是否是码流加密设备
        ("wDevType", WORD), # 设备型号
        ("bySupport3", BYTE), # 能力集扩展，位与结果为0表示不支持，1表示支持
        # bySupport3 & 0x1, 表示是否支持批量配置多码流参数
        # bySupport3 & 0x4 表示支持按组配置， 具体包含 通道图像参数、报警输入参数、IP报警输入、输出接入参数、
        # 用户参数、设备工作状态、JPEG抓图、定时和时间抓图、硬盘盘组管理
        # bySupport3 & 0x8为1 表示支持使用TCP预览、UDP预览、多播预览中的"延时预览"字段来请求延时预览（后续都将使用这种方式请求延时预览）。而当bySupport3 & 0x8为0时，将使用 "私有延时预览"协议。
        # bySupport3 & 0x10 表示支持"获取报警主机主要状态（V40）"。
        # bySupport3 & 0x20 表示是否支持通过DDNS域名解析取流
        #
        ("byMultiStreamProto", BYTE), # 是否支持多码流,按位表示,0-不支持,1-支持,bit1-码流3,bit2-码流4,bit7-主码流，bit-8子码流
        ("byStartDChan", BYTE), # 起始数字通道号,0表示无效
        ("byStartDTalkChan", BYTE), # 起始数字对讲通道号，区别于模拟对讲通道号，0表示无效
        ("byHighDChanNum", BYTE), # 数字通道个数，高位
        ("bySupport4", BYTE), # 能力集扩展，位与结果为0表示不支持，1表示支持
        # bySupport4 & 0x4表示是否支持拼控统一接口
        # bySupport4 & 0x80 支持设备上传中心报警使能。表示判断调用接口是 NET_DVR_PDC_RULE_CFG_V42还是 NET_DVR_PDC_RULE_CFG_V41
        ("byLanguageType", BYTE), #  支持语种能力,按位表示,每一位0-不支持,1-支持
        # byLanguageType 等于0 表示 老设备
        # byLanguageType & 0x1表示支持中文
        # byLanguageType & 0x2表示支持英文
        ("byVoiceInChanNum", BYTE), # 音频输入通道数
        ("byStartVoiceInChanNo", BYTE), # 音频输入起始通道号 0表示无效
        ("bySupport5", BYTE), # 按位表示,0-不支持,1-支持,bit0-支持多码流
        # bySupport5 &0x01表示支持wEventTypeEx ,兼容dwEventType 的事件类型（支持行为事件扩展）--先占住，防止冲突
        # bySupport5 &0x04表示是否支持使用扩展的场景模式接口
        #
        # bySupport5 &0x08 设备返回该值表示是否支持计划录像类型V40接口协议(DVR_SET_RECORDCFG_V40/ DVR_GET_RECORDCFG_V40)(在该协议中设备支持类型类型13的配置)
        # 之前的部分发布的设备，支持录像类型13，则配置录像类型13。如果不支持，统一转换成录像类型3兼容处理。SDK通过命令探测处理)
        # bySupport5 &0x10 设备返回改值表示支持超过255个预置点
        #
        ("bySupport6", BYTE), # 能力，按位表示，0-不支持,1-支持
        # bySupport6 0x1  表示设备是否支持压缩
        # bySupport6 0x2 表示是否支持流ID方式配置流来源扩展命令，DVR_SET_STREAM_SRC_INFO_V40
        # bySupport6 0x4 表示是否支持事件搜索V40接口
        # bySupport6 0x8 表示是否支持扩展智能侦测配置命令
        # bySupport6 0x40表示图片查询结果V40扩展
        ("byMirrorChanNum", BYTE), # 镜像通道个数，<录播主机中用于表示导播通道>
        ("wStartMirrorChanNo", WORD), # 起始镜像通道号
        ("bySupport7", BYTE), # 能力,按位表示,0-不支持,1-支持
        # bySupport7 & 0x1  表示设备是否支持 INTER_VCA_RULECFG_V42 扩展
        # bySupport7 & 0x2  表示设备是否支持 IPC HVT 模式扩展
        # bySupport7 & 0x04  表示设备是否支持 返回锁定时间
        # bySupport7 & 0x08  表示设置云台PTZ位置时，是否支持带通道号
        # bySupport7 & 0x10  表示设备是否支持双系统升级备份
        # bySupport7 & 0x20  表示设备是否支持 OSD字符叠加 V50
        # bySupport7 & 0x40  表示设备是否支持 主从跟踪（从摄像机）
        # bySupport7 & 0x80  表示设备是否支持 报文加密
        ("byRes2", BYTE), # 保留
    ]


LPNET_DVR_DEVICEINFO_V30 = POINTER(NET_DVR_DEVICEINFO_V30)


class NET_DVR_DEVICEINFO_V40(Structure):
    _fields_ = [
        ("struDeviceV30", NET_DVR_DEVICEINFO_V30),
        ("bySupportLock", BYTE), # 设备支持锁定功能，该字段由SDK根据设备返回值来赋值的。bySupportLock为1时，dwSurplusLockTime和byRetryLoginTime有效
        ("byRetryLoginTime", BYTE), # 剩余可尝试登陆的次数，用户名，密码错误时，此参数有效
        ("byPasswordLevel", BYTE), # admin密码安全等级0-无效，1-默认密码，2-有效密码,3-风险较高的密码。当用户的密码为出厂默认密码（12345）或者风险较高的密码时，上层客户端需要提示用户更改密码。4-管理员创建一个普通用户为其设置密码，该普通用户正确登录设备后要提示“请修改初始登录密码”，未修改的情况下，用户每次登入都会进行提醒；5-当普通用户的密码被管理员修改，该普通用户再次正确登录设备后，需要提示“请重新设置登录密码”，未修改的情况下，用户每次登入都会进行提醒
        ("byProxyType", BYTE), # 代理类型，0-不使用代理, 1-使用socks5代理, 2-使用EHome代理
        ("dwSurplusLockTime", DWORD), # 剩余时间，单位秒，用户锁定时，此参数有效
        ("byCharEncodeType", BYTE), # 字符编码类型
        ("bySupportDev5", BYTE), # 支持v50版本的设备参数获取，设备名称和设备类型名称长度扩展为64字节
        ("bySupport", BYTE), # 能力集扩展，位与结果：0- 不支持，1- 支持
        # bySupport & 0x1:  保留
        # bySupport & 0x2:  0-不支持变化上报 1-支持变化上报
        ("byLoginMode", BYTE), # 登录模式 0-Private登录 1-ISAPI登录
        ("dwOEMCode", DWORD),
        ("iResidualValidity", INT), # 该用户密码剩余有效天数，单位：天，返回负值，表示密码已经超期使用，例如“-3表示密码已经超期使用3天”
        ("byResidualValidity", BYTE), #  iResidualValidity字段是否有效，0-无效，1-有效
        ("bySingleStartDTalkChan", BYTE), # 独立音轨接入的设备，起始接入通道号，0-为保留字节，无实际含义，音轨通道号不能从0开始
        ("bySingleDTalkChanNums", BYTE), # 独立音轨接入的设备的通道总数，0-表示不支持
        ("byPassWordResetLevel", BYTE), # 0-无效，1-管理员创建一个非管理员用户为其设置密码，该非管理员用户正确登录设备后要提示“请修改初始登录密码”，未修改的情况下，用户每次登入都会进行提醒；2-当非管理员用户的密码被管理员修改，该非管理员用户再次正确登录设备后，需要提示“请重新设置登录密码”，未修改的情况下，用户每次登入都会进行提醒。
        ("bySupportStreamEncrypt", BYTE), # 能力集扩展，位与结果：0- 不支持，1- 支持 bySupportStreamEncrypt & 0x1:表示是否支持RTP/TLS取流 bySupportStreamEncrypt & 0x2:  表示是否支持SRTP/UDP取流 bySupportStreamEncrypt & 0x4:  表示是否支持SRTP/MULTICAST取流
        ("byMarketType", BYTE), # 0-无效（未知类型）,1-经销型，2-行业型
        ("byRes2", BYTE * 238),
    ]


LPNET_DVR_DEVICEINFO_V40 = POINTER(NET_DVR_DEVICEINFO_V40)

fLoginResultCallBack = WINFUNCTYPE(None, LONG, DWORD, LPNET_DVR_DEVICEINFO_V30, VOIDP)

NET_DVR_DEV_ADDRESS_MAX_LEN = 129
NET_DVR_LOGIN_USERNAME_MAX_LEN = 64
NET_DVR_LOGIN_PASSWD_MAX_LEN = 64
class NET_DVR_USER_LOGIN_INFO(Structure):
    _fields_ = [
        ("sDeviceAddress", CHAR * NET_DVR_DEV_ADDRESS_MAX_LEN),
        ("byUseTransport", BYTE), # 是否启用能力集透传，0--不启用透传，默认，1--启用透传
        ("wPort", WORD),
        ("sUserName", CHAR * NET_DVR_LOGIN_USERNAME_MAX_LEN),
        ("sPassword", CHAR * NET_DVR_LOGIN_PASSWD_MAX_LEN),
        ("cbLoginResult", fLoginResultCallBack),
        ("pUser", VOIDP),
        ("bUseAsynLogin", BOOL),
        ("byProxyType", BYTE), # 0:不使用代理，1：使用标准代理，2：使用EHome代理
        ("byUseUTCTime", BYTE), # 0-不进行转换，默认,1-接口上输入输出全部使用UTC时间,SDK完成UTC时间与设备时区的转换,2-接口上输入输出全部使用平台本地时间，SDK完成平台本地时间与设备时区的转换
        ("byLoginMode", BYTE), # 0-Private 1-ISAPI 2-自适应
        ("byHttps", BYTE), # 0-不适用tls，1-使用tls 2-自适应
        ("iProxyID", LONG), # 代理服务器序号，添加代理服务器信息时，相对应的服务器数组下表值
        ("byVerifyMode", BYTE), # 认证方式，0-不认证，1-双向认证，2-单向认证；认证仅在使用TLS的时候生效
        ("byRes3", BYTE * 119),
    ]


LPNET_DVR_USER_LOGIN_INFO = POINTER(NET_DVR_USER_LOGIN_INFO)

LOCAL_AREA_NETWORK = 0
WIDE_AREA_NETWORK = 1

NORMALMODE = 0
OVERLAYMODE = 1

PTOPTCPMODE = 0
PTOPUDPMODE = 1
MULTIMODE = 2
RTPMODE = 3
RESERVEDMODE = 4

BMP_MODE = 0 # BMP模式
JPEG_MODE = 1 # JPEG模式

MONOPOLIZE_MODE = 1 # 独占模式
SHARE_MODE = 2 # 共享模式


# 软解码预览参数
class NET_DVR_CLIENTINFO(Structure):
    _fields_ = [
        ("lChannel", LONG), # 通道号
        ("lLinkMode", LONG), # 最高位(31)为0表示主码流，为1表示子，0－30位表示码流连接方式: 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP
        ("hPlayWnd", HWND), # 播放窗口的句柄,为NULL表示不播放图象
        ("sMultiCastIP", CHARP), # 多播组地址
        ("byProtoType", BYTE), # 应用层取流协议，0-私有协议，1-RTSP协议
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_CLIENTINFO = POINTER(NET_DVR_CLIENTINFO)


# SDK状态信息(9000新增)
class NET_DVR_SDKSTATE(Structure):
    _fields_ = [
        ("dwTotalLoginNum", DWORD), # 当前login用户数
        ("dwTotalRealPlayNum", DWORD), # 当前realplay路数
        ("dwTotalPlayBackNum", DWORD), # 当前回放或下载路数
        ("dwTotalAlarmChanNum", DWORD), # 当前建立报警通道路数
        ("dwTotalFormatNum", DWORD), # 当前硬盘格式化路数
        ("dwTotalFileSearchNum", DWORD), # 当前日志或文件搜索路数
        ("dwTotalLogSearchNum", DWORD), # 当前日志或文件搜索路数
        ("dwTotalSerialNum", DWORD), # 当前透明通道路数
        ("dwTotalUpgradeNum", DWORD), # 当前升级路数
        ("dwTotalVoiceComNum", DWORD), # 当前语音转发路数
        ("dwTotalBroadCastNum", DWORD), # 当前语音广播路数
        ("dwTotalListenNum", DWORD), # 当前网络监听路数
        ("dwEmailTestNum", DWORD), # 当前邮件计数路数
        ("dwBackupNum", DWORD), #  当前文件备份路数
        ("dwTotalInquestUploadNum", DWORD), # 当前审讯上传路数
        ("dwRes", DWORD * 6),
    ]


LPNET_DVR_SDKSTATE = POINTER(NET_DVR_SDKSTATE)


# SDK功能支持信息(9000新增)
class NET_DVR_SDKABL(Structure):
    _fields_ = [
        ("dwMaxLoginNum", DWORD), # 最大login用户数 MAX_LOGIN_USERS
        ("dwMaxRealPlayNum", DWORD), # 最大realplay路数 WATCH_NUM
        ("dwMaxPlayBackNum", DWORD), # 最大回放或下载路数 WATCH_NUM
        ("dwMaxAlarmChanNum", DWORD), # 最大建立报警通道路数 ALARM_NUM
        ("dwMaxFormatNum", DWORD), # 最大硬盘格式化路数 SERVER_NUM
        ("dwMaxFileSearchNum", DWORD), # 最大文件搜索路数 SERVER_NUM
        ("dwMaxLogSearchNum", DWORD), # 最大日志搜索路数 SERVER_NUM
        ("dwMaxSerialNum", DWORD), # 最大透明通道路数 SERVER_NUM
        ("dwMaxUpgradeNum", DWORD), # 最大升级路数 SERVER_NUM
        ("dwMaxVoiceComNum", DWORD), # 最大语音转发路数 SERVER_NUM
        ("dwMaxBroadCastNum", DWORD), # 最大语音广播路数 MAX_CASTNUM
        ("dwRes", DWORD * 10),
    ]


LPNET_DVR_SDKABL = POINTER(NET_DVR_SDKABL)


# 报警设备信息
class NET_DVR_ALARMER(Structure):
    _fields_ = [
        ("byUserIDValid", BYTE), #  userid是否有效 0-无效，1-有效
        ("bySerialValid", BYTE), #  序列号是否有效 0-无效，1-有效
        ("byVersionValid", BYTE), #  版本号是否有效 0-无效，1-有效
        ("byDeviceNameValid", BYTE), #  设备名字是否有效 0-无效，1-有效
        ("byMacAddrValid", BYTE), #  MAC地址是否有效 0-无效，1-有效
        ("byLinkPortValid", BYTE), #  login端口是否有效 0-无效，1-有效
        ("byDeviceIPValid", BYTE), #  设备IP是否有效 0-无效，1-有效
        ("bySocketIPValid", BYTE), #  socket ip是否有效 0-无效，1-有效
        ("lUserID", LONG), #  NET_DVR_Login()返回值, 布防时有效
        ("sSerialNumber", BYTE * SERIALNO_LEN), #  序列号
        ("dwDeviceVersion", DWORD), #  版本信息 高16位表示主版本，低16位表示次版本
        ("sDeviceName", CHAR * NAME_LEN), #  设备名字
        ("byMacAddr", BYTE * MACADDR_LEN), #  MAC地址
        ("wLinkPort", WORD), #  link port
        ("sDeviceIP", CHAR * 128), #  IP地址
        ("sSocketIP", CHAR * 128), #  报警主动上传时的socket IP地址
        ("byIpProtocol", BYTE), #  Ip协议 0-IPV4, 1-IPV6
        ("byRes1", BYTE * 2),
        ("bJSONBroken", BYTE), # JSON断网续传标志。0：不续传；1：续传
        ("wSocketPort", WORD),
        ("byRes2", BYTE * 6),
    ]


LPNET_DVR_ALARMER = POINTER(NET_DVR_ALARMER)


# 硬解码显示区域参数(子结构)
class NET_DVR_DISPLAY_PARA(Structure):
    _fields_ = [
        ("bToScreen", LONG),
        ("bToVideoOut", LONG),
        ("nLeft", LONG),
        ("nTop", LONG),
        ("nWidth", LONG),
        ("nHeight", LONG),
        ("nReserved", LONG),
    ]


LPNET_DVR_DISPLAY_PARA = POINTER(NET_DVR_DISPLAY_PARA)


# 硬解码预览参数
class NET_DVR_CARDINFO(Structure):
    _fields_ = [
        ("lChannel", LONG), # 通道号
        ("lLinkMode", LONG), # 最高位(31)为0表示主码流，为1表示子，0－30位表示码流连接方式:0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-电话线，5－128k宽带，6－256k宽带，7－384k宽带，8－512k宽带；
        ("sMultiCastIP", CHARP),
        ("struDisplayPara", NET_DVR_DISPLAY_PARA),
    ]


LPNET_DVR_CARDINFO = POINTER(NET_DVR_CARDINFO)


# 录象文件参数
class NET_DVR_FIND_DATA(Structure):
    _fields_ = [
        ("sFileName", CHAR * 100), # 文件名
        ("struStartTime", NET_DVR_TIME), # 文件的开始时间
        ("struStopTime", NET_DVR_TIME), # 文件的结束时间
        ("dwFileSize", DWORD), # 文件的大小
    ]


LPNET_DVR_FIND_DATA = POINTER(NET_DVR_FIND_DATA)


# 录象文件参数(9000)
class NET_DVR_FINDDATA_V30(Structure):
    _fields_ = [
        ("sFileName", CHAR * 100), # 文件名
        ("struStartTime", NET_DVR_TIME), # 文件的开始时间
        ("struStopTime", NET_DVR_TIME), # 文件的结束时间
        ("dwFileSize", DWORD), # 文件的大小
        ("sCardNum", CHAR * 32),
        ("byLocked", BYTE), # 9000设备支持,1表示此文件已经被锁定,0表示正常的文件
        ("byFileType", BYTE), # 文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
        # 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_FINDDATA_V30 = POINTER(NET_DVR_FINDDATA_V30)


# 录象文件参数(cvr)
class NET_DVR_FINDDATA_V40(Structure):
    _fields_ = [
        ("sFileName", CHAR * 100), # 文件名
        ("struStartTime", NET_DVR_TIME), # 文件的开始时间
        ("struStopTime", NET_DVR_TIME), # 文件的结束时间
        ("dwFileSize", DWORD), # 文件的大小
        ("sCardNum", CHAR * 32),
        ("byLocked", BYTE), # 9000设备支持,1表示此文件已经被锁定,0表示正常的文件
        ("byFileType", BYTE), # 文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
        # 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
        ("byQuickSearch", BYTE), # 0:普通查询结果，1：快速（日历）查询结果
        ("byRes", BYTE),
        ("dwFileIndex", DWORD), # 文件索引号
        ("byStreamType", BYTE),
        ("byRes1", BYTE * 127),
    ]


LPNET_DVR_FINDDATA_V40 = POINTER(NET_DVR_FINDDATA_V40)


class NET_DVR_FINDDATA_V50(Structure):
    _fields_ = [
        ("sFileName", CHAR * 100),
        ("struStartTime", NET_DVR_TIME_SEARCH),
        ("struStopTime", NET_DVR_TIME_SEARCH),
        ("struAddr", NET_DVR_ADDRESS), # 片段所在的地址信息，集群回放时用到
        ("dwFileSize", DWORD), # 文件大小 对于大文件搜索类型时（byBigFileType为1），该值无意义
        ("byLocked", BYTE), # 文件是否被锁定，1－文件已锁定；0－文件未锁定
        ("byFileType", BYTE), # 文件类型，与V40相同
        ("byQuickSearch", BYTE), # 0- 普通查询结果，1- 快速（日历）查询结果
        ("byStreamType", BYTE), # 码流类型：0- 主码流，1- 子码流，2- 码流三
        ("dwFileIndex", DWORD), # 文件索引号
        ("sCardNum", CHAR * 32), # 卡号
        ("dwTotalLenH", DWORD), #  对于大文件搜索，时间段内数据总长度，高32字节
        ("dwTotalLenL", DWORD), #  对于大文件搜索，时间段内数据总长度，低32字节
        ("byBigFileType", BYTE), #  0为普通片段搜索，1为大文件搜索
        ("byRes", BYTE * 247),
    ]


LPNET_DVR_FINDDATA_V50 = POINTER(NET_DVR_FINDDATA_V50)


# 录象文件参数(带卡号)
class NET_DVR_FINDDATA_CARD(Structure):
    _fields_ = [
        ("sFileName", CHAR * 100), # 文件名
        ("struStartTime", NET_DVR_TIME), # 文件的开始时间
        ("struStopTime", NET_DVR_TIME), # 文件的结束时间
        ("dwFileSize", DWORD), # 文件的大小
        ("sCardNum", CHAR * 32),
    ]


LPNET_DVR_FINDDATA_CARD = POINTER(NET_DVR_FINDDATA_CARD)


# 录象文件查找条件结构
class NET_DVR_FILECOND(Structure):
    _fields_ = [
        ("lChannel", LONG), # 通道号
        ("dwFileType", DWORD), # 录象文件类型
        # 不带卡号，0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
        # 带卡号，0xff－全部，0－定时录像，1-移动侦测，2－接近报警，3－出钞报警，4－进钞报警，5-命令触发，6－手动录像，7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
        ("dwIsLocked", DWORD), # 是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
        ("dwUseCardNo", DWORD), # 是否使用卡号
        ("sCardNumber", BYTE * 32), # 卡号
        ("struStartTime", NET_DVR_TIME), # 开始时间
        ("struStopTime", NET_DVR_TIME), # 结束时间
    ]


LPNET_DVR_FILECOND = POINTER(NET_DVR_FILECOND)


# 云台区域选择放大缩小(私有 快球专用)
class NET_DVR_POINT_FRAME(Structure):
    _fields_ = [
        ("xTop", INT), # 方框起始点的x坐标
        ("yTop", INT), # 方框结束点的y坐标
        ("xBottom", INT), # 方框结束点的x坐标
        ("yBottom", INT), # 方框结束点的y坐标
        ("bCounter", INT), # 保留
    ]


LPNET_DVR_POINT_FRAME = POINTER(NET_DVR_POINT_FRAME)


# 语音对讲参数
class NET_DVR_COMPRESSION_AUDIO(Structure):
    _fields_ = [
        ("byAudioEncType", BYTE), # 音频编码类型 0-OggVorbis(G722.1)1-G711_U2-G711_A5-MP2L26-G7267-AAC,8-PCM9-G722.1.C12-AAC_LC13-AAC_LD14-Opus
        ("byAudioSamplingRate", BYTE), # 音频采样率 0-默认，1-16kHZ，2-32kHZ，3-48kHZ, 4- 44.1kHZ,5-8kHZ
        ("byAudioBitRate", BYTE), #  音频码率 参考 BITRATE_ENCODE_INDEX
        ("byres", BYTE * 4), # 这里保留音频的压缩参数
        ("bySupport", BYTE), # bySupport Bit0表示 Mp2l2前4个字节的含义表示后面内容音频数据长度
    ]


LPNET_DVR_COMPRESSION_AUDIO = POINTER(NET_DVR_COMPRESSION_AUDIO)


# 2009-7-22
IW_ESSID_MAX_SIZE = 32
WIFI_WEP_MAX_KEY_COUNT = 4
WIFI_WEP_MAX_KEY_LENGTH = 33
WIFI_WPA_PSK_MAX_KEY_LENGTH = 63
WIFI_WPA_PSK_MIN_KEY_LENGTH = 8
WIFI_MAX_AP_COUNT = 20
WIFI_WPA_PSK_MAX_HEXKEY_LENGTH = 68 # WPA16进制密钥最大长度
class NET_DVR_AP_INFO(Structure):
    _fields_ = [
        ("sSsid", CHAR * IW_ESSID_MAX_SIZE),
        ("dwMode", DWORD), #  0 mange 模式1 ad-hoc模式，参见NICMODE
        ("dwSecurity", DWORD), # 0 不加密；1 wep加密；2 wpa-psk3 wpa-Enterprise4-WPA2_PSK参见WIFISECURITY
        ("dwChannel", DWORD), # 1-11表示11个通道
        ("dwSignalStrength", DWORD), # 0-100信号由最弱变为最强
        ("dwSpeed", DWORD), # 速率,单位是0.01mbps
    ]


LPNET_DVR_AP_INFO = POINTER(NET_DVR_AP_INFO)


class NET_DVR_AP_INFO_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCount", DWORD), # 无线AP数量，不超过20
        ("struApInfo", NET_DVR_AP_INFO * WIFI_MAX_AP_COUNT),
    ]


LPNET_DVR_AP_INFO_LIST = POINTER(NET_DVR_AP_INFO_LIST)


class NET_DVR_WIFIETHERNET(Structure):
    _fields_ = [
        ("sIpAddress", CHAR * 16), # IP地址
        ("sIpMask", CHAR * 16), # 掩码
        ("byMACAddr", BYTE * MACADDR_LEN), # 物理地址，只用来显示
        ("byCloseWifi", BYTE), # 是否关闭wifi连接，0-不关闭，1-关闭
        ("bRes", BYTE),
        ("dwEnableDhcp", DWORD), # 是否启动dhcp  0不启动 1启动
        ("dwAutoDns", DWORD), # 如果启动dhcp是否自动获取dns,0不自动获取 1自动获取；对于有线如果启动dhcp目前自动获取dns
        ("sFirstDns", CHAR * 16), # 第一个dns域名
        ("sSecondDns", CHAR * 16), # 第二个dns域名
        ("sGatewayIpAddr", CHAR * 16), #  网关地址
        ("bRes2", BYTE * 8),
    ]


LPNET_DVR_WIFIETHERNET = POINTER(NET_DVR_WIFIETHERNET)


# # wifi配置结构
# class NET_DVR_WIFI_CFG(Structure):
#     _fields_ = [
#         ("dwSize", DWORD),
#         ("struWifiCfg", NET_DVR_WIFI_CFG_EX),
#     ]


# LPNET_DVR_WIFI_CFG = POINTER(NET_DVR_WIFI_CFG)


# wifi连接状态
class NET_DVR_WIFI_CONNECT_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCurStatus", BYTE), # 1-已连接，2-未连接，3-正在连接
        ("byRes1", BYTE * 3), # 保留
        ("dwErrorCode", DWORD), #  byCurStatus = 2时有效,1-用户名或密码错误,2-无此路由器,3-未知错误
        ("byRes", BYTE * 244),
    ]


LPNET_DVR_WIFI_CONNECT_STATUS = POINTER(NET_DVR_WIFI_CONNECT_STATUS)


# wifi工作模式
class NET_DVR_WIFI_WORKMODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwNetworkInterfaceMode", DWORD), # 0 自动切换模式　1 有线模式
    ]


LPNET_DVR_WIFI_WORKMODE = POINTER(NET_DVR_WIFI_WORKMODE)


# 结构参数宏定义
VCA_MAX_POLYGON_POINT_NUM = 10 # 检测区域最多支持10个点的多边形
MAX_RULE_NUM = 8 # 最多规则条数
MAX_RULE_NUM_V42 = 16 # 最多规则条数扩展
MAX_TARGET_NUM = 30 # 最多目标个数
MAX_CALIB_PT = 6 # 最大标定点个数
MIN_CALIB_PT = 4 # 最小标定点个数
MAX_TIMESEGMENT_2 = 2 # 最大时间段数
DATA_INDEX_LEN = 64 # 数据流水号
MAX_DEV_DATAINDEX_LEN = 64 # 设备数据流水号
MAX_TRAFFIC_PICTURE_NUM = 8 # 交通图片数量
MAX_LICENSE_LEN = 16 # 车牌号最大长度
MAX_LICENSE_LEN_EX = 32 # 车牌号最大长度
MAX_CARDNO_LEN = 48 # 卡号最大长度 2013-11-04
MAX_OPERATE_INDEX_LEN = 32 # 操作数最大长度2014-03-03
MAX_PLATE_NUM = 3 # 车牌个数
MAX_MASK_REGION_NUM = 4 # 最多四个屏蔽区域
MAX_SEGMENT_NUM = 6 # 摄像机标定最大样本线数目
MIN_SEGMENT_NUM = 3 # 摄像机标定最小样本线数目
MAX_REL_SNAPCHAN_NUM = 3 # 最大关联抓图通道数
MAX_PIC_SWITCH_STORAGE_SERVER = 64 # 云存储服务器存储的最大图片类型数
MAX_INFO_SWITCH_STORAGE_SERVER = 64 # 云存储服务器存储的最大附加信息类型数
RTMP_URL_LEN = 128 # RTMP URL 长度
MAX_ID_LEN_128 = 128 # 发布文件ID长度
MAX_DEBUGCMD_LEN = 1024 # 设备调试命令最大长度
MAX_DEBUGINFO_LEN = 1400 # 设备调试信息最大长度
MAX_VEHICLE_ID_LEN = 32 # 最大车辆标识长度
LEN_PROPERTY = 128
class NET_DVR_VEHICLE_INFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 本段报文长度,
        ("strStartTime", NET_DVR_TIME_EX), # 开始时间
        ("strStopTime", NET_DVR_TIME_EX), # 结束时间
        ("sLicense", CHAR * MAX_LICENSE_LEN_EX), # 车牌号码
        ("dwChannel", DWORD),
        ("byRegion", BYTE),
        ("byRes", BYTE * 127), #  区域索引值 0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS) , 4-中东（Middle East），0xff-所有
    ]


LPNET_DVR_VEHICLE_INFO_COND = POINTER(NET_DVR_VEHICLE_INFO_COND)


class NET_DVR_VEHICLE_INFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwIndex", DWORD), # 序号
        ("byDeviceID", BYTE * DEVICE_ID_LEN), # 设备编号
        ("byBelieve", BYTE), # 置信度，0-100
        ("byDir", BYTE), # 方向，0-无意义，1-反向，2-正向，3-未知
        ("byLineID", BYTE), # 车道号
        ("byRes1", BYTE),
        ("struSnapTime", NET_DVR_TIME_EX), # 抓拍时间
        ("sLicense", CHAR * MAX_LICENSE_LEN_EX), # 车牌号码
        ("byMonitoringSiteID", BYTE * MONITORSITE_ID_LEN), # 监测点编号
        ("byCountry", BYTE), #  国家索引值，参照枚举COUNTRY_INDEX（不支持”COUNTRY_ALL = 0xff, ALL  全部”）
        ("byMatchingResult", BYTE), # 黑白名单匹配结果：0-保留，1-白名单，2-黑名单，3-其他
        ("byArea", BYTE), # 区域（省份），各国家内部区域枚举，阿联酋参照 EMI_AREA
        ("byPlateType", BYTE), # 车牌类型 参考 VCA_PLATE_TYPE
        ("sDeviceName", CHAR * NAME_LEN), # 设备名称
        ("byPlateColor", BYTE), # 车牌颜色 参考 VCA_PLATE_COLOR
        ("byPlateSize", BYTE), # 车牌尺寸，0~未知，1~LONG, 2~short(中东车牌使用)
        ("byRes2", BYTE * 2),
        ("sPlateCategory", CHAR * MAX_CATEGORY_LEN), # 车牌附加信息, 即车牌小字信息，(目前只有中东地区支持)
        ("sPlateImageURL", CHAR * URL_LEN_V40), # 车牌小图URL
        ("sEffectiveTime", CHAR * ISO_8601_LEN), # 车牌信息有效时间，使用ISO8601 time格式，如：2009-11-14T15:27Z
        ("byRes", BYTE * 176),
    ]


LPNET_DVR_VEHICLE_INFO_CFG = POINTER(NET_DVR_VEHICLE_INFO_CFG)


# 智能控制信息
MAX_VCA_CHAN = 16 # 最大智能通道数
class NET_VCA_CTRLINFO(Structure):
    _fields_ = [
        ("byVCAEnable", BYTE), # 是否开启智能
        ("byVCAType", BYTE), # 智能能力类型，VCA_CHAN_ABILITY_TYPE
        ("byStreamWithVCA", BYTE), # 码流中是否带智能信息
        ("byMode", BYTE), # 模式，ATM能力时参照VCA_CHAN_MODE_TYPE ,TFS能力时参照TFS_CHAN_MODE_TYPE
        ("byControlType", BYTE), # 控制类型，按位表示，0-否，1-是
        # byControlType &1 是否启用抓拍功能
        ("byPicWithVCA", BYTE), #  报警抓图叠加目标信息(目标框)：0-不叠加（默认），1-叠加；
        ("byRes", BYTE * 2), # 保留，设置为0
    ]


LPNET_VCA_CTRLINFO = POINTER(NET_VCA_CTRLINFO)


# 智能控制信息结构
class NET_VCA_CTRLCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struCtrlInfo", NET_VCA_CTRLINFO * MAX_VCA_CHAN), # 控制信息,数组0对应设备的起始通道
        ("byRes", BYTE * 16),
    ]


LPNET_VCA_CTRLCFG = POINTER(NET_VCA_CTRLCFG)


# 智能设备能力集
class NET_VCA_DEV_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byVCAChanNum", BYTE), # 智能通道个数
        ("byPlateChanNum", BYTE), # 车牌通道个数
        ("byBBaseChanNum", BYTE), # 行为基本版个数
        ("byBAdvanceChanNum", BYTE), # 行为高级版个数
        ("byBFullChanNum", BYTE), # 行为完整版个数
        ("byATMChanNum", BYTE), # 智能ATM个数
        ("byPDCChanNum", BYTE), # 人数统计通道个数
        ("byITSChanNum", BYTE), # 交通事件通道个数
        ("byBPrisonChanNum", BYTE), # 行为监狱版(监舍)通道个数
        ("byFSnapChanNum", BYTE), # 人脸抓拍通道个数
        ("byFSnapRecogChanNum", BYTE), # 人脸抓拍和识别通道个数
        ("byFRetrievalChanNum", BYTE), # 人脸后检索个数
        ("bySupport", BYTE), # 能力，位与结果为0表示不支持，1表示支持
        # bySupport & 0x1，表示是否支持智能跟踪 2012-3-22
        # bySupport & 0x2，表示是否支持128路取流扩展2012-12-27
        ("byFRecogChanNum", BYTE), # 人脸识别通道个数
        ("byBPPerimeterChanNum", BYTE), # 行为监狱版(周界)通道个数
        ("byTPSChanNum", BYTE), # 交通诱导通道个数
        ("byTFSChanNum", BYTE), # 道路违章取证通道个数
        ("byFSnapBFullChanNum", BYTE), # 人脸抓拍和行为分析通道个数
        ("byHeatMapChanNum", BYTE), # 热度图通道个数
        ("bySmartVehicleNum", BYTE), # SMART事件+车辆检测通道个数
        ("bySmartHVTNum", BYTE), # SMART事件+混行检测通道个数
        ("bySmartNum", BYTE), # SMART事件个数
        ("byVehicleNum", BYTE), # 车辆检测通道个数
        ("bySmartRoadDetectionNum", BYTE), #  SMART事件+道路监控通道个数
        ("bySmartFaceDetectionNum", BYTE), #  SMART事件+人脸侦测通道个数
        ("bySmartHeatMapNum", BYTE), #  SMART事件+热度图通道个数
        ("byHumanRecognitionNum", BYTE), # 人体识别通道个数
        ("byEdcationStudentNum", BYTE), # 教育录播（学生起来检测&&学生人数统计）支持的通道数
        ("byRoadDetectionNum", BYTE), # 道路监控通道个数
        ("byPersonDensityDetection", BYTE), # 人员密度检测通道个数
        ("bySafetyHelmetDetection", BYTE), # 安全帽检测通道个数
        ("byPerimeterCapture", BYTE), # 周界抓拍通道个数
        ("byHeelPDC", BYTE), # 倾斜客流通道个数
        ("by12MPLiveView", BYTE), #  主码流 1200W@20fps预览（4000*3000）
        ("byTeacherBehaviorDetectNum", BYTE), # 教育录播（教师行为检测）支持的通道数
        ("byMixedTargetDetection", BYTE), # 混合目标检测通道个数
        ("byFaceContrast", BYTE), # 人脸比对检测通道个数
        ("byCityManagement", BYTE), # 智慧城管检测通道个数
        ("byMixedTargetDetectionSmart", BYTE), # 混合目标检测+Smart事件
        ("byRes", BYTE),
    ]


LPNET_VCA_DEV_ABILITY = POINTER(NET_VCA_DEV_ABILITY)

TRAVERSE_PLANE_ABILITY = 0x01 # 穿越警戒面
ENTER_AREA_ABILITY = 0x02 # 进入区域
EXIT_AREA_ABILITY = 0x04 # 离开区域
INTRUSION_ABILITY = 0x08 # 入侵
LOITER_ABILITY = 0x10 # 徘徊
LEFT_TAKE_ABILITY = 0x20 # 物品遗留拿取
PARKING_ABILITY = 0x40 # 停车
RUN_ABILITY = 0x80 # 快速移动
HIGH_DENSITY_ABILITY = 0x100 # 人员聚集
LF_TRACK_ABILITY = 0x200 # 球机跟踪
VIOLENT_MOTION_ABILITY = 0x400 # 剧烈运动检测
REACH_HIGHT_ABILITY = 0x800 # 攀高检测
GET_UP_ABILITY = 0x1000 # 起身检测
LEFT_ABILITY = 0x2000 # 物品遗留
TAKE_ABILITY = 0x4000 # 物品拿取
LEAVE_POSITION = 0x8000 # 离岗
TRAIL_ABILITY = 0x10000 # 尾随
KEY_PERSON_GET_UP_ABILITY = 0x20000 # 重点人员起身检测
STANDUP_ABILITY = 0x40000 # 起立
FALL_DOWN_ABILITY = 0x80000 # 倒地
AUDIO_ABNORMAL_ABILITY = 0x100000 # 声强突变
ADV_REACH_HEIGHT_ABILITY = 0x200000 # 折线攀高
TOILET_TARRY_ABILITY = 0x400000 # 如厕超时
YARD_TARRY_ABILITY = 0x800000 # 放风场滞留
ADV_TRAVERSE_PLANE_ABILITY = 0x1000000 # 折线警戒面
LECTURE_ABILITY = 0x2000000 # 授课
ANSWER_ABILITY = 0x4000000 # 回答问题
HUMAN_ENTER_ABILITY = 0x10000000 # 人靠近ATM, 只在ATM_PANEL模式下支持
OVER_TIME_ABILITY = 0x20000000 # 操作超时, 只在ATM_PANEL模式下支持
STICK_UP_ABILITY = 0x40000000 # 贴纸条
INSTALL_SCANNER_ABILITY = 0x80000000 # 安装读卡器

PEOPLENUM_CHANGE_ABILITY = 0x00000002 # 人数变化检测
SPACING_CHANGE_ABILITY = 0x00000004 # 间距变化检测
EVENT_COMBINED_ABILITY = 0x00000008 # 组合事件规则
EVENT_SIT_QUIETLY = 0x00000010 # 静坐
EVENT_HIGH_DENSITY_STATUS_ABILITY = 0x00000020 # 人员聚集状态
EVENT_RUNNING = 0x00000040 # 奔跑
EVENT_RETENTION = 0x00000080 # 滞留
EVENT_TEACHER_WRITING = 0x00000100 # 板书

VCA_BEHAVIOR_BASE = 1 # 行为分析基本版
VCA_BEHAVIOR_ADVANCE = 2 # 行为分析高级版
VCA_BEHAVIOR_FULL = 3 # 行为分析完整版
VCA_PLATE = 4 # 车牌能力
VCA_ATM = 5 # ATM能力
VCA_PDC = 6 # 人流量统计
VCA_ITS = 7 # 智能 交通事件
VCA_BEHAVIOR_PRISON = 8 # 行为分析监狱版(监舍)
VCA_FACE_SNAP = 9 # 人脸抓拍能力
VCA_FACE_SNAPRECOG = 10 # 人脸抓拍和识别能力
VCA_FACE_RETRIEVAL = 11 # 人脸后检索能力
VCA_FACE_RECOG = 12 # 人脸识别能力
VCA_BEHAVIOR_PRISON_PERIMETER = 13 # 行为分析监狱版(周界)
VCA_TPS = 14 # 交通诱导
VCA_TFS = 15 # 道路违章取证
VCA_BEHAVIOR_FACESNAP = 16 # 人脸抓拍和行为分析能力
VCA_HEATMAP = 17 # 热度图
VCA_SMART_VEHICLE_DETECTION = 18 # SMART事件 + 车辆检测
VCA_SMART_HVT_DETECTION = 19 # SMART事件 + 混行检测
VCA_SMART_EVENT = 20 # SMART事件
VCA_VEHICLE_DETECTION = 21 # 车辆检测
VCA_SMART_ROAD_DETECTION = 22 # SMART事件 + 道路监控
VCA_SMART_FACE_DETECTION = 23 # SMART事件 + 人脸侦测
VCA_SMART_HEATMAP = 24 # SMART事件 + 热度图
VCA_HUMAN_RECOGNITION = 25 # 人体识别
VCA_EDUCATION_STUDENT_DETECTION = 26 # 教育录播（学生起来检测 & & 学生人数统计）
VCA_ROAD_DETECTION = 27 # 道路监控
VCA_PERSON_DENSITY_DETECTION = 28 # 人员密度检测
VCA_PERIMETER_CAPTURE = 29 # 周界抓拍
VCA_SAFETY_HELMET_DETECTION = 30 # 安全帽检测
VCA_HEEL_PDC = 31 # 倾斜客流
VCA_12MPLIVE_VIEW = 32 # 主码流 1200 W @ 20 fps预览（4000 * 3000）
VCA_TEACHER_BEHAVIOR_DETECTION = 33 # 教师行为检测
VCA_MIXED_TARGET_DETECTION = 34 # 混合目标检测
VCA_FACE_CONTRAST = 35 # 人脸对比检测(同时支持人脸抓拍及人脸对比功能，但是算法核心不同。算法采用人脸比对为核心，确保每次比对成功。若目标不适合对比则将舍弃对该目标进行抓拍。)
VCA_CITY_MANAGEMENT = 36 # 智慧城管
VCA_MIXED_TARGET_DETECTION_SMART = 37 # 混合目标检测加Smart

VCA_ATM_PANEL = 0 # ATM面板
VCA_ATM_SURROUND = 1 # ATM环境
VCA_ATM_FACE = 2 # ATM人脸
VCA_ATM_SAFETYCABIN = 3 # ATM防护舱

TFS_CITYROAD = 0 # TFS 城市道路
TFS_FREEWAY = 1 # TFS 高速道路

BEHAVIOR_SCENE_DEFAULT = 0 # 系统默认
BEHAVIOR_SCENE_WALL = 1 # 围墙
BEHAVIOR_SCENE_INDOOR = 2 # 室内

BEHAVIOR_PRISON = 0 # 监所
BEHAVIOR_HEARING = 1 # 审讯室
BEHAVIOR_RECFIELD = 2 # 放风场


# 通道能力输入参数
class NET_VCA_CHAN_IN_PARAM(Structure):
    _fields_ = [
        ("byVCAType", BYTE), # VCA_CHAN_ABILITY_TYPE枚举值
        ("byMode", BYTE), # 模式，ATM 能力时参照VCA_CHAN_MODE_TYPE,TFS能力时参照TFS_CHAN_MODE_TYPE,当VCA_TYPE 为交通事件时参照TRAFFIC_SCENE_MODE
        ("byRes", BYTE * 2), # 保留，设置为0
    ]


LPNET_VCA_CHAN_IN_PARAM = POINTER(NET_VCA_CHAN_IN_PARAM)


# 行为能力集结构
class NET_VCA_BEHAVIOR_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwAbilityType", DWORD), # 支持的能力类型，按位表示，见VCA_ABILITY_TYPE定义
        ("byMaxRuleNum", BYTE), # 最大规则数
        ("byMaxTargetNum", BYTE), # 最大目标数
        ("bySupport", BYTE), #  支持的功能类型   按位表示
        # bySupport & 0x01 支持标定功能
        ("byRes", BYTE * 5), # 保留，设置为0
        ("dwAbilityTypeEx", DWORD), # 支持的能力类型，按位表示，见VCA_ABILITY_TYPE_EX定义
    ]


LPNET_VCA_BEHAVIOR_ABILITY = POINTER(NET_VCA_BEHAVIOR_ABILITY)


# 场景变更数据更新参数
class NET_DVR_SCENE_CHANGE_UPDATE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIDCount", BYTE), # 实际流ID数
        ("byRes1", BYTE * 3),
        ("byStreamID", BYTE * MAX_STREAM_ID_NUM),
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_SCENE_CHANGE_UPDATE_PARAM = POINTER(NET_DVR_SCENE_CHANGE_UPDATE_PARAM)


#  交通能力集结构
class NET_DVR_ITS_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwAbilityType", DWORD), #  支持的能力列表  参照ITS_ABILITY_TYPE
        ("byMaxRuleNum", BYTE), # 最大规则数
        ("byMaxTargetNum", BYTE), # 最大目标数
        ("byRes", BYTE * 10), #  保留
    ]


LPNET_DVR_ITS_ABILITY = POINTER(NET_DVR_ITS_ABILITY)


# 智能参数结构
# 智能共用结构
# 坐标值归一化,浮点数值为当前画面的百分比大小, 精度为小数点后三位

# 行为分析事件类型
VCA_TRAVERSE_PLANE = 0x1 # 穿越警戒面
VCA_ENTER_AREA = 0x2 # 目标进入区域, 支持区域规则
VCA_EXIT_AREA = 0x4 # 目标离开区域, 支持区域规则
VCA_INTRUSION = 0x8 # 周界入侵, 支持区域规则
VCA_LOITER = 0x10 # 徘徊, 支持区域规则
VCA_LEFT_TAKE = 0x20 # 物品遗留拿取, 支持区域规则
VCA_PARKING = 0x40 # 停车, 支持区域规则
VCA_RUN = 0x80 # 快速移动, 支持区域规则
VCA_HIGH_DENSITY = 0x100 # 区域内人员聚集, 支持区域规则
VCA_VIOLENT_MOTION = 0x200 # 剧烈运动检测
VCA_REACH_HIGHT = 0x400 # 攀高检测
VCA_GET_UP = 0x800 # 起身检测
VCA_LEFT = 0x1000 # 物品遗留
VCA_TAKE = 0x2000 # 物品拿取
VCA_LEAVE_POSITION = 0x4000 # 离岗
VCA_TRAIL = 0x8000 # 尾随
VCA_KEY_PERSON_GET_UP = 0x10000 # 重点人员起身检测
VCA_STANDUP = 0x20000 # 起立
VCA_FALL_DOWN = 0x80000 # 倒地检测
VCA_AUDIO_ABNORMAL = 0x100000 # 声强突变检测
VCA_ADV_REACH_HEIGHT = 0x200000 # 折线攀高
VCA_TOILET_TARRY = 0x400000 # 如厕超时
VCA_YARD_TARRY = 0x800000 # 放风场滞留
VCA_ADV_TRAVERSE_PLANE = 0x1000000 # 折线警戒面
VCA_LECTURE = 0x2000000 # 授课
VCA_ANSWER = 0x4000000 # 回答问题
VCA_HUMAN_ENTER = 0x10000000 # 人靠近ATM 只在ATM_PANEL模式下支持
VCA_OVER_TIME = 0x20000000 # 操作超时 只在ATM_PANEL模式下支持
VCA_STICK_UP = 0x40000000 # 贴纸条, 支持区域规则
VCA_INSTALL_SCANNER = 0x80000000 # 安装读卡器, 支持区域规则

# 行为分析事件类型扩展
ENUM_VCA_EVENT_TRAVERSE_PLANE = 1 # 穿越警戒面
ENUM_VCA_EVENT_ENTER_AREA = 2 # 目标进入区域, 支持区域规则
ENUM_VCA_EVENT_EXIT_AREA = 3 # 目标离开区域, 支持区域规则
ENUM_VCA_EVENT_INTRUSION = 4 # 周界入侵, 支持区域规则
ENUM_VCA_EVENT_LOITER = 5 # 徘徊, 支持区域规则
ENUM_VCA_EVENT_LEFT_TAKE = 6 # 物品遗留拿取, 支持区域规则
ENUM_VCA_EVENT_PARKING = 7 # 停车, 支持区域规则
ENUM_VCA_EVENT_RUN = 8 # 快速移动, 支持区域规则
ENUM_VCA_EVENT_HIGH_DENSITY = 9 # 区域内人员聚集, 支持区域规则
ENUM_VCA_EVENT_VIOLENT_MOTION = 10 # 剧烈运动检测
ENUM_VCA_EVENT_REACH_HIGHT = 11 # 攀高检测
ENUM_VCA_EVENT_GET_UP = 12 # 起身检测
ENUM_VCA_EVENT_LEFT = 13 # 物品遗留
ENUM_VCA_EVENT_TAKE = 14 # 物品拿取
ENUM_VCA_EVENT_LEAVE_POSITION = 15 # 离岗
ENUM_VCA_EVENT_TRAIL = 16 # 尾随
ENUM_VCA_EVENT_KEY_PERSON_GET_UP = 17 # 重点人员起身检测
ENUM_VCA_EVENT_STANDUP = 18 # 起立
ENUM_VCA_EVENT_FALL_DOWN = 20 # 倒地检测
ENUM_VCA_EVENT_AUDIO_ABNORMAL = 21 # 声强突变检测
ENUM_VCA_EVENT_ADV_REACH_HEIGHT = 22 # 折线攀高
ENUM_VCA_EVENT_TOILET_TARRY = 23 # 如厕超时
ENUM_VCA_EVENT_YARD_TARRY = 24 # 放风场滞留
ENUM_VCA_EVENT_ADV_TRAVERSE_PLANE = 25 # 折线警戒面
ENUM_VCA_EVENT_LECTURE = 26 # 授课（文教）
ENUM_VCA_EVENT_ANSWER = 27 # 回答问题（文教）
ENUM_VCA_EVENT_HUMAN_ENTER = 29 # 人靠近ATM, 只在ATM_PANEL模式下支持
ENUM_VCA_EVENT_OVER_TIME = 30 # 操作超时, 只在ATM_PANEL模式下支持
ENUM_VCA_EVENT_STICK_UP = 31 # 贴纸条, 支持区域规则
ENUM_VCA_EVENT_INSTALL_SCANNER = 32 # 安装读卡器, 支持区域规则
ENUM_VCA_EVENT_PEOPLENUM_CHANGE = 35 # 人数变化事件
ENUM_VCA_EVENT_SPACING_CHANGE = 36 # 间距变化事件
ENUM_VCA_EVENT_COMBINED_RULE = 37 # 组合规则事件
ENUM_VCA_EVENT_SIT_QUIETLY = 38 # 一动不动（静坐）    则事件
ENUM_VCA_EVENT_HIGH_DENSITY_STATUS = 39 # 区域内人员聚集状态
ENUM_VCA_EVENT_RUNNING = 40 # 奔跑检测
ENUM_VCA_EVENT_RETENTION = 41 # 滞留检测
ENUM_VCA_EVENT_BLACKBOARD_WRITE = 42 # 板书
ENUM_VCA_EVENT_SITUATION_ANALYSIS = 43 # 态势分析
ENUM_VCA_EVENT_PLAY_CELLPHONE = 44 # 玩手机检测
ENUM_VCA_EVENT_DURATION = 45 # 持续报警

VCA_BOTH_DIRECTION = 0 # 双向
VCA_LEFT_GO_RIGHT = 1 # 由左至右
VCA_RIGHT_GO_LEFT = 2 # 由右至左

# 线结构
class NET_VCA_LINE(Structure):
    _fields_ = [
        ("struStart", NET_VCA_POINT), # 起点
        ("struEnd", NET_VCA_POINT), # 终点
    ]


LPNET_VCA_LINE = POINTER(NET_VCA_LINE)


# 多边型结构体
class NET_VCA_POLYGON(Structure):
    _fields_ = [
        ("dwPointNum", DWORD), # 有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域
        ("struPos", NET_VCA_POINT * VCA_MAX_POLYGON_POINT_NUM), # 多边形边界点,最多十个
    ]


LPNET_VCA_POLYGON = POINTER(NET_VCA_POLYGON)


# 警戒面参数
class NET_VCA_TRAVERSE_PLANE(Structure):
    _fields_ = [
        ("struPlaneBottom", NET_VCA_LINE), # 警戒面底边
        ("dwCrossDirection", LONG), # 穿越方向: 0-双向，1-从左到右，2-从右到左
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byPlaneHeight", BYTE), # 警戒面高度
        #
        # 检测目标，可支持多选，具体定义为：
        # 0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
        # 0x01 ~ 人，
        # 0x02 ~ 车，
        # 0x04 ~ 其他，
        # 该字段支持多选，按位取值，例如3表示1+2.
        #
        ("byDetectionTarget", BYTE),
        ("byPriority", BYTE), # 优先级,0~低,1~中,2~高
        ("byRes2", BYTE * 36), # 保留留
    ]


LPNET_VCA_TRAVERSE_PLANE = POINTER(NET_VCA_TRAVERSE_PLANE)


class NET_VCA_SIT_QUIETLY(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        # 规则触发顺序，0-顺序或逆序触发，1-顺序触发
        ("dwDuration", DWORD), # 持续时间  单位s 范围1-3600
        ("byRes", BYTE * 4),
    ]


LPNET_VCA_SIT_QUIETLY = POINTER(NET_VCA_SIT_QUIETLY)


# 进入/离开区域参数
class NET_VCA_AREA(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        #
        # 检测目标，可支持多选，具体定义为：
        # 0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
        # 0x01 ~ 人，
        # 0x02 ~ 车，
        # 0x04 ~ 其他，
        # 该字段支持多选，按位取值，例如3表示1+2.
        #
        ("byDetectionTarget", BYTE),
        ("byPriority", BYTE), # 优先级,0~低,1~中,2~高
        ("byRes", BYTE * 5),
    ]


LPNET_VCA_AREA = POINTER(NET_VCA_AREA)


# 根据报警延迟时间来标识报警中带图片，报警间隔和IO报警一致，1秒发送一个。
# 入侵参数
class NET_VCA_INTRUSION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 行为事件触发时间阈值: 1-120秒，建议5秒，判断是有效报警的时间  在ATM系统中触发文件阈值为 1-1000秒
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        ("byRate", BYTE), # 占比：区域内所有未报警目标尺寸目标占区域面积的比重，归一化为－；
        #
        # 检测目标，可支持多选，具体定义为：
        # 0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
        # 0x01 ~ 人，
        # 0x02 ~ 车，
        # 0x04 ~ 其他，
        # 该字段支持多选，按位取值，例如3表示1+2.
        #
        ("byDetectionTarget", BYTE),
        ("byPriority", BYTE), # 优先级,0~低,1~中,2~高
        ("byRes", BYTE * 2), # 保留
    ]


LPNET_VCA_INTRUSION = POINTER(NET_VCA_INTRUSION)


# 徘徊参数
class NET_VCA_LOITER(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 触发时间阈值：1-120秒，建议10秒
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byRes", BYTE * 1),
        ("dwLoiterDistance", DWORD), # 行程总距离阈值：100-5000，默认1000cm
    ]


LPNET_VCA_LOITER = POINTER(NET_VCA_LOITER)


# 物品遗留/物品拿取参数
class NET_VCA_TAKE_LEFT(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 触发时间阈值：1-120秒，建议10秒
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byRes", BYTE * 5),
    ]


LPNET_VCA_TAKE_LEFT = POINTER(NET_VCA_TAKE_LEFT)


# 停车参数
class NET_VCA_PARKING(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 触发时间阈值：1-100秒，建议10秒
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byRes", BYTE * 5),
    ]


LPNET_VCA_PARKING = POINTER(NET_VCA_PARKING)


# 快速移动参数
class NET_VCA_RUN(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("fRunDistance", DOUBLE), # 人快速移动最大距离, 范围: [0.1, 1.00] 像素模式 实际模式(1,20)m/s
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byMode", BYTE), #  0 像素模式  1 实际模式
        #
        # 检测目标，可支持多选，具体定义为：
        # 0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
        # 0x01 ~ 人，
        # 0x02 ~ 车，，
        # 0x04 ~ 其他，
        # 该字段支持多选，按位取值，例如3表示1+2.
        #
        ("byDetectionTarget", BYTE),
        ("byRes", BYTE),
    ]


LPNET_VCA_RUN = POINTER(NET_VCA_RUN)


# 人员聚集参数
class NET_VCA_HIGH_DENSITY(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("fDensity", DOUBLE), # 聚集比率, 范围: [0.1, 1.0]
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byRes", BYTE), #  保留字节
        ("wDuration", WORD), #  触发人员聚集参数报警阈值 20-360s
    ]


LPNET_VCA_HIGH_DENSITY = POINTER(NET_VCA_HIGH_DENSITY)


# 剧烈运动参数
class NET_VCA_VIOLENT_MOTION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 触发剧烈运动报警阈值：1-50秒
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byMode", BYTE), # 0-纯视频模式，1-音视频联合模式，2-纯音频模式
        ("byRes", BYTE * 4), # 保留
    ]


LPNET_VCA_VIOLENT_MOTION = POINTER(NET_VCA_VIOLENT_MOTION)


#  攀高参数
class NET_VCA_REACH_HIGHT(Structure):
    _fields_ = [
        ("struVcaLine", NET_VCA_LINE), # 攀高警戒面
        ("wDuration", WORD), # 触发攀高报警阈值：1-120秒
        ("byRes", BYTE * 6), #  保留字节
    ]


LPNET_VCA_REACH_HIGHT = POINTER(NET_VCA_REACH_HIGHT)


#  起床参数
class NET_VCA_GET_UP(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 触发起床报警阈值1-100 秒
        ("byMode", BYTE), # 起身检测模式,0-大床通铺模式,1-高低铺模式,2-大床通铺坐立起身模式
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,10]
        ("byRes", BYTE * 4), # 保留字节
    ]


LPNET_VCA_GET_UP = POINTER(NET_VCA_GET_UP)


#  物品遗留
class NET_VCA_LEFT(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), #  区域范围
        ("wDuration", WORD), #  触发物品遗留报警阈值 10-100秒
        ("bySensitivity", BYTE), #  灵敏度参数，范围[1,5]
        ("byRes", BYTE * 5), #  保留字节
    ]


LPNET_VCA_LEFT = POINTER(NET_VCA_LEFT)


#  物品拿取
class NET_VCA_TAKE(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), #  区域范围
        ("wDuration", WORD), #  触发物品拿取报警阈值10-100秒
        ("bySensitivity", BYTE), #  灵敏度参数，范围[1,5]
        ("byRes", BYTE * 5), #  保留字节
    ]


LPNET_VCA_TAKE = POINTER(NET_VCA_TAKE)


class NET_VCA_OVER_TIME(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), #  区域范围
        ("wDuration", WORD), #  操作报警时间阈值 4s-60000s
        ("byRes", BYTE * 6), #  保留字节
    ]


LPNET_VCA_OVER_TIME = POINTER(NET_VCA_OVER_TIME)


class NET_VCA_HUMAN_ENTER(Structure):
    _fields_ = [
        ("dwRes", DWORD * 23), # 保留字节
    ]


LPNET_VCA_HUMAN_ENTER = POINTER(NET_VCA_HUMAN_ENTER)


# 贴纸条参数
class NET_VCA_STICK_UP(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 触发时间阈值：4-60秒，建议10秒
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byRes", BYTE * 5),
    ]


LPNET_VCA_STICK_UP = POINTER(NET_VCA_STICK_UP)


# 读卡器参数
class NET_VCA_SCANNER(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 读卡持续时间：4-60秒
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byRes", BYTE * 5),
    ]


LPNET_VCA_SCANNER = POINTER(NET_VCA_SCANNER)


# 离岗事件
class NET_VCA_LEAVE_POSITION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wLeaveDelay", WORD), # 无人报警时间，单位：s
        ("wStaticDelay", WORD), # 睡觉报警时间，单位：s
        ("byMode", BYTE), # 模式，0-离岗事件，1-睡岗事件，2-离岗睡岗事件
        ("byPersonType", BYTE), # 值岗人数类型，0-单人值岗，1-双人值岗
        ("byOnPosition", BYTE), # 在岗人数，1-10，默认1
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
    ]


LPNET_VCA_LEAVE_POSITION = POINTER(NET_VCA_LEAVE_POSITION)


# 尾随参数
class NET_VCA_TRAIL(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wRes", WORD), #  保留
        ("bySensitivity", BYTE), #  灵敏度参数，范围[1,5]
        ("byRes", BYTE * 5),
    ]


LPNET_VCA_TRAIL = POINTER(NET_VCA_TRAIL)


# 倒地参数
class NET_VCA_FALL_DOWN(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), #  触发事件阈值 1-60s
        ("bySensitivity", BYTE), #  灵敏度参数，范围[1,5]
        ("byHeightThreshold", BYTE), # 高度阈值，范围[0,250]，默认90，单位：厘米
        ("byRes", BYTE * 4),
    ]


LPNET_VCA_FALL_DOWN = POINTER(NET_VCA_FALL_DOWN)


# 起立
class NET_VCA_STANDUP(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,100]
        ("byHeightThreshold", BYTE), # 高度阈值，范围[0,250]，默认130，单位：厘米
        ("wDuration", WORD), # 触发事件阈值[1,3600]，默认2，单位：秒
        ("byRes", BYTE * 4), # 保留
    ]


LPNET_VCA_STANDUP = POINTER(NET_VCA_STANDUP)


# 人数变化
class NET_VCA_PEOPLENUM_CHANGE(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,100]
        ("byPeopleNumThreshold", BYTE), # 人数阈值，范围[0,5]，默认1
        ("byDetectMode", BYTE), # 检测方式，与人数阈值相比较。1-大于，2-小于，3-等于，4-不等于
        ("byNoneStateEffective", BYTE), # 无人状态是否有效，0-无效，1-有效
        ("wDuration", WORD), # 触发时间阈值[1,3600]，默认2，单位：秒
        ("byPeopleNum", BYTE), # 触发报警人数，只读，仅报警上报，设备返回0表示不支持本功能上报，0xff表示报警人数为0
        ("byRes", BYTE), # 保留
    ]


LPNET_VCA_PEOPLENUM_CHANGE = POINTER(NET_VCA_PEOPLENUM_CHANGE)


# 间距变化
class NET_VCA_SPACING_CHANGE(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("fSpacingThreshold", DOUBLE), # 间距阈值，范围[0,10.0]，默认1.0，单位：米
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,100]
        ("byDetectMode", BYTE), # 检测方式，与间距阈值相比较。1-大于，2-小于
        ("wDuration", WORD), # 触发时间阈值[1,3600]，默认2，单位：秒
    ]


LPNET_VCA_SPACING_CHANGE = POINTER(NET_VCA_SPACING_CHANGE)


# 声强突变参数
class NET_VCA_AUDIO_ABNORMAL(Structure):
    _fields_ = [
        ("wDecibel", WORD), # 声音强度
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,100]
        ("byAudioMode", BYTE), # 声音检测模式，0-灵敏度检测，1-分贝阈值检测，2-灵敏度与分贝阈值检测
        ("byEnable", BYTE), # 使能，是否开启(声强突变，陡升)
        ("byThreshold", BYTE), # 声音阈值[1,100]
        ("byRes", BYTE * 54), # 保留
    ]


LPNET_VCA_AUDIO_ABNORMAL = POINTER(NET_VCA_AUDIO_ABNORMAL)


# 声强陡降 2014-03-21
class NET_DVR_AUDIO_STEEP_DROP(Structure):
    _fields_ = [
        ("bySensitivity", BYTE), #  灵敏度参数，范围[1,100]
        ("byEnable", BYTE), # 使能，是否开启(声强突变，陡降)
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_AUDIO_STEEP_DROP = POINTER(NET_DVR_AUDIO_STEEP_DROP)


class NET_DVR_AUDIO_EXCEPTION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableAudioInException", BYTE), # 使能，是否开启
        ("byRes1", BYTE * 3),
        ("struAudioAbnormal", NET_VCA_AUDIO_ABNORMAL),
        ("struAlarmSched", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V40), # 异常处理方式
        ("dwMaxRelRecordChanNum", DWORD), # 报警触发的录象通道 数（只读）最大支持数量
        ("dwRelRecordChanNum", DWORD), # 报警触发的录象通道 数 实际支持的数量
        ("byRelRecordChan", DWORD * MAX_CHANNUM_V30),
        ("struAudioSteepDrop", NET_DVR_AUDIO_STEEP_DROP), # 声强陡降
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_AUDIO_EXCEPTION = POINTER(NET_DVR_AUDIO_EXCEPTION)


class NET_VCA_TOILET_TARRY(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDelay", WORD), # 如厕超时时间[1,3600]，单位：秒
        ("byRes", BYTE * 6),
    ]


LPNET_VCA_TOILET_TARRY = POINTER(NET_VCA_TOILET_TARRY)


class NET_VCA_YARD_TARRY(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDelay", WORD), # 放风场滞留时间[1,120]，单位：秒
        ("byRes", BYTE * 6),
    ]


LPNET_VCA_YARD_TARRY = POINTER(NET_VCA_YARD_TARRY)


class NET_VCA_ADV_REACH_HEIGHT(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 攀高折线
        ("dwCrossDirection", DWORD), # 跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
        ("byRes", BYTE * 4), #  保留字节
    ]


LPNET_VCA_ADV_REACH_HEIGHT = POINTER(NET_VCA_ADV_REACH_HEIGHT)


class NET_VCA_ADV_TRAVERSE_PLANE(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 警戒面折线
        ("dwCrossDirection", DWORD), # 跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byRes", BYTE * 3), # 保留字节
    ]


LPNET_VCA_ADV_TRAVERSE_PLANE = POINTER(NET_VCA_ADV_TRAVERSE_PLANE)


class NET_VCA_PLAY_CELLPHONE(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 玩手机超时时间[1,600]秒, 默认20秒
        ("byRes", BYTE * 6), # 保留字节
    ]


LPNET_VCA_PLAY_CELLPHONE = POINTER(NET_VCA_PLAY_CELLPHONE)


class NET_VCA_LECTURE(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("wDuration", WORD), # 行为事件触发时间阈值: 1-10秒，建议1秒，判断是有效报警的时间
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        ("byAlarmState", BYTE), # 只读字段界面不显示；0-保留,1-报警开始,2-报警结束
        ("byTrackingMode", BYTE), # 跟踪模式，0-自动(默认) , 1-水平, 2-垂直
        ("byZoomMode", BYTE), # 变倍模式, 0-固定(默认), 1-自动
        ("byZoomOver", BYTE), # 0-保留,1-变倍到位(报警上传录播主机，作为切换画面判断依据)
        ("byTrackStatus", BYTE), # 跟踪状态 0-保留，1-开始授课（A，全景） 2-正在跟踪（2,特写），3 -跟踪丢失（2,全景）
    ]


LPNET_VCA_LECTURE = POINTER(NET_VCA_LECTURE)


class NET_VCA_ANSWER(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        ("byAlarmState", BYTE), # 只读字段界面不显示；0-保留,1-报警开始,2-报警结束
        ("byZoomOver", BYTE), # 0-保留,1-变倍到位(报警上传录播主机，作为切换画面判断依据)
        ("byAnswerStudent", BYTE), # 0-保留，1-无学生起立，2-单个学生起立，3-多个学生起立,4-疑似学生起立, 5-单个学生走动
        ("byRes", BYTE * 4), # 保留
    ]


LPNET_VCA_ANSWER = POINTER(NET_VCA_ANSWER)


# 关联规则结构体
class NET_VCA_RELATE_RULE_PARAM(Structure):
    _fields_ = [
        ("byRuleID", BYTE), # 规则序号 0-表示无
        ("byRes", BYTE), # 保留
        ("wEventType", WORD), # 行为事件类型，参考VCA_RULE_EVENT_TYPE_EX留
    ]


LPNET_VCA_RELATE_RULE_PARAM = POINTER(NET_VCA_RELATE_RULE_PARAM)


class NET_VCA_COMBINED_RULE(Structure):
    _fields_ = [
        # 规则触发顺序，0-顺序或逆序触发，1-顺序触发
        ("byRuleSequence", BYTE),
        ("byRes", BYTE * 7),
        ("dwMinInterval", DWORD), # 最小时间间隔，单位：秒
        ("dwMaxInterval", DWORD), # 最大时间间隔，单位：秒
        ("struRule1Raram", NET_VCA_RELATE_RULE_PARAM), # 规则1
        ("struRule2Raram", NET_VCA_RELATE_RULE_PARAM), # 规则2
        ("byRes1", BYTE * 36),
    ]


LPNET_VCA_COMBINED_RULE = POINTER(NET_VCA_COMBINED_RULE)


# 板书事件
class NET_VCA_BLACKBOARD_WRITE(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围（配置区域，报警中不含有该区域）
        ("byTeacherState", BYTE), # 教师状态；0~教师特写，1~教师全景，2~讲台无人状态
        ("byWritingState", BYTE), # 板书状态；0~板书开始，1~板书结束
        ("byWritingArea", BYTE), # 板书区域；0~整个板书，1~板书左边，2~板书右边
        ("byRes", BYTE * 5),
    ]


LPNET_VCA_BLACKBOARD_WRITE = POINTER(NET_VCA_BLACKBOARD_WRITE)


# 人员聚集状态
class NET_VCA_HIGH_DENSITY_STATUS(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("fDensity", DOUBLE), # 聚集比率, 范围: [0.1, 1.0]
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,5]
        ("byRes", BYTE * 3), #  保留字节
    ]


LPNET_VCA_HIGH_DENSITY_STATUS = POINTER(NET_VCA_HIGH_DENSITY_STATUS)


# 奔跑检测
class NET_VCA_RUNNING(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("dwSpeed", DWORD), # 奔跑速度，范围[1,10]
        ("wDuration", WORD), #  触发报警时间阈值
        ("byRunMode", BYTE), # 奔跑模式，0-保留,1：单人奔跑,2:多人奔跑
        ("byRes", BYTE),
    ]


LPNET_VCA_RUNNING = POINTER(NET_VCA_RUNNING)


#  滞留检测
class NET_VCA_RETENTION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), #  区域范围
        ("wDuration", WORD), # 触发滞留报警阈值时间（60-3600秒）默认1800秒
        ("byRes", BYTE * 6), #  保留字节
    ]


LPNET_VCA_RETENTION = POINTER(NET_VCA_RETENTION)


#  态势分析参数
class NET_VCA_SITUATION_ANALYSIS(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), #  区域范围
        ("wPeopleNum", WORD), # 区域人数
        ("byRes", BYTE * 6), #  保留字节
    ]


LPNET_VCA_SITUATION_ANALYSIS = POINTER(NET_VCA_SITUATION_ANALYSIS)


# 持续报警
class NET_VCA_DURATION(Structure):
    _fields_ = [
        ("wRelationEventType", WORD), # 参考VCA_RULE_EVENT_TYPE_EX
        ("byRes", BYTE * 90),
    ]


LPNET_VCA_DURATION = POINTER(NET_VCA_DURATION)


# 警戒事件参数
class NET_VCA_EVENT_UNION(Union):
    _fields_ = [
        ("uLen", DWORD * 23), # 参数
        ("struTraversePlane", NET_VCA_TRAVERSE_PLANE), # 穿越警戒面参数
        ("struArea", NET_VCA_AREA), # 进入/离开区域参数
        ("struIntrusion", NET_VCA_INTRUSION), # 入侵参数
        ("struLoiter", NET_VCA_LOITER), # 徘徊参数
        ("struTakeTeft", NET_VCA_TAKE_LEFT), # 物品遗留/物品拿取参数
        ("struParking", NET_VCA_PARKING), # 停车参数
        ("struRun", NET_VCA_RUN), # 快速移动参数
        ("struHighDensity", NET_VCA_HIGH_DENSITY), # 人员聚集参数
        ("struViolentMotion", NET_VCA_VIOLENT_MOTION), # 剧烈运动
        ("struReachHight", NET_VCA_REACH_HIGHT), # 攀高
        ("struGetUp", NET_VCA_GET_UP), # 起床
        ("struLeft", NET_VCA_LEFT), # 物品遗留
        ("struTake", NET_VCA_TAKE), #  物品拿取
        ("struHumanEnter", NET_VCA_HUMAN_ENTER), # 人员进入
        ("struOvertime", NET_VCA_OVER_TIME), # 操作超时
        ("struStickUp", NET_VCA_STICK_UP), # 贴纸条
        ("struScanner", NET_VCA_SCANNER), # 读卡器参数
        ("struLeavePos", NET_VCA_LEAVE_POSITION), # 离岗参数
        ("struTrail", NET_VCA_TRAIL), # 尾随参数
        ("struFallDown", NET_VCA_FALL_DOWN), # 倒地参数
        ("struAudioAbnormal", NET_VCA_AUDIO_ABNORMAL), # 声强突变
        ("struReachHeight", NET_VCA_ADV_REACH_HEIGHT), # 折线攀高参数
        ("struToiletTarry", NET_VCA_TOILET_TARRY), # 如厕超时参数
        ("struYardTarry", NET_VCA_YARD_TARRY), # 放风场滞留参数
        ("struAdvTraversePlane", NET_VCA_ADV_TRAVERSE_PLANE), # 折线警戒面参数
        ("struLecture", NET_VCA_LECTURE), # 授课事件
        ("struAnswer", NET_VCA_ANSWER), # 回答问题事件
        ("struStandUp", NET_VCA_STANDUP), # 起立参数
        ("struPeopleNumChange", NET_VCA_PEOPLENUM_CHANGE), # 人数变化参数
        ("struSpacingChange", NET_VCA_SPACING_CHANGE), # 间距变化参数
        ("struCombinedRule", NET_VCA_COMBINED_RULE), # 组合规则参数
        ("struSitQuietly", NET_VCA_SIT_QUIETLY), # 静坐参数
        ("struHighDensityStatus", NET_VCA_HIGH_DENSITY_STATUS), # 人员聚集状态
        ("struRunning", NET_VCA_RUNNING), # 奔跑参数
        ("struRetention", NET_VCA_RETENTION), # 滞留检测
        ("struBlackboardWrite", NET_VCA_BLACKBOARD_WRITE), # 板书参数
        ("struSituationAnalysis", NET_VCA_SITUATION_ANALYSIS), # 态势分析参数
        ("struPlayCellphone", NET_VCA_PLAY_CELLPHONE), # 玩手机检测参数
        ("struDruation", NET_VCA_DURATION), # 持续报警参数
    ]


LPNET_VCA_EVENT_UNION = POINTER(NET_VCA_EVENT_UNION)

IMAGE_PIX_MODE = 0 # 根据像素大小设置
REAL_WORLD_MODE = 1 # 根据实际大小设置
DEFAULT_MODE = 2 # 默认模式


# 尺寸过滤器
class NET_VCA_SIZE_FILTER(Structure):
    _fields_ = [
        ("byActive", BYTE), # 是否激活尺寸过滤器 0-否 非0-是
        ("byMode", BYTE), # 过滤器模式SIZE_FILTER_MODE
        ("byRes", BYTE * 2), # 保留，置0
        ("struMiniRect", NET_VCA_RECT), # 最小目标框,全0表示不设置
        ("struMaxRect", NET_VCA_RECT), # 最大目标框,全0表示不设置
    ]


LPNET_VCA_SIZE_FILTER = POINTER(NET_VCA_SIZE_FILTER)


# 警戒规则结构
class NET_VCA_ONE_RULE(Structure):
    _fields_ = [
        ("byActive", BYTE), # 是否激活规则,0-否,非0-是
        ("byRes", BYTE * 7), # 保留，设置为0字段
        ("byRuleName", BYTE * NAME_LEN), # 规则名称
        ("dwEventType", DWORD), # 行为分析事件类型
        ("uEventParam", NET_VCA_EVENT_UNION), # 行为分析事件参数
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
    ]


LPNET_VCA_ONE_RULE = POINTER(NET_VCA_ONE_RULE)


# 行为分析配置结构体
class NET_VCA_RULECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 非0-上传
        ("byUpLastAlarm", BYTE), # 2011-04-06 是否先上传最近一次的报警
        ("byPicRecordEnable", BYTE), # 2012-3-1是否启用图片存储, 0-不启用, 1-启用
        ("byRes", BYTE),
        ("struPictureParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struRule", NET_VCA_ONE_RULE * MAX_RULE_NUM), # 规则数组
    ]


LPNET_VCA_RULECFG = POINTER(NET_VCA_RULECFG)


# 前端设备地址信息，智能分析仪表示的是前端设备的地址信息，其他设备表示本机的地址
#
# 当接入设备模拟通道(IPC/DVR/DVS/IVMS)报警的时候，下面字段填写设备的IP地址，端口，byChannel和byIvmsChannel 均为当前的模拟通道号
# eg:
# struDevIP =  模拟通道对应设备的IP地址
# wPort  =  模拟通道对应设备的端口
# byChannel =  报警对应模拟通道的通道号
# byIvmsChannel = 报警对应模拟通道的通道号
# 当接入设备数字通道(DVR/DVS/IVMS)报警的时候，下面字段填写数字通道接入设备的IP地址，端口，byChannel为数字通道接入设备的通道号，byIvmsChannel为数字通道号
# eg:
# struDevIP =  数字通道接入设备的IP地址
# wPort  =  数字通道接入设备的端口
# byChannel =  数字通道接入设备的通道号
# byIvmsChannel = 数字通道号

class NET_VCA_DEV_INFO(Structure):
    _fields_ = [
        ("struDevIP", NET_DVR_IPADDR), # 前端设备地址，
        ("wPort", WORD), # 前端设备端口号，
        ("byChannel", BYTE), # 前端设备通道，
        ("byIvmsChannel", BYTE), #  Ivms 通道
    ]


LPNET_VCA_DEV_INFO = POINTER(NET_VCA_DEV_INFO)


class NET_DVR_TARGET_LEFT_REGION_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("byTargetType", BYTE), # 检测目标类型 0-无效目标，1-教师 2-学生
        ("byLeftDirection", BYTE), # 检测目标离开方向类型0-保留,1-上,2-下,3-左,4-右
        ("byTargetStatus", BYTE), # 0-保留(不做处理)
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_TARGET_LEFT_REGION_ALARM = POINTER(NET_DVR_TARGET_LEFT_REGION_ALARM)


#  报警图片图片信息
class NET_DVR_DBD_PICTURE_INFO(Structure):
    _fields_ = [
        # 20-司机吸烟   司机报警从抽烟开始, 21-司机打电话, 22-司机疲劳驾驶, 23-司机没有目视前方（离岗）,24-司机检测不到头部, 25-司机系安全带,
        # 26-司机捡拾物品, 27-司机打哈欠, 28-司机吃东西或喝水, 29-司机聊天, 31-司机未穿工作服
        ("dwPicType", DWORD), #  报警图片类型
        ("*pPicBuf", CHAR), # 图片指针
        ("dwPicLen", DWORD), #  报警图片长度，为0时表示没有图片
        ("dwTime", DWORD), #  抓图时间
        ("*pVideoBuf", CHAR), # 视频指针, xxx.mp4
        ("dwVideoLen", DWORD), #  抓图视频的长度，0表示没有报警视频 20180518
        ("byRes", BYTE * 12), #  预留
    ]


LPNET_DVR_DBD_PICTURE_INFO = POINTER(NET_DVR_DBD_PICTURE_INFO)


#  报警位置信息
class NET_DVR_DBD_POSITION_INFO(Structure):
    _fields_ = [
        ("bValid", DWORD), #  定位信息是否有效
        ("dwLongitude", DWORD), #  经度 = 实际度*3600*100+实际分*60*100+实际秒*100
        ("dwLatitude", DWORD), #  纬度 = 实际度*3600*100+实际分*60*100+实际秒*100
        ("dwVehicleSpeed", DWORD), #  速度 = 实际速度*1000*100
        ("dwVehicleDirection", DWORD), #  速度方向角 = 实际方向*100
        ("dwAltitude", DWORD), #  海拔高度(厘米)
    ]


LPNET_DVR_DBD_POSITION_INFO = POINTER(NET_DVR_DBD_POSITION_INFO)


#  报警状态信息
class NET_DVR_DBD_ALARM_STATE(Structure):
    _fields_ = [
        ("bySmoke", BYTE), #  吸烟
        ("byPhone", BYTE), #  打电话
        ("byTiredDriving", BYTE), #  疲劳驾驶
        ("byNoVisualFront", BYTE), #  没有目视前方
        ("byNoHead", BYTE), #  离岗
        ("byWithoutBelt", BYTE), #  不系安全带
        ("byPickingUpThing", BYTE), #  捡拾物品
        ("byYawn", BYTE), #  打哈欠
        ("byEatOrDrink", BYTE), #  吃喝
        ("byChatting", BYTE), #  聊天
        ("byTampering", BYTE), #  遮挡IPC
        ("byWithoutUniform", BYTE), #  未穿工作服
        ("byDriverCmpFail", BYTE), #  身份识别异常
        ("byDriverChange", BYTE), #  驾驶员更换
        ("byDriveLongTime", BYTE), # 超时驾驶
        ("byInfraredBlockingSunglasses", BYTE), #  红外阻断墨镜
        ("byOutOfWheel", BYTE), #  0-保留，1-单手脱离方向盘，2-双手脱离方向盘
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_DBD_ALARM_STATE = POINTER(NET_DVR_DBD_ALARM_STATE)


#  驾驶行为报警信息
class NET_DVR_DBD_ALRAM_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  报警上传结构体大小 4
        ("byChannel", BYTE), #  通道号 1
        ("byLevel", BYTE), # 报警等级,当前只有1
        ("byRes1", BYTE * 2), #  保留字节 3
        ("struIpcInfo", NET_VCA_DEV_INFO), #  报警IP通道信息 24
        ("struPosInfo", NET_DVR_DBD_POSITION_INFO), #  报警位置信息 24
        ("struPicInfo", NET_DVR_DBD_PICTURE_INFO), #  报警图片信息
        ("struAlarmState", NET_DVR_DBD_ALARM_STATE), #  报警状态信息 24
        ("byRes2", BYTE * 20), #  保留   20
    ]


LPNET_DVR_DBD_ALRAM_INFO = POINTER(NET_DVR_DBD_ALRAM_INFO)


#  ADAS报警图片信息
class NET_DVR_ADAS_PICTURE_INFO(Structure):
    _fields_ = [
        ("dwPicType", DWORD), #  报警图片类型
        ("*pPicBuf", CHAR), # 图片指针
        ("dwPicLen", DWORD), #  报警图片长度，为0时表示没有图片
        ("dwTime", DWORD), #  抓图时间
        ("*pVideoBuf", CHAR), # 视频指针, xxx.mp4
        ("dwVideoLen", DWORD), #  抓图视频的长度，0表示没有报警视频 20180518
        ("byRes", BYTE * 12), #  预留
    ]


LPNET_DVR_ADAS_PICTURE_INFO = POINTER(NET_DVR_ADAS_PICTURE_INFO)


#  ADAS报警位置信息
class NET_DVR_ADAS_POSITION_INFO(Structure):
    _fields_ = [
        ("dwValid", DWORD), #  定位信息是否有效
        ("dwLongitude", DWORD), #  经度 = 实际度*3600*100+实际分*60*100+实际秒*100
        ("dwLatitude", DWORD), #  纬度 = 实际度*3600*100+实际分*60*100+实际秒*100
        ("dwVehicleSpeed", DWORD), #  速度 = 实际速度*1000*100
        ("dwVehicleDirection", DWORD), #  速度方向角 = 实际方向*100
        ("dwAltitude", DWORD), #  海拔高度(厘米)
    ]


LPNET_DVR_ADAS_POSITION_INFO = POINTER(NET_DVR_ADAS_POSITION_INFO)


#  ADAS报警状态信息
class NET_DVR_ADAS_ALARM_STATE(Structure):
    _fields_ = [
        ("dwFcw", BYTE), #  前车碰撞，0无，1事件发生
        ("dwLdw", BYTE), #  车道偏离，0无，1左侧偏离，2右侧偏离
        ("dwHmw", BYTE), #  车距监测，0无，1事件发生
        ("dwPcw", BYTE), #  行人碰撞，0无，1事件发生
        ("dwBsd", BYTE), #  盲区检测，0无，1事件发生 , 2-右侧盲区报警，3-左侧盲区报警, 4-后侧盲区报警
        ("byAcc", BYTE), #  急加速，0无，1事件发生
        ("byBrake", BYTE), # 急减速，0无，1事件发生
        ("byTurn", BYTE), #  急转弯，0无，1右急转弯，2左急转弯
        ("byRollover", BYTE), #  侧翻，0无，1事件发生
        ("byNoCourtesy", BYTE), #  未礼让行人，0无，1事件发生
        ("byTsr", BYTE), # 交通标识警告，0无，1限速，2限高，3限宽
        ("byRes", BYTE * 13),
    ]


LPNET_DVR_ADAS_ALARM_STATE = POINTER(NET_DVR_ADAS_ALARM_STATE)


#  ADAS驾驶行为报警信息
class NET_DVR_ADAS_ALRAM_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  报警上传结构体大小 4
        ("byChannel", BYTE), #  通道号 1
        ("byRes1", BYTE * 3), #  保留字节 3
        ("struIpcInfo", NET_VCA_DEV_INFO), #  报警IP通道信息 28
        ("struPosInfo", NET_DVR_ADAS_POSITION_INFO), #  报警位置信息 24
        ("struPicInfo", NET_DVR_ADAS_PICTURE_INFO), #  报警图片信息
        ("struAlarmState", NET_DVR_ADAS_ALARM_STATE), #  报警状态信息 24
        ("byRes2", BYTE * 20), #  保留   20
    ]


LPNET_DVR_ADAS_ALRAM_INFO = POINTER(NET_DVR_ADAS_ALRAM_INFO)


#  行车实时数据
class NET_DVR_VEH_REALTIME_DATA_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  报警上传结构体大小
        ("dwSpeedValue", DWORD), #  速度值
        ("dwSpeedPulse", DWORD), #  测速脉冲
        ("byUpgPercent", BYTE), #  升级进度，正常0-100，升级失败返回255，每次开始升级时，首先需要等进度0，才表示准备开始了 20180508扩展
        ("byRes1", BYTE * 3),
        ("dwVideoLostChans", DWORD), # 按位表示，0表示正常，1-表示视频丢失，第一位表示第一通道
        ("byRes2", BYTE * 44),
    ]


LPNET_DVR_VEH_REALTIME_DATA_INFO = POINTER(NET_DVR_VEH_REALTIME_DATA_INFO)


VCA_ATTEND_MAX_PIC_NUM = 3 # 考勤事件最大图片张数
VCA_ATTEND_DRIVER_NAME_LEN = 64 # 分组信息司机名字长度
VCA_ATTEND_CARD_ID_LEN = 32 # 分组信息司机证件号码长度
VCA_ATTEND_MAX_ALARM_ID_LEN = 32 # 报警事件唯一编号的最大长度
class NET_DVR_VCA_ATTEND_PICDATA(Structure):
    _fields_ = [
        ("dwPicLen", DWORD), # 报警图片长度，为0时表示没有图片
        ("*pPicBuf", CHAR), # 图片指针
        ("byRes", BYTE * 12), # 预留
    ]


LPNET_DVR_VCA_ATTEND_PICDATA = POINTER(NET_DVR_VCA_ATTEND_PICDATA)


#  考勤事件图片信息
class NET_DVR_VCA_ATTEND_PICTURE_INFO(Structure):
    _fields_ = [
        ("byPicNum", BYTE), # 考勤图片数量
        ("byRes1", BYTE * 3), # 预留
        ("struPicData", NET_DVR_VCA_ATTEND_PICDATA * VCA_ATTEND_MAX_PIC_NUM), # 报警图片数据
        ("dwVideoLen", DWORD), # 抓图视频的长度，0表示没有报警视频
        ("*pVideoBuf", CHAR), # 视频指针
        ("byRes", BYTE * 64), # 预留
    ]


LPNET_DVR_VCA_ATTEND_PICTURE_INFO = POINTER(NET_DVR_VCA_ATTEND_PICTURE_INFO)


#  考勤事件上传信息
class NET_DVR_VCA_ATTEND_ALARM_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  报警上传结构体大小
        ("byMethod", BYTE), # 考勤方式 0-IC卡考勤,1-人脸考勤
        ("byStatus", BYTE), # 考勤状态 0-保留，1-上班,2-下班（无人脸或换班）
        ("byCertIDType", BYTE), # 驾驶员证件类型：0-营运资格证，1-身份证
        ("byCertIDLen", BYTE), # 驾驶员从业资格证编码长度
        ("sCertId", CHAR * VCA_ATTEND_CARD_ID_LEN), # 驾驶员从业资格证编码
        ("dwTime", DWORD), # 考勤时间
        ("sName", CHAR * VCA_ATTEND_DRIVER_NAME_LEN), # 驾驶员姓名
        ("sAlarmIdNo", CHAR * VCA_ATTEND_MAX_ALARM_ID_LEN), # 报警标识号
        ("struPicInfo", NET_DVR_VCA_ATTEND_PICTURE_INFO), # 报警图片信息
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_VCA_ATTEND_ALARM_INFO = POINTER(NET_DVR_VCA_ATTEND_ALARM_INFO)


# 尺寸过滤策略
class NET_VCA_FILTER_STRATEGY(Structure):
    _fields_ = [
        ("byStrategy", BYTE), # 尺寸过滤策略 0 - 不启用 1-高度和宽度过滤,2-面积过滤
        ("byRes", BYTE * 11), # 保留
    ]


LPNET_VCA_FILTER_STRATEGY = POINTER(NET_VCA_FILTER_STRATEGY)


# 规则触发参数
class NET_VCA_RULE_TRIGGER_PARAM(Structure):
    _fields_ = [
        ("byTriggerMode", BYTE), # 规则的触发方式，0- 不启用，1- 轨迹点 2- 目标面积
        ("byTriggerPoint", BYTE), # 触发点，触发方式为轨迹点时有效 0- 中,1-上,2-下
        ("byRes1", BYTE * 2), # 保留
        ("fTriggerArea", DOUBLE), # 触发目标面积百分比 [0,100]，触发方式为目标面积时有效
        ("byRes2", BYTE * 4), # 保留
    ]


LPNET_VCA_RULE_TRIGGER_PARAM = POINTER(NET_VCA_RULE_TRIGGER_PARAM)


# 警戒规则结构
class NET_VCA_ONE_RULE_V41(Structure):
    _fields_ = [
        ("byActive", BYTE), # 是否激活规则,0-否,非0-是
        ("byRes1", BYTE * 4), # 保留，设置为0字段
        ("byEventTypeFlag", BYTE), # 标志行为事件类型字段的有效性，0-dwEventType有效，1-wEventTypeEx有效
        # 注：此字段byEventTypeFlag只在设置参数时有效，从设备获取参数时，可直接从wEventTypeEx获取事件类型，无需判断此字段的值
        ("wEventTypeEx", WORD), # 行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
        ("byRuleName", BYTE * NAME_LEN), # 规则名称
        ("dwEventType", DWORD), # 行为事件类型，保留是为了兼容，后续建议使用wEventTypeEx获取事件类型
        ("uEventParam", NET_VCA_EVENT_UNION), # 行为分析事件参数
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("wAlarmDelay", WORD), # 智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
        ("byRes2", BYTE * 2), # 保留
        ("struFilterStrategy", NET_VCA_FILTER_STRATEGY), # 尺寸过滤策略
        ("struTriggerParam", NET_VCA_RULE_TRIGGER_PARAM), # 规则触发参数
        ("byRes", BYTE * 32),
    ]


LPNET_VCA_ONE_RULE_V41 = POINTER(NET_VCA_ONE_RULE_V41)


# 行为分析配置结构体
class NET_VCA_RULECFG_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 非0-上传
        ("byUpLastAlarm", BYTE), # 2011-04-06 是否先上传最近一次的报警
        ("byPicRecordEnable", BYTE), # 2012-3-1是否启用图片存储, 0-不启用, 1-启用
        ("byRes1", BYTE),
        ("struPictureParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struRule", NET_VCA_ONE_RULE_V41 * MAX_RULE_NUM), # 规则数组
        ("wRelSnapChan", WORD * MAX_REL_SNAPCHAN_NUM), # 关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
        ("byRes", BYTE * 26),
    ]


LPNET_VCA_RULECFG_V41 = POINTER(NET_VCA_RULECFG_V41)


# 警戒规则结构
class NET_VCA_ONE_RULE_V42(Structure):
    _fields_ = [
        ("byActive", BYTE), # 是否激活规则, 0-否，非0-是
        ("byEventPriority", BYTE), # 事件优先级 0-低，1-中，2-高
        ("byBackgroundSuppression", BYTE), # 背景干扰抑制 0-关闭 1-开启 2-自适应
        ("byRes1", BYTE * 3), # 保留，设置为0字段
        ("wEventType", WORD), # 行为事件类型，参考VCA_RULE_EVENT_TYPE_EX
        ("byRuleName", BYTE * NAME_LEN), # 规则名称
        ("uEventParam", NET_VCA_EVENT_UNION), # 行为分析事件参数
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V40), # 处理方式
        # 异常处理方式中报警输出号与组号绑定，即组号为0时，表示关联的报警输出号范围为1-64，当组号为1时，表示关联的报警输出号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的报警出号无效
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V30), #  报警触发的录象通道（四字节的通道号，初始值是 0xffffffff）
        # 关联的录像通道号与组号绑定，即组号为0时，表示关联的通道号范围为1-64，当组号为1时，表示关联的通道号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的关联通道号无效
        ("wAlarmDelay", WORD), # 智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
        ("byRes2", BYTE * 2), # 保留
        ("struFilterStrategy", NET_VCA_FILTER_STRATEGY), # 尺寸过滤策略
        ("struTriggerParam", NET_VCA_RULE_TRIGGER_PARAM), # 规则触发参数
        ("byRes", BYTE * 32),
    ]


LPNET_VCA_ONE_RULE_V42 = POINTER(NET_VCA_ONE_RULE_V42)


class NET_DVR_PTZ_POSITION(Structure):
    _fields_ = [
        # 是否启用场景，在设置场景行为规则的时候该字段无效，在设置球机本地配置场景位置信息时作为使能位
        ("byEnable", BYTE),
        ("byRes1", BYTE * 3), # 保留
        ("byPtzPositionName", BYTE * NAME_LEN), # 场景位置名称
        ("struPtzPos", NET_DVR_PTZPOS), # ptz 坐标
        ("byRes2", BYTE * 40),
    ]


LPNET_DVR_PTZ_POSITION = POINTER(NET_DVR_PTZ_POSITION)


# 行为分析配置结构体
class NET_VCA_RULECFG_V42(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构图大小
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 1-上传
        ("byUpLastAlarm", BYTE), # 是否先上传最近一次的报警，0-否，1-是
        ("byPicRecordEnable", BYTE), # 是否启用图片存储, 0-不启用, 1-启用
        ("byRes1", BYTE),
        ("struPicParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struRule", NET_VCA_ONE_RULE_V42 * MAX_RULE_NUM_V42), #  规则数组
        ("wRelSnapChan", WORD * MAX_REL_SNAPCHAN_NUM), # 关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
        ("byTrackEnable", BYTE), # 是否启用跟踪
        ("byRes2", BYTE),
        ("struPTZPosition", NET_DVR_PTZ_POSITION), # 场景位置信息
        ("wTrackDuration", WORD), # 跟踪持续时间，单位s
        ("wIntervalTime", WORD), # 单次报警间隔时间（秒）[1-7200]（默认为600）
        ("wHeightLimit", WORD), # 目标检测高度下限（厘米）[0-250]（默认为80cm），小于此高度的目标将不作为目标进行检测
        ("byRes", BYTE * 58), # 保留
    ]


LPNET_VCA_RULECFG_V42 = POINTER(NET_VCA_RULECFG_V42)


# 简化目标结构体
class NET_VCA_TARGET_INFO(Structure):
    _fields_ = [
        ("dwID", DWORD), # 目标ID ,人员聚集过高报警时为0
        ("struRect", NET_VCA_RECT), # 目标边界框
        ("byRes", BYTE * 4), # 保留
    ]


LPNET_VCA_TARGET_INFO = POINTER(NET_VCA_TARGET_INFO)


# 简化的规则信息, 包含规则的基本信息
class NET_VCA_RULE_INFO(Structure):
    _fields_ = [
        ("byRuleID", BYTE), # 规则ID,0-7
        ("bySceneID", BYTE), # 场景ID,返回0无效
        ("wEventTypeEx", WORD), # 行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
        ("byRuleName", BYTE * NAME_LEN), # 规则名称
        ("dwEventType", DWORD), # 行为事件类型，保留是为了兼容，后续建议使wEventTypeEx获取事件类型
        ("uEventParam", NET_VCA_EVENT_UNION), # 事件参数
    ]


LPNET_VCA_RULE_INFO = POINTER(NET_VCA_RULE_INFO)


# 行为分析结果上报结构
class NET_VCA_RULE_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwRelativeTime", DWORD), # 相对时标,历史原因，实际没用，本版本用起来当byRelativeTimeFlag为1时，表示为UTC的时间
        ("dwAbsTime", DWORD), # 绝对时标,历史原因，这里实际为OSD时间
        ("struRuleInfo", NET_VCA_RULE_INFO), # 事件规则信息
        ("struTargetInfo", NET_VCA_TARGET_INFO), # 报警目标信息
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("dwPicDataLen", DWORD), # 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
        ("byPicType", BYTE), #   0-触发抓拍图片 1-对比图片
        ("byRelAlarmPicNum", BYTE), # 关联通道报警图片数量
        ("bySmart", BYTE), # IDS设备返回0(默认值)，Smart Functiom Return 1
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("dwAlarmID", DWORD), # 报警ID，用以标识通道间关联产生的组合报警，0表示无效
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byRelativeTimeFlag", BYTE), # dwRelativeTime字段是否有效  0-无效， 1-有效，dwRelativeTime表示UTC时间
        ("byAppendInfoUploadEnabled", BYTE), # 附加信息上传使能 0-不上传 1-上传
        ("*pAppendInfo", BYTE), # 指向附加信息NET_VCA_APPEND_INFO的指针，byAppendInfoUploadEnabled为1时或者byTimeDiffFlag为1时有效
        ("*pImage", BYTE), # 指向图片的指针
    ]


LPNET_VCA_RULE_ALARM = POINTER(NET_VCA_RULE_ALARM)


# 行为分析附加信息
class NET_VCA_APPEND_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwAppendPicLen", DWORD), # 附加图片长度
        ("pAppendPicBuff", CHARP), # 附加图片指针
        ("byAppendPicType", BYTE), # 附加图片类型：0-保留1-可见光图片2-热成像图片
        ("byUID", BYTE * 64), # 设备报警UID
        ("byRes1", BYTE * 3), # 保留
        ("dwTargetSpeed", DWORD), # 雷达检测到目标速度,单位:km/h
        ("dwTargetDistance", DWORD), # 雷达检测到目标距离,单位:m/米
        ("byAlarmType", BYTE), # 报警类型 0-视频 1-雷达
        ("byRadarChannel", BYTE), # 雷达通道，从1开始累加
        ("byRes", BYTE * 50), # 保留
    ]


LPNET_VCA_APPEND_INFO = POINTER(NET_VCA_APPEND_INFO)


# 行为分析规则DSP信息叠加结构
class NET_VCA_DRAW_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDspAddTarget", BYTE), # 编码是否叠加目标
        ("byDspAddRule", BYTE), # 编码是否叠加规则
        ("byDspPicAddTarget", BYTE), # 抓图是否叠加目标
        ("byDspPicAddRule", BYTE), # 抓图是否叠加规则
        ("byRes", BYTE * 4),
    ]


LPNET_VCA_DRAW_MODE = POINTER(NET_VCA_DRAW_MODE)


# 物体类型
class OBJECT_TYPE_ENUM(Structure):
    _fields_ = [
        # ENUM_OBJECT_TYPE_COAT  = 1  上衣
    ]


# 物体颜色条件结构体
class NET_DVR_OBJECT_COLOR_COND(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号
        ("dwObjType", DWORD), # 物体类型，参见OBJECT_TYPE_ENUM
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_OBJECT_COLOR_COND = POINTER(NET_DVR_OBJECT_COLOR_COND)


# 图片参数
class NET_DVR_PIC(Structure):
    _fields_ = [
        ("byPicType", BYTE), # 图片类型，1-jpg
        ("byRes1", BYTE * 3), # 保留
        ("dwPicWidth", DWORD), # 图片宽度
        ("dwPicHeight", DWORD), # 图片高度
        ("dwPicDataLen", DWORD), # 图片数据实际大小
        ("dwPicDataBuffLen", DWORD), # 图片数据缓冲区大小
        ("byPicDataBuff", CHARP), # 图片数据缓冲区
        ("byRes2", BYTE * 40), # 保留
    ]


LPNET_DVR_PIC = POINTER(NET_DVR_PIC)


# 颜色联合体
class NET_DVR_OBJECT_COLOR_UNION(Union):
    _fields_ = [
        ("struColor", NET_DVR_COLOR), # 颜色值
        ("struPicture", NET_DVR_PIC), # 图片
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_OBJECT_COLOR_UNION = POINTER(NET_DVR_OBJECT_COLOR_UNION)


# 物体颜色参数结构体
class NET_DVR_OBJECT_COLOR(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 0-不启用，1-启用
        ("byColorMode", BYTE), # 取色方式，1-颜色值，2-图片
        ("byRes1", BYTE * 2), # 保留
        ("uObjColor", NET_DVR_OBJECT_COLOR_UNION), # 物体颜色联合体，取值依赖于取色方式
        ("byRes2", BYTE * 64), # 保留
    ]


LPNET_DVR_OBJECT_COLOR = POINTER(NET_DVR_OBJECT_COLOR)


# 区域类型
class AREA_TYPE_ENUM(Structure):
    _fields_ = [
        # ENUM_OVERLAP_REGION  = 1,共同区域
        # ENUM_BED_LOCATION  = 2   床铺位置
    ]


# 辅助区域
class NET_DVR_AUXAREA(Structure):
    _fields_ = [
        ("dwAreaType", DWORD), # 区域类型，参见AREA_TYPE_ENUM
        ("byEnable", BYTE), # 0-不启用，1-启用
        ("byRes1", BYTE * 3), # 保留
        ("struPolygon", NET_VCA_POLYGON), # 区域
        ("byRes2", BYTE * 16), # 保留
    ]


LPNET_DVR_AUXAREA = POINTER(NET_DVR_AUXAREA)


# 辅助区域列表
class NET_DVR_AUXAREA_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struArea", NET_DVR_AUXAREA * MAX_AUXAREA_NUM), # 辅助区域
        ("byRes2", BYTE * 64), #  保留
    ]


LPNET_DVR_AUXAREA_LIST = POINTER(NET_DVR_AUXAREA_LIST)


# 通道工作模式
class CHAN_WORKMODE_ENUM(Structure):
    _fields_ = [
        # ENUM_CHAN_WORKMODE_INDEPENDENT = 1,  独立模式
        # ENUM_CHAN_WORKMODE_MASTER  = 2,      主模式
        # ENUM_CHAN_WORKMODE_SLAVE  = 3        从模式
    ]


# 通道工作模式参数结构体
class NET_DVR_CHANNEL_WORKMODE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byWorkMode", BYTE), # 工作模式，参见CHAN_WORKMODE_ENUM
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_CHANNEL_WORKMODE = POINTER(NET_DVR_CHANNEL_WORKMODE)


# 设备通道参数结构体
class NET_DVR_CHANNEL(Structure):
    _fields_ = [
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # 设备IP或域名
        ("wDVRPort", WORD), # 端口号
        ("byRes1", BYTE * 2), # 保留
        ("sUserName", BYTE * NAME_LEN), # 主机用户名
        ("sPassword", BYTE * PASSWD_LEN), # 主机密码
        ("dwChannel", DWORD), # 通道号
        ("byRes2", BYTE * 32), # 保留
    ]


LPNET_DVR_CHANNEL = POINTER(NET_DVR_CHANNEL)


# 从通道信息联合体
class NET_DVR_SLAVE_CHANNEL_UNION(Union):
    _fields_ = [
        ("byRes", BYTE * 152), # 联合体大小
        ("dwLocalChannel", DWORD), # 本机通道
        ("struRemoteChannel", NET_DVR_CHANNEL), # 远程通道
    ]


LPNET_DVR_SLAVE_CHANNEL_UNION = POINTER(NET_DVR_SLAVE_CHANNEL_UNION)


# 从通道参数结构体
class NET_DVR_SLAVE_CHANNEL_PARAM(Structure):
    _fields_ = [
        ("byChanType", BYTE), # 从通道类型，1-本机通道，2-远程通道
        ("byRes1", BYTE * 3), # 保留
        ("uSlaveChannel", NET_DVR_SLAVE_CHANNEL_UNION), # 从通道联合体，取值依赖于byChanType
        ("byRes2", BYTE * 64), # 保留
    ]


LPNET_DVR_SLAVE_CHANNEL_PARAM = POINTER(NET_DVR_SLAVE_CHANNEL_PARAM)


# 从通道参数配置结构体
class NET_DVR_SLAVE_CHANNEL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struChanParam", NET_DVR_SLAVE_CHANNEL_PARAM * MAX_SLAVE_CHANNEL_NUM), # 从通道参数
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_SLAVE_CHANNEL_CFG = POINTER(NET_DVR_SLAVE_CHANNEL_CFG)

ENUM_VQD_EVENT_BLUR = 1 # 图像模糊
ENUM_VQD_EVENT_LUMA = 2 # 亮度异常
ENUM_VQD_EVENT_CHROMA = 3 # 图像偏色
ENUM_VQD_EVENT_SNOW = 4 # 雪花干扰
ENUM_VQD_EVENT_STREAK = 5 # 条纹干扰
ENUM_VQD_EVENT_FREEZE = 6 # 画面冻结
ENUM_VQD_EVENT_SIGNAL_LOSS = 7 # 信号丢失
ENUM_VQD_EVENT_PTZ = 8 # 云台失控
ENUM_VQD_EVENT_SCNENE_CHANGE = 9 # 场景突变
ENUM_VQD_EVENT_VIDEO_ABNORMAL = 10 # 视频异常
ENUM_VQD_EVENT_VIDEO_BLOCK = 11 # 视频遮挡
ENUM_VQD_EVENT_CLARTY = 12 # 清晰度异常
ENUM_VQD_EVENT_JITTER = 13 # 画面抖动
ENUM_VQD_EVENT_FLOWERS = 14 # 画屏
ENUM_VQD_EVENT_NOISE = 15 # 噪点
ENUM_VQD_EVENT_GHOST = 16 # 异常光斑
ENUM_VQD_EVENT_PURPLE = 17 # 紫边
ENUM_VQD_EVENT_ICR = 18 # ICR检测异常
ENUM_VQD_EVENT_PROTECTFILM = 19 # 保护膜未撕


# 视频质量诊断事件条件结构体
class NET_DVR_VQD_EVENT_COND(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号
        ("dwEventType", DWORD), # 检测事件类型，参见VQD_EVENT_ENUM
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_VQD_EVENT_COND = POINTER(NET_DVR_VQD_EVENT_COND)


# 视频质量诊断事件参数
class NET_DVR_VQD_EVENT_PARAM(Structure):
    _fields_ = [
        ("byThreshold", BYTE), # 报警阈值，范围[0,100]
        ("byTriggerMode", BYTE), # 1-持续触发，2-单次触发
        ("byUploadPic", BYTE), # 0-不上传图片，1-上传图片，无论是否上传图片，事后都可以从设备获取该事件所对应最新的一张报警图片，参见接口NET_DVR_StartDownload
        ("byRes1", BYTE), # 保留
        ("dwTimeInterval", DWORD), # 持续触发报警时间间隔，范围[0,3600] 单位：秒
        ("byRes2", BYTE * 64), # 保留
    ]


LPNET_DVR_VQD_EVENT_PARAM = POINTER(NET_DVR_VQD_EVENT_PARAM)


# 视频质量诊断事件规则
class NET_DVR_VQD_EVENT_RULE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 0-不启用，1-启用
        ("byRes1", BYTE * 3), # 保留
        ("struEventParam", NET_DVR_VQD_EVENT_PARAM), # 视频质量诊断事件参数
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 检测时间
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRelRecordChan", BYTE * MAX_IVMS_IP_CHANNEL), # 报警触发的录象通道：1表示触发该通道；0表示不触发
        ("byRes2", BYTE * 128), # 保留
    ]


LPNET_DVR_VQD_EVENT_RULE = POINTER(NET_DVR_VQD_EVENT_RULE)


# 基准场景参数
class NET_DVR_BASELINE_SCENE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 0-不启用，1-启用
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_BASELINE_SCENE = POINTER(NET_DVR_BASELINE_SCENE)


# 基准场景操作参数结构体
class NET_DVR_CONTROL_BASELINE_SCENE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD), # 通道号
        ("byCommand", BYTE), # 操作类型，1-此字段保留，暂不使用，2-更新基准场景
        ("byRes", BYTE * 127), # 保留
    ]


LPNET_DVR_CONTROL_BASELINE_SCENE_PARAM = POINTER(NET_DVR_CONTROL_BASELINE_SCENE_PARAM)


# 视频质量诊断报警结构体
class NET_DVR_VQD_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("dwEventType", DWORD), # 事件类型，参考VQD_EVENT_ENUM
        ("fThreshold", DOUBLE), # 报警阈值[0.000,1.000]
        ("dwPicDataLen", DWORD), # 图片长度，为0表示没有图片
        ("*pImage", BYTE), # 指向图片的指针
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_VQD_ALARM = POINTER(NET_DVR_VQD_ALARM)


# 标定点子结构
class NET_DVR_CB_POINT(Structure):
    _fields_ = [
        ("struPoint", NET_VCA_POINT), # 标定点，主摄像机（枪机）
        ("struPtzPos", NET_DVR_PTZPOS), # 球机输入的PTZ坐标
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_CB_POINT = POINTER(NET_DVR_CB_POINT)


# 标定参数配置结构
class NET_DVR_TRACK_CALIBRATION_PARAM(Structure):
    _fields_ = [
        ("byPointNum", BYTE), # 有效标定点个数
        ("byRes", BYTE * 3),
        ("struCBPoint", NET_DVR_CB_POINT * MAX_CALIB_PT), # 标定点组
    ]


LPNET_DVR_TRACK_CALIBRATION_PARAM = POINTER(NET_DVR_TRACK_CALIBRATION_PARAM)


# 球机配置结构
class NET_DVR_TRACK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byEnable", BYTE), # 标定使能
        ("byFollowChan", BYTE), #  被控制的从通道
        ("byDomeCalibrate", BYTE), # 设置智能跟踪球机标定，1设置 0不设置
        ("byRes", BYTE), #  保留字节
        ("struCalParam", NET_DVR_TRACK_CALIBRATION_PARAM), # 标定点组
    ]


LPNET_DVR_TRACK_CFG = POINTER(NET_DVR_TRACK_CFG)


# 跟踪模式
MANUAL_CTRL = 0 # 手动跟踪
ALARM_TRACK = 1 # 报警触发跟踪



# 手动控制结构
class NET_DVR_MANUAL_CTRL_INFO(Structure):
    _fields_ = [
        ("struCtrlPoint", NET_VCA_POINT),
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_MANUAL_CTRL_INFO = POINTER(NET_DVR_MANUAL_CTRL_INFO)


class NET_DVR_ALARM_JPEG(Structure):
    _fields_ = [
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 1-上传
        ("byRes", BYTE * 3), # 保留字节
        ("struPicParam", NET_DVR_JPEGPARA), # 图片规格结构
    ]


LPNET_DVR_ALARM_JPEG = POINTER(NET_DVR_ALARM_JPEG)


# ipc/d5.3.0
class NET_DVR_PHY_RATIO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPhysicsRatio", DWORD), # 物理倍率坐标
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_PHY_RATIO = POINTER(NET_DVR_PHY_RATIO)


class NET_DVR_SLAVECAMERA_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byID", BYTE), # 主从跟踪 从摄像机ID编号[1,4]
        ("byRes1", BYTE * 3),
        ("dwSceneID", DWORD), #  scene Id
        ("byRes", BYTE * 56),
    ]


LPNET_DVR_SLAVECAMERA_COND = POINTER(NET_DVR_SLAVECAMERA_COND)


class NET_DVR_SLAVECAMERA_PARAM(Structure):
    _fields_ = [
        ("byLinkStatus", BYTE), # 连接状态 0- 未连接，1-连接
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_SLAVECAMERA_PARAM = POINTER(NET_DVR_SLAVECAMERA_PARAM)


class NET_DVR_SLAVECAMERA_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSlaveCamera", NET_DVR_SLAVECAMERA_PARAM * MAX_SLAVECAMERA_NUM), # 数组下标0表示从摄像机ID 1,依次类推
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SLAVECAMERA_STATUS = POINTER(NET_DVR_SLAVECAMERA_STATUS)


class NET_PTZ_INFO(Structure):
    _fields_ = [
        ("fPan", DOUBLE),
        ("fTilt", DOUBLE),
        ("fZoom", DOUBLE),
        ("dwFocus", DWORD), #  聚焦参数，聚焦范围：归一化0-100000
        ("byRes", BYTE * 4),
    ]


LPNET_PTZ_INFO = POINTER(NET_PTZ_INFO)


class NET_DVR_BV_CALIB_POSITION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("struInitialPos", NET_PTZ_INFO), # 初始坐标
        ("struAdjustPos", NET_PTZ_INFO), # 调整坐标
        ("byRes", BYTE * 300), # 保留
    ]


LPNET_DVR_BV_CALIB_POSITION = POINTER(NET_DVR_BV_CALIB_POSITION)


class NET_DVR_HUMAN_CALIB_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("struLeftPos", NET_VCA_POINT), # 人体左坐标点
        ("struRightPos", NET_VCA_POINT), # 人体右坐标点
        ("byRes", BYTE * 300), # 保留
    ]


LPNET_DVR_HUMAN_CALIB_CFG = POINTER(NET_DVR_HUMAN_CALIB_CFG)


class NET_DVR_CALIB_PARAM(Structure):
    _fields_ = [
        ("struPtzInfo", NET_PTZ_INFO),
        ("struCalibCoordinates", NET_VCA_POINT), # 标定坐标
        ("iHorValue", INT), # 双目标定 水平值 cm（手动模式下生效 双目相机配置）
        ("iVerValue", INT), # 双目标定 垂直值 cm（手动模式下生效 双目相机配置）
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_CALIB_PARAM = POINTER(NET_DVR_CALIB_PARAM)


class NET_DVR_SLAVECAMERA_CALIB_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCalibMode", BYTE), # 标定模式: 0-保留,1-自动标定, 2-手动标定
        ("byRes", BYTE * 3),
        # 数组下标0表示从摄像机ID 1，依次类推
        # 手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
        ("struCalibParam", NET_DVR_CALIB_PARAM * MAX_CALIB_NUM), # 只在手动标定模式下生效
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_SLAVECAMERA_CALIB_CFG = POINTER(NET_DVR_SLAVECAMERA_CALIB_CFG)


class NET_DVR_TRACKING(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byEnable", BYTE), # 使能 0-false,1-true
        ("byMode", BYTE), # 模式 0-关闭，1-手动，2-自动
        ("wTrackingTime", WORD), # 跟踪时间：[0,60]s
        ("struRegion", NET_VCA_POLYGON), # 手动跟踪目标区域范围
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_TRACKING = POINTER(NET_DVR_TRACKING)


class NET_DVR_SLAVECAMERA_CALIB_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCalibMode", BYTE), # 标定模式: 0-保留,1-自动标定, 2-手动标定
        ("byRes", BYTE * 3),
        # 数组下标0表示从摄像机ID 1，依次类推
        # 手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
        ("struCalibParam", NET_DVR_CALIB_PARAM * MAX_CALIB_NUM_EX),
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_SLAVECAMERA_CALIB_V50 = POINTER(NET_DVR_SLAVECAMERA_CALIB_V50)


class NET_DVR_SLAVECAMERA_CALIB_V51(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCalibMode", BYTE), # 标定模式: 0-保留,1-自动标定, 2-手动标定
        ("byRes", BYTE * 3),
        # 数组下标0表示从摄像机ID 1，依次类推
        # 手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
        ("struCalibParam", NET_DVR_CALIB_PARAM * MAX_CALIB_NUM_EX),
        ("byRes1", BYTE * 512),
    ]


LPNET_DVR_SLAVECAMERA_CALIB_V51 = POINTER(NET_DVR_SLAVECAMERA_CALIB_V51)


# 特殊功能抓图结果结构（鹰眼项目）
class NET_DVR_CAPTURE_PICTURE_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwReturnPicSize", DWORD), # 返回的图片大小
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_CAPTURE_PICTURE_RESULT = POINTER(NET_DVR_CAPTURE_PICTURE_RESULT)


class NET_DVR_GOTOSCENE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("dwSceneID", DWORD), # 场景ID号
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_GOTOSCENE_COND = POINTER(NET_DVR_GOTOSCENE_COND)


class NET_DVR_TRACK_INITPOSTION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byID", BYTE), # 主从跟踪 从摄像机ID编号[1,4]
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_TRACK_INITPOSTION = POINTER(NET_DVR_TRACK_INITPOSTION)


class NET_DVR_MANUAL_TRACKRATIO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCoefficient", BYTE), # 倍率系数[1,60]
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_MANUAL_TRACKRATIO = POINTER(NET_DVR_MANUAL_TRACKRATIO)

# 分析仪行为分析规则结构
# 警戒规则结构
class NET_IVMS_ONE_RULE(Structure):
    _fields_ = [
        ("byActive", BYTE), #  是否激活规则,0-否, 非0-是
        ("byRes1", BYTE * 7), # 保留，设置为0字段
        ("byRuleName", BYTE * NAME_LEN), # 规则名称
        ("dwEventType", DWORD), # 行为分析事件类型
        ("uEventParam", NET_VCA_EVENT_UNION), # 行为分析事件参数
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("byRes2", BYTE * 68), # 保留，设置为0
    ]


LPNET_IVMS_ONE_RULE = POINTER(NET_IVMS_ONE_RULE)


#  分析仪规则结构
class NET_IVMS_RULECFG(Structure):
    _fields_ = [
        ("struRule", NET_IVMS_ONE_RULE * MAX_RULE_NUM), # 规则数组
    ]


LPNET_IVMS_RULECFG = POINTER(NET_IVMS_RULECFG)


#  IVMS行为分析配置结构
class NET_IVMS_BEHAVIORCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 非0-上传
        ("byRes", BYTE * 3),
        ("struPicParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struRuleCfg", NET_IVMS_RULECFG * MAX_DAYS), # 每个时间段对应规则
    ]


LPNET_IVMS_BEHAVIORCFG = POINTER(NET_IVMS_BEHAVIORCFG)


# 智能分析仪取流计划子结构
class NET_IVMS_DEVSCHED(Structure):
    _fields_ = [
        ("struTime", NET_DVR_SCHEDTIME), # 时间参数
        ("struPUStream", NET_DVR_PU_STREAM_CFG), # 前端取流参数
    ]


LPNET_IVMS_DEVSCHED = POINTER(NET_IVMS_DEVSCHED)


# 智能分析仪参数配置结构
class NET_IVMS_STREAMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDevSched", NET_IVMS_DEVSCHED * MAX_DAYS), # 按时间段配置前端取流以及规则信息
    ]


LPNET_IVMS_STREAMCFG = POINTER(NET_IVMS_STREAMCFG)


# 屏蔽区域
class NET_VCA_MASK_REGION(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否激活, 0-否，非0-是
        ("byRes", BYTE * 3), # 保留，置0
        ("struPolygon", NET_VCA_POLYGON), # 屏蔽多边形
    ]


LPNET_VCA_MASK_REGION = POINTER(NET_VCA_MASK_REGION)


# 屏蔽区域链表结构
class NET_VCA_MASK_REGION_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byRes", BYTE * 4), # 保留，置0
        ("struMask", NET_VCA_MASK_REGION * MAX_MASK_REGION_NUM), # 屏蔽区域数组
    ]


LPNET_VCA_MASK_REGION_LIST = POINTER(NET_VCA_MASK_REGION_LIST)


# ATM进入区域参数
class NET_VCA_ENTER_REGION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否激活，0-否，非0-是
        ("byRes1", BYTE * 3),
        ("struPolygon", NET_VCA_POLYGON), # 进入区域
        ("byRes2", BYTE * 16),
    ]


LPNET_VCA_ENTER_REGION = POINTER(NET_VCA_ENTER_REGION)


# IVMS屏蔽区域链表
class NET_IVMS_MASK_REGION_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("struList", NET_VCA_MASK_REGION_LIST * MAX_DAYS),
    ]


LPNET_IVMS_MASK_REGION_LIST = POINTER(NET_IVMS_MASK_REGION_LIST)


# IVMS的ATM进入区域参数
class NET_IVMS_ENTER_REGION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struEnter", NET_VCA_ENTER_REGION * MAX_DAYS), # 进入区域
    ]


LPNET_IVMS_ENTER_REGION = POINTER(NET_IVMS_ENTER_REGION)


#  ivms 报警图片上传结构
class NET_IVMS_ALARM_JPEG(Structure):
    _fields_ = [
        ("byPicProType", BYTE),
        ("byRes", BYTE * 3),
        ("struPicParam", NET_DVR_JPEGPARA),
    ]


LPNET_IVMS_ALARM_JPEG = POINTER(NET_IVMS_ALARM_JPEG)


#  IVMS 后检索配置
class NET_IVMS_SEARCHCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRemotePlay", NET_DVR_MATRIX_DEC_REMOTE_PLAY), #  远程回放
        ("struAlarmJpeg", NET_IVMS_ALARM_JPEG), #  报警上传图片配置
        ("struRuleCfg", NET_IVMS_RULECFG), # IVMS 行为规则配置
    ]


LPNET_IVMS_SEARCHCFG = POINTER(NET_IVMS_SEARCHCFG)


# 标定参数结构体
class NET_DVR_TRACK_CALIBRATION_PARAM_V41(Structure):
    _fields_ = [
        ("byPointNum", BYTE), # 有效标定点个数
        ("byRes", BYTE * 3), # 保留
        ("struCBPoint", NET_DVR_CB_POINT * MAX_CALIB_PT), # 标定点组
        ("struHorizonPtzPos", NET_DVR_PTZPOS), # 球机水平线PTZ坐标
        ("byRes2", BYTE * 256), # 保留
    ]


LPNET_DVR_TRACK_CALIBRATION_PARAM_V41 = POINTER(NET_DVR_TRACK_CALIBRATION_PARAM_V41)


# 跟踪设备配置参数
class NET_DVR_TRACK_DEV_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 启用此跟踪设备, 0-不启用, 1 -启用
        ("byTransMode", BYTE), # 通讯方式，0-网络SDK，1-485串口
        ("byRes1", BYTE * 2), # 保留
        ("struTrackDevChan", NET_DVR_CHANNEL), # 联动跟踪设备参数
        ("struCalParam", NET_DVR_TRACK_CALIBRATION_PARAM_V41), # 跟踪设备标定参数
        ("byRes2", BYTE * 256), # 保留
    ]


LPNET_DVR_TRACK_DEV_PARAM = POINTER(NET_DVR_TRACK_DEV_PARAM)


# NAS认证配置
class NET_DVR_IDENTIFICATION_PARAM(Structure):
    _fields_ = [
        ("sUserName", BYTE * NAME_LEN), #  用户名 32
        ("sPassword", BYTE * PASSWD_LEN), #  密码 16
        ("byRes1", BYTE * 4), # 保留
    ]


LPNET_DVR_IDENTIFICATION_PARAM = POINTER(NET_DVR_IDENTIFICATION_PARAM)


class NET_DVR_MOUNT_PARAM_UNION(Union):
    _fields_ = [
        ("uLen", BYTE * 52), # 联合体结构大小
        ("struIdentificationParam", NET_DVR_IDENTIFICATION_PARAM), # (SMB/CIFS时生效)
    ]


LPNET_DVR_MOUNT_PARAM_UNION = POINTER(NET_DVR_MOUNT_PARAM_UNION)


class NET_DVR_NAS_MOUNT_PARAM(Structure):
    _fields_ = [
        ("byMountType", BYTE), # 0～保留,1~NFS, 2~ SMB/CIFS
        ("byRes", BYTE * 3),
        ("uMountParam", NET_DVR_MOUNT_PARAM_UNION),
    ]


LPNET_DVR_NAS_MOUNT_PARAM = POINTER(NET_DVR_NAS_MOUNT_PARAM)


class NET_DVR_MOUNTMETHOD_PARAM_UNION(Union):
    _fields_ = [
        ("uLen", BYTE * 56), # 联合体结构大小
        ("struNasMountParam", NET_DVR_NAS_MOUNT_PARAM), # NAS挂载方式 (byNetDiskType为NFS(NAS)时生效)
    ]


LPNET_DVR_MOUNTMETHOD_PARAM_UNION = POINTER(NET_DVR_MOUNTMETHOD_PARAM_UNION)


# 网络硬盘结构配置
class NET_DVR_SINGLE_NET_DISK_INFO(Structure):
    _fields_ = [
        ("byNetDiskType", BYTE), # 网络硬盘类型, 0-NFS(NAS),1-iSCSI
        ("byRes1", BYTE * 3), # 保留
        ("struNetDiskAddr", NET_DVR_IPADDR), # 网络硬盘地址
        ("sDirectory", BYTE * PATHNAME_LEN), #  PATHNAME_LEN = 128
        ("wPort", WORD), # iscsi有端口，现在为默认
        ("byRes2", BYTE * 2),
        ("uMountMethodParam", NET_DVR_MOUNTMETHOD_PARAM_UNION),
        ("byRes3", BYTE * 8), # 保留
    ]


LPNET_DVR_SINGLE_NET_DISK_INFO = POINTER(NET_DVR_SINGLE_NET_DISK_INFO)


MAX_NET_DISK = 16 # 最大网络硬盘个数
class NET_DVR_NET_DISKCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNetDiskParam", NET_DVR_SINGLE_NET_DISK_INFO * MAX_NET_DISK),
    ]


LPNET_DVR_NET_DISKCFG = POINTER(NET_DVR_NET_DISKCFG)


class NET_DVR_SINGLE_NET_DISK_INFO_V40(Structure):
    _fields_ = [
        ("byNetDiskType", BYTE), # 网络硬盘类型, 0-NFS(NAS),1-iSCSI
        ("byRes1", BYTE * 3), # 保留
        ("sDirectory", BYTE * PATHNAME_LEN), #  PATHNAME_LEN = 128
        ("byDevAddr", BYTE * MAX_DOMAIN_NAME), # 域名 64
        ("wPort", WORD), # iscsi有端口，现在为默认
        ("byRes2", BYTE * 2),
        ("uMountMethodParam", NET_DVR_MOUNTMETHOD_PARAM_UNION),
        ("byRes4", BYTE * 80),
    ]


LPNET_DVR_SINGLE_NET_DISK_INFO_V40 = POINTER(NET_DVR_SINGLE_NET_DISK_INFO_V40)


class NET_DVR_NET_DISKCFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNetDiskParam", NET_DVR_SINGLE_NET_DISK_INFO_V40 * MAX_NET_DISK),
    ]


LPNET_DVR_NET_DISKCFG_V40 = POINTER(NET_DVR_NET_DISKCFG_V40)

EVENT_MOT_DET = 0 # 移动侦测
EVENT_ALARM_IN = 1 # 报警输入
EVENT_VCA_BEHAVIOR = 2 # 行为分析
EVENT_INQUEST = 3 # 审讯事件
EVENT_VCA_DETECTION = 4 # 智能侦测
EVENT_POS = 5,
EVENT_TRIAL_CASE = 6 # 庭审案件信息
EVENT_ACS_CASE = 7 # 门禁事件
EVENT_IOT_CASE = 8 # 非视频联动事件—本类事件均为非视频设备联动视频设备产生的事件，不包含非视频设备本身的事件
EVENT_STREAM_INFO = 100 # 流ID信息

INQUEST_START_INFO = 0x1001 # 讯问开始信息
INQUEST_STOP_INFO = 0x1002 # 讯问停止信息
INQUEST_TAG_INFO = 0x1003 # 重点标记信息
INQUEST_SEGMENT_INFO = 0x1004 # 审讯片断状态信息
INQUEST_CASE_INFO = 0x1005 #  案件信息类型

EVENT_VCA_TRAVERSE_PLANE = 1 # 越警侦测
EVENT_FIELD_DETECTION = 2 # 区域入侵侦测
EVENT_AUDIO_INPUT_ALARM = 3 # 音频输入异常
EVENT_SOUND_INTENSITY_ALARM = 4 # 声强突变侦测
EVENT_FACE_DETECTION = 5 # 人脸侦测
EVENT_VIRTUAL_FOCUS_ALARM = 6 # 虚焦侦测
EVENT_SCENE_CHANGE_ALARM = 7 # 场景变更侦测
EVENT_PIR_ALARM = 8 # PIR报警
EVENT_ENTER_REGION = 9 # 进入区域
EVENT_EXIT_REGION = 10 # 目标离开区域
EVENT_LOITERING = 11 # 徘徊
EVENT_GROUPDETECTION = 12 # 区域内人员聚集, 支持区域规则
EVENT_RAPIDMOVE = 13 # 快速移动
EVENT_PARK = 14 # 停车
EVENT_UNATTENDED_BAGGAGE = 15 # 物品遗留
EVENT_ATTENDEDBAGGAGE = 16 # 物品拿取
EVENT_VEHICLE_DETECTION = 17 # 车辆检测
EVENT_ALL = 0xffffffff # 表示全部

EVENT_TRAVERSE_PLANE = 0 # 穿越警戒面
EVENT_ENTER_AREA = 1 # 目标进入区域, 支持区域规则
EVENT_EXIT_AREA = 2 # 目标离开区域, 支持区域规则
EVENT_INTRUSION = 3 # 周界入侵, 支持区域规则
EVENT_LOITER = 4 # 徘徊, 支持区域规则
EVENT_LEFT_TAKE = 5 # 物品遗留拿取, 支持区域规则
EVENT_PARKING = 6 # 停车, 支持区域规则
EVENT_RUN = 7 # 快速移动, 支持区域规则
EVENT_HIGH_DENSITY = 8 # 区域内人员聚集, 支持区域规则
EVENT_STICK_UP = 9 # 贴纸条, 支持区域规则
EVENT_INSTALL_SCANNER = 10 # 安装读卡器, 支持区域规则
EVENT_OPERATE_OVER_TIME = 11 # 操作超时
EVENT_FACE_DETECT = 12 # 异常人脸
EVENT_LEFT = 13 # 物品遗留
EVENT_TAKE = 14 # 物品拿取
EVENT_LEAVE_POSITION = 15 # 离岗事件
EVENT_TRAIL_INFO = 16 # 尾随
EVENT_HUMAN_ENTER = 18 # 人员进入
EVENT_FALL_DOWN_INFO = 19 # 倒地
EVENT_OBJECT_PASTE = 20 # 异物粘贴区域
EVENT_FACE_CAPTURE_INFO = 21 # 正常人脸
EVENT_MULTI_FACES_INFO = 22 # 多张人脸
EVENT_AUDIO_ABNORMAL_INFO = 23 # 声强突变
EVENT_SUNGLASSES_FACE_INFO = 25 # 戴墨镜人脸
EVENT_CALLING_FACE_INFO = 26 # 打电话人脸
EVENT_VIOLENT_MOTION = 27 # 剧烈运动
EVENT_SAFETY_HELMET = 28 # 安全帽检测
EVENT_PEOPLE_NUM_CHANGE = 29 # 人数变化
EVENT_GET_UP = 30 # 起身
EVENT_ADV_REACH_HEIGHT = 31 # 折线攀高
EVENT_STOOD_UP = 32 # 起立
EVENT_PERSON_DENSITY = 33 # 人员密度（人数预警）
EVENT_MANUAL_ALARM = 34 # 手动报警
EVENT_VIOLATION_HIGH_SPEED = 35 # 超速
EVENT_GSENSOR = 36 # G - Sensor事件（急加速、急减速、急左转弯、急右转弯、车辆翻车、车辆碰撞）
EVENT_SENSOR_IN = 37 # Sensor - In行为（刹车、左转、右转、倒车）
EVENT_VCA_DBD = 38 # 司机驾驶行为
EVENT_VCA_ABS = 39 # 高级辅助驾驶
EVENT_TOILET_TARRY = 40 # 如厕超时

TRIAL_START_INFO = 0x1001 # 庭审开始事件
TRIAL_STOP_INFO = 0x1002 # 庭审结束事件
TRIAL_TAG_INFO = 0x1003 # 庭审重点标注事件
TRIAL_SEGMENT_INFO = 0x1004 # 庭审片段状态信息
TRIAL_JUDGE_CASE_INFO = 0x1005 # 庭审案件信息

EVENT_STREAM_ID = 0 # 流ID
EVENT_TIMING = 1 # 定时录像
EVENT_MOTION_DETECT = 2 # 移动侦测
EVENT_ALARM = 3 # 报警录像
EVENT_ALARM_OR_MOTION_DETECT = 4 # 报警或移动侦测
EVENT_ALARM_AND_MOTION_DETECT = 5 # 报警和移动侦测
EVENT_COMMAND_TRIGGER = 6 # 命令触发
EVENT_MANNUAL = 7 # 手动录像
EVENT_BACKUP_VOLUME = 8 # 存档卷录像
STREAM_EVENT_SEMAPHORE = 9 # 信号量
STREAM_EVENT_HIDE = 10 # 遮挡
STREAM_EVENT_INVERSE = 11 # 逆行
STREAM_EVENT_VIDEO_LOST = 12 # 视频丢失
STREAM_EVENT_WIRELESS_ALARM = 13 # 无线报警
STREAM_EVENT_PIR_ALARM = 14 # PIR报警
STREAM_EVENT_CALLHELP_ALARM = 15 # 呼救报警

STREAM_EVENT_FACESNAP = 0 # 人脸抓拍
STREAM_EVENT_FACE_DETECTION = 1 # 人脸侦测
STREAM_EVENT_ITS_PLATE = 2 # 车辆检测
STREAM_EVENT_PDC = 3 # 客流量统计
STREAM_EVENT_SCENECHANGE_DETECTION = 4 # 场景变更
STREAM_EVENT_DEFOCUS_DETECTION = 5 # 虚焦侦测
STREAM_EVENT_AUDIOEXCEPTION = 6 # 音频异常

# 以下为行为分析（COMM_ALARM_RULE）的子类型，具体见VCA_EVENT_TYPE
VCA_EVENT_TRAVERSE_PLANE = 0 # 穿越警戒面
VCA_EVENT_INTRUSION = 1 # 周界入侵
VCA_EVENT_ENTER_AREA = 2 # 进入区域
VCA_EVENT_EXIT_AREA = 3 # 离开区域
VCA_EVENT_LOITER = 4 # 徘徊侦测
VCA_EVENT_HIGH_DENSITY = 5 # 人员聚集
VCA_EVENT_RUN = 6 # 快速移动
VCA_EVENT_PARKING = 7 # 非法停车
VCA_EVENT_LEFT = 8 # 物品遗留
VCA_EVENT_TAKE = 9 # 物品拿取

SEARCH_EVENT_INFO_LEN = 300 # 事件信息长度
CASE_NO_LEN = 64
CASE_NAME_LEN = 128
LITIGANT_LEN = 32
CHIEF_JUDGE_LEN = 32
SEARCH_CASE_NO_LEN = 56
SEARCH_CASE_NAME_LEN = 100
SEARCH_LITIGANT_LEN = 32
SEARCH_CHIEF_JUDGE_LEN = 32
CASE_NO_RET_LEN = 52
CASE_NAME_RET_LEN = 64
LITIGANT_RET_LEN = 24
CHIEF_JUDGE_RET_LEN = 24
NET_SDK_CASETYPE_LEN = 32

MAX_POS_KEYWORDS_NUM = 3 # 支持关键字查找条数
MAX_POS_KEYWORD_LEN = 128 # 每条关键字长度
SEARCH_EVENT_INFO_LEN_V40 = 800

PDC_CALIBRATE = 0x01 # PDC 标定
BEHAVIOR_OUT_CALIBRATE = 0x02 # 行为室外场景标定
BEHAVIOR_IN_CALIBRATE = 0x03 # 行为室内场景标定
ITS_CALBIRETE = 0x04 # 交通事件标定
BV_DIRECT_CALIBRATE = 0x05 # 双目直接标定
PDC_LINE_CALIBRATE = 0x06 # PDC 线 标定


MAX_RECT_NUM = 6
class NET_DVR_RECT_LIST(Structure):
    _fields_ = [
        ("byRectNum", BYTE), #  矩形框的个数
        ("byRes1", BYTE * 11), # 保留字节
        ("struVcaRect", NET_VCA_RECT * MAX_RECT_NUM), #  最大为6个Rect
    ]


LPNET_DVR_RECT_LIST = POINTER(NET_DVR_RECT_LIST)


#  PDC 标定参数
class NET_DVR_PDC_CALIBRATION(Structure):
    _fields_ = [
        ("struRectList", NET_DVR_RECT_LIST), #  标定矩形框列表
        ("byRes", BYTE * 120), #  保留字节
    ]


LPNET_DVR_PDC_CALIBRATION = POINTER(NET_DVR_PDC_CALIBRATION)

HEIGHT_LINE = 0 # 高度样本线
LENGTH_LINE = 1 # 长度样本线


#
# 在设置标定信息的时候，如果相应位设置了使能，并设置相关参数，
# 若没有设置使能，则标定后可以获取相关的摄像机参数
class NET_DVR_CAMERA_PARAM(Structure):
    _fields_ = [
        ("byEnableHeight", BYTE), #  是否使能设置摄像机高度线
        ("byEnableAngle", BYTE), #  是否使能设置摄像机俯仰角度
        ("byEnableHorizon", BYTE), #  是否使能设置摄像机地平线
        ("byRes", BYTE * 5), #  保留字节
        ("fCameraHeight", DOUBLE), #  摄像机高度
        ("fCameraAngle", DOUBLE), #  摄像机俯仰角度
        ("fHorizon", DOUBLE), #  场景中的地平线
    ]


LPNET_DVR_CAMERA_PARAM = POINTER(NET_DVR_CAMERA_PARAM)


#
# 当fValue表示目标高度的时候，struStartPoint和struEndPoint分别表示目标头部点和脚部点。
# 当fValue表示线段长度的时候，struStartPoint和struEndPoint分别表示线段起始点和终点，
# mode表示当前样本线表示高度线还是长度线。
class NET_DVR_LINE_SEGMENT(Structure):
    _fields_ = [
        ("byLineMode", BYTE), #  参照 LINE_MODE
        ("byRes", BYTE * 3), #  保留字节
        ("struStartPoint", NET_VCA_POINT),
        ("struEndPoint", NET_VCA_POINT),
        ("fValue", DOUBLE),
    ]


LPNET_DVR_LINE_SEGMENT = POINTER(NET_DVR_LINE_SEGMENT)


MAX_LINE_SEG_NUM = 8
# 标定样本线目前需要4-8调样本线，以获取摄像机相关参数
class NET_DVR_BEHAVIOR_OUT_CALIBRATION(Structure):
    _fields_ = [
        ("dwLineSegNum", DWORD), #  样本线个数
        ("struLineSegment", NET_DVR_LINE_SEGMENT * MAX_LINE_SEG_NUM), #  样本线最大个数
        ("struCameraParam", NET_DVR_CAMERA_PARAM), #  摄像机参数
        ("byRes", BYTE * 20),
    ]


LPNET_DVR_BEHAVIOR_OUT_CALIBRATION = POINTER(NET_DVR_BEHAVIOR_OUT_CALIBRATION)


#
# 该结构体表示IAS智能库标定样本，
# 其中包括一个目标框和一条对应的高度标定线；
# 目标框为站立的人体外接矩形框；高度线样本标识从人头顶点到脚点的标定线；
# 用归一化坐标表示；

class NET_DVR_IN_CAL_SAMPLE(Structure):
    _fields_ = [
        ("struVcaRect", NET_VCA_RECT), #  目标框
        ("struLineSegment", NET_DVR_LINE_SEGMENT), #  高度标定线
    ]


LPNET_DVR_IN_CAL_SAMPLE = POINTER(NET_DVR_IN_CAL_SAMPLE)


MAX_SAMPLE_NUM = 5 # 直接标定点最大个数
MAX_SAMPLE_NUM_EX = 7 # 样本标定点个数扩展
class NET_DVR_BEHAVIOR_IN_CALIBRATION(Structure):
    _fields_ = [
        ("dwCalSampleNum", DWORD), #   标定样本个数
        ("struCalSample", NET_DVR_IN_CAL_SAMPLE * MAX_SAMPLE_NUM), #  标定样本最大个数
        ("struCameraParam", NET_DVR_CAMERA_PARAM), #  摄像机参数
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_BEHAVIOR_IN_CALIBRATION = POINTER(NET_DVR_BEHAVIOR_IN_CALIBRATION)


CALIB_PT_NUM = 4
class NET_DVR_ITS_CALIBRATION(Structure):
    _fields_ = [
        ("dwPointNum", DWORD), # 标定点数
        ("struPoint", NET_VCA_POINT * CALIB_PT_NUM), # 图像坐标
        ("fWidth", DOUBLE),
        ("fHeight", DOUBLE),
        ("byRes1", BYTE * 100), #  保留字节
    ]


LPNET_DVR_ITS_CALIBRATION = POINTER(NET_DVR_ITS_CALIBRATION)


class NET_DVR_BV_DIRECT_CALIBRATION(Structure):
    _fields_ = [
        ("dwCameraHeight", DWORD), # 摄像机高度，单位cm
        ("fPitchAngle", DOUBLE), # 摄像机俯视角度[0°, 60°],
        ("fInclineAngle", DOUBLE), # 摄像机倾斜角度[-20°,20°]
        ("byRes1", BYTE * 228), # 保留
    ]


LPNET_DVR_BV_DIRECT_CALIBRATION = POINTER(NET_DVR_BV_DIRECT_CALIBRATION)


#  PDC 标定参数
class NET_DVR_PDC_LINE_CALIBRATION(Structure):
    _fields_ = [
        ("struCalibrationLine", NET_VCA_LINE),
        ("byRes", BYTE * 224), #  保留字节
    ]


LPNET_DVR_PDC_LINE_CALIBRATION = POINTER(NET_DVR_PDC_LINE_CALIBRATION)


#  标定参数联合体
#  后续的相关标定参数可以放在该结构里面
class NET_DVR_CALIBRATION_PRARM_UNION(Union):
    _fields_ = [
        ("byRes", BYTE * 240), # 联合体结构大小
        ("struPDCCalibration", NET_DVR_PDC_CALIBRATION), # PDC 标定参数
        ("struBehaviorOutCalibration", NET_DVR_BEHAVIOR_OUT_CALIBRATION), #   行为室外场景标定  主要应用于IVS等
        ("struBehaviorInCalibration", NET_DVR_BEHAVIOR_IN_CALIBRATION), #  行为室内场景标定，主要应用IAS等
        ("struITSCalibration", NET_DVR_ITS_CALIBRATION),
        ("struBvDirectCalibration", NET_DVR_BV_DIRECT_CALIBRATION), # 双目直接标定
        ("struPDCLineCalibration", NET_DVR_PDC_LINE_CALIBRATION), # PDC 线标定参数
    ]


LPNET_DVR_CALIBRATION_PRARM_UNION = POINTER(NET_DVR_CALIBRATION_PRARM_UNION)


#  标定配置结构
class NET_DVR_CALIBRATION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 标定结构大小
        ("byEnable", BYTE), #  是否启用标定
        ("byCalibrationType", BYTE), #  标定类型 根据不同类型在联合体类选择不同的标定 参考CALIBRATE_TYPE
        ("byRes1", BYTE * 2),
        ("uCalibrateParam", NET_DVR_CALIBRATION_PRARM_UNION), #  标定参数联合体
        ("byRes2", BYTE * 12),
    ]


LPNET_DVR_CALIBRATION_CFG = POINTER(NET_DVR_CALIBRATION_CFG)


# 流量统计方向结构体
class NET_DVR_PDC_ENTER_DIRECTION(Structure):
    _fields_ = [
        ("struStartPoint", NET_VCA_POINT), # 流量统计方向起始点
        ("struEndPoint", NET_VCA_POINT), #  流量统计方向结束点
    ]


LPNET_DVR_PDC_ENTER_DIRECTION = POINTER(NET_DVR_PDC_ENTER_DIRECTION)


class NET_DVR_PDC_RULE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byEnable", BYTE), #  是否激活规则
        ("byRes1", BYTE * 23), #  保留字节
        ("struPolygon", NET_VCA_POLYGON), #  多边形
        ("struEnterDirection", NET_DVR_PDC_ENTER_DIRECTION), #  流量进入方向
    ]


LPNET_DVR_PDC_RULE_CFG = POINTER(NET_DVR_PDC_RULE_CFG)


class NET_DVR_PDC_RULE_CFG_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byEnable", BYTE), #  是否激活规则
        ("byRes1", BYTE * 23), #  保留字节
        ("struPolygon", NET_VCA_POLYGON), #  多边形
        ("struEnterDirection", NET_DVR_PDC_ENTER_DIRECTION), #  流量进入方向
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struDayStartTime", NET_DVR_TIME_EX), # 白天开始时间，时分秒有效
        ("struNightStartTime", NET_DVR_TIME_EX), # 夜晚开始时间，时分秒有效
        ("byRes", BYTE * 100), #  保留字节
    ]


LPNET_DVR_PDC_RULE_CFG_V41 = POINTER(NET_DVR_PDC_RULE_CFG_V41)


# 条件结构
class NET_DVR_PDC_RULE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwChannel", DWORD), # 通道号
        ("dwID", DWORD), # 场景ID，兼容球机多场景概念，兼容老版本SDK配置新设备时，保留字节为0的情况，所以这个字节为0时，也默认为场景1
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_PDC_RULE_COND = POINTER(NET_DVR_PDC_RULE_COND)


# 折线结构体
class NET_VCA_POLYLINE(Structure):
    _fields_ = [
        ("struPoint", NET_VCA_POINT * 4), # 折线点
    ]


LPNET_VCA_POLYLINE = POINTER(NET_VCA_POLYLINE)


# 配置结构
class NET_DVR_PDC_RULE_CFG_V42(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byEnable", BYTE), # 是否激活规则
        ("byOSDEnable", BYTE), # 客流统计OSD显示是否启用,  0-否（0-无），1-是（0-进入和离开）， 2-进入， 3-离开   对于老设备的不启用OSD叠加对应（无），启用对应（进入/离开），4-经过人数，5-进入和经过。
        ("byCurDetectType", BYTE), # 当前检测区域类型，0-多边形，1-检测线, 2-折线检测
        ("byInterferenceSuppression", BYTE), # 干扰抑制，按位表示,0-未勾选,1-勾选，bit0-阴影，bit1-徘徊，bit2-推车
        ("struOSDPoint", NET_VCA_POINT), # 客流统计显示OSD显示左上角坐标
        # 客流量检测数据上传周期（0-15、1-1、2-5、3-10、4-20、5-30、6-60）单位：分钟
        ("byDataUploadCycle", BYTE),
        # 每秒上传机制使能（0-关闭，1-开启）
        ("bySECUploadEnable", BYTE),
        ("byEmailDayReport", BYTE), # 客流日报表使能 0-关闭，1-开启
        ("byEmailWeekReport", BYTE), # 客流周报表使能 0-关闭，1-开启
        ("byEmailMonthReport", BYTE), # 客流月报表使能0-关闭，1-开启
        ("byEmailYearReport", BYTE), # 客流年报表使能0-关闭，1-开启
        ("byRes2", BYTE * 6), #  保留字节
        ("struPolygon", NET_VCA_POLYGON), #  多边形
        ("struEnterDirection", NET_DVR_PDC_ENTER_DIRECTION), #  流量进入方向
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struDayStartTime", NET_DVR_TIME_EX), # 白天开始时间，时分秒有效
        ("struNightStartTime", NET_DVR_TIME_EX), # 夜晚开始时间，时分秒有效
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V40), # 处理方式 仅支持上传中心
        ("byDetecteSensitivity", BYTE), # 目标检测灵敏度：范围1-100，默认50
        ("byGenerateSpeedSpace", BYTE), # 目标生成速度（空域）：范围1-100，默认50
        ("byGenerateSpeedTime", BYTE), #  目标生成速度（时域）：范围1-100，默认50
        ("byCountSpeed", BYTE), #  计数速度：范围1-100，默认50
        ("byDetecteType", BYTE), #  目标检测类型：0-自动，1-人头，2-头肩，默认0-自动，自动模式下DSP调整算法的参数配置给算法库
        ("byTargetSizeCorrect", BYTE), # 目标尺寸修正：范围1-100，默认50
        ("byStreamOverlayRuleInfos", BYTE), # 码流智能信息叠加 0-否，1-是
        ("byRes3", BYTE), #  保留字节
        ("struLine", NET_VCA_LINE), # 检测线
        ("byHeightFilterEnable", BYTE), # 高度过滤是否开启，0-保留，1-关闭，2-开启
        ("byDetectThreshold", BYTE), # 检测阈值,范围[0,100],默认 90(内部使用，暂不开放)用于设定算法库中被检测目标的置信度阈值，置信度低于该阈值的目标，不用于跟踪计数；
        ("byAidedTrackEnabled", BYTE), # 辅助跟踪开关，0~开启、1~关闭，默认开启(内部使用) 用于开启和关闭算法跟踪模块中的光流辅助跟踪，跟踪客流人员，增加精准度。
        ("byRes4", BYTE),
        ("fHeightFilter", DOUBLE), # 过滤高度，单位：厘米，默认值：120厘米，范围：40-200厘米。byHeightFilterEnable为2是才有效
        ("byCalibrateType", BYTE), # 标定类型，0-未进行标定，1-自动标定，2-手动标定
        ("byCountingType", BYTE), # 计数触发方式 0-无,1-报警输入触发,2-视频分析触发
        ("bySignalType", BYTE), # 信号类型 0-电平，1-脉冲
        ("byRS485TransmissionEnabled", BYTE), # 启用485传输 0-关闭，1-开启
        ("fTiltAngle", DOUBLE), # 俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,只读
        ("fHeelAngle", DOUBLE), # 倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,只读
        ("fHeight", DOUBLE), # 高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时设置有效，其余时只读
        ("struCountPolygon", NET_VCA_POLYGON), # 计数区域：该参数默认为只读属性，若智能通道分析能力中返回了<CountingPolygon>能力节点，则代表该参数支持配置。
        ("struAutoCalibPolygon", NET_VCA_POLYGON), # 标定区域，当byCalibrateType为1时有效
        ("struDailyResetTime", NET_DVR_TIME_EX), # 定时清零
        ("struPolyLine", NET_VCA_POLYLINE), # 折线检测区域（配置折线后，struLine不做显示）
        ("byRes", BYTE * 4), # 保留字节
    ]


LPNET_DVR_PDC_RULE_CFG_V42 = POINTER(NET_DVR_PDC_RULE_CFG_V42)


# 试用版信息结构体
class NET_DVR_TRIAL_VERSION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wReserveTime", WORD), # 试用期剩余时间，0xffff表示无效，单位：天
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_TRIAL_VERSION_CFG = POINTER(NET_DVR_TRIAL_VERSION_CFG)


class NET_DVR_SYN_CHANNEL_NAME_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SYN_CHANNEL_NAME_PARAM = POINTER(NET_DVR_SYN_CHANNEL_NAME_PARAM)


class NET_DVR_RESET_COUNTER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("byMode", BYTE), # 生效模式，0-定时，1-手动
        ("byRes1", BYTE * 2),
        ("struTime", NET_DVR_TIME_EX * MAX_DAYS), # 数据清零时间，时分秒有效
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_RESET_COUNTER_CFG = POINTER(NET_DVR_RESET_COUNTER_CFG)


class NET_DVR_VCA_CTRLINFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamInfo", NET_DVR_STREAM_INFO),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_VCA_CTRLINFO_COND = POINTER(NET_DVR_VCA_CTRLINFO_COND)


NET_SDK_MAX_RELATED_CHAN_NUM = 4 # 最大关联通道数
class NET_DVR_VCA_CTRLINFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byVCAEnable", BYTE), # 是否开启智能
        ("byVCAType", BYTE), # 智能能力类型，VCA_CHAN_ABILITY_TYPE
        ("byStreamWithVCA", BYTE), # 码流中是否带智能信息
        ("byMode", BYTE), # 模式，ATM 能力时参照VCA_CHAN_MODE_TYPE ,TFS 能力时参照 TFS_CHAN_MODE_TYPE，行为分析完整版时参照BEHAVIOR_SCENE_MODE_TYPE
        ("byControlType", BYTE), # 控制类型，按位表示，0-否，1-是
        # byControlType &1 是否启用抓拍功能
        # byControlType &2 是否启用联动前端设备
        ("byRes1", BYTE * 3),
        ("wRelatedChannel", WORD * NET_SDK_MAX_RELATED_CHAN_NUM), # 关联通道号，0-不关联（当前仅ATM设备使用，当设置通道模式为ATM面板时，可以关联一路ATM人脸通道）
        ("byRes", BYTE * 72), # 保留，设置为0
    ]


LPNET_DVR_VCA_CTRLINFO_CFG = POINTER(NET_DVR_VCA_CTRLINFO_CFG)


# 设置人流量统计参数  复用行为内部关键字参数
#  HUMAN_GENERATE_RATE
#  目标生成速度参数，控制PDC库生成目标的速度。速度越快，目标越容易生成。当输入视频光照条件较差，对比度较低时，或者设置的规则区域较小时，应加快目标生成速度， 避免目标的漏检；当输入视频中对比度较高时，或者规则区域较大时，应该降低目标生成速度，以减少误检。目标生成速度参数共有5级，1级速度最慢，5级最快，默认参数为3。
#
#  DETECT_SENSITIVE
#  目标检测灵敏度控制参数，控制PDC库中一个矩形区域被检测为目标的灵敏度。灵敏度越高，矩形区域越容易被检测为目标，灵敏度越低则越难检测为目标。当输入视频光照条件较差，对比度较低时，应提高检测灵敏度， 避免目标的漏检；当输入视频中对比度较高时，应该降低检测灵敏度，以减少误检。对应参数共有5级，级别1灵敏度最低，5级最高，默认级别为3。
#  TRAJECTORY_LEN
#  轨迹生成长度控制参数，表示生成轨迹时要求目标的最大位移像素。对应参数共有5级，级别1，生成长度最长，轨迹生成最慢，5级生成长度最短，轨迹生成最快，默认级别为3。
#  TRAJECT_CNT_LEN
#  轨迹计数长度控制参数，表示轨迹计数时要求目标的最大位移像素。对应参数共有5级，级别1，计数要求长度最长，轨迹计数最慢，5级计数要求长度最短，轨迹计数最快，默认级别为3。
#  PREPROCESS
#  图像预处理控制参数，0 - 不处理；1 - 处理。默认为0；
#  CAMERA_ANGLE
#  摄像机角度输入参数， 0 - 倾斜； 1 - 垂直。默认为0；
HUMAN_GENERATE_RATE = 50 # 目标生成速度 从50开始
DETECT_SENSITIVE = 51 # 检测灵敏度

class NET_DVR_PDC_TARGET_INFO(Structure):
    _fields_ = [
        ("dwTargetID", DWORD), #  目标id
        ("struTargetRect", NET_VCA_RECT), #  目标框
        ("byRes1", BYTE * 8), #  保留字节
    ]


LPNET_DVR_PDC_TARGET_INFO = POINTER(NET_DVR_PDC_TARGET_INFO)


class NET_DVR_PDC_TARGET_IN_FRAME(Structure):
    _fields_ = [
        ("byTargetNum", BYTE), # 目标个数
        ("byRes1", BYTE * 3),
        ("struTargetInfo", NET_DVR_PDC_TARGET_INFO * MAX_TARGET_NUM), # 目标信息数组
        ("byRes2", BYTE * 8), #  保留字节
    ]


LPNET_DVR_PDC_TARGET_IN_FRAME = POINTER(NET_DVR_PDC_TARGET_IN_FRAME)


#   人流量信息查询
class NET_DVR_PDC_QUERY(Structure):
    _fields_ = [
        ("tmStart", NET_DVR_TIME),
        ("tmEnd", NET_DVR_TIME),
        ("dwLeaveNum", DWORD),
        ("dwEnterNum", DWORD),
        ("byRes1", BYTE * 256),
    ]


LPNET_DVR_PDC_QUERY = POINTER(NET_DVR_PDC_QUERY)


class NET_DVR_POSITION_RULE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struPtzPosition", NET_DVR_PTZ_POSITION), #  场景位置信息
        ("struVcaRuleCfg", NET_VCA_RULECFG), # 行为规则配置
        ("byRes2", BYTE * 80), #  保留字节
    ]


LPNET_DVR_POSITION_RULE_CFG = POINTER(NET_DVR_POSITION_RULE_CFG)


class NET_DVR_POSITION_RULE_CFG_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struPtzPosition", NET_DVR_PTZ_POSITION), #  场景位置信息
        ("struVcaRuleCfg", NET_VCA_RULECFG_V41), # 行为规则配置
        ("byTrackEnable", BYTE), # 是否启用跟踪
        ("byRes1", BYTE),
        ("wTrackDuration", WORD), # 跟踪持续时间，单位s
        ("byRes2", BYTE * 76), #  保留字节
    ]


LPNET_DVR_POSITION_RULE_CFG_V41 = POINTER(NET_DVR_POSITION_RULE_CFG_V41)


class NET_DVR_LIMIT_ANGLE(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否启用场景限位功能
        ("byRes1", BYTE * 3),
        ("struUp", NET_DVR_PTZPOS), #  上限位
        ("struDown", NET_DVR_PTZPOS), #  下限位
        ("struLeft", NET_DVR_PTZPOS), #  左限位
        ("struRight", NET_DVR_PTZPOS), #  右限位
        ("byRes2", BYTE * 20),
    ]


LPNET_DVR_LIMIT_ANGLE = POINTER(NET_DVR_LIMIT_ANGLE)


class NET_DVR_POSITION_INDEX(Structure):
    _fields_ = [
        ("byIndex", BYTE), #  场景索引
        ("byRes1", BYTE),
        ("wDwell", WORD), #  停留时间
        ("byRes2", BYTE * 4), #  保留字节
    ]


LPNET_DVR_POSITION_INDEX = POINTER(NET_DVR_POSITION_INDEX)


MAX_POSITION_NUM = 10
class NET_DVR_POSITION_TRACK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byNum", BYTE), #  场景个数
        ("byRes1", BYTE * 3),
        ("struPositionIndex", NET_DVR_POSITION_INDEX * MAX_POSITION_NUM),
        ("byRes2", BYTE * 8),
    ]


LPNET_DVR_POSITION_TRACK_CFG = POINTER(NET_DVR_POSITION_TRACK_CFG)


# 巡航路径场景信息
class NET_DVR_PATROL_SCENE_INFO(Structure):
    _fields_ = [
        ("wDwell", WORD), #  停留时间 30-300
        ("byPositionID", BYTE), #  场景号1-10，默认0表示该巡航点不添加场景
        ("byRes", BYTE * 5),
    ]


LPNET_DVR_PATROL_SCENE_INFO = POINTER(NET_DVR_PATROL_SCENE_INFO)


#  场景巡航跟踪配置信息
class NET_DVR_PATROL_TRACKCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struPatrolSceneInfo", NET_DVR_PATROL_SCENE_INFO * 10), #  巡航路径
        ("byRes", BYTE * 16), #  保留字节
    ]


LPNET_DVR_PATROL_TRACKCFG = POINTER(NET_DVR_PATROL_TRACKCFG)


# 球机本地规则菜单配置结构体
class NET_DVR_TRACK_PARAMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("wAlarmDelayTime", WORD), #  报警延时时间，目前球机只支持全局入侵 范围1-120秒
        ("wTrackHoldTime", WORD), #  报警跟踪持续时间  范围0-300秒
        ("byTrackMode", BYTE), #   参照 IPDOME_TRACK_MODE
        ("byPreDirection", BYTE), #  跟踪方向预判 0-不启用 1-启用
        ("byTrackSmooth", BYTE), #  跟踪连续  0-不启用 1-启用
        ("byZoomAdjust", BYTE), #  倍率系数调整 参见下表
        ("byMaxTrackZoom", BYTE), # 最大跟踪倍率系数,0-表示默认倍率系数,等级6-标定值*1.0(默认),1-5为缩小标定值，值越小，缩小的比例越大,7-15为放大，值越大，放大的比例越大
        ("byStopTrackWhenFindFace", BYTE), # 人脸检测到后是否停止跟踪 0-否 1-是
        ("byStopTrackThreshold", BYTE), # 跟踪终止评分阈值
        ("byRes", BYTE * 9), #   保留字节
    ]


LPNET_DVR_TRACK_PARAMCFG = POINTER(NET_DVR_TRACK_PARAMCFG)


#  球机机芯参数
class NET_DVR_DOME_MOVEMENT_PARAM(Structure):
    _fields_ = [
        ("wMaxZoom", WORD), #  球机最大倍率系数
        ("byRes", BYTE * 42), #  保留字节
    ]


LPNET_DVR_DOME_MOVEMENT_PARAM = POINTER(NET_DVR_DOME_MOVEMENT_PARAM)

MAX_REGION_NUM = 8 #  区域列表最大数目
MAX_TPS_RULE = 8 #  最大参数规则数目
MAX_AID_RULE = 8 #  最大事件规则数目
MAX_LANE_NUM = 8 #  最大车道数目

CONGESTION = 0x01 # 拥堵
PARKING = 0x02 # 停车
INVERSE = 0x04 # 逆行
PEDESTRIAN = 0x08 # 行人
DEBRIS = 0x10 # 遗留物 抛洒物碎片
SMOKE = 0x20 # 烟雾
OVERLINE = 0x40 # 压线
VEHICLE_CONTROL_LIST = 0x80 # 黑名单数据
SPEED = 0x100 # 超速
LANECHANGE = 0x200 # 变道
TURNAROUND = 0x400 # 掉头
VEHICLE_OCCUPANCY_NONVEHICLE = 0x800 # 机动车占用非机动车位
GASSER = 0x1000 # 加塞
ROADBLOCK = 0x2000 # 路障
CONSTRUCTION = 0x4000 # 施工
TRAFFIC_ACCIDENT = 0x8000 # 交通事故检测（交通事故目前先做车车事故，追尾、剐蹭等算法判断车与车之间轨迹有交叉，其他车辆绕行则报警）
PARALLEL_PARKING = 0x10000 # 侧方位停车检测
FOG_DETECTION = 0x20000 # 浓雾检测
OCCUPY_EMERGENCY_LANE = 0x40000 # 占用紧急车道
CONFLAGRATION = 0X80000 # 火灾
TFS_MANUAL_TRIGGER = 0x100000 # 手动违章取证事件
LOADING_DOCK_TRIGGER_UPLOAD = 0x200000 # 月台触发上传
OCCUPY_OVERTAKING_LANE = 0x400000 # 占用超车道
PROHIBITION_MARK_VIOLATION = 0x800000 # 违反禁令标志
CHECK_POINT = 0x1000000 # 卡口
SUDDEN_SPEED_DROP = 0x2000000 # 速度骤降
SLOW_MOVING = 0x4000000 # 车辆缓行

FREEWAY = 0 # 高速户外场景
TUNNEL = 1 # 高速隧道场景
BRIDGE = 2 # 高速桥梁场景

ITS_CONGESTION_ABILITY = 0x01 # 拥堵
ITS_PARKING_ABILITY = 0x02 # 停车
ITS_INVERSE_ABILITY = 0x04 # 逆行
ITS_PEDESTRIAN_ABILITY = 0x08 # 行人
ITS_DEBRIS_ABILITY = 0x10 # 遗留物 抛洒物碎片
ITS_SMOKE_ABILITY = 0x20 # 烟雾 - 隧道
ITS_OVERLINE_ABILITY = 0x40 # 压线
ITS_VEHICLE_CONTROL_LIST_ABILITY = 0x80 # 黑名单数据
ITS_SPEED_ABILITY = 0x100 # 超速
ITS_LANECHANGE_ABILITY = 0x200 # 变道
ITS_TURNAROUND_ABILITY = 0x400 # 掉头
ITS_LANE_VOLUME_ABILITY = 0x010000 # 车道流量
ITS_LANE_VELOCITY_ABILITY = 0x020000 # 车道平均速度
ITS_TIME_HEADWAY_ABILITY = 0x040000 # 车头时距
ITS_SPACE_HEADWAY_ABILITY = 0x080000 # 车头间距
ITS_TIME_OCCUPANCY_RATIO_ABILITY = 0x100000 # 车道占有率，（时间上)
ITS_SPACE_OCCUPANCY_RATIO_ABILITY = 0x200000 # 车道占有率，百分比计算（空间上)
ITS_LANE_QUEUE_ABILITY = 0x400000 # 排队长度
ITS_VEHICLE_TYPE_ABILITY = 0x800000 # 车辆类型
ITS_TRAFFIC_STATE_ABILITY = 0x1000000 # 交通状态

LANE_VOLUME = 0x01 # 车道流量
LANE_VELOCITY = 0x02 # 车道速度
TIME_HEADWAY = 0x04 # 车头时距
SPACE_HEADWAY = 0x08 # 车头间距
TIME_OCCUPANCY_RATIO = 0x10 # 车道占有率(时间上)
SPACE_OCCUPANCY_RATIO = 0x20 # 车道占有率，百分比计算(空间上)
QUEUE = 0x40 # 排队长度
VEHICLE_TYPE = 0x80 # 车辆类型
TRAFFIC_STATE = 0x100 # 交通状态


class NET_DVR_REGION_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byNum", BYTE), #  区域个数
        ("byRes1", BYTE * 3), #  保留字节
        ("struPolygon", NET_VCA_POLYGON * MAX_REGION_NUM), #  区域
        ("byRes2", BYTE * 20), #  保留字节
    ]


LPNET_DVR_REGION_LIST = POINTER(NET_DVR_REGION_LIST)


#  方向结构体
class NET_DVR_DIRECTION(Structure):
    _fields_ = [
        ("struStartPoint", NET_VCA_POINT), #  方向起始点
        ("struEndPoint", NET_VCA_POINT), #  方向结束点
    ]


LPNET_DVR_DIRECTION = POINTER(NET_DVR_DIRECTION)


#  单个车道
class NET_DVR_ONE_LANE(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  车道是否启用
        ("byRes1", BYTE * 11), #  保留字节
        ("byLaneName", BYTE * NAME_LEN), #  车道规则名称
        ("struFlowDirection", NET_DVR_DIRECTION), #  车道内车流方向
        ("struPolygon", NET_VCA_POLYGON), #  车道区域
    ]


LPNET_DVR_ONE_LANE = POINTER(NET_DVR_ONE_LANE)


#  车道配置
class NET_DVR_LANE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struLane", NET_DVR_ONE_LANE * MAX_LANE_NUM), #  车道参数 数组下标作为车道ID，
        ("byRes1", BYTE * 40), #  保留字节
    ]


LPNET_DVR_LANE_CFG = POINTER(NET_DVR_LANE_CFG)


#  交通事件参数
class NET_DVR_AID_PARAM(Structure):
    _fields_ = [
        ("wParkingDuration", WORD), #  违停检测灵敏度  10-120s
        ("wPedestrianDuration", WORD), #  行人持续时间    1-120s
        ("wDebrisDuration", WORD), #  抛洒物持续时间  10-120s
        ("wCongestionLength", WORD), #  拥堵长度阈值    5-200（米）
        ("wCongestionDuration", WORD), #  拥堵持续参数    10-120s
        ("wInverseDuration", WORD), #  逆行持续时间    1-10s
        ("wInverseDistance", WORD), #  逆行距离阈值 单位m 范围[2-100] 默认 10米
        ("wInverseAngleTolerance", WORD), #  允许角度偏差 90-180度,车流与逆行允许的夹角
        ("wIllegalParkingTime", WORD), #  违停时间[4,60]，单位：分钟 ,TFS(交通违章取证) 城市模式下
        ("wIllegalParkingPicNum", WORD), #  违停图片数量[1,6], TFS(交通违章取证) 城市模式下
        ("byMergePic", BYTE), #  图片拼接,TFS 城市模式下 0- 不拼接 1- 拼接
        ("byRes1", BYTE * 23), #  保留字节
    ]


LPNET_DVR_AID_PARAM = POINTER(NET_DVR_AID_PARAM)


#  单条交通事件规则结构体
class NET_DVR_ONE_AID_RULE(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否启用事件规则
        ("byRes1", BYTE * 3), #  保留字节
        ("byRuleName", BYTE * NAME_LEN), #  规则名称
        ("dwEventType", DWORD), #  交通事件检测类型 TRAFFIC_AID_TYPE
        ("struSizeFilter", NET_VCA_SIZE_FILTER), #  尺寸过滤器
        ("struPolygon", NET_VCA_POLYGON), #  规则区域
        ("struAIDParam", NET_DVR_AID_PARAM), #   事件参数
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("byRes2", BYTE * 20),
    ]


LPNET_DVR_ONE_AID_RULE = POINTER(NET_DVR_ONE_AID_RULE)


#  交通事件规则
class NET_DVR_AID_RULECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 非0-上传
        ("byRes1", BYTE * 3), #  保留字节
        ("struPictureParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struOneAIDRule", NET_DVR_ONE_AID_RULE * MAX_AID_RULE),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_AID_RULECFG = POINTER(NET_DVR_AID_RULECFG)


#  单条交通事件规则结构体(扩展)
class NET_DVR_ONE_AID_RULE_V41(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否启用事件规则
        ("byLaneNo", BYTE), #  关联车道号
        ("byRes1", BYTE * 2), #  保留字节
        ("byRuleName", BYTE * NAME_LEN), #  规则名称
        ("dwEventType", DWORD), #  交通事件检测类型 TRAFFIC_AID_TYPE
        ("struSizeFilter", NET_VCA_SIZE_FILTER), #  尺寸过滤器
        ("struPolygon", NET_VCA_POLYGON), #  规则区域
        ("struAIDParam", NET_DVR_AID_PARAM), #  事件参数
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), #  布防时间段
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRelRecordChan", BYTE * MAX_IVMS_IP_CHANNEL), # 报警触发的录象通道：1表示触发该通道；0表示不触发
        ("byRes2", BYTE * 60), # 保留
    ]


LPNET_DVR_ONE_AID_RULE_V41 = POINTER(NET_DVR_ONE_AID_RULE_V41)


#  交通事件规则(扩展)
class NET_DVR_AID_RULECFG_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byPicProType", BYTE), #  报警时图片处理方式 0-不处理 非0-上传
        ("byRes1", BYTE * 3), #  保留字节
        ("struPictureParam", NET_DVR_JPEGPARA), #  图片规格结构
        ("struAIDRule", NET_DVR_ONE_AID_RULE_V41 * MAX_AID_RULE), # 规则数组
        ("byRes2", BYTE * 128), # 保留
    ]


LPNET_DVR_AID_RULECFG_V41 = POINTER(NET_DVR_AID_RULECFG_V41)


#  交通统计参数结构体
class NET_DVR_ONE_TPS_RULE(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否使能车道交通规则参数
        ("byLaneID", BYTE), # 车道ID
        ("byRes1", BYTE * 2),
        ("dwCalcType", DWORD), # 统计参数类型ITS_TPS_TYPE
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struVitrualLoop", NET_VCA_POLYGON), # 虚拟线圈
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式,一般为处理是否上传中心，其他功能不需要
        ("byRes2", BYTE * 20), # 保留字节
    ]


LPNET_DVR_ONE_TPS_RULE = POINTER(NET_DVR_ONE_TPS_RULE)


#  交通参数统计规则配置结构体
class NET_DVR_TPS_RULECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struOneTpsRule", NET_DVR_ONE_TPS_RULE * MAX_TPS_RULE), #  下标对应交通参数ID
        ("byRes2", BYTE * 40), #  保留字节
    ]


LPNET_DVR_TPS_RULECFG = POINTER(NET_DVR_TPS_RULECFG)


#  交通统计参数结构体(扩展)
class NET_DVR_ONE_TPS_RULE_V41(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否使能车道交通规则参数
        ("byLaneID", BYTE), # 车道ID
        ("byRes1", BYTE * 2), # 保留
        ("dwCalcType", DWORD), #  统计参数类型ITS_TPS_TYPE
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struVitrualLoop", NET_VCA_POLYGON), # 虚拟线圈
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRes2", BYTE * 60), #  保留字节
    ]


LPNET_DVR_ONE_TPS_RULE_V41 = POINTER(NET_DVR_ONE_TPS_RULE_V41)


#  交通参数统计规则配置结构体(扩展)
class NET_DVR_TPS_RULECFG_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struOneTpsRule", NET_DVR_ONE_TPS_RULE_V41 * MAX_TPS_RULE), #  下标对应交通参数ID
        ("byRes", BYTE * 128), #  保留
    ]


LPNET_DVR_TPS_RULECFG_V41 = POINTER(NET_DVR_TPS_RULECFG_V41)

ENUM_AID_TYPE_CONGESTION = 1 # 拥堵
ENUM_AID_TYPE_PARKING = 2 # 停车
ENUM_AID_TYPE_INVERSE = 3 # 逆行
ENUM_AID_TYPE_PEDESTRIAN = 4 # 行人
ENUM_AID_TYPE_DEBRIS = 5 # 遗留物 抛洒物碎片
ENUM_AID_TYPE_SMOKE = 6 # 烟雾
ENUM_AID_TYPE_OVERLINE = 7 # 压线
ENUM_AID_TYPE_VEHICLE_CONTROL_LIST = 8 # 黑名单数据
ENUM_AID_TYPE_SPEED = 9 # 超速
ENUM_AID_TYPE_LANECHANGE = 10 # 变道
ENUM_AID_TYPE_TURNAROUND = 11 # 掉头
ENUM_AID_TYPE_VEHICLE_OCCUPANCY_NONVEHICLE = 12 # 机动车占用非机动车位
ENUM_AID_TYPE_GASSER = 13 # 加塞
ENUM_AID_TYPE_ROADBLOCK = 14 # 路障
ENUM_AID_TYPE_CONSTRUCTION = 15 # 施工
ENUM_AID_TYPE_TRAFFIC_ACCIDENT = 16 # 交通事故检测（交通事故目前先做车车事故，追尾、剐蹭等算法判断车与车之间轨迹有交叉，其他车辆绕行则报警）
ENUM_AID_TYPE_PARALLEL_PARKING = 17 # 侧方位停车检测
ENUM_AID_TYPE_FOG_DETECTION = 18 # 浓雾检测
ENUM_AID_TYPE_OCCUPY_EMERGENCY_LANE = 19 # 占用紧急车道
ENUM_AID_TYPE_CONFLAGRATION = 20 # 火灾
ENUM_AID_TYPE_TFS_MANUAL_TRIGGER = 21 # 手动违章取证事件
ENUM_AID_TYPE_LOADING_DOCK_TRIGGER_UPLOAD = 22 # 月台触发上传
ENUM_AID_TYPE_OCCUPY_OVERTAKING_LANE = 23 # 占用超车道
ENUM_AID_TYPE_PROHIBITION_MARK_VIOLATION = 24 # 违反禁令标志
ENUM_AID_TYPE_CHECK_POINT = 25 # 卡口
ENUM_AID_TYPE_SUDDEN_SPEED_DROP = 26 # 速度骤降
ENUM_AID_TYPE_SLOW_MOVING = 27 # 车辆缓行
ENUM_AID_TYPE_NOT_KEEP_DISTANCE = 28 # 未保持车距
ENUM_AID_TYPE_NOT_SLOW_ZEBRA_CROSSING = 29 # 斑马线未减速
ENUM_AID_TYPE_OVER_TAKE_RIGHT_SIDE = 30 # 右侧超车
ENUM_AID_TYPE_LOW_SPEED = 31 # 机动车低速行驶
ENUM_AID_TYPE_DRAG_RACING = 32 # 飙车
ENUM_AID_TYPE_CHANGE_LANE_CONTINUOUSLY = 33 # 连续变道
ENUM_AID_TYPE_S_SHARP_DRIVING = 34 # 蛇形行驶
ENUM_AID_TYPE_LARGE_VEHICLE_OCCUPY_LINE = 35 # 大车占道


#  交通事件信息
class NET_DVR_AID_INFO(Structure):
    _fields_ = [
        ("byRuleID", BYTE), #  规则序号，为规则配置结构下标，0-16
        ("byVisibilityLevel", BYTE), #  能见度等级：0-保留；1-无雾~薄雾；2-薄雾~中雾；3-大雾~浓雾；4-浓雾及以上
        ("byRes1", BYTE * 2),
        ("byRuleName", BYTE * NAME_LEN), #   规则名称
        ("dwAIDType", DWORD), #  报警事件类型
        ("struDirect", NET_DVR_DIRECTION), #  报警指向区域
        ("bySpeedLimit", BYTE), # 限速值，单位km/h[0,255]
        ("byCurrentSpeed", BYTE), # 当前速度值，单位km/h[0,255]
        ("byVehicleEnterState", BYTE), # 车辆出入状态 0-无效 1-驶入 2-驶出
        ("byState", BYTE), # 0-变化上传，1-轮巡上传，2-当前设备定时抓拍的数据上传，实际作用于平台形成图片序列，用于反查算法没有检测到的停车车辆（索引值2在“dwAIDType报警事件类型”为 “停车事件”的时候生效）
        ("byParkingID", BYTE * 16), # 停车位编号
        ("dwAIDTypeEx", DWORD), #  报警事件类型扩展,参考TRAFFIC_AID_TYPE_EX
        ("byRes2", BYTE * 16), #  保留字节
    ]


LPNET_DVR_AID_INFO = POINTER(NET_DVR_AID_INFO)


#  交通事件报警
class NET_DVR_AID_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构长度
        ("dwRelativeTime", DWORD), #  相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), #  前端设备信息
        ("struAIDInfo", NET_DVR_AID_INFO), #  交通事件信息
        ("dwPicDataLen", DWORD), #  返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
        ("*pImage", BYTE), #  指向图片的指针
        ("byRes", BYTE * 40), #  保留字节
    ]


LPNET_DVR_AID_ALARM = POINTER(NET_DVR_AID_ALARM)


#  车道队列结构体
class NET_DVR_LANE_QUEUE(Structure):
    _fields_ = [
        ("struHead", NET_VCA_POINT), # 队列头
        ("struTail", NET_VCA_POINT), # 队列尾
        ("dwLength", DWORD), # 实际队列长度 单位为米 [0-500]
    ]


LPNET_DVR_LANE_QUEUE = POINTER(NET_DVR_LANE_QUEUE)

NO_VARY = 0 # 无变化
VEHICLE_ENTER = 1 # 车辆进入虚拟线圈
VEHICLE_LEAVE = 2 # 车辆离开虚拟线圈
UEUE_VARY = 3 # 队列变化

class NET_DVR_LANE_PARAM(Structure):
    _fields_ = [
        ("byRuleName", BYTE * NAME_LEN), # 车道规则名称
        ("byRuleID", BYTE), # 规则序号，为规则配置结构下标，0-7
        ("byVaryType", BYTE), # 车道交通参数变化类型 参照 TRAFFIC_DATA_VARY_TYPE
        ("byLaneType", BYTE), # 车道上行或下行
        ("byRes1", BYTE),
        ("dwLaneVolume", DWORD), # 车道流量 ，统计有多少车子通过
        ("dwLaneVelocity", DWORD), # 车道速度，公里计算
        ("dwTimeHeadway", DWORD), # 车头时距，以秒计算
        ("dwSpaceHeadway", DWORD), # 车头间距，以米来计算
        ("fSpaceOccupyRation", DOUBLE), # 车道占有率，百分比计算（空间上)
        ("struLaneQueue", NET_DVR_LANE_QUEUE), # 车道队列长度
        ("struRuleLocation", NET_VCA_POINT), # 线圈规则的中心点位置
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_LANE_PARAM = POINTER(NET_DVR_LANE_PARAM)


class NET_DVR_TPS_INFO(Structure):
    _fields_ = [
        ("dwLanNum", DWORD), #  交通参数的车道数目
        ("struLaneParam", NET_DVR_LANE_PARAM * MAX_TPS_RULE),
    ]


LPNET_DVR_TPS_INFO = POINTER(NET_DVR_TPS_INFO)


class NET_DVR_TPS_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("struTPSInfo", NET_DVR_TPS_INFO), # 交通事件信息
        ("byRes1", BYTE * 32), # 保留字节
    ]


LPNET_DVR_TPS_ALARM = POINTER(NET_DVR_TPS_ALARM)

ENUM_TRAFFIC_VARY_NO = 0x00 # 无变化
ENUM_TRAFFIC_VARY_VEHICLE_ENTER = 0x01 # 车辆进入虚拟线圈
ENUM_TRAFFIC_VARY_VEHICLE_LEAVE = 0x02 # 车辆离开虚拟线圈
ENUM_TRAFFIC_VARY_QUEUE = 0x04 # 队列变化
ENUM_TRAFFIC_VARY_STATISTIC = 0x08 # 统计数据变化（每分钟变化一次包括平均速度，车道空间 / 时间占有率，交通状态）       


class NET_DVR_LANE_PARAM_V41(Structure):
    _fields_ = [
        ("byRuleName", BYTE * NAME_LEN), #  车道规则名称
        ("byRuleID", BYTE), #  规则序号，为规则配置结构下标，0-7
        ("byLaneType", BYTE), #  车道上行或下行
        ("byTrafficState", BYTE), #  车道的交通状态，0-无效，1-畅通，2-拥挤，3-堵塞
        ("byLaneNo", BYTE), # 车道号
        ("dwVaryType", DWORD), #  车道交通参数变化类型参照  TRAFFIC_DATA_VARY_TYPE_EX_ENUM，按位区分
        ("dwTpsType", DWORD), #  数据变化类型标志，表示当前上传的统计参数中，哪些数据有效，参照ITS_TPS_TYPE,按位区分
        ("dwLaneVolume", DWORD), #  车道流量，统计有多少车子通过
        ("dwLaneVelocity", DWORD), #  车道速度，公里计算
        ("dwTimeHeadway", DWORD), #  车头时距，以秒计算
        ("dwSpaceHeadway", DWORD), #  车头间距，以米来计算
        ("fSpaceOccupyRation", DOUBLE), #  车道占有率，百分比计算（空间上)
        ("fTimeOccupyRation", DOUBLE), #  时间占有率，百分比计算
        ("dwLightVehicle", DWORD), #  小型车数量
        ("dwMidVehicle", DWORD), #  中型车数量
        ("dwHeavyVehicle", DWORD), #  重型车数量
        ("struLaneQueue", NET_DVR_LANE_QUEUE), #  车道队列长度
        ("struRuleLocation", NET_VCA_POINT), #  规则位置虚拟线圈的中心
        ("dwOversizeVehicle", DWORD), #  大型车数量
        ("byRes2", BYTE * 60), #  保留
    ]


LPNET_DVR_LANE_PARAM_V41 = POINTER(NET_DVR_LANE_PARAM_V41)


class NET_DVR_TPS_INFO_V41(Structure):
    _fields_ = [
        ("dwLanNum", DWORD), #  交通参数的车道数目
        ("struLaneParam", NET_DVR_LANE_PARAM_V41 * MAX_TPS_RULE),
        ("dwSceneID", DWORD), # 场景ID
        ("byRes", BYTE * 28), # 保留
    ]


LPNET_DVR_TPS_INFO_V41 = POINTER(NET_DVR_TPS_INFO_V41)


#  人脸规则配置
class NET_DVR_FACEDETECT_RULECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnable", BYTE), #  是否启用
        ("byEventType", BYTE), # 警戒事件类型， 0-异常人脸 1-正常人脸2-异常人脸&正常人脸4-多张人脸&异常人脸5-多张人脸&正常人脸 6-多张人脸&异常人脸&正常人脸 7-多张人脸
        ("byUpLastAlarm", BYTE), # 2011-04-06 是否先上传最近一次的报警
        ("byUpFacePic", BYTE), # 是否上传人脸子图，0-否，1-是
        ("byRuleName", BYTE * NAME_LEN),
        ("struVcaPolygon", NET_VCA_POLYGON), #  人脸检测规则区域
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 非0-上传
        ("bySensitivity", BYTE), #  规则灵敏度
        ("wDuration", WORD), #  触发人脸报警时间阈值
        ("struPictureParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("byPicRecordEnable", BYTE), # 2012-3-1是否启用图片存储, 0-不启用, 1-启用
        ("byRes1", BYTE * 3), # 保留字节
        #
        # 警戒事件类型：（目前事件类型按位表示，可任意选择其中1种或者几种进行组合）
        # 0x00: 无效
        # 0x01: 异常人脸
        # 0x02: 正常人脸
        # 0x04: 多张人脸
        # 0x08: 戴墨镜人脸
        # 0x10: 打电话人脸
        #
        ("dwEventTypeEx", DWORD), # dwEventTypeEx字段若为0时，byEventType字段生效。若dwEventTypeEx、byEventType字段都有值时，以dwEventTypeEx字段为准。上层配置dwEventTypeEx字段后，会将值同步到byEventType中。
        ("byRes2", BYTE * 32), # 保留字节
    ]


LPNET_DVR_FACEDETECT_RULECFG = POINTER(NET_DVR_FACEDETECT_RULECFG)


class NET_DVR_FACE_PIPCFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否开启画中画
        ("byBackChannel", BYTE), # 背景通道号（面板通道）
        ("byPosition", BYTE), # 叠加位置，0-左上,1-左下,2-右上,3-右下
        ("byPIPDiv", BYTE), # 分屏系数(人脸画面:面板画面)，0-1:4,1-1:9,2-1:16
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_FACE_PIPCFG = POINTER(NET_DVR_FACE_PIPCFG)


class NET_DVR_FACEDETECT_RULECFG_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnable", BYTE), #  是否启用
        ("byEventType", BYTE), # 警戒事件类型， 0-异常人脸 1-正常人脸2-异常人脸&正常人脸4-多张人脸&异常人脸5-多张人脸&正常人脸 6-多张人脸&异常人脸&正常人脸 7-多张人脸
        ("byUpLastAlarm", BYTE), # 2011-04-06 是否先上传最近一次的报警
        ("byUpFacePic", BYTE), # 是否上传人脸子图，0-否，1-是
        ("byRuleName", BYTE * NAME_LEN),
        ("struVcaPolygon", NET_VCA_POLYGON), #  人脸检测规则区域
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 非0-上传
        ("bySensitivity", BYTE), #  规则灵敏度
        ("wDuration", WORD), #  触发人脸报警时间阈值
        ("struPictureParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("byPicRecordEnable", BYTE), # 2012-10-22是否启用图片存储, 0-不启用, 1-启用
        ("byRes1", BYTE),
        ("wAlarmDelay", WORD), # 2012-10-22智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
        ("struFacePIP", NET_DVR_FACE_PIPCFG), # 2012-11-7画中画参数
        ("wRelSnapChan", WORD * MAX_REL_SNAPCHAN_NUM), # 关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
        ("byRes2", BYTE * 2), # 保留字节
        #
        # 警戒事件类型：（目前事件类型按位表示，可任意选择其中1种或者几种进行组合）
        # 0x00: 无效
        # 0x01: 异常人脸
        # 0x02: 正常人脸
        # 0x04: 多张人脸
        # 0x08: 戴墨镜人脸
        # 0x10: 打电话人脸
        #
        ("dwEventTypeEx", DWORD), # dwEventTypeEx字段若为0时，byEventType字段生效。若dwEventTypeEx、byEventType字段都有值时，以dwEventTypeEx字段为准。上层配置dwEventTypeEx字段后，会将值同步到byEventType中。
        ("byRes", BYTE * 16), # 保留字节
    ]


LPNET_DVR_FACEDETECT_RULECFG_V41 = POINTER(NET_DVR_FACEDETECT_RULECFG_V41)


class NET_DVR_FACEDETECT_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("byRuleName", BYTE * NAME_LEN), # 规则名称
        ("struTargetInfo", NET_VCA_TARGET_INFO), # 报警目标信息
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("dwPicDataLen", DWORD), # 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
        ("byAlarmPicType", BYTE), #  0-异常人脸报警图片 1- 人脸图片,2-多张人脸, 3-戴墨镜人脸, 4-打电话人脸
        ("byPanelChan", BYTE), # 2012-3-1人脸通道关联的面板通道
        ("byRelAlarmPicNum", BYTE), # 关联通道报警图片数量
        ("byRes1", BYTE),
        ("dwFacePicDataLen", DWORD), # 人脸图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
        ("dwAlarmID", DWORD), # 报警ID，用以标识通道间关联产生的组合报警，0表示无效
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byRes2", BYTE * 42), #  保留字节
        ("*pFaceImage", BYTE), # 指向人脸图指针
        ("*pImage", BYTE), # 指向图片的指针
    ]


LPNET_DVR_FACEDETECT_ALARM = POINTER(NET_DVR_FACEDETECT_ALARM)


class NET_DVR_EVENT_PARAM_UNION(Structure):
    _fields_ = [
        ("uLen", DWORD * 3), #  联合体大小为12字节
        ("dwHumanIn", DWORD), # 有无人接近 0 - 无人 1- 有人
        ("fCrowdDensity", DOUBLE), #  人员聚集值
    ]


LPNET_DVR_EVENT_PARAM_UNION = POINTER(NET_DVR_EVENT_PARAM_UNION)


#  目前只有有人无人事件和人员聚集事件实时报警上传
class NET_DVR_EVENT_INFO(Structure):
    _fields_ = [
        ("byRuleID", BYTE), #  Rule ID
        ("byRes", BYTE * 3), #  保留字节
        ("byRuleName", BYTE * NAME_LEN), #  规则名称
        ("dwEventType", DWORD), #  参照VCA_EVENT_TYPE
        ("uEventParam", NET_DVR_EVENT_PARAM_UNION),
    ]


LPNET_DVR_EVENT_INFO = POINTER(NET_DVR_EVENT_INFO)


class NET_DVR_EVENT_INFO_LIST(Structure):
    _fields_ = [
        ("byNum", BYTE), #  事件实时信息个数
        ("byRes1", BYTE * 3), #  保留字节
        ("struEventInfo", NET_DVR_EVENT_INFO * MAX_RULE_NUM), #  事际实时信息
    ]


LPNET_DVR_EVENT_INFO_LIST = POINTER(NET_DVR_EVENT_INFO_LIST)


class NET_DVR_RULE_INFO_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwRelativeTime", DWORD), #  相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), #  前端设备信息
        ("struEventInfoList", NET_DVR_EVENT_INFO_LIST), # 事件信息列表
        ("byRes2", BYTE * 40), #  保留字节
    ]


LPNET_DVR_RULE_INFO_ALARM = POINTER(NET_DVR_RULE_INFO_ALARM)


# 单条场景时间段
class NET_DVR_ONE_SCENE_TIME(Structure):
    _fields_ = [
        ("byActive", BYTE), # 0 -无效,1–有效
        ("byRes1", BYTE * 3), # 保留
        ("dwSceneID", DWORD), # 场景ID
        ("struEffectiveTime", NET_DVR_SCHEDTIME), # 场景起效时间
        ("byRes2", BYTE * 16), # 保留
    ]


LPNET_DVR_ONE_SCENE_TIME = POINTER(NET_DVR_ONE_SCENE_TIME)


# 场景起效时间段配置
class NET_DVR_SCENE_TIME_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("struSceneTime", NET_DVR_ONE_SCENE_TIME * MAX_SCENE_TIMESEG_NUM), # 场景时间段数组
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_SCENE_TIME_CFG = POINTER(NET_DVR_SCENE_TIME_CFG)


# 单条场景配置信息
class NET_DVR_ONE_SCENE_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该场景,0-不启用 1- 启用
        ("byDirection", BYTE), # 监测方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
        ("byRes1", BYTE * 2), # 保留
        ("dwSceneID", DWORD), # 场景ID(只读), 0 - 表示该场景无效
        ("bySceneName", BYTE * NAME_LEN), # 场景名称
        ("struPtzPos", NET_DVR_PTZPOS), # ptz 坐标
        ("dwTrackTime", DWORD), # 球机跟踪时间[5,300] 秒，TFS(交通取证)模式下有效
        ("byRes2", BYTE * 24), # 保留
    ]


LPNET_DVR_ONE_SCENE_CFG = POINTER(NET_DVR_ONE_SCENE_CFG)


# 场景配置结构体
class NET_DVR_SCENE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("struSceneCfg", NET_DVR_ONE_SCENE_CFG * MAX_ITS_SCENE_NUM), # 场景配置信息
        ("byRes", BYTE * 40), # 保留
    ]


LPNET_DVR_SCENE_CFG = POINTER(NET_DVR_SCENE_CFG)


# 多场景操作条件
class NET_DVR_SCENE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("lChannel", LONG), # 通道号
        ("dwSceneID", DWORD), # 场景ID, 0-表示该场景无效
        ("byRes", BYTE * 48), # 保留
    ]


LPNET_DVR_SCENE_COND = POINTER(NET_DVR_SCENE_COND)


# 取证方式
class NET_DVR_FORENSICS_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byMode", BYTE), #  0-手动取证 ,1-自动取证，2-半自动跟踪和静态取证
        ("byRes", BYTE * 23), # 保留
    ]


LPNET_DVR_FORENSICS_MODE = POINTER(NET_DVR_FORENSICS_MODE)


# 报警场景信息
class NET_DVR_SCENE_INFO(Structure):
    _fields_ = [
        ("dwSceneID", DWORD), # 场景ID, 0 - 表示该场景无效
        ("bySceneName", BYTE * NAME_LEN), # 场景名称
        ("byDirection", BYTE), # 监测方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
        ("byRes1", BYTE * 3), # 保留
        ("struPtzPos", NET_DVR_PTZPOS), # Ptz 坐标
        ("byRes2", BYTE * 64), # 保留
    ]


LPNET_DVR_SCENE_INFO = POINTER(NET_DVR_SCENE_INFO)


# 交通事件报警(扩展)
class NET_DVR_AID_ALARM_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("struAIDInfo", NET_DVR_AID_INFO), # 交通事件信息
        ("struSceneInfo", NET_DVR_SCENE_INFO), # 场景信息
        ("dwPicDataLen", DWORD), # 图片长度
        ("*pImage", BYTE), # 指向图片的指针
        # 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
        ("byDataType", BYTE),
        ("byLaneNo", BYTE), # 关联车道号
        ("wMilliSecond", WORD), # 时标毫秒
        # 监测点编号（路口编号、内部编号）
        ("byMonitoringSiteID", BYTE * MONITORSITE_ID_LEN),
        ("byDeviceID", BYTE * DEVICE_ID_LEN), # 设备编号
        ("dwXmlLen", DWORD), # XML报警信息长度
        ("pXmlBuf", CHARP), #  XML报警信息指针,其XML对应到EventNotificationAlert XML Block
        ("byTargetType", BYTE), #  检测的目标类型，0~未知，1~行人、2~二轮车、3~三轮车(行人检测中返回)
        ("byRes", BYTE * 7), #  保留字节
        ("dwPlateSmallPicDataLen", DWORD), # 车牌小图图片长度
        # #if (defined(OS_WINDOWS64) || defined(OS_POSIX64))win64及linux64下指针为8字节
        ("pPlateSmallImage", CHARP), #  指向车牌小图的指针
        # #else
        ("pPlateSmallImage", CHARP), # 指向车牌小图的指针
        ("byRes1", BYTE * 4),
        # #endif
    ]


LPNET_DVR_AID_ALARM_V41 = POINTER(NET_DVR_AID_ALARM_V41)


# 交通统计信息报警(扩展)
class NET_DVR_TPS_ALARM_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwRelativeTime", DWORD), #  相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), #  前端设备信息
        ("struTPSInfo", NET_DVR_TPS_INFO_V41), #  交通参数统计信息
        # 监测点编号（路口编号、内部编号）
        ("byMonitoringSiteID", BYTE * MONITORSITE_ID_LEN),
        ("byDeviceID", BYTE * DEVICE_ID_LEN), # 设备编号
        ("dwStartTime", DWORD), #  开始统计时间
        ("dwStopTime", DWORD), #  结束统计时间
        ("byRes", BYTE * 24), #  保留
    ]


LPNET_DVR_TPS_ALARM_V41 = POINTER(NET_DVR_TPS_ALARM_V41)


XXX_MAJOR_VERSION = 2
#  子版本号，性能优化、局部结构调整、模块内集成其他库的主版本提升时递增，最大31
XXX_SUB_VERSION = 3
#  修正版本号，修正bug后递增，最大31
XXX_REVISION_VERSION = 4
class NET_DVR_VCA_VERSION(Structure):
    _fields_ = [
        ("wMajorVersion", WORD), #  主版本号
        ("wMinorVersion", WORD), #  次版本号
        ("wRevisionNumber", WORD), #  修正号
        ("wBuildNumber", WORD), #  编译号
        ("wVersionYear", WORD), #     版本日期-年
        ("byVersionMonth", BYTE), #     版本日期-月
        ("byVersionDay", BYTE), #     版本日期-日
        ("byType", BYTE), # 算法库类型名称，0-保留，1-人脸属性,2-行为分析,3-人体属性,4-人脸抓拍,5人脸识别 6-人脸对比,7-学生站立检测,
        # 8-区域人数统计,9-人脸评分库,10-安全帽检测,11-电梯检测算法库,12-客流量统计,13-(海康目标结构化算法)HMS,
        # 14-教师行为检测, 15-人员密度，16-人数异常，17-离岗检测，18-人员滞留，19-人脸建模抓拍，20-HMS建模,21-态势分析,
        # 22-城管算法,23-排队检测
        ("byRes", BYTE * 7), #  保留字节
    ]


LPNET_DVR_VCA_VERSION = POINTER(NET_DVR_VCA_VERSION)


class NET_DVR_PALTE_PARAM(Structure):
    _fields_ = [
        ("byPlateRecoMode", BYTE), # 车牌识别的模式,默认为1(视频触发模式)
        ("byBelive", BYTE), # 整牌置信度阈值, 只用于视频识别方式, 根据背景复杂程度设置, 误触发率高就设高, 漏车率高就设低, 建议在80-90范围内
        ("byRes", BYTE * 22), # 保留字节
    ]


LPNET_DVR_PALTE_PARAM = POINTER(NET_DVR_PALTE_PARAM)


class NET_DVR_PLATECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEnable", DWORD), #  是否启用视频车牌识别 0－否 1－是
        ("byPicProType", BYTE), # 报警时图片处理方式 0-不处理 非0-上传
        ("byRes1", BYTE * 3), #  保留字节
        ("struPictureParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struPlateParam", NET_DVR_PALTE_PARAM), #  车牌识别参数配置
        ("struHandleType", NET_DVR_HANDLEEXCEPTION), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRelRecordChan", BYTE * MAX_CHANNUM), # 报警触发的录象通道,为1表示触发该通道
        ("byRes", BYTE * 20), #  保留字节
    ]


LPNET_DVR_PLATECFG = POINTER(NET_DVR_PLATECFG)


if sysbit == '64bit':
    class NET_DVR_PLATE_INFO(Structure):
        _fields_ = [
            ("byPlateType", BYTE), # 车牌类型
            ("byColor", BYTE), # 车牌颜色
            ("byBright", BYTE), # 车牌亮度
            ("byLicenseLen", BYTE), # 车牌字符个数
            ("byEntireBelieve", BYTE), # 整个车牌的置信度，-100
            ("byRegion", BYTE), #  区域索引值 0-保留，1-欧洲(EU)，2-俄语区域(ER)，3-欧洲&俄罗斯(EU&CIS) ,4-中东(ME),0xff-所有
            ("byCountry", BYTE), #  国家索引值，参照枚举COUNTRY_INDEX（不支持"COUNTRY_ALL = 0xff, ALL  全部"）
            ("byArea", BYTE), # 区域（省份），各国家内部区域枚举，阿联酋参照 EMI_AREA
            ("byPlateSize", BYTE), # 车牌尺寸，0~未知，1~long, 2~short(中东车牌使用)
            # 附加信息标识（即是否有NET_DVR_VEHICLE_ADDINFO结构体）,0-无附加信息, 1-有附加信息。
            ("byAddInfoFlag", BYTE),
            # 该字段是在byCountry索引基础上，扩展了区域索引，之后使用该字段代替byCountry，优先使用wCRIndex字段
            # 为了兼容老用户，如果该字段值大于256（即新增区域），则byCountry赋值为0xfd（国家字段无效）。
            ("wCRIndex", WORD), # 国家/地区索引，索引值参考_CR_ INDEX_
            ("byRes", BYTE * 4), # 保留
            # 附加信息指针,指向NET_DVR_VEHICLE_ADDINFO结构体
            ("pAddInfoBuffer", CHARP),
            ("sPlateCategory", CHAR * MAX_CATEGORY_LEN), # 车牌附加信息, 即中东车牌中车牌号码旁边的小字信息，(目前只有中东地区支持)
            ("dwXmlLen", DWORD), # XML报警信息长度
            ("pXmlBuf", CHARP), #  XML报警信息指针,报警类型为 COMM_ITS_PLATE_RESUL时有效，其XML对应到EventNotificationAlert XML Block
            ("struPlateRect", NET_VCA_RECT), # 车牌位置
            ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码,注：中东车牌需求把小字也纳入车牌号码，小字和车牌号中间用空格分隔
            ("byBelieve", BYTE * MAX_LICENSE_LEN), # 各个识别字符的置信度，如检测到车牌"浙A12345", 置信度为,20,30,40,50,60,70，则表示"浙"字正确的可能性只有%，"A"字的正确的可能性是%
        ]
if sysbit == '32bit':
    class NET_DVR_PLATE_INFO(Structure):
        _fields_ = [
            ("byPlateType", BYTE), # 车牌类型
            ("byColor", BYTE), # 车牌颜色
            ("byBright", BYTE), # 车牌亮度
            ("byLicenseLen", BYTE), # 车牌字符个数
            ("byEntireBelieve", BYTE), # 整个车牌的置信度，-100
            ("byRegion", BYTE), #  区域索引值 0-保留，1-欧洲(EU)，2-俄语区域(ER)，3-欧洲&俄罗斯(EU&CIS) ,4-中东(ME),0xff-所有
            ("byCountry", BYTE), #  国家索引值，参照枚举COUNTRY_INDEX（不支持"COUNTRY_ALL = 0xff, ALL  全部"）
            ("byArea", BYTE), # 区域（省份），各国家内部区域枚举，阿联酋参照 EMI_AREA
            ("byPlateSize", BYTE), # 车牌尺寸，0~未知，1~long, 2~short(中东车牌使用)
            # 附加信息标识（即是否有NET_DVR_VEHICLE_ADDINFO结构体）,0-无附加信息, 1-有附加信息。
            ("byAddInfoFlag", BYTE),
            # 该字段是在byCountry索引基础上，扩展了区域索引，之后使用该字段代替byCountry，优先使用wCRIndex字段
            # 为了兼容老用户，如果该字段值大于256（即新增区域），则byCountry赋值为0xfd（国家字段无效）。
            ("wCRIndex", WORD), # 国家/地区索引，索引值参考_CR_ INDEX_
            ("byRes", BYTE * 4), # 保留
            # 附加信息指针,指向NET_DVR_VEHICLE_ADDINFO结构体
            ("pAddInfoBuffer", CHARP),
            ("byRes2", BYTE * 4),
            ("sPlateCategory", CHAR * MAX_CATEGORY_LEN), # 车牌附加信息, 即中东车牌中车牌号码旁边的小字信息，(目前只有中东地区支持)
            ("dwXmlLen", DWORD), # XML报警信息长度
            ("pXmlBuf", CHARP), #  XML报警信息指针,报警类型为 COMM_ITS_PLATE_RESUL时有效，其XML对应到EventNotificationAlert XML Block
            ("struPlateRect", NET_VCA_RECT), # 车牌位置
            ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码,注：中东车牌需求把小字也纳入车牌号码，小字和车牌号中间用空格分隔
            ("byBelieve", BYTE * MAX_LICENSE_LEN), # 各个识别字符的置信度，如检测到车牌"浙A12345", 置信度为,20,30,40,50,60,70，则表示"浙"字正确的可能性只有%，"A"字的正确的可能性是%
        ]

LPNET_DVR_PLATE_INFO = POINTER(NET_DVR_PLATE_INFO)

class NET_DVR_PLATERECO_RESULE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), #  前段设备信息
        ("struPlateInfo", NET_DVR_PLATE_INFO),
        ("dwPicDataLen", DWORD), # 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
        ("dwRes", DWORD * 4), # 保留，设置为0
        ("*pImage", BYTE), # 指向图片的指针
    ]


LPNET_DVR_PLATERECO_RESULE = POINTER(NET_DVR_PLATERECO_RESULE)


# 视频综合平台
class NET_DVR_LOG_MATRIX(Structure):
    _fields_ = [
        ("strLogTime", NET_DVR_TIME),
        ("dwMajorType", DWORD), # Main type 1-alarm 2-abnormal 3-operation 0xff-all
        ("dwMinorType", DWORD), # Hypo-Type 0-all
        ("sPanelUser", BYTE * MAX_NAMELEN), # user ID for local panel operation
        ("sNetUser", BYTE * MAX_NAMELEN), # user ID for network operation
        ("struRemoteHostAddr", NET_DVR_IPADDR), # remote host IP
        ("dwParaType", DWORD), # parameter type
        ("dwChannel", DWORD), # channel number
        ("dwDiskNumber", DWORD), # HD number
        ("dwAlarmInPort", DWORD), # alarm input port
        ("dwAlarmOutPort", DWORD), # alarm output port
        ("dwInfoLen", DWORD),
        ("byDevSequence", BYTE), # 槽位号
        ("byMacAddr", BYTE * MACADDR_LEN), # MAC地址,6
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号，48
        ("sInfo", CHAR * LOG_INFO_LEN),
    ]


LPNET_DVR_LOG_MATRIX = POINTER(NET_DVR_LOG_MATRIX)


# 2009-11-21 视频综合平台
class NET_DVR_VEDIOPLATLOG(Structure):
    _fields_ = [
        ("bySearchCondition", BYTE), # 搜索条件，0-按槽位号搜索，1-按序列号搜索，2-按MAC地址进行搜索
        # 槽位号，0-79：对应子系统的槽位号；
        # 0xff：表示搜索所有的日志，包括78K和所有6467；
        # 0xfe：表示搜索78K上的日志；0xfd：子域日志；0xfc：域日志。。
        ("byDevSequence", BYTE),
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号，48
        ("byMacAddr", BYTE * MACADDR_LEN), # MAC地址,6
    ]


LPNET_DVR_VEDIOPLATLOG = POINTER(NET_DVR_VEDIOPLATLOG)


class NET_DVR_CODESYSTEMABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwAbilityVersion", DWORD), # 能力集版本号，高16位表示主版本，低16位表示次版本
        ("dwSupportMaxVideoFrameRate", DWORD), # 单位(K)
        # 按位:
        # 0:定时录像；
        # 1:定时|事件触发录像
        # 2:移动侦测录像；
        # 3:网络开关量报警录像；
        # 4:移动侦测|网络开关量报警录像；
        # 5:移动侦测&网络开关量报警录像；
        # 6:周界防范触发录像；
        # 7:人脸检测触发录像；
        # 8:车牌识别触发录像；
        # 9:手动录像
        ("dwSupportRecordType", DWORD),
        ("bySupportLinkMode", BYTE), # 按位:第0位:表示主码流，第1位:表示子码流
        ("bySupportStringRow", BYTE), # 支持字符叠加行数
        ("bySupportHideNum", BYTE), # 支持视频遮挡数量
        ("byRes1", BYTE),
        # 0-DCIF，1-CIF，2-QCIF，3-4CIF，4-2CIF，6-QVGA(320*240), 16-VGA，17-UXGA，18-SVGA，19-HD720p，20-XVGA，21-HD900p，22-SXGAp，27-HD1080i，28-2560*1920，29-1600*304，30-2048*1536，31-2448*2048，32-2448*1200，33-2448*800 ，34-XGA（1024x768），35-SXGA（1280x1024）
        ("byMainStreamSupportResolution", BYTE * 8), # 主码流支持的分辨率，按位
        ("bySubStreamSupportResolution", BYTE * 8), # 子码流支持的分辨率，按位
        ("byEventStreamSupportResolution", BYTE * 8), # 事件触发码流支持的分辨率，按位
        ("byNotSupportPreview", BYTE), # 是否支持预览,1-不支持，0-支持
        ("byNotSupportStorage", BYTE), # 是否支持存储,1-不支持，0-支持
        ("byRes2", BYTE * 98), # 保留
    ]


LPNET_DVR_CODESYSTEMABILITY = POINTER(NET_DVR_CODESYSTEMABILITY)


# IO输入配置
class NET_DVR_IO_INCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIoInStatus", BYTE), # 输入的IO口状态，0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
        ("byRes", BYTE * 3), # 保留字节
    ]


LPNET_DVR_IO_INCFG = POINTER(NET_DVR_IO_INCFG)


# IO输出配置
class NET_DVR_IO_OUTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDefaultStatus", BYTE), # IO默认状态：0-低电平，1-高电平
        ("byIoOutStatus", BYTE), # IO起效时状态：0-低电平，1-高电平，2-脉冲
        ("wAheadTime", WORD), # 输出IO提前时间，单位us
        ("dwTimePluse", DWORD), # 脉冲间隔时间，单位us
        ("dwTimeDelay", DWORD), # IO有效持续时间，单位us
        ("byFreqMulti", BYTE), # 倍频，数值范围[1,15]
        ("byDutyRate", BYTE), # 占空比，[0,40%]
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_IO_OUTCFG = POINTER(NET_DVR_IO_OUTCFG)


# 闪光灯配置
class NET_DVR_FLASH_OUTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMode", BYTE), # 闪光灯闪烁模式，0-不闪，1-闪，2-关联闪，3-轮闪
        ("byRelatedIoIn", BYTE), # 闪光灯关联的输入IO号（关联闪时此参数有效）
        ("byRecognizedLane", BYTE), # 关联的IO号，按位表示，bit0表示IO1是否关联，0-不关联，1-关联
        ("byDetectBrightness", BYTE), # 自动检测亮度使能闪光灯0-不检测；1-检测
        ("byBrightnessThreld", BYTE), # 使能闪光灯亮度阈值，范围[0,100],高于阈值闪
        ("byStartHour", BYTE), # 开始时间-小时,取值范围0-23
        ("byStartMinute", BYTE), # 开始时间-分,取值范围0-59
        ("byEndHour", BYTE), # 结束时间-小时,取值范围0-23
        ("byEndMinute", BYTE), # 结束时间-分,取值范围0-59
        ("byFlashLightEnable", BYTE), # 设置闪光灯时间使能:0-关1-开
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_FLASH_OUTCFG = POINTER(NET_DVR_FLASH_OUTCFG)


# 红绿灯功能（2个IO输入一组）
class NET_DVR_LIGHTSNAPCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLightIoIn", BYTE), # 红绿灯的IO 号
        ("byTrigIoIn", BYTE), # 触发的IO号
        ("byRelatedDriveWay", BYTE), # 触发IO关联的车道号
        ("byTrafficLight", BYTE), # 0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
        ("bySnapTimes1", BYTE), # 红灯抓拍次数1，0-不抓拍，非0-连拍次数，最大5次
        ("bySnapTimes2", BYTE), # 绿灯抓拍次数2，0-不抓拍，非0-连拍次数，最大5次
        ("byRes1", BYTE * 2),
        ("wIntervalTime1", WORD * MAX_INTERVAL_NUM), # 红灯连拍间隔时间，ms
        ("wIntervalTime2", WORD * MAX_INTERVAL_NUM), # 绿灯连拍间隔时间，ms
        ("byRecord", BYTE), # 闯红灯周期录像标志，0-不录像，1-录像
        ("bySessionTimeout", BYTE), # 闯红灯周期录像超时时间（秒）
        ("byPreRecordTime", BYTE), # 闯红灯录像片段预录时间(秒)
        ("byVideoDelay", BYTE), # 闯红灯录像片段延时时间（秒）
        ("byRes2", BYTE * 32), # 保留字节
    ]


LPNET_DVR_LIGHTSNAPCFG = POINTER(NET_DVR_LIGHTSNAPCFG)


# 测速功能(2个IO输入一组）
class NET_DVR_MEASURESPEEDCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byTrigIo1", BYTE), # 测速第1线圈
        ("byTrigIo2", BYTE), # 测速第2线圈
        ("byRelatedDriveWay", BYTE), # 触发IO关联的车道号
        ("byTestSpeedTimeOut", BYTE), # 测速模式超时时间，单位s
        ("dwDistance", DWORD), # 线圈距离,cm
        ("byCapSpeed", BYTE), # 测速模式起拍速度，单位km/h
        ("bySpeedLimit", BYTE), # 限速值，单位km/h
        ("bySnapTimes1", BYTE), # 线圈1抓拍次数，0-不抓拍，非0-连拍次数，最大5次
        ("bySnapTimes2", BYTE), # 线圈2抓拍次数，0-不抓拍，非0-连拍次数，最大5次
        ("wIntervalTime1", WORD * MAX_INTERVAL_NUM), # 线圈1连拍间隔时间，ms
        ("wIntervalTime2", WORD * MAX_INTERVAL_NUM), # 线圈2连拍间隔时间，ms
        ("byRes", BYTE * 32), # 保留字节
    ]


LPNET_DVR_MEASURESPEEDCFG = POINTER(NET_DVR_MEASURESPEEDCFG)


# 配置条件
class NET_DVR_CLOUDSTORAGE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_CLOUDSTORAGE_COND = POINTER(NET_DVR_CLOUDSTORAGE_COND)


# 配置结构
class NET_DVR_POOLPARAM(Structure):
    _fields_ = [
        ("dwPoolID", DWORD), #  云存储分配节点号
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_POOLPARAM = POINTER(NET_DVR_POOLPARAM)


class NET_DVR_CLOUDSTORAGE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 0-不开启，1-开启
        ("byRes", BYTE * 3),
        ("struIP", NET_DVR_IPADDR),
        ("wPort", WORD), # 数据端口
        ("byRes1", BYTE * 2),
        ("szUser", CHAR * CLOUD_NAME_LEN), # 用户名
        ("szPassword", CHAR * CLOUD_PASSWD_LEN), #  密码
        ("struPoolInfo", NET_DVR_POOLPARAM * 16), # 数组0表示卡口录像池，数组1表示违章录像池，数组2表示车辆侦测数据池（IPC/D）
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_CLOUDSTORAGE_CFG = POINTER(NET_DVR_CLOUDSTORAGE_CFG)


class NET_DVR_PARKLAMP_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byParkingIndex", BYTE), # 相对车位号（1～4）
        ("byRes", BYTE * 15), # 保留
    ]


LPNET_DVR_PARKLAMP_COND = POINTER(NET_DVR_PARKLAMP_COND)


class NET_DVR_PARKLAMP_INFOCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("sParkingNo", CHAR * MAX_LICENSE_LEN), # 车位编号(实际的车位编号)
        ("byLampFlicker", BYTE), # 0~不闪烁 1 ～闪烁 (车位指示灯闪烁)
        ("byLampColor", BYTE), # 0- 灭 1-红 2-绿  3-黄  4-蓝 5-品红 6-青 7-白色  (车位指示灯颜色)
        ("byStatus", BYTE), # 车位状态 0-无车，1-有车
        ("byColorDepth", BYTE), # 车身颜色深浅，0-深色，1-浅色,0xff-未知
        ("byColor", BYTE), # 车身颜色，0-其他色，1-白色，2-银色，3-灰色，4-黑色，5-红色，6-深蓝，7-蓝色，8-黄色，9-绿色，10-棕色，11-粉色，12-紫色，0xff-未进行车身颜色识别
        # 车辆品牌类型识别； 参考枚举类型 VLR_VEHICLE_CLASS
        ("byVehicleLogoRecog", BYTE),
        ("byRes", BYTE * 250), # 保留
    ]


LPNET_DVR_PARKLAMP_INFOCFG = POINTER(NET_DVR_PARKLAMP_INFOCFG)


# 视频参数配置
class NET_DVR_VIDEOEFFECT(Structure):
    _fields_ = [
        ("byBrightnessLevel", BYTE), # 0-100
        ("byContrastLevel", BYTE), # 0-100
        ("bySharpnessLevel", BYTE), # 0-100
        ("bySaturationLevel", BYTE), # 0-100
        ("byHueLevel", BYTE), # 0-100,（保留）
        ("byEnableFunc", BYTE), # 使能，按位表示，bit0-SMART IR(防过曝)，bit1-低照度,bit2-强光抑制使能，0-否，1-是
        ("byLightInhibitLevel", BYTE), # 强光抑制等级，[1-3]表示等级
        ("byGrayLevel", BYTE), # 灰度值域，0-[0-255]，1-[16-235]
    ]


LPNET_DVR_VIDEOEFFECT = POINTER(NET_DVR_VIDEOEFFECT)


# 增益配置
class NET_DVR_GAIN(Structure):
    _fields_ = [
        ("byGainLevel", BYTE), # 增益：0-100
        ("byGainUserSet", BYTE), # 用户自定义增益；0-100，对于抓拍机，是CCD模式下的抓拍增益
        ("byRes", BYTE * 2),
        ("dwMaxGainValue", DWORD), # 最大增益值，单位dB
    ]


LPNET_DVR_GAIN = POINTER(NET_DVR_GAIN)


# 白平衡配置
class NET_DVR_WHITEBALANCE(Structure):
    _fields_ = [
        ("byWhiteBalanceMode", BYTE), # 0-手动白平衡（MWB）,1-自动白平衡1（AWB1）,2-自动白平衡2 (AWB2),3-自动控制改名为锁定白平衡(Locked WB)，
        # 4-室外(Indoor)，5-室内(Outdoor)6-日光灯(Fluorescent Lamp)，7-钠灯(Sodium Lamp)，
        # 8-自动跟踪(Auto-Track)9-一次白平衡(One Push)，10-室外自动(Auto-Outdoor)，
        # 11-钠灯自动 (Auto-Sodiumlight)，12-水银灯(Mercury Lamp)，13-自动白平衡(Auto)，
        # 14-白炽灯 (IncandescentLamp)，15-暖光灯(Warm Light Lamp)，16-自然光(Natural Light)
        ("byWhiteBalanceModeRGain", BYTE), # 手动白平衡时有效，手动白平衡 R增益
        ("byWhiteBalanceModeBGain", BYTE), # 手动白平衡时有效，手动白平衡 B增益
        ("byRes", BYTE * 5),
    ]


LPNET_DVR_WHITEBALANCE = POINTER(NET_DVR_WHITEBALANCE)


# 曝光控制
class NET_DVR_EXPOSURE(Structure):
    _fields_ = [
        ("byExposureMode", BYTE), # 0 手动曝光 1自动曝光
        ("byAutoApertureLevel", BYTE), #  自动光圈灵敏度, 0-10
        ("byRes", BYTE * 2),
        ("dwVideoExposureSet", DWORD), #  自定义视频曝光时间（单位us）注:自动曝光时该值为曝光最慢值 新增20-1s(1000000us)
        ("dwExposureUserSet", DWORD), #  自定义曝光时间,在抓拍机上应用时，CCD模式时是抓拍快门速度
        ("dwRes", DWORD),
    ]


LPNET_DVR_EXPOSURE = POINTER(NET_DVR_EXPOSURE)


# 宽动态配置
class NET_DVR_WDR(Structure):
    _fields_ = [
        ("byWDREnabled", BYTE), # 宽动态：0 dsibale  1 enable 2 auto
        ("byWDRLevel1", BYTE), # 0-F
        ("byWDRLevel2", BYTE), # 0-F
        ("byWDRContrastLevel", BYTE), # 0-100
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_WDR = POINTER(NET_DVR_WDR)


class NET_DVR_WDR_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struWDR", NET_DVR_WDR), # 配置信息
    ]


LPNET_DVR_WDR_CFG = POINTER(NET_DVR_WDR_CFG)


# 日夜转换功能配置
class NET_DVR_DAYNIGHT(Structure):
    _fields_ = [
        ("byDayNightFilterType", BYTE), # 日夜切换：0-白天，1-夜晚，2-自动，3-定时，4-报警输入触发, 5-自动模式2（无光敏）,6-黑光，7-黑光自动，8-黑光定时
        ("bySwitchScheduleEnabled", BYTE), # 0 dsibale  1 enable,(保留)
        # 定时模式参数
        ("byBeginTime", BYTE), # 开始时间（小时），0-23
        ("byEndTime", BYTE), # 结束时间（小时），0-23
        # 模式2
        ("byDayToNightFilterLevel", BYTE), # 0-7
        ("byNightToDayFilterLevel", BYTE), # 0-7
        ("byDayNightFilterTime", BYTE), # (60秒)
        # 定时模式参数
        ("byBeginTimeMin", BYTE), # 开始时间（分），0-59
        ("byBeginTimeSec", BYTE), # 开始时间（秒），0-59
        ("byEndTimeMin", BYTE), # 结束时间（分），0-59
        ("byEndTimeSec", BYTE), # 结束时间（秒），0-59
        # 报警输入触发模式参数
        ("byAlarmTrigState", BYTE), # 报警输入触发状态，0-白天，1-夜晚
    ]


LPNET_DVR_DAYNIGHT = POINTER(NET_DVR_DAYNIGHT)


# Gamma校正
class NET_DVR_GAMMACORRECT(Structure):
    _fields_ = [
        ("byGammaCorrectionEnabled", BYTE), # 0 dsibale  1 enable
        ("byGammaCorrectionLevel", BYTE), # 0-100
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_GAMMACORRECT = POINTER(NET_DVR_GAMMACORRECT)


# 背光补偿配置
class NET_DVR_BACKLIGHT(Structure):
    _fields_ = [
        ("byBacklightMode", BYTE), # 背光补偿:0 off 1 UP、2 DOWN、3 LEFT、4 RIGHT、5MIDDLE、6自定义，10-开，11-自动，12-多区域背光补偿
        ("byBacklightLevel", BYTE), # 0x0-0xF
        ("byRes1", BYTE * 2),
        ("dwPositionX1", DWORD), # （X坐标1）
        ("dwPositionY1", DWORD), # （Y坐标1）
        ("dwPositionX2", DWORD), # （X坐标2）
        ("dwPositionY2", DWORD), # （Y坐标2）
        ("byRes2", BYTE * 4),
    ]


LPNET_DVR_BACKLIGHT = POINTER(NET_DVR_BACKLIGHT)


# 数字降噪功能
class NET_DVR_NOISEREMOVE(Structure):
    _fields_ = [
        ("byDigitalNoiseRemoveEnable", BYTE), # 0-不启用，1-普通模式数字降噪，2-专家模式数字降噪
        ("byDigitalNoiseRemoveLevel", BYTE), # 普通模式数字降噪级别：0x0-0xF
        ("bySpectralLevel", BYTE), # 专家模式下空域强度：0-100
        ("byTemporalLevel", BYTE), # 专家模式下时域强度：0-100
        ("byDigitalNoiseRemove2DEnable", BYTE), #  抓拍帧2D降噪，0-不启用，1-启用
        ("byDigitalNoiseRemove2DLevel", BYTE), #  抓拍帧2D降噪级别，0-100
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_NOISEREMOVE = POINTER(NET_DVR_NOISEREMOVE)


# CMOS模式下前端镜头配置
class NET_DVR_CMOSMODECFG(Structure):
    _fields_ = [
        ("byCaptureMod", BYTE), # 抓拍模式：0-抓拍模式1；1-抓拍模式2
        ("byBrightnessGate", BYTE), # 亮度阈值
        ("byCaptureGain1", BYTE), # 抓拍增益1,0-100
        ("byCaptureGain2", BYTE), # 抓拍增益2,0-100
        ("dwCaptureShutterSpeed1", DWORD), # 抓拍快门速度1
        ("dwCaptureShutterSpeed2", DWORD), # 抓拍快门速度2
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_CMOSMODECFG = POINTER(NET_DVR_CMOSMODECFG)


# 前端参数配置
class NET_DVR_CAMERAPARAMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struVideoEffect", NET_DVR_VIDEOEFFECT), # 亮度、对比度、饱和度、锐度、色调配置
        ("struGain", NET_DVR_GAIN), # 自动增益
        ("struWhiteBalance", NET_DVR_WHITEBALANCE), # 白平衡
        ("struExposure", NET_DVR_EXPOSURE), # 曝光控制
        ("struGammaCorrect", NET_DVR_GAMMACORRECT), # Gamma校正
        ("struWdr", NET_DVR_WDR), # 宽动态
        ("struDayNight", NET_DVR_DAYNIGHT), # 日夜转换
        ("struBackLight", NET_DVR_BACKLIGHT), # 背光补偿
        ("struNoiseRemove", NET_DVR_NOISEREMOVE), # 数字降噪
        ("byPowerLineFrequencyMode", BYTE), # 0-50HZ 1-60HZ
        #
        # 0-自动光圈,
        # 1-手动光圈,
        # 2-P-Iris1,
        # 3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        # 4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        # 5-HIK 3.8-16mm F1.5（HV3816P-8MPIR)
        # 6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
        # 7-HIK 2.7-12mm F1.2（TV2712P-MPIR）
        # 8- MZ5721D-12MPIR
        # 9- MZ1555D-12MPIR
        # 10- MZ5721D-12MPIR(RS485)
        # 11- MZ1555D-12MPIR(RS485)
        #
        ("byIrisMode", BYTE),
        ("byMirror", BYTE), #  镜像：0 off，1- leftright，2- updown，3-center
        ("byDigitalZoom", BYTE), # 数字缩放:0 dsibale  1 enable
        ("byDeadPixelDetect", BYTE), # 坏点检测,0 dsibale  1 enable
        ("byBlackPwl", BYTE), # 黑电平补偿 ,  0-255
        ("byEptzGate", BYTE), #  EPTZ开关变量:0-不启用电子云台，1-启用电子云台
        ("byLocalOutputGate", BYTE), # 本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭  11-缩放输出，12-裁剪输出，13-裁剪缩放输出
        # 20-HDMI_720P50输出开
        # 21-HDMI_720P60输出开
        # 22-HDMI_1080I60输出开
        # 23-HDMI_1080I50输出开
        # 24-HDMI_1080P24输出开
        # 25-HDMI_1080P25输出开
        # 26-HDMI_1080P30输出开
        # 27-HDMI_1080P50输出开
        # 28-HDMI_1080P60输出开
        # 40-SDI_720P50,
        # 41-SDI_720P60,
        # 42-SDI_1080I50,
        # 43-SDI_1080I60,
        # 44-SDI_1080P24,
        # 45-SDI_1080P25,
        # 46-SDI_1080P30,
        # 47-SDI_1080P50,
        # 48-SDI_1080P60,
        # 49-SDI_720P25
        # 50-SDI_720P30
        # 51-SDI_1080I25
        # 52-SDI_1080I30
        # 60- YPBPR_720P50
        # 61-YPBPR_720P60
        # 62-YPBPR_1080I50
        # 63-YPBPR_1080I60
        # 64-YPBPR_1080P24
        # 65-YPBPR_1080P25
        # 66-YPBPR_1080P30
        # 67-YPBPR_1080P50
        # 68-YPBPR_1080P60
        # 69-YPBPR_720P25
        # 70-YPBPR_720P30
        # 71- HDMI_1080P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
        # 72- HDMI_720P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
        # 73- HDMI_2160P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
        ("byCoderOutputMode", BYTE), # 编码器fpga输出模式0直通3像素搬家
        ("byLineCoding", BYTE), # 是否开启行编码：0-否，1-是
        ("byDimmerMode", BYTE), # 调光模式：0-半自动，1-自动
        ("byPaletteMode", BYTE), # 调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8
        ("byEnhancedMode", BYTE), # 增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
        ("byDynamicContrastEN", BYTE), # 动态对比度增强 0-1
        ("byDynamicContrast", BYTE), # 动态对比度 0-100
        ("byJPEGQuality", BYTE), # JPEG图像质量 0-100
        ("struCmosModeCfg", NET_DVR_CMOSMODECFG), # CMOS模式下前端参数配置，镜头模式从能力集获取
        ("byFilterSwitch", BYTE), # 滤波开关：0-不启用，1-启用
        ("byFocusSpeed", BYTE), # 镜头调焦速度：0-10
        ("byAutoCompensationInterval", BYTE), # 定时自动快门补偿：1-120，单位：分钟
        ("bySceneMode", BYTE), # 场景模式：0-室外，1-室内，2-默认，3-弱光
    ]


LPNET_DVR_CAMERAPARAMCFG = POINTER(NET_DVR_CAMERAPARAMCFG)


# 透雾
class NET_DVR_DEFOGCFG(Structure):
    _fields_ = [
        ("byMode", BYTE), # 模式，0-不启用，1-自动模式，2-常开模式
        ("byLevel", BYTE), # 等级，0-100
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_DEFOGCFG = POINTER(NET_DVR_DEFOGCFG)


# 电子防抖
class NET_DVR_ELECTRONICSTABILIZATION(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能 0- 不启用，1- 启用
        ("byLevel", BYTE), # 等级，0-100
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_ELECTRONICSTABILIZATION = POINTER(NET_DVR_ELECTRONICSTABILIZATION)


# 走廊模式
class NET_DVR_CORRIDOR_MODE_CCD(Structure):
    _fields_ = [
        ("byEnableCorridorMode", BYTE), # 是否启用走廊模式 0～不启用， 1～启用
        ("byRes", BYTE * 11),
    ]


LPNET_DVR_CORRIDOR_MODE_CCD = POINTER(NET_DVR_CORRIDOR_MODE_CCD)


#  SMART IR(防过曝)配置参数
class NET_DVR_SMARTIR_PARAM(Structure):
    _fields_ = [
        ("byMode", BYTE), # 0～手动，1～自动
        ("byIRDistance", BYTE), # 红外距离等级(等级，距离正比例)level:1~100 默认:50（手动模式下增加）
        ("byShortIRDistance", BYTE), #  近光灯距离等级(1~100)
        ("byLongIRDistance", BYTE), #  远光灯距离等级(1~100)
    ]


LPNET_DVR_SMARTIR_PARAM = POINTER(NET_DVR_SMARTIR_PARAM)


# 在byIrisMode 为P-Iris1时生效，配置红外光圈大小等级，配置模式
class NET_DVR_PIRIS_PARAM(Structure):
    _fields_ = [
        ("byMode", BYTE), # 0-自动，1-手动
        ("byPIrisAperture", BYTE), # 红外光圈大小等级(等级,光圈大小正比例)level:1~100 默认:50（手动模式下增加）
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_PIRIS_PARAM = POINTER(NET_DVR_PIRIS_PARAM)


# 激光参数配置 2014-02-25
class NET_DVR_LASER_PARAM_CFG(Structure):
    _fields_ = [
        # Length = 16
        ("byControlMode", BYTE), # 控制模式            0-无效，1-自动，2-手动 默认自动
        ("bySensitivity", BYTE), # 激光灯灵敏度        0-100 默认50
        ("byTriggerMode", BYTE), # 激光灯触发模式    0-无效，1-机芯触发，2-光敏触发 默认机芯触发
        ("byBrightness", BYTE), # 控制模式为手动模式下有效；激光灯亮度        0-255 默认100
        ("byAngle", BYTE), # 激光灯角度        0-无效，范围1-36  默认12，激光灯照射范围为一个圆圈，调节激光角度是调节这个圆的半径的大小
        ("byLimitBrightness", BYTE), # 控制模式为自动模式下有效；激光灯亮度限制 0~100 （新增）2014-01-26
        ("byEnabled", BYTE), # 手动控制激光灯使能 0-关闭，1-启动
        ("byIllumination", BYTE), # 激光灯强度配置0~100
        ("byLightAngle", BYTE), # 补光角度 0~100
        ("byRes", BYTE * 7), # 保留
    ]


LPNET_DVR_LASER_PARAM_CFG = POINTER(NET_DVR_LASER_PARAM_CFG)


class NET_DVR_FFC_PARAM(Structure):
    _fields_ = [
        # 1-Schedule Mode,2-Temperature Mode, 3-Off
        ("byMode", BYTE),
        # （时间:按能力显示，单位分钟，选项有10,20,30,40,50,60,120,180,240）
        ("byRes1", BYTE),
        ("wCompensateTime", WORD), # 定时模式下生效
        ("byRes2", BYTE * 4),
    ]


LPNET_DVR_FFC_PARAM = POINTER(NET_DVR_FFC_PARAM)


class NET_DVR_DDE_PARAM(Structure):
    _fields_ = [
        ("byMode", BYTE), # 1-Off,2-Normal Mode,3-Expert Mode
        ("byNormalLevel", BYTE), # 普通模式等级范围[1,100]，普通模式下生效
        ("byExpertLevel", BYTE), # 专家模式等级范围[1,100]，专家模式下生效
        ("byRes", BYTE * 5),
    ]


LPNET_DVR_DDE_PARAM = POINTER(NET_DVR_DDE_PARAM)


class NET_DVR_AGC_PARAM(Structure):
    _fields_ = [
        ("bySceneType", BYTE), # 1-Normal Sence,2-Highlight Sence,3-Manual Sence
        ("byLightLevel", BYTE), # 亮度等级[1,100]；手动模式下生效
        ("byGainLevel", BYTE), # 增益等级[1,100]；手动模式下生效
        ("byRes", BYTE * 5),
    ]


LPNET_DVR_AGC_PARAM = POINTER(NET_DVR_AGC_PARAM)


# 抓拍机CCD参数 共64字节
class NET_DVR_SNAP_CAMERAPARAMCFG(Structure):
    _fields_ = [
        ("byWDRMode", BYTE), #  宽动态模式0~关闭，1~数字宽动态 2~宽动态
        ("byWDRType", BYTE), #  宽动态切换模式 0~强制启用，1~按时间启用，2~按亮度启用
        ("byWDRLevel", BYTE), #  宽动态等级，0~6索引对应1-7，默认索引2（即3级）；
        ("byRes1", BYTE),
        ("struStartTime", NET_DVR_TIME_EX), # 开始宽动态时间
        ("struEndTime", NET_DVR_TIME_EX), # 结束宽动态时间
        ("byDayNightBrightness", BYTE), # 日夜转换亮度阈值，0-100，默认50；
        # 记忆色增强
        ("byMCEEnabled", BYTE), # 记忆色增强使能，true：开启，false：关闭
        ("byMCELevel", BYTE), # 记忆色增强强度，0~100，默认值50
        # 自动对比度
        ("byAutoContrastEnabled", BYTE), # 自动对比度使能，true：开启，false：关闭
        ("byAutoContrastLevel", BYTE), # 自动对比等级（0-100）,默认50
        # 细节增强
        ("byLSEDetailEnabled", BYTE), # 细节增强使能，true：开启，false：关闭
        ("byLSEDetailLevel", BYTE), # 细节增强等级（0-100）,默认50
        # License Plate Definition Enhancement车牌增强
        ("byLPDEEnabled", BYTE), # 车牌增强使能，true：开启，false：关闭
        ("byLPDELevel", BYTE), # 车牌增强等级（0-100）,默认50
        # 对比度增强
        ("byLseEnabled", BYTE), # 对比度增强使能，true：开启，false：关闭
        ("byLseLevel", BYTE), # 对比度增强等级（0-100）,默认0
        ("byLSEHaloLevel", BYTE), # 光晕抑制等级。范围 0-100,默认0
        ("byLseType", BYTE), # 对比度增强切换模式 0~强制启用，1~按时间启用，2~按亮度启用（该字段可同时控制byLseLevel、byLSEHaloLevel两个参数）
        ("byRes2", BYTE * 3),
        ("struLSEStartTime", NET_DVR_TIME_EX), # 开始对比度增强时间（当byLseType为1时生效）
        ("struLSEEndTime", NET_DVR_TIME_EX), # 结束对比度增强时间（当byLseType为1时生效）
        ("byLightLevel", BYTE), # 为亮度等级参数（0-100）,默认0，（当byLseType为2时生效）
        # 车牌对比度
        ("byPlateContrastLevel", BYTE), # 车牌对比度等级，0~100，默认0
        # 车牌饱和度
        ("byPlateSaturationLevel", BYTE), # 车牌饱和度等级，0~100，默认0
        ("byRes", BYTE * 9),
    ]


LPNET_DVR_SNAP_CAMERAPARAMCFG = POINTER(NET_DVR_SNAP_CAMERAPARAMCFG)


# 光学透雾参数
class NET_DVR_OPTICAL_DEHAZE(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 0~不启用光学透雾，1~启用光学透雾
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_OPTICAL_DEHAZE = POINTER(NET_DVR_OPTICAL_DEHAZE)


# 测温AGC设置，当测温AGC模式为无效时，以NET_DVR_AGC_PARAM配置参数为准，当测温AGC模式为自动或者手动时，NET_DVR_AGC_PARAM配置参数无效
class NET_DVR_THERMOMETRY_AGC(Structure):
    _fields_ = [
        ("byMode", BYTE), # AGC模式，0~无效，1~自动，2~手动
        ("byRes1", BYTE * 3),
        ("iHighTemperature", INT), # 最高温度，范围为：-273~9999摄氏度（1~手动模式下生效）
        ("iLowTemperature", INT), # 最低温度，范围为：-273~9999摄氏度（1~手动模式下生效）
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_THERMOMETRY_AGC = POINTER(NET_DVR_THERMOMETRY_AGC)


# 前端参数配置
class NET_DVR_CAMERAPARAMCFG_EX(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struVideoEffect", NET_DVR_VIDEOEFFECT), # 亮度、对比度、饱和度、锐度、色调配置
        ("struGain", NET_DVR_GAIN), # 自动增益
        ("struWhiteBalance", NET_DVR_WHITEBALANCE), # 白平衡
        ("struExposure", NET_DVR_EXPOSURE), # 曝光控制
        ("struGammaCorrect", NET_DVR_GAMMACORRECT), # Gamma校正
        ("struWdr", NET_DVR_WDR), # 宽动态
        ("struDayNight", NET_DVR_DAYNIGHT), # 日夜转换
        ("struBackLight", NET_DVR_BACKLIGHT), # 背光补偿
        ("struNoiseRemove", NET_DVR_NOISEREMOVE), # 数字降噪
        ("byPowerLineFrequencyMode", BYTE), # 0-50HZ 1-60HZ
        #
        # 0-自动光圈,
        # 1-手动光圈,
        # 2-P-Iris1,
        # 3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        # 4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        # 5-HIK 3.8-16mm F1.5（HV3816P-8MPIR)
        # 6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
        # 7-HIK 2.7-12mm F1.2（TV2712P-MPIR）
        # 8- MZ5721D-12MPIR
        # 9- MZ1555D-12MPIR
        # 10- MZ5721D-12MPIR(RS485)
        # 11- MZ1555D-12MPIR(RS485)
        #
        ("byIrisMode", BYTE),
        ("byMirror", BYTE), #  镜像：0 off，1- leftright，2- updown，3-center 4-Auto
        ("byDigitalZoom", BYTE), # 数字缩放:0 dsibale  1 enable
        ("byDeadPixelDetect", BYTE), # 坏点检测,0 dsibale  1 enable
        ("byBlackPwl", BYTE), # 黑电平补偿 ,  0-255
        ("byEptzGate", BYTE), #  EPTZ开关变量:0-不启用电子云台，1-启用电子云台
        ("byLocalOutputGate", BYTE), # 本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭
        # 20-HDMI_720P50输出开
        # 21-HDMI_720P60输出开
        # 22-HDMI_1080I60输出开
        # 23-HDMI_1080I50输出开
        # 24-HDMI_1080P24输出开
        # 25-HDMI_1080P25输出开
        # 26-HDMI_1080P30输出开
        # 27-HDMI_1080P50输出开
        # 28-HDMI_1080P60输出开
        ("byCoderOutputMode", BYTE), # 编码器fpga输出模式0直通3像素搬家
        ("byLineCoding", BYTE), # 是否开启行编码：0-否，1-是
        ("byDimmerMode", BYTE), # 调光模式：0-半自动，1-自动
        ("byPaletteMode", BYTE), # 调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8, 9-融合1,10-彩虹,11-融合2,12-铁红1,13-铁红2,14-深褐色,15-色彩1,16-色彩2,17-冰火,18-雨,19-红热,20-绿热,21-深蓝，22-色彩3
        ("byEnhancedMode", BYTE), # 增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
        ("byDynamicContrastEN", BYTE), # 动态对比度增强 0-1
        ("byDynamicContrast", BYTE), # 动态对比度 0-100
        ("byJPEGQuality", BYTE), # JPEG图像质量 0-100
        ("struCmosModeCfg", NET_DVR_CMOSMODECFG), # CMOS模式下前端参数配置，镜头模式从能力集获取
        ("byFilterSwitch", BYTE), # 滤波开关：0-不启用，1-启用
        ("byFocusSpeed", BYTE), # 镜头调焦速度：0-10
        ("byAutoCompensationInterval", BYTE), # 定时自动快门补偿：1-120，单位：分钟
        ("bySceneMode", BYTE), # 场景模式：0-室外，1-室内，2-默认，3-弱光
        ("struDefogCfg", NET_DVR_DEFOGCFG), # 透雾参数
        ("struElectronicStabilization", NET_DVR_ELECTRONICSTABILIZATION), # 电子防抖
        ("struCorridorMode", NET_DVR_CORRIDOR_MODE_CCD), # 走廊模式
        ("byExposureSegmentEnable", BYTE), # 0~不启用,1~启用  曝光时间和增益呈阶梯状调整，比如曝光往上调整时，先提高曝光时间到中间值，然后提高增益到中间值，再提高曝光到最大值，最后提高增益到最大值
        ("byBrightCompensate", BYTE), # 亮度增强 [0~100]
        #
        # 0-关闭、1-640*480@25fps、2-640*480@30ps、3-704*576@25fps、4-704*480@30fps、5-1280*720@25fps、6-1280*720@30fps、
        # 7-1280*720@50fps、8-1280*720@60fps、9-1280*960@15fps、10-1280*960@25fps、11-1280*960@30fps、
        # 12-1280*1024@25fps、13--1280*1024@30fps、14-1600*900@15fps、15-1600*1200@15fps、16-1920*1080@15fps、
        # 17-1920*1080@25fps、18-1920*1080@30fps、19-1920*1080@50fps、20-1920*1080@60fps、21-2048*1536@15fps、22-2048*1536@20fps、
        # 23-2048*1536@24fps、24-2048*1536@25fps、25-2048*1536@30fps、26-2560*2048@25fps、27-2560*2048@30fps、
        # 28-2560*1920@7.5fps、29-3072*2048@25fps、30-3072*2048@30fps、31-2048*1536@12.5、32-2560*1920@6.25、
        # 33-1600*1200@25、34-1600*1200@30、35-1600*1200@12.5、36-1600*900@12.5、37-1280*960@12.5fps、38-800*600@25fps、39-800*600@30fps40、
        # 4000*3000@12.5fps、41-4000*3000@15fps、42-4096*2160@20fps、43-3840*2160@20fps 、44-960*576@25fps、45-960*480@30fps、46-752*582@25fps、
        # 47-768*494@30fps、48-2560*1440@25fps、49-2560*1440@30fps 、50-720P@100fps、51-720P@120fps、52-2048*1536@50fps、53-2048*1536@60fps、
        # 54-3840*2160@25fps、55-3840*2160@30fps、56-4096*2160@25fps、57-4096*2160@30fps 、58-1280*1024@50fps、59-1280*1024@60fps、
        # 60-3072*2048@50fps、61-3072*2048@60fps、62-3072*1728@25fps、63-3072*1728@30fps、64-3072*1728@50fps、65-3072*1728@60fps、66-336*256@50fps、67-336*256@60fps、
        # 68-384*288@50fps、69-384*288@60fps 、70- 640 * 512@50fps 、71- 640 * 512@60fps、72-2592*1944@25fps、73-2592*1944@30fps、74-2688*1536@25fps、75-2688*1536@30fps
        # 76-2592*1944@20fps、77-2592*1944@15fps、78-2688*1520@20fps、79-2688*1520@15fps、80-2688*1520@25fps、81-2688*1520@30fps、82- 2720*2048@25fps、 83- 2720*2048@30fps、
        # 84-336*256@25fps、85- 384*288@25fps、86-640*512@25fps、87-1280*960@50fps、88-1280*960@60fps、89-1280*960@100fps、90-1280*960@120fps、91-4000*3000@20fps、
        # 92-1920*1200@25fps、93-1920*1200@30fps、94-2560*1920@25fps、95-2560*1920@20fps、96-2560*1920@30fps、97-1280*1920@25fps、98-1280*1920@30fps
        # 99-4000*3000@24fps、100-4000*3000@25fps、101-4000*3000@10fps、102- 384*288@30fps、103-2560*1920@15fps、104-2400*3840@25fps、105-1200*1920@25fps
        # 106-4096*1800@30fps、107-3840*1680@30fps、108-2560*1120@30fps、109-704*320@30fps、110-1280*560@30fps、111-4096*1800@25fps、112-3840*1680@25fps
        # 113-2560*1120@25fps、114-704*320@25fps、115-1280*560@25fps、116-2400*3840@24fps、117-3840*2400@24fps、118-3840*2400@25fps、119-2560*1920@12.5fps
        # 120-2560*2048@12fps、121-2560*2048@15fps、122-2560*1536@25fps、123-2560*1536@30fps、124-2256*2048@25fps、125-2256*2048@30fps、126-2592*2592@12.5fps、127-2592*2592@15fps、
        # 128 - 640*512@30fps、129-2048*1520@30fps、130-2048*1520@25fps、131-3840*2160@24fps、132-2592*1520@25fps、133-2592*1520@30fps、134-2592*1536@25fps、135-2592*1536@30fps
        # 136-640*960@25fps、137-640*960@24fps、142-2992*2192@25fps、143-2992*2192@30fps、144-3008*2160@25fps、145-3008*2160@30fps、146-3072*1728@20fps、147-2560*1440@20fps、
        # 148-2160*3840@25fps、149-2160*3840@30fps、150-7008*1080@25fps、151-7008*1080@30fps、152-3072*2048@20fps、153-1536*864@25fps、154-2560*1920@24fps、155-2400*3840@30fps、
        # 156-3840*2400@30fps、157-3840*2160@15fps
        # 158-384*288@8.3fps、159-640*512@8.3fps、160-160*120@8.3fps、161-1024*768@8.3fps、162-640*480@8.3fps、163-3840*2160@12.5fps、164-2304*1296@30fps、165-2304*1296@25fps、
        # 166-2560*1440@24fps、167-2688*1512@25fps、168-2688*1512@30fps、169-2688*1512@50fps、170-2688*1512@60fps、171-1536*864@30fps、172-2560*1440@50fps、173-2560*1440@60fps、
        # 174-2048*2048@25fps、175-2048*2048@30fps、176-4000*3060@20fps、177-3060*3060@25fps、178-3060*3060@30fps、179-3000*3000@25fps、180-3000*3000@30fps、181-8160*3616@30fps、
        # 182-8160*3616@25fps、183-3000*3000@20fps、184-3000*3000@15fps、185-3000*3000@12.5fps、186-5472*3648@25fps、187-5472*3648@30fps、188-7680*4320@25fps、189-7680*4320@30fps、
        # 190-8160*2400@25fps、191-8160*2400@30fps、192-5520*2400@25fps、193-5520*2400@30fps、194-2560*1440@15fps、195-1944*1212@24fps、196-1944*1212@25fps、197-3456*1920@30fps、
        # 198-4800*2688@25fps、199-4800*2688@30fps、200-6480*1080@25fps、201-6480*1080@30fps、202-8640*1440@25fps、203-8640*1440@30fps、204-3456*1920@25fps、205-2688*1520@50fps、
        # 206-2688*1520@60fps、207-4976*1452@25fps、208-4976*1452@30fps、 209-3200*1800@25fps、210-3200*1800@30fps、211-5472*3648@24fps、212-1920*1080@12.5fps、213-2944*1656@20fps、
        # 214-1920*1080@24fps、215-4800*1600@25fps、216-4800*1600@30fps
        ("byCaptureModeN", BYTE), # 视频输入模式（N制）
        ("byCaptureModeP", BYTE), # 视频输入模式（P制）
        ("struSmartIRParam", NET_DVR_SMARTIR_PARAM), # 红外放过爆配置信息
        ("struPIrisParam", NET_DVR_PIRIS_PARAM), # PIris配置信息对应byIrisMode字段从2-PIris1开始生效
        # 2014-02-25 新增参数
        ("struLaserParam", NET_DVR_LASER_PARAM_CFG), # 激光参数
        ("struFFCParam", NET_DVR_FFC_PARAM),
        ("struDDEParam", NET_DVR_DDE_PARAM),
        ("struAGCParam", NET_DVR_AGC_PARAM),
        ("byLensDistortionCorrection", BYTE), # 镜头畸变校正 0-关闭,1-开启
        ("byDistortionCorrectionLevel", BYTE), # 畸变校正等级：0-保留；1-等级一；2-等级二；3-等级三255-自定义
        ("byCalibrationAccurateLevel", BYTE), #  畸变校正强度[0-100]
        ("byZoomedInDistantViewLevel", BYTE), # 远端放大等级[0-100]
        ("struSnapCCD", NET_DVR_SNAP_CAMERAPARAMCFG), # 抓拍机CCD参数，只用于抓拍机
        ("struOpticalDehaze", NET_DVR_OPTICAL_DEHAZE), # 光学透雾参数
        ("struThermAGC", NET_DVR_THERMOMETRY_AGC), # 测温AGC配置
        ("byFusionMode", BYTE), # 双光谱视频融合模式，0~热成像模式，1~融合模式，2~画中画模式,3~可见光模式, 4~融合黑白模式, 5~融合彩色模式-草地，6~融合彩色模式-荒地，7~融合彩色模式-雪地，8~融合彩色模式-海洋，9~融合彩色模式-城市
        ("byHorizontalFOV", BYTE), # 水平视场角[0-100]
        ("byVerticalFOV", BYTE), # 垂直视场角[0-100]
        ("byBrightnessSuddenChangeSuppression", BYTE), # 亮度突变抑制0-关闭,1-开启
        ("byGPSEnabled", BYTE), # GPS开关使能，0-关，1-开
        ("byRes2", BYTE * 155),
    ]


LPNET_DVR_CAMERAPARAMCFG_EX = POINTER(NET_DVR_CAMERAPARAMCFG_EX)


class NET_DVR_FOCUSING_POSITION_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byState", BYTE), # 聚焦到位状态参数 0-不到位，1-到位
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_FOCUSING_POSITION_STATE = POINTER(NET_DVR_FOCUSING_POSITION_STATE)

VCA_BLUE_PLATE = 0 # 蓝色车牌
VCA_YELLOW_PLATE = 1 # 黄色车牌
VCA_WHITE_PLATE = 2 # 白色车牌
VCA_BLACK_PLATE = 3 # 黑色车牌
VCA_GREEN_PLATE = 4 # 绿色车牌
VCA_BKAIR_PLATE = 5 # 民航黑色车牌
VCA_RED_PLATE = 6 # 红色车牌
VCA_ORANGE_PLATE = 7 # 橙色车牌
VCA_OTHER = 0xff # 其他

VCA_STANDARD92_PLATE = 0 # 标准民用车与军车
VCA_STANDARD02_PLATE = 1 # 02 式民用车牌
VCA_WJPOLICE_PLATE = 2 # 武警车
VCA_JINGCHE_PLATE = 3 # 警车
STANDARD92_BACK_PLATE = 4 # 民用车双行尾牌
VCA_SHIGUAN_PLATE = 5 # 使馆车牌
VCA_NONGYONG_PLATE = 6 # 农用车
VCA_MOTO_PLATE = 7 # 摩托车
NEW_ENERGY_PLATE = 8 # 新能源车牌
# 2017 - 05 - 18 增加 中东地区车牌类型
TRANSPORT_PLATE = 0x20 # 运输车
COMMERCIAL_PLATE = 0x21 # 商用车
PRIVATE_PLATE = 0x22 # 私家车
LEARNING_PLATE = 0x23 # 教练车
CD_PLATE = 0x24 # 使馆车
CC_PLATE = 0x25 # 使馆车
ARMY_PLATE = 0x26 # 军车
PROTOCOL_PLATE = 0x27 # PROTOCOL
GOVERNMENT_PLATE = 0x28 # 政府车
EXPORT_PLATE = 0x29 # EXPORT
TAXI_PLATE = 0x2A # 出租车
TESTING_PLATE = 0x2B # TESTING
TRANSFER_PLATE = 0x2C # TRANSFER
TRUCK_PLATE = 0x2D # 货车
BUS_PLATE = 0x2F # 公交车
PUBLIC_PLATE = 0x30 # PUBLIC
PUB_TRANS_PLATE = 0x31 # PUBLIC TRANSFER
PRI_TRANS_PLATE = 0x32 # PRIVATE TRANSPORT
UNKNOWN_PLATE = 0xff # 未知（未识别）

VTR_RESULT_OTHER = 0 # 未知
VTR_RESULT_BUS = 1 # 客车
VTR_RESULT_TRUCK = 2 # 货车
VTR_RESULT_CAR = 3 # 轿车
VTR_RESULT_MINIBUS = 4 # 面包车
VTR_RESULT_SMALLTRUCK = 5 # 小货车
VTR_RESULT_HUMAN = 6 # 行人
VTR_RESULT_TUMBREL = 7 # 二轮车
VTR_RESULT_TRIKE = 8 # 三轮车
VTR_RESULT_SUV_MPV = 9 # SUV / MPV
VTR_RESULT_MEDIUM_BUS = 10 # 中型客车
VTR_RESULT_MOTOR_VEHICLE = 11 # 机动车
VTR_RESULT_NON_MOTOR_VEHICLE = 12 # 非机动车
VTR_RESULT_SMALLCAR = 13 # 小型轿车
VTR_RESULT_MICROCAR = 14 # 微型轿车
VTR_RESULT_PICKUP = 15 # 皮卡车
VTR_RESULT_CONTAINER_TRUCK = 16 # 集装箱卡车
VTR_RESULT_MINI_TRUCK = 17 # 微卡，栏板卡
VTR_RESULT_SLAG_CAR = 18 # 渣土车
VTR_RESULT_CRANE = 19 # 吊车，工程车
VTR_RESULT_OIL_TANK_TRUCK = 20 # 油罐车
VTR_RESULT_CONCRETE_MIXER = 21 # 混凝土搅拌车
VTR_RESULT_PLATFORM_TRAILER = 22 # 平板拖车
VTR_RESULT_HATCHBACK = 23 # 两厢轿车
VTR_RESULT_SALOON = 24 # 三厢轿车
VTR_RESULT_SPORT_SEDAN = 25 # 轿跑
VTR_RESULT_SMALL_BUS = 26 # 小型客车

VCR_CLR_UNSUPPORT = 0 # 不支持
VCR_CLR_WHITE = 1 # 白
VCR_CLR_SILVER = 2 # 银
VCR_CLR_GRAY = 3 # 灰
VCR_CLR_BLACK = 4 # 黑
VCR_CLR_RED = 5 # 红
VCR_CLR_DARKBLUE = 6 # 深蓝
VCR_CLR_BLUE = 7 # 蓝
VCR_CLR_YELLOW = 8 # 黄
VCR_CLR_GREEN = 9 # 绿
VCR_CLR_BROWN = 10 # 棕
VCR_CLR_PINK = 11 # 粉
VCR_CLR_PURPLE = 12 # 紫
VCR_CLR_DARKGRAY = 13 # 深灰
VCR_CLR_CYAN = 14 # 青色

VCA_LICENSE_TYPE = 0x1 # 车牌号码
VCA_PLATECOLOR_TYPE = 0x2 # 车牌颜色
VCA_CARDNO_TYPE = 0x4 # 卡号
VCA_PLATETYPE_TYPE = 0x8 # 车牌类型
VCA_LISTTYPE_TYPE = 0x10 # 车辆名单类型
VCA_INDEX_TYPE = 0x20 # 数据流水号 2014 - 02 - 25
VCA_OPERATE_INDEX_TYPE = 0x40 # 操作数 2014 - 03 - 03

VCA_POSTPIC_TYPE = 0x1 # 卡口图片
VCA_LOWSPEED_TYPE = 0x2 # 低速
VCA_HIGHSPEED_TYPE = 0x4 # 高速
VCA_RETROGRADE_TYPE = 0x8 # 逆行
VCA_RUSH_REDLIGHT_TYPE = 0x10 # 闯红灯
VCA_PRESS_LANE_TYPE = 0x20 # 压车道线
VCA_VIOLATE_GUIDE_TYPE = 0x40 # 不按导向
VCA_ROAD_STRAND_TYPE = 0x80 # 路口滞留(设备不支持)
VCA_VEHICLE_ILLEGAL_LANE_TYPE = 0x100 # 机占非
VCA_ILLEGAL_LANE_CHANGE_TYPE = 0x200 # 违法变道
VCA_ILLEGAL_LANE_DRIVE_TYPE = 0x400 # 不按车道
VCA_VIOLATE_BAN_TYPE = 0x800 # 违法禁令
VCA_CROSS_PARKING_TYPE = 0x1000 # 路口停车
VCA_GREEN_PARKING_TYPE = 0x2000 # 绿灯停车

VCA_OTHER_TYPE = 0x1 # 其它车型
VCA_SMALLCAR_TYPE = 0x2 # 小型车
VCA_BIGCAR_TYPE = 0x4 # 大型车
VCA_BUS_TYPE = 0x8 # 客车
VCA_TRUCK_TYPE = 0x10 # 货车
VCA_CAR_TYPE = 0x20 # 轿车
VCA_MINIBUS_TYPE = 0x40 # 面包车
VCA_SMALL_TRUCK_TYPE = 0x80 # 小货车

VLR_OTHER = 0 # 其它
VLR_VOLKSWAGEN = 1 # 大众
VLR_BUICK = 2 # 别克
VLR_BMW = 3 # 宝马
VLR_HONDA = 4 # 本田
VLR_PEUGEOT = 5 # 标致
VLR_TOYOTA = 6 # 丰田
VLR_FORD = 7 # 福特
VLR_NISSAN = 8 # 日产
VLR_AUDI = 9 # 奥迪
VLR_MAZDA = 10 # 马自达
VLR_CHEVROLET = 11 # 雪佛兰
VLR_CITROEN = 12 # 雪铁龙
VLR_HYUNDAI = 13 # 现代
VLR_CHERY = 14 # 奇瑞
VLR_KIA = 15 # 起亚
VLR_ROEWE = 16 # 荣威
VLR_MITSUBISHI = 17 # 三菱
VLR_SKODA = 18 # 斯柯达
VLR_GEELY = 19 # 吉利
VLR_ZHONGHUA = 20 # 中华
VLR_VOLVO = 21 # 沃尔沃
VLR_LEXUS = 22 # 雷克萨斯
VLR_FIAT = 23 # 菲亚特
VLR_EMGRAND = 24 # 帝豪(吉利)
VLR_DONGFENG = 25 # 东风
VLR_BYD = 26 # 比亚迪
VLR_SUZUKI = 27 # 铃木
VLR_JINBEI = 28 # 金杯
VLR_HAIMA = 29 # 海马
VLR_SGMW = 30 # 五菱
VLR_JAC = 31 # 江淮
VLR_SUBARU = 32 # 斯巴鲁
VLR_ENGLON = 33 # 英伦(吉利)
VLR_GREATWALL = 34 # 长城
VLR_HAFEI = 35 # 哈飞
VLR_ISUZU = 36 # 五十铃(庆铃)
VLR_SOUEAST = 37 # 东南
VLR_CHANA = 38 # 长安
VLR_FOTON = 39 # 福田
VLR_XIALI = 40 # 夏利(一汽)
VLR_BENZ = 41 # 奔驰
VLR_FAW = 42 # 一汽
VLR_NAVECO = 43 # 依维柯
VLR_LIFAN = 44 # 力帆
VLR_BESTURN = 45 # 一汽奔腾(一汽)
VLR_CROWN = 46 # 皇冠(丰田)
VLR_RENAULT = 47 # 雷诺
VLR_JMC = 48 # JMC(江铃)
VLR_MG = 49 # MG名爵
VLR_KAMA = 50 # 凯马
VLR_ZOTYE = 51 # 众泰
VLR_CHANGHE = 52 # 昌河
VLR_XMKINGLONG = 53 # 厦门金龙(金旅)
VLR_HUIZHONG = 54 # 上海汇众(上汽集团)
VLR_SZKINGLONG = 55 # 苏州金龙
VLR_HIGER = 56 # 海格
VLR_YUTONG = 57 # 宇通
VLR_CNHTC = 58 # 中国重汽
VLR_BEIBEN = 59 # 北奔重卡
VLR_XINGMA = 60 # 华菱星马
VLR_YUEJIN = 61 # 跃进
VLR_HUANGHAI = 62 # 黄海
VLR_OLDWALL = 63 # 老款长城
VLR_CHANACOMMERCIAL = 64 # 长安商用
VLR_PORSCHE = 65 # 保时捷
VLR_CADILLAC = 66 # 凯迪拉克
VLR_INFINITI = 67 # 英菲尼迪
VLR_GLEAGLE = 68 # 吉利全球鹰(吉利)
VLR_JEEP = 69 # JEEP(吉普)
VLR_LANDROVER = 70 # 路虎
VLR_CHANGFENG = 71 # 长丰
VLR_BENNI = 72 # 长安奔奔(长安)
VLR_ERA = 73 # 福田时代(时代)
VLR_TAURUS = 74 # 长安金牛星(长安商用)
VLR_EADO = 75 # 长安逸动
VLR_SHANQI = 76 # 陕汽
VLR_HONGYAN = 77 # 红岩汽车(上汽依维柯红岩)
VLR_DRAGON = 78 # 霸龙汽车(东风柳汽)
VLR_JACTEXT = 79 # 江淮JAC(江淮)
VLR_JACBUS = 80 # 江淮现代客车(江淮)
VLR_ANKAI = 81 # 安凯客车
VLR_SHENLONG = 82 # 申龙客车
VLR_DAEWOO = 83 # 大宇客车
VLR_WUZHENG = 84 # 五征汽车
VLR_MAN = 85 # MAN汽车
VLR_ZHONGTONG = 86 # 中通客车
VLR_BAOJUN = 87 # 宝骏
VLR_BQWEIWANG = 88 # 北汽威旺
VLR_TRUMPCHE = 89 # 传祺
VLR_LUFENG = 90 # 陆风
VLR_HMZHENGZHOU = 91 # 海马郑州
VLR_BEIJING = 92 # 北京汽车
VLR_ZHONGSHUN = 93 # 中顺
VLR_WEILIN = 94 # 威麟汽车
VLR_OPEL = 95 # 欧宝
VLR_KARRY = 96 # 开瑞
VLR_SMA = 97 # 华普汽车
VLR_SMATEXT = 98 # 华普汽车文字SMA
VLR_YUWIN = 99 # 江铃驭胜
VLR_MINI = 100 # 宝马MINI
VLR_MARK = 101 # 丰田MARKX
VLR_HAVAL = 102 # 哈弗HAVAL
VLR_OGA = 103 # 讴歌
VLR_VENUCIA = 104 # 启辰
VLR_BYD2 = 105 # 比亚迪样式2(比亚迪)
VLR_SMART = 106 # 奔驰SMART
VLR_BAW = 107 # 北京汽车制造厂BAW
VLR_LUXGEN = 108 # 纳智捷
VLR_YEMA = 109 # 野马
VLR_ZTE = 110 # 中兴
VLR_EVERUS = 111 # 理念
VLR_CHRYSLER = 112 # 克莱斯勒
VLR_GONOW = 113 # 吉奥汽车
VLR_SHJIANG = 114 # 松花江
VLR_RUILIN = 115 # 瑞麟
VLR_FORTA = 116 # 福达
VLR_GAGUAR = 117 # 捷豹
VLR_HEIBAO = 118 # 黑豹
VLR_TKING = 119 # 唐骏
VLR_TKINGTEXT = 120 # 唐骏文字
VLR_FODAY = 121 # 福迪
VLR_LOTUS = 122 # 莲花汽车
VLR_NANJUN = 123 # 南骏
VLR_SHUANGHUAN = 124 # 双环汽车
VLR_SAIBAO = 125 # 哈飞赛豹
VLR_HAWTAI = 126 # 华泰
VLR_LIFO = 127 # 永源飞碟
VLR_JONWAY = 128 # 永源汽车
VLR_FULONGMA = 129 # 福龙马
VLR_WEILI = 130 # 潍力
VLR_ANCHI = 131 # 江淮安驰
VLR_PAIXI = 132 # 派喜
VLR_HIGERTEXT = 133 # 海格HIGER文字
VLR_RIYECAR = 134 # 广汽日野轻卡
VLR_RIYETRUCK = 135 # 广汽日野重卡
VLR_JIANGNAN = 136 # 江南
VLR_OLDZOTYE = 137 # 老款众泰
VLR_OLDXIALI = 138 # 老款夏利
VLR_NEWAOCHI = 139 # 新奥驰
VLR_CDW = 140 # 王牌重汽
VLR_CDWTEXT = 141 # 王牌重汽文字
VLR_CIIMO = 142 # 本田思铭
VLR_CHANADS = 143 # 长安谛艾仕
VLR_DS = 144 # 道奇
VLR_ROHENS = 145 # 现代劳恩斯酷派
VLR_YANTAI = 146 # 燕台
VLR_SHUANGLONG = 147 # 双龙
VLR_FENGLING = 148 # 时代风菱
VLR_XINKAI = 149 # 新凯
VLR_GMC = 150 # GMC
VLR_DATONG = 151 # 上汽大通
VLR_BQYINXIANG = 152 # 北汽银翔
VLR_NEWCHERY = 153 # 新奇瑞
VLR_MUDAN = 154 # 牡丹
VLR_DAYUN = 155 # 大运汽车
VLR_DONGWO = 156 # 东沃汽车
VLR_UNION = 157 # 联合汽车
VLR_CHUNZHOU = 158 # 春洲客车
VLR_SANY = 159 # 三一重工
VLR_YAXING = 160 # 亚星客车
VLR_HENGTONG = 161 # 恒通客车
VLR_SHAOLIN = 162 # 少林客车
VLR_YOUNG = 163 # 青年客车
VLR_STOM = 164 # 十通
VLR_SANHUAN = 165 # 三环
VLR_XUGONG = 166 # 徐工
VLR_BEIFANG = 167 # 北方汽车
VLR_JIANGHUAN = 168 # 江环货车
VLR_BJFARM = 169 # 北京农用
VLR_NEWDADI = 170 # 新大地汽车
VLR_SUNWIN = 171 # 申沃客车
VLR_YINGTIAN = 172 # 英田
VLR_QINGQI = 173 # 轻骑
VLR_CHUFENG = 174 # 楚风汽车
VLR_SCANIA = 175 # 斯堪尼亚
VLR_JIULONG = 176 # 九龙客车
VLR_YOUYI = 177 # 友谊客车
VLR_SHANGRAO = 178 # 上饶客车
VLR_JIJIANG = 179 # 吉江
VLR_YANGZI = 180 # 扬子客车
VLR_XIWO = 181 # 西沃客车
VLR_CHANGJIANG = 182 # 长江客车
VLR_WUYI = 183 # 武夷
VLR_CHENGDU = 184 # 成都客车
VLR_TIANMA = 185 # 天马
VLR_BAOLONG = 186 # 宝龙
VLR_NEWYATU = 187 # 新雅途
VLR_BARUI = 188 # 起亚霸锐
VLR_GUANZHI = 189 # 观致
VLR_XIYATE = 190 # 西雅特
VLR_BINLI = 191 # 宾利
VLR_DADI = 192 # 大迪
VLR_FUQI = 193 # 富奇
VLR_HANGTIAN = 194 # 航天汽车
VLR_HENGTIAN = 195 # 恒天汽车
VLR_JMCCAR = 196 # 江铃轻汽
VLR_KAERSEN = 197 # 卡尔森汽车
VLR_KAWEI = 198 # 卡威汽车
VLR_LANBOJINI = 199 # 兰博基尼
VLR_MASHALADI = 200 # 玛莎拉蒂
VLR_SHUCHI = 201 # 舒驰客车
VLR_SHILI = 202 # 实力客车
VLR_HUABEI = 203 # 中客华北
VLR_YIZHENG = 204 # 上汽仪征
VLR_CHUNLAN = 205 # 春兰汽车
VLR_DAFA = 206 # 大发汽车
VLR_SHENYE = 207 # 神野汽车
VLR_FALALI = 208 # 法拉利汽车
VLR_FUXING = 209 # 福星汽车
VLR_ANYUAN = 210 # 安源客车
VLR_JINGHUA = 211 # 京华客车
VLR_TAIHU = 212 # 太湖客车
VLR_WUZHOULONG = 213 # 五洲龙
VLR_CHANGLONG = 214 # 常隆客车
VLR_YUEXI = 215 # 悦西客车
VLR_SHENMA = 216 # 神马客车
VLR_LUSHAN = 217 # 庐山牌
VLR_WANFENG = 218 # 万丰牌
VLR_GZYUNBAO = 219 # 广州云豹
VLR_ZHONGDA = 220 # 中大汽车
VLR_THREEWHEEL = 221 # 三轮车
VLR_TWOWHEEL = 222 # 二轮车
VLR_JBC = 223 # 金杯JBC
VLR_YZJIANG = 224 # 扬子江客车
VLR_CNJ = 225 # 南骏CNJ
VLR_FORLAND = 226 # 福田时代文字
VLR_FARMCAR = 227 # 农用车
VLR_DONGFANGHONG = 228 # 东方红
VLR_STEYR = 229 # 斯太尔汽车
VLR_HONGQI = 230 # 红旗
VLR_USER1 = 231 # 用户1
VLR_USER2 = 232 # 用户2
VLR_USER3 = 233 # 用户3
VLR_USER4 = 234 # 用户4
VLR_USER5 = 235 # 用户5
VLR_USER6 = 236 # 用户6
VLR_USER7 = 237 # 用户7
VLR_USER8 = 238 # 用户8

VSB_VOLKSWAGEN_OTHER = 0 # 其他（保留）
VSB_VOLKSWAGEN_LAVIDA = 1 # 朗逸
VSB_VOLKSWAGEN_CROSSLAVIDA = 2 # 朗境
VSB_VOLKSWAGEN_TIGUAN = 3 # 途观
VSB_VOLKSWAGEN_TOURAN = 4 # 途安
VSB_VOLKSWAGEN_SANTANA = 5 # 桑塔纳
VSB_VOLKSWAGEN_SANTANA2000 = 6 # 桑塔纳2000
VSB_VOLKSWAGEN_SANTANA3000 = 7 # 桑塔纳3000
VSB_VOLKSWAGEN_VISTA = 8 # 桑塔纳 - 志俊
VSB_VOLKSWAGEN_PASSAT = 9 # 帕萨特
VSB_VOLKSWAGEN_PASSATLINGYU = 10 # 帕萨特 - 领驭
VSB_VOLKSWAGEN_POLO = 11 # 波罗
VSB_VOLKSWAGEN_POLOCROSS = 12 # 波罗 - 运动版
VSB_VOLKSWAGEN_POLOGTI = 13 # 波罗 - GTI
VSB_VOLKSWAGEN_SAGITAR = 14 # 速腾
VSB_VOLKSWAGEN_MAGOTAN = 15 # 迈腾
VSB_VOLKSWAGEN_JETTA = 16 # 捷达
VSB_VOLKSWAGEN_BORA = 17 # 宝来
VSB_VOLKSWAGEN_NEWGOLF = 18 # 新高尔夫
VSB_VOLKSWAGEN_GOLFGTI = 19 # 高尔夫 - GTI
VSB_VOLKSWAGEN_GOL = 20 # 高尔
VSB_VOLKSWAGEN_CADDY = 21 # 开迪
VSB_VOLKSWAGEN_PHAETON = 22 # 辉腾
VSB_VOLKSWAGEN_TOUREG = 23 # 途锐
VSB_VOLKSWAGEN_SCIROCCO = 24 # 尚酷
VSB_VOLKSWAGEN_BEETLE = 25 # 甲壳虫
VSB_VOLKSWAGEN_SHARAN = 26 # 夏朗
VSB_VOLKSWAGEN_MULTIVAN = 27 # 迈特威
VSB_VOLKSWAGEN_CARBONCOPY = 28 # 一汽大众 - CC
VSB_VOLKSWAGEN_VISTACHANGDA = 29 # 桑塔纳志俊 - 畅达
VSB_VOLKSWAGEN_BORASPORTLINE = 30 # 宝来 - SPORTLINE
VSR_VOLKSWAGEN_CC_1 = 31 # 大众 - CC - 2012, 2011, 2010
VSR_VOLKSWAGEN_Cross_POLO_1 = 32 # 大众 - Cross - POLO - 2010, 2007
VSR_VOLKSWAGEN_Cross_POLO_2 = 33 # 大众 - Cross - POLO - 2014, 2012
VSR_VOLKSWAGEN_MULTIVAN_1 = 34 # 大众 - Multivan - 2014, 2012, 2011
VSR_VOLKSWAGEN_POLO_1 = 35 # 大众 - POLO - 2006, 2005, 2004, 2003, 2002
VSR_VOLKSWAGEN_POLO_2 = 36 # 大众 - POLO - 2013, 2012, 2011
VSR_VOLKSWAGEN_POLO_JINQU_1 = 37 # 大众 - POLO劲取 - 2009, 2008, 2007, 2006
VSR_VOLKSWAGEN_POLO_JINQU_2 = 38 # 大众 - POLO劲取 - 2011
VSR_VOLKSWAGEN_Tiguan_1 = 39 # 大众 - Tiguan - 2011, 2009
VSR_VOLKSWAGEN_Tiguan_2 = 40 # 大众 - Tiguan - 2014, 2013, 2012
VSR_VOLKSWAGEN_XIALANG_1 = 41 # 大众 - 夏朗 - 2013, 2012
VSR_VOLKSWAGEN_BAOLAI_1 = 42 # 大众 - 宝来 - 2005, 2004
VSR_VOLKSWAGEN_BAOLAI_2 = 43 # 大众 - 宝来 - 2006
VSR_VOLKSWAGEN_BAOLAI_3 = 44 # 大众 - 宝来 - 2012, 2011, 2010, 2009, 2008
VSR_VOLKSWAGEN_BAOLAI_4 = 45 # 大众 - 宝来 - 2014, 2013
VSR_VOLKSWAGEN_SHANGKU_1 = 46 # 大众 - 尚酷 - 2014, 2013
VSR_VOLKSWAGEN_PASATE_1 = 47 # 大众 - 帕萨特 - 2003 进口, 2001 领驭
VSR_VOLKSWAGEN_PASATE_2 = 48 # 大众 - 帕萨特 - 2007, 2006, 2005 领驭
VSR_VOLKSWAGEN_PASATE_3 = 49 # 大众 - 帕萨特 - 2009, 2008, 2007, 2005, 2004, 2003, 2001, 2000
VSR_VOLKSWAGEN_PASATE_4 = 50 # 大众 - 帕萨特 - 2011, 2009 领驭
VSR_VOLKSWAGEN_PASATE_5 = 51 # 大众 - 帕萨特 - 2014, 2013, 2012, 2011
VSR_VOLKSWAGEN_JIEDA_1 = 52 # 大众 - 捷达 - 2005 CIF伙伴, 2002
VSR_VOLKSWAGEN_JIEDA_2 = 53 # 大众 - 捷达 - 2009, 2008, 2006, 2005, 2004
VSR_VOLKSWAGEN_JIEDA_3 = 54 # 大众 - 捷达 - 2012, 2010
VSR_VOLKSWAGEN_JIEDA_4 = 55 # 大众 - 捷达 - 2013
VSR_VOLKSWAGEN_LANGYI_1 = 56 # 大众 - 朗逸 - 2012, 2011, 2010, 2009, 2008
VSR_VOLKSWAGEN_LANGYI_2 = 57 # 大众 - 朗逸 - 2013
VSR_VOLKSWAGEN_SANGTANA_1 = 58 # 大众 - 桑塔纳 - 2007, 2002, 2000, 1999, 1995
VSR_VOLKSWAGEN_SANGTANA_2 = 59 # 大众 - 桑塔纳 - 2014, 2013
VSR_VOLKSWAGEN_SANGTANA_3 = 60 # 大众 - 桑塔纳2000 - 2003, 2001, 2000, 1999, 1998, 1996
VSR_VOLKSWAGEN_SANGTANA_4 = 61 # 大众 - 桑塔纳3000 - 2007, 2006, 2005, 2004, 2003
VSR_VOLKSWAGEN_SANGTANAZHIJUN_1 = 62 # 大众 - 桑塔纳志俊(vista) - 2011, 2010, 2009, 2008
VSR_VOLKSWAGEN_SANGTANAZHIJUN_2 = 63 # 大众 - 桑塔纳志俊(vista) - 2006
VSR_VOLKSWAGEN_JIAKECHONG_1 = 64 # 大众 - 甲壳虫 - 2010, 2009, 2008, 2007, 2006, 2005
VSR_VOLKSWAGEN_JIAKECHONG_2 = 65 # 大众 - 甲壳虫 - 2014, 2013
VSR_VOLKSWAGEN_HUITENG_2 = 66 # 大众 - 辉腾 - 2010, 2009, 2007, 2006
VSR_VOLKSWAGEN_MAITENG_1 = 67 # 大众 - 迈腾 - 2011, 2010, 2009, 2008, 2007
VSR_VOLKSWAGEN_MAITENG_2 = 68 # 大众 - 迈腾 - 2013, 2012
VSR_VOLKSWAGEN_TUAN_3 = 69 # 大众 - 途安 - 2006, 2005, 2004
VSR_VOLKSWAGEN_TUAN_1 = 70 # 大众 - 途安 - 2010, 2009, 2008
VSR_VOLKSWAGEN_TUAN_2 = 71 # 大众 - 途安 - 2013, 2012, 2011
VSR_VOLKSWAGEN_TUGUAN_1 = 72 # 大众 - 途观 - 2012, 2011, 2010
VSR_VOLKSWAGEN_TURUI_1 = 73 # 大众 - 途锐 - 2006, 2005, 2003
VSR_VOLKSWAGEN_TURUI_2 = 74 # 大众 - 途锐 - 2014, 2013, 2012, 2011
VSR_VOLKSWAGEN_SUTENG_1 = 75 # 大众 - 速腾 - 2010, 2009, 2007, 2006
VSR_VOLKSWAGEN_SUTENG_2 = 76 # 大众 - 速腾 - 2011
VSR_VOLKSWAGEN_SUTENG_3 = 77 # 大众 - 速腾 - 2014, 2013, 2012
VSR_VOLKSWAGEN_GAOERFU_1 = 78 # 大众 - 高尔夫 - 2008, 2007, 2006, 2005, 2004, 2003
VSR_VOLKSWAGEN_GAOERFU_2 = 79 # 大众 - 高尔夫 - 2012, 2011 进口, 2012, 2011, 2010
VSR_VOLKSWAGEN_GAOERFU_3 = 80 # 大众 - 高尔夫GTI - 2013, 2012, 2011, 2010
VSR_VOLKSWAGEN_LANGYI_3 = 81 # 大众 - 朗逸 - 2014
VSR_VOLKSWAGEN_HUITENG_1 = 82 # 大众 - 辉腾 - 2004

VBR_BUICK_OTHER = 0 # 其他（保留）
VBR_BUICK_ENCORE = 1 # 昂科拉
VBR_BUICK_GL8 = 2 # GL8
VBR_BUICK_LEGAL = 3 # 君威
VBR_BUICK_LACROSS = 4 # 君越
VBR_BUICK_EXCELLE = 5 # 凯越
VBR_BUICK_EXCELLEGT = 6 # 英朗GT
VBR_BUICK_WXCELLEXT = 7 # 英朗XT
VBR_BUICK_ENCLAVE = 8 # 昂科雷
VBR_BUICK_ROYAUM = 9 # 荣御
VBR_BUICK_SAIL = 10 # 别克赛欧
VBR_BUICK_EXCELLEHRV = 11 # 凯越HRV
VBR_BUICK_PARKAVENUE = 12 # 林荫大道
VBR_BUICK_CENTURY = 13 # 新世纪
VBR_BUICK_GL8_1 = 14 # 别克 - GL8 - 2004, 2003
VBR_BUICK_GL8_2 = 15 # 别克 - GL8 - 2007, 2006, 2005
VBR_BUICK_GL8_3 = 16 # 别克 - GL8 - 2010_2008_2006_2005 陆尊
VBR_BUICK_GL8_4 = 17 # 别克 - GL8 - 2014, 2013, 2012, 2011
VBR_BUICK_GL8_5 = 18 # 别克 - GL8 - 2014_2013_2011 豪华版
VBR_BUICK_ENCORE_1 = 19 # 别克 - 昂科拉 - 2014, 2013
VBR_BUICK_ENCLAVE_1 = 20 # 别克 - 昂科雷 - 2013, 2010, 2009
VBR_BUICK_LEGAL_1 = 21 # 别克 - 君威 - 2001, 2000, 1999
VBR_BUICK_LEGAL_2 = 22 # 别克 - 君威 - 2008, 2006, 2005, 2004, 2002
VBR_BUICK_LEGAL_3 = 23 # 别克 - 君威 - 2013, 2012, 2011, 2010, 2009
VBR_BUICK_LEGAL_4 = 24 # 别克 - 君威 - 2013_2012_2011 运动版
VBR_BUICK_LEGAL_5 = 25 # 别克 - 君威 - 2014
VBR_BUICK_LEGAL_6 = 26 # 别克 - 君威 - 2014 运动版
VBR_BUICK_LACROSS_1 = 27 # 别克 - 君越 - 2008, 2007, 2006
VBR_BUICK_LACROSS_2 = 28 # 别克 - 君越 - 2012, 2011, 2010, 2009
VBR_BUICK_LACROSS_3 = 29 # 别克 - 君越 - 2013
VBR_BUICK_EXCELLE_1 = 30 # 别克 - 凯越 - 2006, 2005, 2004
VBR_BUICK_EXCELLE_2 = 31 # 别克 - 凯越 - 2008_2006_2005_2004 HRV
VBR_BUICK_EXCELLE_3 = 32 # 别克 - 凯越 - 2011, 2009, 2008
VBR_BUICK_EXCELLE_4 = 33 # 别克 - 凯越 - 2013
VBR_BUICK_PARKAVENUE_1 = 34 # 别克 - 林荫大道 - 2011, 2010, 2009, 2008, 2007
VBR_BUICK_SAIL_1 = 35 # 别克 - 赛欧 - 2004, 2003
VBR_BUICK_EXCELLEGT_1 = 36 # 别克 - 英朗GT - 2013, 2012, 2011, 2010
VBR_BUICK_WXCELLEXT_1 = 37 # 别克 - 英朗XT - 2014, 2013, 2012, 2010
VBR_BUICK_CENTURY_1 = 38 # 别克 - 新世纪 - 2000
VBR_BUICK_RONGYU_1 = 39 # 别克 - 荣御 - 2005, 2004

VSB_BMW_OTHER = 0 # 其他（保留）
VSB_BMW_3SERIES = 1 # 宝马3系
VSB_BMW_5SERIES = 2 # 宝马5系
VSB_BMW_X1 = 3 # 宝马X1
VSB_BMW_1SERIES = 4 # 宝马1系
VSB_BMW_7SERIES = 5 # 宝马7系
VSB_BMW_X3 = 6 # 宝马X3
VSB_BMW_X5 = 7 # 宝马X5
VSB_BMW_X6 = 8 # 宝马X6
VSB_BMW_Z4 = 9 # 宝马Z4
VSB_BMW_MINI = 10 # 迷你
VSB_BMW_6SERIES = 11 # 宝马6系
VSB_BMW_YIXI_1 = 12 # 宝马 - 1 系 - 2011, 2010, 2008, 2007
VSB_BMW_YIXI_2 = 13 # 宝马 - 1 系 - 2013, 2012
VSB_BMW_SANXI_1 = 14 # 宝马 - 3 系 - 2004
VSB_BMW_SANXI_2 = 15 # 宝马 - 3 系 - 2007, 2005
VSB_BMW_SANXI_3 = 16 # 宝马 - 3系 - 2012, 2011, 2010, 2009
VSB_BMW_SANXI_4 = 17 # 宝马 - 3 系 - 2014, 2013
VSB_BMW_WUXI_1 = 18 # 宝马 - 5 系 - 2010, 2009, 2008
VSB_BMW_WUXI_2 = 19 # 宝马 - 5 系 - 2013, 2012, 2011
VSB_BMW_LIUXI_1 = 20 # 宝马 - 6 系 - 未知
VSB_BMW_QIXI_1 = 21 # 宝马 - 7 系 - 2011, 2010, 2009
VSB_BMW_QIXI_2 = 22 # 宝马 - 7 系 - 2013
VSB_BMW_X1_1 = 23 # 宝马 - X1 - 2012, 2010
VSB_BMW_X1_2 = 24 # 宝马 - X1 - 2014, 2013
VSB_BMW_X3_1 = 25 # 宝马 - X3 - 2009, 2008, 2006
VSB_BMW_X3_2 = 26 # 宝马 - X3 - 2013, 2012, 2011
VSB_BMW_X5_1 = 27 # 宝马 - X5 - 2010, 2009, 2008
VSB_BMW_X5_2 = 28 # 宝马 - X5 - 2013, 2012, 2011
VSB_BMW_X5_3 = 29 # 宝马 - X5 - 2013 运动型
VSB_BMW_X6_1 = 30 # 宝马 - X6 - 2013, 2012, 2011, 2009, 2008
VSB_BMW_Z4_1 = 31 # 宝马 - Z4 - 2004

VSB_HONDA_OTHER = 0 # 其他（保留）
VSB_HONDA_CRV = 1 # 本田CR - V(思威)
VSB_HONDA_JADE = 2 # 杰德
VSB_HONDA_CIVIC = 3 # 思域
VSB_HONDA_SPIRIOR = 4 # 思铂睿
VSB_HONDA_CIIMO = 5 # 思铭
VSB_HONDA_ELYSION = 6 # 艾力绅
VSB_HONDA_OBYSSEY = 7 # 奥赛德
VSB_HONDA_FIT = 8 # 飞度
VSB_HONDA_NEWCITY = 9 # 锋范
VSB_HONDA_CROSSTOUR = 10 # 歌诗图
VSB_HONDA_CRIDER = 11 # 凌派
VSB_HONDA_ACCORD = 12 # 雅阁
VSB_HONDA_CITY = 13 # 思迪
VSB_HONDA_ANTILOCK = 14 # 阿柯德
VSB_HONDA_CRZ = 15 # 本田CR - Z
VSB_HONDA_CRV_1 = 16 # 本田 - CR - V - 2004
VSB_HONDA_CRV_2 = 17 # 本田 - CR - V - 2005
VSB_HONDA_CRV_3 = 18 # 本田 - CR - V - 2008, 2007
VSB_HONDA_CRV_4 = 19 # 本田 - CR - V - 2010
VSB_HONDA_CRV_5 = 20 # 本田 - CR - V - 2013, 2012
VSB_HONDA_CRIDER_1 = 21 # 本田 - 凌派 - 2014, 2013
VSB_HONDA_OBYSSEY_1 = 22 # 本田 - 奥德赛 - 2002
VSB_HONDA_OBYSSEY_2 = 23 # 本田 - 奥德赛 - 2006, 2005, 2004
VSB_HONDA_OBYSSEY_3 = 24 # 本田 - 奥德赛 - 2008, 2007
VSB_HONDA_OBYSSEY_4 = 25 # 本田 - 奥德赛 - 2011 豪华版
VSB_HONDA_CIVIC_1 = 26 # 本田 - 思域 - 2007
VSB_HONDA_CIVIC_5 = 27 # 本田 - 思域 - 1996
VSB_HONDA_CIVIC_2 = 28 # 本田 - 思域 - 2008, 2006
VSB_HONDA_CIVIC_3 = 29 # 本田 - 思域 - 2009
VSB_HONDA_CIVIC_4 = 30 # 本田 - 思域 - 2013, 2012, 2011
VSB_HONDA_CITY_1 = 31 # 本田 - 思迪 - 2008, 2007, 2006
VSB_HONDA_SPIRIOR_1 = 32 # 本田 - 思铂睿 - 2009
VSB_HONDA_SIMING_1 = 33 # 本田 - 思铭 - 2012
VSB_HONDA_JIEDE_1 = 34 # 本田 - 杰德 - 2013
VSB_HONDA_CROSSTOUR_1 = 35 # 本田 - 歌诗图 - 2013, 2012, 2010
VSB_HONDA_AILISHEN_1 = 36 # 本田 - 艾力绅 - 2012
VSB_HONDA_NEWCITY_1 = 37 # 本田 - 锋范 - 2009
VSB_HONDA_NEWCITY_2 = 38 # 本田 - 锋范 - 2011
VSB_HONDA_NEWCITY_3 = 39 # 本田 - 锋范 - 2014, 2012
VSB_HONDA_ACCORD_1 = 40 # 本田 - 雅阁 - 1996
VSB_HONDA_ACCORD_2 = 41 # 本田 - 雅阁 - 1999
VSB_HONDA_ACCORD_3 = 42 # 本田 - 雅阁 - 2001
VSB_HONDA_ACCORD_4 = 43 # 本田 - 雅阁 - 2003
VSB_HONDA_ACCORD_5 = 44 # 本田 - 雅阁 - 2008
VSB_HONDA_ACCORD_6 = 45 # 本田 - 雅阁 - 2010
VSB_HONDA_ACCORD_7 = 46 # 本田 - 雅阁 - 2011
VSB_HONDA_ACCORD_8 = 47 # 本田 - 雅阁 - 2012
VSB_HONDA_ACCORD_9 = 48 # 本田 - 雅阁 - 2013
VSB_HONDA_ACCORD_10 = 49 # 本田 - 雅阁 - 2014
VSB_HONDA_FIT_1 = 50 # 本田 - 飞度 - 2004
VSB_HONDA_FIT_2 = 51 # 本田 - 飞度 - 2004 三厢
VSB_HONDA_FIT_3 = 52 # 本田 - 飞度 - 2005
VSB_HONDA_FIT_4 = 53 # 本田 - 飞度 - 2007
VSB_HONDA_FIT_5 = 54 # 本田 - 飞度 - 2008
VSB_HONDA_FIT_6 = 55 # 本田 - 飞度 - 2013, 2011

VSB_PEUGEOT_OTHER = 0 # 其他（保留）
VSB_PEUGEOT_2008 = 1 # 标致2008
VSB_PEUGEOT_207 = 2 # 标致207
VSB_PEUGEOT_SENNA = 3 # 赛纳
VSB_PEUGEOT_3008 = 4 # 标致3008
VSB_PEUGEOT_301 = 5 # 标致301
VSB_PEUGEOT_307 = 6 # 标致307
VSB_PEUGEOT_308 = 7 # 标致308
VSB_PEUGEOT_408 = 8 # 标致408
VSB_PEUGEOT_508 = 9 # 标致508
VSB_PEUGEOT_206 = 10 # 标致206
VSB_PEUGEOT_407 = 11 # 标致407
VSB_PEUGEOT_206_1 = 12 # 标致 - 206 - 未知
VSB_PEUGEOT_207_1 = 13 # 标致 - 207 两厢 - 2011, 2010, 2009
VSB_PEUGEOT_207_2 = 14 # 标致 - 207 两厢 - 2013
VSB_PEUGEOT_3008_1 = 15 # 标致 - 3008 - 2014, 2013
VSB_PEUGEOT_301_1 = 16 # 标致 - 301 - 未知
VSB_PEUGEOT_307_1 = 17 # 标致 - 307 三厢 - 2007, 2006, 2005, 2004
VSB_PEUGEOT_307_2 = 18 # 标致 - 307 三厢 - 2010, 2009, 2008
VSB_PEUGEOT_307_3 = 19 # 标致 - 307 两厢 - 2013_2012_2011 CROSS
VSB_PEUGEOT_308_1 = 20 # 标致 - 308 - 2014, 2013, 2012
VSB_PEUGEOT_407_1 = 21 # 标致 - 407 - 未知
VSB_PEUGEOT_408_1 = 22 # 标致 - 408 - 2012, 2011, 2010
VSB_PEUGEOT_408_2 = 23 # 标致 - 408 - 2013
VSB_PEUGEOT_508_1 = 24 # 标致 - 508 - 2014, 2013, 2012, 2011
VSB_PEUGEOT_207_3 = 25 # 标致 - 207 三厢 - 2011, 2010, 2009
VSB_PEUGEOT_307_4 = 26 # 标致 - 307 两厢 - 2013, 2012, 2010, 2009, 2008

VSB_TOYOTA_OTHER = 0 # 其他（保留）
VSB_TOYOTA_HIGHLANDER = 1 # 汉兰达
VSB_TOYOTA_CAMRY = 2 # 凯美瑞
VSB_TOYOTA_YARIS = 3 # 雅力士
VSB_TOYOTA_YARISL = 4 # YARIS L致炫
VSB_TOYOTA_VERSO = 5 # 逸致
VSB_TOYOTA_HUAGUAN = 6 # 花冠
VSB_TOYOTA_CROWN = 7 # 皇冠
VSB_TOYOTA_COROLLA = 8 # 卡罗拉
VSB_TOYOTA_COSTER = 9 # 柯斯达
VSB_TOYOTA_PRADO = 10 # 普拉多
VSB_TOYOTA_PRIUS = 11 # 普锐斯
VSB_TOYOTA_RAV4 = 12 # 丰田RAV4
VSB_TOYOTA_REZI = 13 # 锐志
VSB_TOYOTA_VIOS = 14 # 威驰
VSB_TOYOTA_PREVIA = 15 # 普瑞维亚
VSB_TOYOTA_HIACE = 16 # 海狮
VSB_TOYOTA_86 = 17 # 丰田86
VSB_TOYOTA_SPEQUOIA = 18 # 红杉
VSB_TOYOTA_LANDCRUISER = 19 # 陆地巡洋舰(兰德酷路泽)
VSB_TOYOTA_SIENNA = 20 # 赛纳
VSB_TOYOTA_CAMRYHYBRID = 21 # 凯美瑞 - HYBRID
VSB_TOYOTA_GRACE = 22 # 阁瑞斯
VSB_TOYOTA_ALPHARD = 23 # 埃尔法
VSB_TOYOTA_RAV4_1 = 24 # 丰田 - RAV4 - 2012 手动经典版, 2011, 2010, 2009
VSB_TOYOTA_RAV4_2 = 25 # 丰田 - RAV4 - 2013
VSB_TOYOTA_86_1 = 26 # 丰田 - 丰田86 - 未知
VSB_TOYOTA_JIAMEI_2 = 27 # 丰田 - 佳美 - 2001, 2000, 1999, 1998
VSB_TOYOTA_JIAMEI_3 = 28 # 丰田 - 佳美 - 2004, 2003, 2002
VSB_TOYOTA_LANDEKLZ_1 = 29 # 丰田 - 兰德酷路泽 - 2011 中东版, 2010, 2007
VSB_TOYOTA_KAIMEIRUI_1 = 30 # 丰田 - 凯美瑞 - 2008, 2007, 2006
VSB_TOYOTA_KAIMEIRUI_2 = 31 # 丰田 - 凯美瑞 - 2012 尊瑞
VSB_TOYOTA_KAIMEIRUI_3 = 32 # 丰田 - 凯美瑞 - 2012 经典版, 2011, 2010, 2009
VSB_TOYOTA_KAIMEIRUI_4 = 33 # 丰田 - 凯美瑞 - 2013, 2012
VSB_TOYOTA_KAIMEIRUI_5 = 34 # 丰田 - 凯美瑞 - 2013 经典版
VSB_TOYOTA_KAIMEIRUI_6 = 35 # 丰田 - 凯美瑞 - 2014, 2012 骏瑞
VSB_TOYOTA_KALUOLA_1 = 36 # 丰田 - 卡罗拉 - 2010, 2009, 2008, 2007, 2006
VSB_TOYOTA_KALUOLA_2 = 37 # 丰田 - 卡罗拉 - 2013, 2012, 2011
VSB_TOYOTA_AIERFA_1 = 38 # 丰田 - 埃尔法 - 2011, 2010
VSB_TOYOTA_AIERFA_2 = 39 # 丰田 - 埃尔法 - 2013, 2012
VSB_TOYOTA_WEICHI_1 = 40 # 丰田 - 威驰 - 2004, 2003
VSB_TOYOTA_WEICHI_2 = 41 # 丰田 - 威驰 - 2007, 2006, 2005
VSB_TOYOTA_WEICHI_3 = 42 # 丰田 - 威驰 - 2009, 2008
VSB_TOYOTA_WEICHI_4 = 43 # 丰田 - 威驰 - 2013, 2012, 2011, 2010
VSB_TOYOTA_WEICHI_5 = 44 # 丰田 - 威驰 - 2014
VSB_TOYOTA_PULADUO_1 = 45 # 丰田 - 普拉多 - 2007, 2006, 2005, 2004
VSB_TOYOTA_PULADUO_2 = 46 # 丰田 - 普拉多 - 2010
VSB_TOYOTA_PULADUO_3 = 47 # 丰田 - 普拉多 - 2014
VSB_TOYOTA_PURUIWEIYA_1 = 48 # 丰田 - 普瑞维亚 - 2004
VSB_TOYOTA_PURUIWEIYA_4 = 49 # 丰田 - 普瑞维亚 - 2005
VSB_TOYOTA_PURUIWEIYA_2 = 50 # 丰田 - 普瑞维亚 - 2006
VSB_TOYOTA_PURUIWEIYA_3 = 51 # 丰田 - 普瑞维亚 - 2012, 2010, 2008, 2007
VSB_TOYOTA_KESIDA_1 = 52 # 丰田 - 柯斯达 - 2007
VSB_TOYOTA_KESIDA_2 = 53 # 丰田 - 柯斯达 - 2011
VSB_TOYOTA_HANLANDA_1 = 54 # 丰田 - 汉兰达 - 2011, 2009
VSB_TOYOTA_HANLANDA_2 = 55 # 丰田 - 汉兰达 - 2012
VSB_TOYOTA_HANLANDA_3 = 56 # 丰田 - 汉兰达 - 2013
VSB_TOYOTA_HAISHI_1 = 57 # 丰田 - 海狮 - 2001
VSB_TOYOTA_HUANGGUAN_1 = 58 # 丰田 - 皇冠 - 1999
VSB_TOYOTA_HUANGGUAN_2 = 59 # 丰田 - 皇冠 - 2009, 2008, 2007, 2006, 2005
VSB_TOYOTA_HUANGGUAN_3 = 60 # 丰田 - 皇冠 - 2010
VSB_TOYOTA_HUANGGUAN_4 = 61 # 丰田 - 皇冠 - 2012, 2011
VSB_TOYOTA_HONGSHAN_1 = 62 # 丰田 - 红杉 - 未知
VSB_TOYOTA_HUAGUAN_1 = 63 # 丰田 - 花冠 - 2006, 2005, 2004
VSB_TOYOTA_HUAGUAN_2 = 64 # 丰田 - 花冠 - 2009, 2008, 2007
VSB_TOYOTA_HUAGUAN_3 = 65 # 丰田 - 花冠 - 2011, 2010
VSB_TOYOTA_YIZHI_1 = 66 # 丰田 - 逸致 - 2014, 2012, 2011
VSB_TOYOTA_RUIZHI_1 = 67 # 丰田 - 锐志 - 2006, 2005
VSB_TOYOTA_RUIZHI_2 = 68 # 丰田 - 锐志 - 2009, 2008, 2007
VSB_TOYOTA_RUIZHI_3 = 69 # 丰田 - 锐志 - 2010 风度版
VSB_TOYOTA_RUIZHI_4 = 70 # 丰田 - 锐志 - 2012, 2010
VSB_TOYOTA_LUDIXUNYANG_1 = 71 # 丰田 - 陆地巡洋舰 - 未知
VSB_TOYOTA_YALISHI_1 = 72 # 丰田 - 雅力士 - 2009, 2008, 2007
VSB_TOYOTA_YALISHI_2 = 73 # 丰田 - 雅力士 - 2012, 2011, 2010
VSB_TOYOTA_RAV4_3 = 74 # 丰田 - RAV4 - 2013 经典, 精英, 尊崇, 2012
VSB_TOYOTA_YARiSL_1 = 75 # 丰田 - YARiS - L
VSB_TOYOTA_JIAMEI_1 = 76 # 丰田 - 佳美 - 1996
VSB_TOYOTA_PLATZ_1 = 77 # 丰田 - PLATZ - 1999
VSB_TOYOTA_LANDEKLZ_2 = 78 # 丰田 - 兰德酷路泽 - 2014, 2012 中东版, 2012

VSB_FORD_OTHER = 0 # 其他（保留）
VSB_FORD_FOCUS = 1 # 福克斯
VSB_FORD_FIESTA = 2 # 嘉年华
VSB_FORD_SMAX = 3 # 麦柯斯
VSB_FORD_MONDEO = 4 # 蒙迪欧
VSB_FORD_ECOSPORT = 5 # 翼博
VSB_FORD_ESCAPE = 6 # 翼虎
VSB_FORD_ZHISHENG = 7 # 致胜
VSB_FORD_ESCORT = 8 # 福睿斯
VSB_FORD_EXPLORER = 9 # 福特探险者
VSB_FORD_EDGE = 10 # 锐界
VSB_FORD_TRANSIT = 11 # 全顺
VSB_FORD_QUANSHUN_1 = 12 # 福特 - 全顺 - 未知
VSB_FORD_JIANIANHUA_1 = 13 # 福特 - 嘉年华三厢 - 2006, 2005, 2004
VSB_FORD_JIANIANHUA_2 = 14 # 福特 - 嘉年华三厢 - 2011, 2010, 2009
VSB_FORD_JIANIANHUA_3 = 15 # 福特 - 嘉年华三厢 - 2013
VSB_FORD_JIANIANHUA_4 = 16 # 福特 - 嘉年华两厢 - 2012
VSB_FORD_TANXIANZHE_1 = 17 # 福特 - 探险者 - 2013, 2011
VSB_FORD_FOCUS_1 = 18 # 福特 - 福克斯三厢 - 2005
VSB_FORD_FOCUS_2 = 19 # 福特 - 福克斯三厢 - 2005 经典型
VSB_FORD_FOCUS_3 = 20 # 福特 - 福克斯三厢 - 2008, 2007, 2006
VSB_FORD_FOCUS_4 = 21 # 福特 - 福克斯三厢 - 2013, 2012 经典, 2011, 2009
VSB_FORD_FOCUS_5 = 22 # 福特 - 福克斯两厢 - 2012
VSB_FORD_FOCUS_6 = 23 # 福特 - 福克斯两厢 - 2012 基本, 时尚, 2011, 2010, 2009, 2008
VSB_FORD_YIBO_1 = 24 # 福特 - 翼博 - 2013
VSB_FORD_YIHU_1 = 25 # 福特 - 翼虎 - 2013
VSB_FORD_MENGDIOU_1 = 26 # 福特 - 蒙迪欧 - 2003
VSB_FORD_MENGDIOU_2 = 27 # 福特 - 蒙迪欧 - 2005, 2004
VSB_FORD_MENGDIOU_3 = 28 # 福特 - 蒙迪欧 - 2006
VSB_FORD_MENGDIOU_4 = 29 # 福特 - 蒙迪欧 - 2013
VSB_FORD_MENGDIOU_5 = 30 # 福特 - 蒙迪欧 - 致胜 - 2010, 2008, 2007
VSB_FORD_MENGDIOU_6 = 31 # 福特 - 蒙迪欧 - 致胜 - 2011
VSB_FORD_RUIJIE_1 = 32 # 福特 - 锐界 - 2012, 2011
VSB_FORD_MAIKESI_1 = 33 # 福特 - 麦柯斯 - 2008, 2007

VSB_NISSAN_OTHER = 0 # 其他（保留）
VSB_NISSAN_XTRAIL = 1 # 奇骏
VSB_NISSAN_MURANO = 2 # 楼兰
VSB_NISSAN_LIVINA = 3 # 骊威
VSB_NISSAN_MARCH = 4 # 玛驰
VSB_NISSAN_TIIDA = 5 # 骐达
VSB_NISSAN_TEANA = 6 # 天籁
VSB_NISSAN_QASHQAI = 7 # 逍客
VSB_NISSAN_SYLPHY = 8 # 轩逸
VSB_NISSAN_SUNNY = 9 # 阳光
VSB_NISSAN_D22PICKUP = 10 # D22皮卡
VSB_NISSAN_D22VAN = 11 # D22厢式车
VSB_NISSAN_CABSTAR = 12 # 凯普斯达
VSB_NISSAN_HV200 = 13 # NV200
VSB_NISSAN_PALADIN = 14 # 帕拉丁
VSB_NISSAN_YIDA = 15 # 颐达
VSB_NISSAN_DUCK = 16 # 公爵
VSB_NISSAN_CEFIRO = 17 # 风度
VSB_NISSAN_FENGSHENBLUEBIRD = 18 # 风神蓝鸟
VSB_NISSAN_FENGSHENSUNNY = 19 # 风神阳光
VSB_NISSAN_SUCCE = 20 # 帅客
VSB_NISSAN_FUGA = 21 # 风雅
VSB_NISSAN_BLUEBIRD4 = 22 # 蓝鸟4代
VSB_NISSAN_VENUCIA = 23 # 启辰
VSB_NISSAN_QUEST = 24 # 贵士
VSB_NISSAN_GENISS = 25 # 俊逸
VSB_NISSAN_NV200_1 = 26 # 日产 - NV200 - 2013, 2012, 2011, 2010
VSB_NISSAN_TIANLAI_1 = 27 # 日产 - 天籁 - 2005, 2004
VSB_NISSAN_TIANLAI_2 = 28 # 日产 - 天籁 - 2007, 2006
VSB_NISSAN_TIANLAI_3 = 29 # 日产 - 天籁 - 2010, 2008
VSB_NISSAN_TIANLAI_4 = 30 # 日产 - 天籁 - 2012, 2011
VSB_NISSAN_TIANLAI_5 = 31 # 日产 - 天籁 - 2012 云安全版, 2011 公爵
VSB_NISSAN_TIANLAI_6 = 32 # 日产 - 天籁 - 2014, 2013
VSB_NISSAN_QIJUN_1 = 33 # 日产 - 奇骏 - 2010, 2008
VSB_NISSAN_QIJUN_2 = 34 # 日产 - 奇骏 - 2012, 2011 进口
VSB_NISSAN_PALADING_1 = 35 # 日产 - 帕拉丁 - 2013, 2011, 2006, 2004
VSB_NISSAN_LOULAN_1 = 36 # 日产 - 楼兰 - 2013, 2011
VSB_NISSAN_LOULAN_2 = 37 # 日产 - 玛驰 - 2010
VSB_NISSAN_LANNIAO_1 = 38 # 日产 - 蓝鸟 - 2002
VSB_NISSAN_LANNIAO_2 = 39 # 日产 - 蓝鸟 - 2003
VSB_NISSAN_LANNIAO_3 = 40 # 日产 - 蓝鸟 - 2004
VSB_NISSAN_GUISHI_1 = 41 # 日产 - 贵士 - 2005
VSB_NISSAN_XUANYI_1 = 42 # 日产 - 轩逸 - 2006
VSB_NISSAN_XUANYI_2 = 43 # 日产 - 轩逸 - 2012 经典, 2009, 2007
VSB_NISSAN_XUANYI_3 = 44 # 日产 - 轩逸 - 2014, 2012
VSB_NISSAN_XIAOKE_1 = 45 # 日产 - 逍客 - 2009, 2008
VSB_NISSAN_XIAOKE_2 = 46 # 日产 - 逍客 - 2013, 2012, 2011
VSB_NISSAN_SUNNY_3 = 47 # 日产 - 阳光 - 2004
VSB_NISSAN_SUNNY_1 = 48 # 日产 - 阳光 - 2006, 2005
VSB_NISSAN_SUNNY_2 = 49 # 日产 - 阳光 - 2012, 2011
VSB_NISSAN_YIDA_1 = 50 # 日产 - 颐达 - 2008, 2006, 2005
VSB_NISSAN_YIDA_2 = 51 # 日产 - 颐达 - 未知
VSB_NISSAN_FENGDU_1 = 52 # 日产 - 风度 - 未知
VSB_NISSAN_FENGYA_1 = 53 # 日产 - 风雅 - 未知
VSB_NISSAN_LIWEI_1 = 54 # 日产 - 骊威 - 2008, 2007
VSB_NISSAN_LIWEI_2 = 55 # 日产 - 骊威 - 2009
VSB_NISSAN_LIWEI_3 = 56 # 日产 - 骊威 - 2010
VSB_NISSAN_LIWEI_4 = 57 # 日产 - 骊威 - 2011, 2010 劲锐, 2008 炫能型
VSB_NISSAN_JUNYI_1 = 58 # 日产 - 骏逸 - 2006
VSB_NISSAN_QIDA_1 = 59 # 日产 - 骐达 - 2006, 2005
VSB_NISSAN_QIDA_2 = 60 # 日产 - 骐达 - 2009, 2008
VSB_NISSAN_QIDA_3 = 61 # 日产 - 骐达 - 2013, 2012, 2011
VSB_NISSAN_RUIQI_1 = 62 # 日产 - 锐骐皮卡 - 2009 豪华型

VSB_AUDI_OTHER = 0 # 其他（保留）
VSB_AUDI_A3 = 1 # 奥迪A3
VSB_AUDI_A4L = 2 # 奥迪A4L
VSB_AUDI_A6L = 3 # 奥迪A6L
VSB_AUDI_Q3 = 4 # 奥迪Q3
VSB_AUDI_Q5 = 5 # 奥迪Q5
VSB_AUDI_A1 = 6 # 奥迪A1
VSB_AUDI_A4 = 7 # 奥迪A4
VSB_AUDI_A5 = 8 # 奥迪A5
VSB_AUDI_A6 = 9 # 奥迪A6
VSB_AUDI_A7 = 10 # 奥迪A7
VSB_AUDI_A8L = 11 # 奥迪A8L
VSB_AUDI_Q7 = 12 # 奥迪Q7
VSB_AUDI_S5 = 13 # 奥迪S5
VSB_AUDI_TT = 14 # 奥迪TT
VSB_AUDI_100 = 15 # 奥迪100
VSB_AUDI_200 = 16 # 奥迪200
VSB_AUDI_S7 = 17 # 奥迪S7
VSB_AUDI_S8 = 18 # 奥迪S8
VSB_AUDI_100_1 = 19 # 奥迪 - 100 - 未知
VSB_AUDI_200_1 = 20 # 奥迪 - 200 - 未知
VSB_AUDI_A1_1 = 21 # 奥迪 - A1 - 2014, 2013, 2012
VSB_AUDI_A3_1 = 22 # 奥迪 - A3 - 2013, 2010 舒适版
VSB_AUDI_A3_2 = 23 # 奥迪 - A3 - 2013 技术型, 2011, 2010
VSB_AUDI_A4_1 = 24 # 奥迪 - A4 - 2005 国产, 2000 进口版
VSB_AUDI_A4_2 = 25 # 奥迪 - A4 - 2007, 2006 国产, 2004 进口
VSB_AUDI_A4L_1 = 26 # 奥迪 - A4L - 2013
VSB_AUDI_A5_1 = 27 # 奥迪 - A5 - 2011, 2010
VSB_AUDI_A6_1 = 28 # 奥迪 - A6 - 1996, 1995, 1991
VSB_AUDI_A6L_1 = 29 # 奥迪 - A6L - 2008, 2007, 2006, 2005
VSB_AUDI_A6L_2 = 30 # 奥迪 - A6L - 2011, 2010, 2009
VSB_AUDI_A6L_3 = 31 # 奥迪 - A6L - 2014, 2013, 2012
VSB_AUDI_A7_1 = 32 # 奥迪 - A7 - 2014, 2013 进取型, 2012, 2011
VSB_AUDI_A8L_1 = 33 # 奥迪 - A8L - 2006
VSB_AUDI_A8L_2 = 34 # 奥迪 - A8L - 2009, 2008
VSB_AUDI_A8L_3 = 35 # 奥迪 - A8L - 2011
VSB_AUDI_A8L_4 = 36 # 奥迪 - A8L - 2013, 2012
VSB_AUDI_Q3_1 = 37 # 奥迪 - Q3 - 2014, 2013, 2012
VSB_AUDI_Q5_1 = 38 # 奥迪 - Q5 - 2012, 2010 运动
VSB_AUDI_Q5_2 = 39 # 奥迪 - Q5 - 2012 豪华型, 2010 越野版
VSB_AUDI_Q5_3 = 40 # 奥迪 - Q5 - 2012 进取型, 2011, 2010, 2009
VSB_AUDI_Q5_4 = 41 # 奥迪 - Q5 - 2013
VSB_AUDI_Q7_1 = 42 # 奥迪 - Q7 - 2007
VSB_AUDI_Q7_2 = 43 # 奥迪 - Q7 - 2014, 2013
VSB_AUDI_S7_1 = 44 # 奥迪 - S7 - 2013
VSB_AUDI_S8_1 = 45 # 奥迪 - S8 - 2013
VSB_AUDI_TT_2 = 46 # 奥迪 - TT - 2010, 2008, 2007
VSB_AUDI_TT_3 = 47 # 奥迪 - TT - 2012, 2011
VSB_AUDI_TT_4 = 48 # 奥迪 - TT - 2013, 2013, 2011 TTS
VSB_AUDI_TT_1 = 49 # 奥迪 - TT - 2008 TTS

VSB_MAZDA_OTHER = 0 # 其他（保留）
VSB_MAZDA_CX5 = 1 # 马自达CX5
VSB_MAZDA_2 = 2 # 马自达2
VSB_MAZDA_3 = 3 # 马自达3
VSB_MAZDA_6 = 4 # 马自达6
VSB_MAZDA_8 = 5 # 马自达8
VSB_MAZDA_COREWING = 6 # 睿翼
VSB_MAZDA_CX7 = 7 # 马自达CX7
VSB_MAZDA_X5 = 8 # 马自达X5
VSB_MAZDA_5 = 9 # 马自达5
VSB_MAZDA_PREMACY = 10 # 老款普力马
VSB_MAZDA_MPV = 11 # 马自达MPV
VSB_MAZDA_CX5_1 = 12 # 马自达 - CX - 5 - 2014, 2013, 2012 进口
VSB_MAZDA_CX7_1 = 13 # 马自达 - CX - 7 - 2014, 2013, 2011, 2010
VSB_MAZDA_2_1 = 14 # 马自达 - Mazda2两厢 - 2011, 2009, 2008, 2007 A
VSB_MAZDA_3_1 = 15 # 马自达 - Mazda3三厢 - 2004, 2002
VSB_MAZDA_3_2 = 16 # 马自达 - Mazda3三厢 - 2009, 2007
VSB_MAZDA_3_3 = 17 # 马自达 - Mazda3三厢 - 2012, 2010
VSB_MAZDA_3_4 = 18 # 马自达 - Mazda3星骋两厢 - 2013, 2012
VSB_MAZDA_5_1 = 19 # 马自达 - Mazda5 - 2010, 2008, 2007
VSB_MAZDA_5_2 = 20 # 马自达 - Mazda5 - 2013, 2012, 2011
VSB_MAZDA_6_2 = 21 # 马自达 - Mazda6 - 2006
VSB_MAZDA_6_3 = 22 # 马自达 - Mazda6 - 2007
VSB_MAZDA_8_1 = 23 # 马自达 - Mazda8 - 2013, 2011, 2010
VSB_MAZDA_PREMACY_1 = 24 # 马自达 - 普力马 - 2003
VSB_MAZDA_PREMACY_2 = 25 # 马自达 - 普力马 - 2006, 2005, 2004
VSB_MAZDA_COREWING_1 = 26 # 马自达 - 睿翼 - 2012, 2011, 2010, 2009
VSB_MAZDA_COREWING_2 = 27 # 马自达 - 睿翼轿跑 - 2011, 2010
VSB_MAZDA_COREWING_3 = 28 # 马自达 - 睿翼轿跑 - 2012
VSB_MAZDA_2_2 = 29 # 马自达 - Mazda2劲翔(三厢) - 2011, 2010, 2008
VSB_MAZDA_6_1 = 30 # 马自达 - Mazda6 - 2004
VSB_MAZDA_6_4 = 31 # 马自达 - Mazda6 - 2014, 2013, 2012, 2011, 2010

VSB_CHEVROLET_OTHER = 0 # 其他（保留）
VSB_CHEVROLET_NEWAVEO = 1 # 爱唯欧
VSB_CHEVROLET_EPICA = 2 # 景程
VSB_CHEVROLET_CRUZE = 3 # 科鲁兹
VSB_CHEVROLET_CAPTIVA = 4 # 科帕奇
VSB_CHEVROLET_MALIBU = 5 # 迈锐宝
VSB_CHEVROLET_SAIL = 6 # 赛欧
VSB_CHEVROLET_CAMARO = 7 # 科迈罗
VSB_CHEVROLET_LECHENG = 8 # 乐成
VSB_CHEVROLET_LOVA = 9 # 乐风
VSB_CHEVROLET_OLDAVEO = 10 # 乐骋 - 老款爱唯欧
VSB_CHEVROLET_SPARK = 11 # 乐驰
VSB_CHEVROLET_SAILSRV = 12 # 赛欧SRV
VSB_CHEVROLET_LOVA_1 = 13 # 雪佛兰 - 乐风 - 2009, 2008, 2007, 2006
VSB_CHEVROLET_LOVA_2 = 14 # 雪佛兰 - 乐风 - 2010
VSB_CHEVROLET_SPARK_1 = 15 # 雪佛兰 - 乐驰 - 2010, 2009, 2006, 2005, 2004
VSB_CHEVROLET_SPARK_2 = 16 # 雪佛兰 - 乐驰 - 2010 运动款
VSB_CHEVROLET_OLDAVEO_1 = 17 # 雪佛兰 - 乐骋 - 2005
VSB_CHEVROLET_OLDAVEO_2 = 18 # 雪佛兰 - 乐骋 - 2010, 2009, 2008
VSB_CHEVROLET_EPICA_1 = 19 # 雪佛兰 - 景程 - 2005
VSB_CHEVROLET_EPICA_3 = 20 # 雪佛兰 - 景程 - 2012, 2011, 2010
VSB_CHEVROLET_EPICA_4 = 21 # 雪佛兰 - 景程 - 2012, 2011, 2010 致真版
VSB_CHEVROLET_EPICA_5 = 22 # 雪佛兰 - 景程 - 2013
VSB_CHEVROLET_NEWAVEO_1 = 23 # 雪佛兰 - 爱唯欧三厢 - 2013, 2012, 2011
VSB_CHEVROLET_CAPTIVA_1 = 24 # 雪佛兰 - 科帕奇 - 2010, 2008
VSB_CHEVROLET_CAPTIVA_2 = 25 # 雪佛兰 - 科帕奇 - 2014, 2013, 2012, 2011
VSB_CHEVROLET_KEMAILUO_1 = 26 # 雪佛兰 - 科迈罗 - 2012, 2011
VSB_CHEVROLET_CRUZE_1 = 27 # 雪佛兰 - 科鲁兹 - 2014, 2013, 2012, 2011, 2010, 2009
VSB_CHEVROLET_SAIL_1 = 28 # 雪佛兰 - 赛欧三厢 - 2005
VSB_CHEVROLET_SAIL_2 = 29 # 雪佛兰 - 赛欧三厢 - 2013, 2011, 2010
VSB_CHEVROLET_MALIBU_1 = 30 # 雪佛兰 - 迈锐宝 - 2014, 2013, 2012
VSB_CHEVROLET_EPICA_2 = 31 # 雪佛兰 - 景程 - 2009, 2008, 2007

VSB_CITROEN_OTHER = 0 # 其他（保留）
VSB_CITROEN_C2 = 1 # 雪铁龙C2
VSB_CITROEN_C4L = 2 # 雪铁龙C4L
VSB_CITROEN_C5 = 3 # 雪铁龙C5
VSB_CITROEN_ELYSEE = 4 # 爱丽舍三厢
VSB_CITROEN_CQUATRELIANGXIANG = 5 # 世嘉两厢
VSB_CITROEN_CQUATRESANXIANG = 6 # 世嘉三厢
VSB_CITROEN_SAEAPICASSO = 7 # 萨拉 - 毕加索
VSB_CITROEN_PICASSO = 8 # 毕加索
VSB_CITROEN_CTRIOMPHE = 9 # 凯旋
VSB_CITROEN_XSARA = 10 # 塞纳
VSB_CITROEN_SHENLONGFUKANG = 11 # 神龙富康
VSB_CITROEN_CHANGANDS = 12 # 长安DS
VSB_CITROEN_C2_1 = 13 # 雪铁龙 - C2 - 2012, 2010, 2008, 2007, 2006
VSB_CITROEN_C4L_1 = 14 # 雪铁龙 - C4L - 2014, 2013
VSB_CITROEN_C4PICASSO_1 = 15 # 雪铁龙 - C4毕加索 - 2009 舒适版
VSB_CITROEN_C5_1 = 16 # 雪铁龙 - C5 - 2012, 2011, 2010
VSB_CITROEN_CQUATRESANXIANG_1 = 17 # 雪铁龙 - 世嘉三厢 - 2013, 2012
VSB_CITROEN_CQUATRELIANGXIANG_1 = 18 # 雪铁龙 - 世嘉两厢 - 2011, 2010, 2009, 2008
VSB_CITROEN_CTRIOMPHE_1 = 19 # 雪铁龙 - 凯旋 - 2010, 2009, 2008, 2006
VSB_CITROEN_FUKANG_1 = 20 # 雪铁龙 - 富康 - 2006, 2005, 2004, 2003, 2002
VSB_CITROEN_ELYSEE_1 = 21 # 雪铁龙 - 爱丽舍三厢 - 2006, 2005, 2004, 2003, 2002
VSB_CITROEN_ELYSEE_2 = 22 # 雪铁龙 - 爱丽舍三厢 - 2013, 2012, 2011, 2010, 2009, 2008, 2007
VSB_CITROEN_SAEAPICASSO_1 = 23 # 雪铁龙 - 萨拉 - 毕加索 - 2014

VSB_HYUNDAI_OTHER = 0 # 其他（保留）
VSB_HYUNDAI_IX35 = 1 # 现代IX35
VSB_HYUNDAI_LANGDONG = 2 # 朗动
VSB_HYUNDAI_MOINCA = 3 # 名驭
VSB_HYUNDAI_SHENGDA = 4 # 胜达
VSB_HYUNDAI_VERNA = 5 # 瑞纳
VSB_HYUNDAI_RUIYI = 6 # 瑞奕
VSB_HYUNDAI_SONATAEIGHT = 7 # 索纳塔八
VSB_HYUNDAI_TUCSON = 8 # 途胜
VSB_HYUNDAI_YUEDONG = 9 # 悦动
VSB_HYUNDAI_ELANTRA = 10 # 伊兰特
VSB_HYUNDAI_GRANDSANTAFE = 11 # 格锐
VSB_HYUNDAI_COUPE = 12 # 酷派
VSB_HYUNDAI_MATRIX = 13 # 美佳
VSB_HYUNDAI_ACCENT = 14 # 雅绅特
VSB_HYUNDAI_IX30 = 15 # 现代IX30
VSB_HYUNDAI_SONATA = 16 # 索纳塔
VSB_HYUNDAI_REFINE = 17 # 现代瑞风商务车
VSB_HYUNDAI_MISTRA = 18 # 名图
VSB_HYUNDAI_SONATAYUFENG = 19 # 索纳塔 - 御翔
VSB_HYUNDAI_SANTAFE = 20 # 现代圣达菲
VSB_HYUNDAI_HUIYI = 21 # 进口辉翼
VSB_HYUNDAI_I30_1 = 22 # 现代 - i30 - 2010, 2009
VSB_HYUNDAI_IX35_1 = 23 # 现代 - ix35 - 2012, 2011, 2010
VSB_HYUNDAI_YILANTE_1 = 24 # 现代 - 伊兰特 - 2006, 2005, 2004
VSB_HYUNDAI_YILANTE_2 = 25 # 现代 - 伊兰特 - 2007 三厢
VSB_HYUNDAI_YILANTE_3 = 26 # 现代 - 伊兰特 - 2011
VSB_HYUNDAI_SHENGDA_1 = 27 # 现代 - 全新胜达 - 2013, 2012
VSB_HYUNDAI_MINGTU_1 = 28 # 现代 - 名图 - 2014, 2013
VSB_HYUNDAI_MINGYU_1 = 29 # 现代 - 名驭 - 2013, 2011, 2009
VSB_HYUNDAI_SHENGDAFEI_1 = 30 # 现代 - 圣达菲 - 未知
VSB_HYUNDAI_YUXIANG_1 = 31 # 现代 - 御翔 - 2005 舒适版
VSB_HYUNDAI_YUXIANG_2 = 32 # 现代 - 御翔 - 2006, 2005
VSB_HYUNDAI_YUEDONG_1 = 33 # 现代 - 悦动 - 2010, 2009, 2008
VSB_HYUNDAI_YUEDONG_2 = 34 # 现代 - 悦动 - 2012, 2011
VSB_HYUNDAI_SHENGDA_2 = 35 # 现代 - 新胜达 - 2009, 2006
VSB_HYUNDAI_SHENGDA_3 = 36 # 现代 - 新胜达 - 2012, 2011, 2010
VSB_HYUNDAI_LANGDONG_1 = 37 # 现代 - 朗动 - 2013, 2012
VSB_HYUNDAI_GERUI_1 = 38 # 现代 - 格锐 - 未知
VSB_HYUNDAI_RUIYI_1 = 39 # 现代 - 瑞奕 - 2014
VSB_HYUNDAI_RUINA_1 = 40 # 现代 - 瑞纳三厢 - 2013, 2010
VSB_HYUNDAI_RUINA_2 = 41 # 现代 - 瑞纳两厢 - 2014, 2013, 2011
VSB_HYUNDAI_RUIFENG_1 = 42 # 现代 - 瑞风 - 未知
VSB_HYUNDAI_SUONATA_1 = 43 # 现代 - 索纳塔 - 2008, 2007, 2006, 2004, 2003 标准型
VSB_HYUNDAI_SUONATA_2 = 44 # 现代 - 索纳塔 - 2010, 2009, 2008, 2006, 2004
VSB_HYUNDAI_SOUNATA_3 = 45 # 现代 - 索纳塔八 - 2011, 2010
VSB_HYUNDAI_WEILAKESI_1 = 46 # 现代 - 维拉克斯 - 2012, 2010, 2008, 2007
VSB_HYUNDAI_MEIJIA_1 = 47 # 现代 - 美佳 - 未知
VSB_HYUNDAI_JINKOUHUIYI_1 = 48 # 现代 - 进口辉翼 - 未知
VSB_HYUNDAI_TUSHENG_1 = 49 # 现代 - 途胜 - 2005
VSB_HYUNDAI_TUSHENG_2 = 50 # 现代 - 途胜 - 2011, 2009, 2008, 2006
VSB_HYUNDAI_TUSHENG_3 = 51 # 现代 - 途胜 - 2013
VSB_HYUNDAI_KUPAI_1 = 52 # 现代 - 酷派 - 未知
VSB_HYUNDAI_YASHENTE_1 = 53 # 现代 - 雅绅特 - 2008, 2006
VSB_HYUNDAI_YASHENTE_2 = 54 # 现代 - 雅绅特 - 2011
VSB_HYUNDAI_LINGXIANG_1 = 55 # 现代 - 领翔 - 2009, 2008
VSB_HYUNDAI_FEISI_1 = 56 # 现代 - 飞思 - 2011

VSB_CHERY_OTHER = 0 # 其他（保留）
VSB_CHERY_A1 = 1 # 奇瑞A1
VSB_CHERY_A3 = 2 # 奇瑞A3
VSB_CHERY_EASTAR = 3 # 东方之子
VSB_CHERY_FULWIN = 4 # 风云
VSB_CHERY_QQ = 5 # 奇瑞QQ
VSB_CHERY_E5 = 6 # 奇瑞E5
VSB_CHERY_COWIN = 7 # 旗云
VSB_CHERY_TIGGO = 8 # 瑞虎
VSB_CHERY_A5 = 9 # 奇瑞A5
VSB_CHERY_S16 = 10 # 奇瑞S16
VSB_CHERY_YOUYA = 11 # 优雅
VSB_CHERY_V5 = 12 # 奇瑞V5
VSB_CHERY_E3 = 13 # 奇瑞E3
VSB_CHERY_A1_1 = 14 # 奇瑞 - A1 - 2011, 2008, 2007
VSB_CHERY_A3LIANGXIANG_1 = 15 # 奇瑞 - A3两厢 - 2012, 2010, 2009
VSB_CHERY_A5_1 = 16 # 奇瑞 - A5 - 2009, 2007, 2006
VSB_CHERY_QQ_1 = 17 # 奇瑞 - QQ - 2006, 2005, 2004
VSB_CHERY_QQ_2 = 18 # 奇瑞 - QQ - 2010, 2007, 2006
VSB_CHERY_QQ_3 = 19 # 奇瑞 - QQ - 2012, 2011, 2010, 2009, 2007
VSB_CHERY_QQ_4 = 20 # 奇瑞 - QQ - 2012 运动版
VSB_CHERY_QQ_5 = 21 # 奇瑞 - QQ - 2013
VSB_CHERY_DONGFANGZHIZI_1 = 22 # 奇瑞 - 东方之子 - 2005, 2004, 2003
VSB_CHERY_DONGFANGZHIZI_2 = 23 # 奇瑞 - 东方之子 - 2007, 2006
VSB_CHERY_DONGFANGZHIZI_3 = 24 # 奇瑞 - 东方之子CROSS - 2009, 2008, 2007
VSB_CHERY_YOUYA_1 = 25 # 奇瑞 - 优雅 - 未知
VSB_CHERY_E3_1 = 26 # 奇瑞 - 奇瑞E3 - 2013
VSB_CHERY_E5_1 = 27 # 奇瑞 - 奇瑞E5 - 2014, 2012, 2011
VSB_CHERY_QIYUN1_1 = 28 # 奇瑞 - 旗云1 - 2010
VSB_CHERY_QIYUN1_2 = 29 # 奇瑞 - 旗云1 - 2012
VSB_CHERY_QIYUN_1 = 30 # 奇瑞 - 旗云 - 2004
VSB_CHERY_QIYUN_2 = 31 # 奇瑞 - 旗云 - 2009, 2008, 2007, 2006
VSB_CHERY_QIYUN2_1 = 32 # 奇瑞 - 旗云2 - 2012
VSB_CHERY_QIYUN2_2 = 33 # 奇瑞 - 旗云2 - 2012 豪华型, 2010
VSB_CHERY_QIYUN3_1 = 34 # 奇瑞 - 旗云3 - 2010
VSB_CHERY_RUIHU_1 = 35 # 奇瑞 - 瑞虎 - 2007, 2006, 2005
VSB_CHERY_RUIHU_2 = 36 # 奇瑞 - 瑞虎 - 2009, 2007
VSB_CHERY_RUIHU_3 = 37 # 奇瑞 - 瑞虎 - 2012, 2011
VSB_CHERY_RUIHU_4 = 38 # 奇瑞 - 瑞虎 - 2013, 2012 自动DVVT豪华型
VSB_CHERY_RUIHU_5 = 39 # 奇瑞 - 瑞虎 - 2013 精英版豪华型, 2012 精英版舒适型
VSB_CHERY_FENGYUN2SANXIANG_1 = 40 # 奇瑞 - 风云2三厢 - 2010
VSB_CHERY_AIRUIZE7_1 = 41 # 奇瑞 - 艾瑞泽7 - 2014, 2013

VSB_KIA_OTHER = 0 # 其他（保留）
VSB_KIA_K2 = 1 # 起亚K2
VSB_KIA_K3 = 2 # 起亚K3
VSB_KIA_K5 = 3 # 起亚K5
VSB_KIA_RIO = 4 # 锐欧
VSB_KIA_CERATO = 5 # 赛拉图
VSB_KIA_SPORTAGER = 6 # 狮跑
VSB_KIA_SOUL = 7 # 秀尔
VSB_KIA_ZHIPAO = 8 # 智跑
VSB_KIA_CARENS = 9 # 佳乐
VSB_KIA_CARNIVAL = 10 # 嘉华
VSB_KIA_OPTIMA = 11 # 远舰
VSB_KIA_OPIRUS = 12 # 欧菲莱斯
VSB_KIA_MAXIMA = 13 # 千里马
VSB_KIA_FORTE = 14 # 福瑞迪
VSB_KIA_SORENTO = 15 # 索兰托
VSB_KIA_K2_1 = 16 # 起亚 - K2 - 2013, 2012, 2011
VSB_KIA_K3_1 = 17 # 起亚 - K3 - 2012
VSB_KIA_K5_1 = 18 # 起亚 - K5 - 2012, 2011
VSB_KIA_RUIOU_1 = 19 # 起亚 - RIO锐欧 - 2009, 2007
VSB_KIA_QIANLIMA_1 = 20 # 起亚 - 千里马 - 2004
VSB_KIA_QIANLIMA_2 = 21 # 起亚 - 千里马 - 2006, 2005
VSB_KIA_JIAHUA_1 = 22 # 起亚 - 嘉华 - 未知
VSB_KIA_XINJIALE_1 = 23 # 起亚 - 新佳乐 - 2011
VSB_KIA_ZHIPAO_1 = 24 # 起亚 - 智跑 - 2014, 2012, 2011, 2010
VSB_KIA_SHIPAO_1 = 25 # 起亚 - 狮跑 - 2008, 2007, 2005
VSB_KIA_SHIPAO_2 = 26 # 起亚 - 狮跑 - 2011, 2009
VSB_KIA_SHIPAO_3 = 27 # 起亚 - 狮跑 - 2012
VSB_KIA_SHIPAO_4 = 28 # 起亚 - 狮跑 - 2013
VSB_KIA_FURUIDI_1 = 29 # 起亚 - 福瑞迪 - 2012, 2011, 2009
VSB_KIA_FURUIDI_2 = 30 # 起亚 - 福瑞迪 - 2014
VSB_KIA_XIUER_1 = 31 # 起亚 - 秀尔 - 2012, 2010
VSB_KIA_SUOLANTUO_1 = 32 # 起亚 - 索兰托 - 2006
VSB_KIA_SUOLANTUO_2 = 33 # 起亚 - 索兰托 - 2012, 2010, 2009
VSB_KIA_SAILATU_1 = 34 # 起亚 - 赛拉图 - 2006, 2005
VSB_KIA_SAILATU_2 = 35 # 起亚 - 赛拉图 - 2007
VSB_KIA_SAILATU_3 = 36 # 起亚 - 赛拉图 - 2012, 2010 GLS
VSB_KIA_YUANJIAN_1 = 37 # 起亚 - 远舰 - 未知

VSB_BENZ_OTHER = 0 # 其他（保留）
VSB_BENZ_C = 1 # 奔驰C级
VSB_BENZ_E = 2 # 奔驰E级
VSB_BENZ_GLK = 3 # 奔驰GLK级
VSB_BENZ_WEITING = 4 # 威霆 - PINYIN
VSB_BENZ_SPRINTER = 5 # 凌特
VSB_BENZ_VIANO = 6 # 唯雅诺
VSB_BENZ_M = 7 # 奔驰M系
VSB_BENZ_CLK = 8 # 奔驰CLK系
VSB_BENZ_G = 9 # 奔驰G系
VSB_BENZ_GL = 10 # 奔驰GL系
VSB_BENZ_R = 11 # 奔驰R系
VSB_BENZ_S = 12 # 奔驰S系
VSB_BENZ_A = 13 # 奔驰A系
VSB_BENZ_SMART = 14 # 斯玛特(精灵)
VSB_BENZ_B = 15 # 奔驰B系
VSB_BENZ_SLK = 16 # 奔驰SLK系
VSB_BENZ_MB100 = 17 # 奔驰MB100
VSB_BENZ_VITO = 18 # 威特
VSB_BENZ_CLS = 19 # 奔驰CLS系
VSB_BENZ_SL = 20 # 奔驰SL系
VSB_BENZ_AJI_1 = 21 # 奔驰 - A级 - 2011, 2009
VSB_BENZ_AJI_2 = 22 # 奔驰 - A级 - 2013
VSB_BENZ_BJI_1 = 23 # 奔驰 - B级 - 2010, 2009
VSB_BENZ_CJI_1 = 24 # 奔驰 - C级 - 2010, 2008, 2007 时尚型
VSB_BENZ_CJI_2 = 25 # 奔驰 - C级 - 2013, 2011, CGI
VSB_BENZ_CJI_3 = 26 # 奔驰 - C级 - 2013, 2011 时尚型
VSB_BENZ_EJI_1 = 27 # 奔驰 - E级 - 2002
VSB_BENZ_EJI_2 = 28 # 奔驰 - E级 - 2007, 2006
VSB_BENZ_EJI_3 = 29 # 奔驰 - E级 - 2013, 2012, 2011, 2010, 2009
VSB_BENZ_EJI_4 = 30 # 奔驰 - E级 - 2013, 2012, 2011, 2010, 2009 时尚型
VSB_BENZ_GLKJI_1 = 31 # 奔驰 - GLK级 - 2012, 2011
VSB_BENZ_GLKJI_2 = 32 # 奔驰 - GLK级 - 2012, 2011 豪华型, 2008
VSB_BENZ_GLKJI_3 = 33 # 奔驰 - GLK级 - 2014, 2013
VSB_BENZ_GLJI_1 = 34 # 奔驰 - GL级 - 2011
VSB_BENZ_GLJI_2 = 35 # 奔驰 - GL级 - 2011 尊贵型, 2010
VSB_BENZ_GLJI_3 = 36 # 奔驰 - GL级 - 2012, 2010 北美版
VSB_BENZ_GJI_1 = 37 # 奔驰 - G级 - 2013, 2010, 2009
VSB_BENZ_MB100_1 = 38 # 奔驰 - MB100 - 2000
VSB_BENZ_MLJI_1 = 39 # 奔驰 - ML级 - 2006, 2005
VSB_BENZ_MLJI_2 = 40 # 奔驰 - ML级 - 2010, 2008
VSB_BENZ_MLJI_3 = 41 # 奔驰 - ML级 - 2014, 2012
VSB_BENZ_RJI_1 = 42 # 奔驰 - R级 - 2006
VSB_BENZ_RJI_2 = 43 # 奔驰 - R级 - 2007
VSB_BENZ_RJI_3 = 44 # 奔驰 - R级 - 2014, 2011, 2010, 2009
VSB_BENZ_SLKJI_2 = 45 # 奔驰 - SLK级 - 2006, 2004
VSB_BENZ_SLKJI_3 = 46 # 奔驰 - SLK级 - 2010, 2009
VSB_BENZ_SLKJI_1 = 47 # 奔驰 - SLK级 - 2011
VSB_BENZ_SJI_1 = 48 # 奔驰 - S级 - 2004
VSB_BENZ_SJI_2 = 49 # 奔驰 - S级 - 2009 _Hybrid, 2008, 2006
VSB_BENZ_SJI_3 = 50 # 奔驰 - S级 - 2009, 2008 商务型
VSB_BENZ_SJI_4 = 51 # 奔驰 - S级 - 2012, 2011, 2010
VSB_BENZ_LINGTE_1 = 52 # 奔驰 - 凌特 - 2013, 2012, 2011
VSB_BENZ_WEIYANUO_1 = 53 # 奔驰 - 唯雅诺 - 2010, 2006, 2004
VSB_BENZ_WEIYANUO_2 = 54 # 奔驰 - 唯雅诺 - 2014, 2013, 2012, 2011
VSB_BENZ_WEITING_1 = 55 # 奔驰 - 威霆 - 2013, 2011, 2010
VSB_BENZ_KECHE_1 = 56 # 奔驰 - 客车车型1 - A款

VSB_SKODA_OTHER = 0 # 其他（保留）
VSB_SKODA_HAORUI = 1 # 昊锐
VSB_SKODA_FABIA = 2 # 晶锐
VSB_SKODA_OCTAVIA = 3 # 明锐
VSB_SKODA_SUPERB = 4 # 速派
VSB_SKODA_SPACEBACK = 5 # 昕动
VSB_SKODA_RAPID = 6 # 昕锐
VSB_SKODA_YETI = 7 # 野帝
VSB_SKODA_HAORUI_1 = 8 # 斯柯达 - 昊锐 - 2013, 2012, 2010, 2009
VSB_SKODA_MINGRUI_1 = 9 # 斯柯达 - 明锐 - 2009, 2008, 2007
VSB_SKODA_MINGRUI_2 = 10 # 斯柯达 - 明锐 - 2014, 2013, 2012, 2011, 2010
VSB_SKODA_MINGRUI_3 = 11 # 斯柯达 - 明锐RS - 2010
VSB_SKODA_XINRUI_1 = 12 # 斯柯达 - 昕锐 - 2013 乐选型
VSB_SKODA_JINGRUI_1 = 13 # 斯柯达 - 晶锐 - 2011, 2009, 2008
VSB_SKODA_JINGRUI_2 = 14 # 斯柯达 - 晶锐 - 2014, 2013, 2012
VSB_SKODA_JINGRUI_3 = 15 # 斯柯达 - 晶锐 - 2014, 2013, 2012 Sport版
VSB_SKODA_SUPAI_1 = 16 # 斯柯达 - 速派 - 2013
VSB_SKODA_YEDI_1 = 17 # 斯柯达 - 野帝 - 2014, 2013

VSB_DONGFENG_OTHER = 0 # 其他（保留）
VSB_DONGFENG_JOYEARX5 = 1 # 景逸X5
VSB_DONGFENG_LINGZHI = 2 # 菱智
VSB_DONGFENG_JOYEARX3 = 3 # 景逸X3
VSB_DONGFENG_JOYEAR = 4 # 景逸
VSB_DONGFENG_FENGXINGCM7 = 5 # 风行CM7
VSB_DONGFENG_YUFENG = 6 # 御风
VSB_DONGFENG_FENGSHENA60 = 7 # 风神A60
VSB_DONGFENG_FENGSHENS30 = 8 # 风神S30
VSB_DONGFENG_FENGSHENH30CROSS = 9 # 风神H30 - CROSS
VSB_DONGFENG_PICKUP = 10 # 东风皮卡
VSB_DONGFENG_ZHONGXINGMIANBAOCHE = 11 # 东风中型面包车
VSB_DONGFENG_XIAOXINGMIANBAOCHE = 12 # 东风小型面包车
VSB_DONGFENG_ZHONGXINGVAN = 13 # 东风重型货车
VSB_DONGFENG_QINGXINGXIANGSHIVAN = 14 # 东风轻型厢式货车
VSB_DONGFENG_QINGZHONGXINGVAN = 15 # 东风轻中型普通货车
VSB_DONGFENG_FENGSHENMERCURY = 16 # 风神水星
VSB_DONGFENG_SUCCE = 17 # 帅客
VSB_DONGFENG_ODIN = 18 # 奥丁
VSB_DONGFENG_YUMSUN = 19 # 御轩
VSB_DONGFENG_RUIQI = 20 # 锐骐
VSB_DONGFENG_FENGGUANG = 21 # 风光
VBR_DONGFENG_C35_1 = 22 # 东风 - C35 - 2013
VBR_DONGFENG_K07_1 = 23 # 东风 - K07 - 2008
VBR_DONGFENG_K07_2 = 24 # 东风 - K07 - 2010, 2006
VBR_DONGFENG_V21_1 = 25 # 东风 - V21 - 2011
VBR_DONGFENG_JIALONG_1 = 26 # 东风 - 东风嘉龙 - 载货车
VBR_DONGFENG_XKFG_1 = 27 # 东风 - 东风小康风光 - 2013
VBR_DONGFENG_CV03_1 = 28 # 东风 - 俊风CV03 - 2012
VBR_DONGFENG_KAIPUTE_1 = 29 # 东风 - 凯普特 - C390
VBR_DONGFENG_DUOLIKA_1 = 30 # 东风 - 多利卡 - S2800
VBR_DONGFENG_DUOLIKA_2 = 31 # 东风 - 多利卡 - XL中卡
VBR_DONGFENG_DUOLIKA_3 = 32 # 东风 - 多利卡 - 中卡
VBR_DONGFENG_TIANJIN_1 = 33 # 东风 - 天锦 - 4 X2载货车
VBR_DONGFENG_TIANJIN_2 = 34 # 东风 - 天锦 - A款
VBR_DONGFENG_XBW_1 = 35 # 东风 - 小霸王 - 轻卡1
VBR_DONGFENG_XBW_2 = 36 # 东风 - 小霸王 - 轻卡2
VBR_DONGFENG_MENGKA_1 = 37 # 东风 - 梦卡 - 轻卡
VBR_DONGFENG_FURUIKA_1 = 38 # 东风 - 福瑞卡 - 轻卡1
VBR_DONGFENG_RUIQI_1 = 39 # 东风 - 锐骐皮卡 - 2013, 2010, 2009
VBR_DONGFENG_A60_1 = 40 # 东风风神 - A60 - 2014, 2012
VBR_DONGFENG_H30_1 = 41 # 东风风神 - H30 - Cross - 2012, 2011
VBR_DONGFENG_H30_2 = 42 # 东风风神 - H30 - Cross - 2014, 2013
VBR_DONGFENG_H30_3 = 43 # 东风风神 - H30 - 2012
VBR_DONGFENG_JINGYI_1 = 44 # 东风风行 - 景逸 - 2014_2012L V, 2011 豪华型
VBR_DONGFENG_JINGYI_2 = 45 # 东风风行 - 景逸 - 2014_2012 XL, 2011, 2010, 2009, 2008, 2007
VBR_DONGFENG_JINGYI_3 = 46 # 东风风行 - 景逸X5 - 2014, 2013
VBR_DONGFENG_LINGZHI_1 = 47 # 东风风行 - 菱智 - 2004
VBR_DONGFENG_LINGZHI_2 = 48 # 东风风行 - 菱智 - 2011, 2008, 2007
VBR_DONGFENG_LINGZHI_3 = 49 # 东风风行 - 菱智 - 2011 Q3标准型, 2010 Q7
VBR_DONGFENG_LINGZHI_4 = 50 # 东风风行 - 菱智 - 2014_2013 M3
VBR_DONGFENG_LINGZHI_5 = 51 # 东风风行 - 菱智 - 2014_2013 V3, 2011 M3_商用版_舒适型

VSB_BYD_OTHER = 0 # 其他（保留）
VSB_BYD_F0 = 1 # 比亚迪F0
VSB_BYD_F3 = 2 # 比亚迪F3
VSB_BYD_F3R = 3 # 比亚迪F3R
VSB_BYD_F6 = 4 # 比亚迪F6
VSB_BYD_G3 = 5 # 比亚迪G3
VSB_BYD_G3R = 6 # 比亚迪G3R
VSB_BYD_G6 = 7 # 比亚迪G6
VSB_BYD_L3 = 8 # 比亚迪L3
VSB_BYD_M6 = 9 # 比亚迪M6
VSB_BYD_S6 = 10 # 比亚迪S6
VSB_BYD_SURUI = 11 # 速锐
VSB_BYD_FOLEL = 12 # 秦川福莱尔
VSB_BYD_SIRUI = 13 # 思锐
VSB_BYD_MT5 = 14 # 比亚迪MT5(精灵)
VSB_BYD_F0_1 = 15 # 比亚迪 - F0 - 2013, 2012, 2011, 2010, 2009, 2008
VSB_BYD_F3R_1 = 16 # 比亚迪 - F3R - 2011, 2009, 2008, 2007
VSB_BYD_F6_1 = 17 # 比亚迪 - F6 - 2011, 2009, 2008
VSB_BYD_G3R_1 = 18 # 比亚迪 - G3R - 2011
VSB_BYD_G6_1 = 19 # 比亚迪 - G6 - 2013, 2012, 2011
VSB_BYD_L3_1 = 20 # 比亚迪 - L3 - 2013, 2012, 2011, 2010
VSB_BYD_M6_1 = 21 # 比亚迪 - M6 - 2013, 2011, 2010
VSB_BYD_S6_1 = 22 # 比亚迪 - S6 - 2014, 2013, 2012, 2011
VSB_BYD_FULAIER_1 = 23 # 比亚迪 - 福莱尔 - 2005 豪华型
VSB_BYD_SURUI_1 = 24 # 比亚迪 - 速锐 - 2014, 2013, 2012

VSB_SUZUKI_OTHER = 0 # 其他（保留）
VSB_SUZUKI_ALTO = 1 # 长安奥拓
VSB_SUZUKI_SCROSS = 2 # 锋驭
VSB_SUZUKI_SWIFT = 3 # 雨燕
VSB_SUZUKI_SX4 = 4 # 天语
VSB_SUZUKI_LINGYANG = 5 # 羚羊
VSB_SUZUKI_BEIDOUXING = 6 # 北斗星
VSB_SUZUKI_LIANAA6 = 7 # 利亚纳 - A6
VSB_SUZUKI_LANDY = 8 # 浪迪
VSB_SUZUKI_SPLASH = 9 # 派喜
VSB_SUZUKI_GRANDVITARA = 10 # 超级维特拉
VSB_SUZUKI_JIMNY = 11 # 吉姆尼
VSB_SUZUKI_KAZASHI = 12 # 凯泽西
VSB_SUZUKI_LIANA = 13 # 利亚纳
VSB_SUZUKI_LIANA_1 = 14 # 铃木 - 利亚纳三厢 - 2012, 2011, 2010, 2008, 2007, 2005
VSB_SUZUKI_LIANA_2 = 15 # 铃木 - 利亚纳两厢 - 2013, 2012, 2011
VSB_SUZUKI_BEIDOUXING_1 = 16 # 铃木 - 北斗星 - 2012, 2011, 2010, 2009, 2008, 2007, 2005, 2004 标准型
VSB_SUZUKI_BEIDOUXING_2 = 17 # 铃木 - 北斗星 - 2013, 2012, 2011, 2010, 2009, 2008, 2007, 2005, 2004, 2003
VSB_SUZUKI_BEIDOUXING_3 = 18 # 铃木 - 北斗星 - 2013, 2012, 2011, 2010, 2009, 2008, 2007, 2005, 2004, 2003 适用型
VSB_SUZUKI_BEIDOUXING_4 = 19 # 铃木 - 北斗星 - 2013 X5
VSB_SUZUKI_JIMUNI_1 = 20 # 铃木 - 吉姆尼 - 2011, 2010, 2009, 2007
VSB_SUZUKI_JIMUNI_2 = 21 # 铃木 - 吉姆尼 - 2012
VSB_SUZUKI_SX4_1 = 22 # 铃木 - 天语SX4三厢 - 2008, 2006
VSB_SUZUKI_SX4_2 = 23 # 铃木 - 天语SX4三厢 - 2010, 2009
VSB_SUZUKI_SX4_3 = 24 # 铃木 - 天语SX4两厢 - 2011 A, 2009, 2008, 2007
VSB_SUZUKI_SX4_4 = 25 # 铃木 - 天语SX4两厢 - 2011 B
VSB_SUZUKI_SX4_5 = 26 # 铃木 - 天语SX4尚悦 - 2013, 2012, 2011
VSB_SUZUKI_ALTO_1 = 27 # 铃木 - 奥拓 - 2006, 2001, 2000, 1999, 1993 标准型
VSB_SUZUKI_ALTO_2 = 28 # 铃木 - 奥拓 - 2006, 2004, 2001, 2000, 1999, 1993
VSB_SUZUKI_ALTO_3 = 29 # 铃木 - 奥拓 - 2013
VSB_SUZUKI_ALTO_4 = 30 # 铃木 - 奥拓 - 2014, 2012, 2011, 2010, 2009
VSB_SUZUKI_SPLASH_1 = 31 # 铃木 - 派喜 - 2013, 2012, 2011
VSB_SUZUKI_LANDY_1 = 32 # 铃木 - 浪迪 - 2011, 2010, 2007
VSB_SUZUKI_LINGYANG_2 = 33 # 铃木 - 羚羊 - 2006, 2004, 2003
VSB_SUZUKI_LINGYANG_3 = 34 # 铃木 - 羚羊 - 2009, 2008, 2007
VSB_SUZUKI_LINGYANG_4 = 35 # 铃木 - 羚羊 - 2011
VSB_SUZUKI_LINGYANG_5 = 36 # 铃木 - 羚羊 - 2012
VSB_SUZUKI_GRANDVITARA_1 = 37 # 铃木 - 超级维特拉 - 2011, 2008, 2007, 2006
VSB_SUZUKI_FENGYU_1 = 38 # 铃木 - 锋驭 - 2014
VSB_SUZUKI_SWIFT_1 = 39 # 铃木 - 雨燕 - 2011_1.3 L, 2009, 2008, 2007, 2005
VSB_SUZUKI_SWIFT_2 = 40 # 铃木 - 雨燕 - 2012, 2011
VSB_SUZUKI_KINGCHANG_1 = 41 # 铃木 - 昌铃王 - 2004
VSB_SUZUKI_LINGYANG_1 = 42 # 铃木 - 羚羊 - 2002

VSB_SGMW_OTHER = 0 # 其他（保留）
VSB_SGMW_HONGGUANG = 1 # 五菱宏光
VSB_SGMW_HONGGUANGS = 2 # 五菱宏光S
VSB_SGMW_ZHIGUANG = 3 # 五菱之光
VSB_SGMW_RONGGUANGS = 4 # 五菱荣光S
VSB_SGMW_RONGGUANG = 5 # 五菱荣光
VSB_SGMW_HONGTU = 6 # 五菱鸿途
VSB_SGMW_XINGWANG = 7 # 五菱兴旺
VSB_SGMW_YANGGUANG = 8 # 五菱扬光
VSB_SGMW_XIAOXUANFENG = 9 # 五菱小旋风
VSB_SGMW_WULINGZHIGUANG_1 = 10 # 五菱 - 五菱之光 - 2010, 2009 立业
VSB_SGMW_WULINGZHIGUANG_2 = 11 # 五菱 - 五菱之光 - 2010 短车身, 基本型
VSB_SGMW_WULINGZHIGUANG_3 = 12 # 五菱 - 五菱之光 - 2010 长车身, 2008 厢式, 2007
VSB_SGMW_XINGWANG_1 = 13 # 五菱 - 兴旺面包车 - 2003
VSB_SGMW_XINGWANG_2 = 14 # 五菱 - 兴旺面包车 - 2009 标准
VSB_SGMW_XINGWANG_3 = 15 # 五菱 - 兴旺面包车 - 2010, 2009, 2007, 2006, 2005, 2004
VSB_SGMW_HONNGUANG_1 = 16 # 五菱 - 宏光 - 2013, 2010
VSB_SGMW_HONNGUANG_2 = 17 # 五菱 - 宏光 - 2014, 2013 S
VSB_SGMW_XIAOXUANFENG_1 = 18 # 五菱 - 小旋风 - 2006
VSB_SGMW_YANGGUANG_1 = 19 # 五菱 - 扬光 - 2006, 2005, 2004
VSB_SGMW_YANGGUANG_2 = 20 # 五菱 - 扬光 - 2008, 2007
VSB_SGMW_YANGGUANG_3 = 21 # 五菱 - 扬光 - 2009, 2006, 2005 手动标准型
VSB_SGMW_RONGGUANG_1 = 22 # 五菱 - 荣光面包车 - 2012, 2011, 2008 基本
VSB_SGMW_RONGGUANG_2 = 23 # 五菱 - 荣光面包车 - 2012, 2011, 2008 标准
VSB_SGMW_HONGTU_1 = 24 # 五菱 - 鸿途 - 2010, 2009, 2008, 2007

VSB_CHANA_OTHER = 0 # 其他（保留）
VSB_CHANA_HONOR = 1 # 欧诺
VSB_CHANA_XINGKA = 2 # 长安星卡
VSB_CHANA_ZHIXING = 3 # 长安之星
VSB_CHANA_PICKUP = 4 # 长安神骐小卡(长安皮卡)
VSB_CHANA_ZHIXING2 = 5 # 长安之星2代
VSB_CHANA_TAURUS = 6 # 金牛星
VSB_CHANA_XINGGUANG = 7 # 长安星光
VSB_CHANA_BENNI = 8 # 奔奔
VSB_CHANA_ALSVIN = 9 # 悦翔
VSB_CHANA_CX20 = 10 # 长安CX20
VSB_CHANA_CX30 = 11 # 长安CX30
VSB_CHANA_EADO = 12 # 逸动
VSB_CHANA_ZHIXINGS460 = 13 # 长安之星S460
VSB_CHANA_CM8 = 14 # 长安CM8
VSB_CHANA_XINBAO = 15 # 新豹
VSB_CHANA_XUNLONG = 16 # 勋龙
VSB_CHANA_YUNTONG = 17 # 运通
VSB_CHANA_LEIMENG = 18 # 镭蒙
VSB_CHANA_XINGYUN = 19 # 长安星韵
VSB_CHANA_OULIWEI = 20 # 欧力威
VSB_CHANA_EADOXT = 21 # 致尚XT
VSB_CHANA_XINGYUN_1 = 22 # 长安商用 - 星韵 - 2004, 2003, 2000
VSB_CHANA_OULIWEI_1 = 23 # 长安商用 - 欧力威 - 2013
VSB_CHANA_YUNTONG_1 = 24 # 长安商用 - 运通 - 2004
VSB_CHANA_TAURUS_1 = 25 # 长安商用 - 金牛星 - 2013, 2012, 2011, 2010
VSB_CHANA_LEIMENG_1 = 26 # 长安商用 - 镭蒙 - 2005, 2003
VSB_CHANA_ZHIXING_1 = 27 # 长安商用 - 长安之星 - 2010, 2009
VSB_CHANA_ZHIXING_2 = 28 # 长安商用 - 长安之星 - 2013
VSB_CHANA_ZHIXING_3 = 29 # 长安商用 - 长安之星2 - 2009, 2008
VSB_CHANA_ZHIXING_4 = 30 # 长安商用 - 长安之星2 - 2012
VSB_CHANA_ZHIXING_5 = 31 # 长安商用 - 长安之星S460 - 2010, 2009
VSB_CHANA_ZHIXING_6 = 32 # 长安商用 - 长安之星SC6350 - 2003
VSB_CHANA_PICKUP_1 = 33 # 长安商用 - 长安微货神骐 - 2013, 2012
VSB_CHANA_XINGGUANG_1 = 34 # 长安商用 - 长安星光4500 - 2009, 2007
VSB_CHANA_XINGGUANG_2 = 35 # 长安商用 - 长安星光4500 - 2012
VSB_CHANA_HONOR_1 = 36 # 长安商用 - 长安欧诺 - 2014, 2012

VSB_EADO_OTHER = 0 # 其他（保留）
VSB_EADO_CS_1 = 1 # 长安轿车 - CS35 - 2014, 2013, 2012
VSB_EADO_CX_1 = 2 # 长安轿车 - CX20 - 2011
VSB_EADO_CX_2 = 3 # 长安轿车 - CX30两厢 - 2010
VSB_EADO_BENBEN_1 = 4 # 长安轿车 - 奔奔 - 2008, 2007, 2006
VSB_EADO_BENBEN_2 = 5 # 长安轿车 - 奔奔 - 2008 经典型, 2007 运动型
VSB_EADO_BENBEN_3 = 6 # 长安轿车 - 奔奔 - 2010
VSB_EADO_BENBEN_4 = 7 # 长安轿车 - 奔奔MINI - 2011, 2010
VSB_EADO_BENBEN_5 = 8 # 长安轿车 - 奔奔MINI - 2012
VSB_EADO_YUEXIANG_1 = 9 # 长安轿车 - 悦翔 - 2011, 2010, 2009
VSB_EADO_YUEXIANG_2 = 10 # 长安轿车 - 悦翔 - 2012
VSB_EADO_YUEXIANG_3 = 11 # 长安轿车 - 悦翔V3 - 2013, 2012
VSB_EADO_YUEXIANG_4 = 12 # 长安轿车 - 悦翔V5 - 2012
VSB_EADO_YIDONG_1 = 13 # 长安轿车 - 逸动 - 2014, 2013, 2012

VSB_JINBEI_OTHER = 0 # 其他（保留）
VSB_JINBEI_GRACE = 1 # 金杯阁瑞斯
VSB_JINBEI_HIACE = 2 # 金杯海狮
VSB_JINBEI_HAIXING = 3 # 海星
VSB_JINBEI_BADAO = 4 # 金杯霸道
VSB_JINBEI_LINGQI = 5 # 领骐
VSB_JINBEI_JINQI = 6 # 金骐
VSB_JINBEI_LINGCHI = 7 # 领驰
VSB_JINBEI_QIYUN = 8 # 骐运
VSB_JINBEI_ZHISHANG_1 = 9 # 金杯 - 智尚S30 - 2014, 2013, 2012
VSB_JINBEI_HAIXING_1 = 10 # 金杯 - 海星 - 2012
VSB_JINBEI_HAIXING_2 = 11 # 金杯 - 海星 - 2012 A7特惠型, 2011
VSB_JINBEI_HIACE_1 = 12 # 金杯 - 海狮 - 2008
VSB_JINBEI_HIACE_2 = 13 # 金杯 - 海狮 - 2013, 2011, 2010
VSB_JINBEI_HIACE_3 = 14 # 金杯 - 海狮 - 2013 豪华型, 2011 汽油, 2008 标准型
VSB_JINBEI_JINDIAN_1 = 15 # 金杯 - 金典 - 2009
VSB_JINBEI_GRACE_1 = 16 # 金杯 - 阁瑞斯MPV - 2011, 2008, 2007
VSB_JINBEI_GRACE_2 = 17 # 金杯 - 阁瑞斯MPV - 2011 御领豪华型, 2010, 2009, 2007 标准9座
VSB_JINBEI_BADAO_1 = 18 # 金杯 - 霸道SUV - 2011, 2008

VSB_GEELY_OTHER = 0 # 其他（保留）
VSB_GEELY_EC7 = 1 # 吉利帝豪EC7
VSB_GEELY_EC8 = 2 # 吉利帝豪EC8
VSB_GEELY_SC3 = 3 # 吉利SC3
VSB_GEELY_SC5RV = 4 # 吉利SC5 - RV
VSB_GEELY_SC6 = 5 # 吉利SC6
VSB_GEELY_JINGYING = 6 # 金鹰
VSB_GEELY_JINGGANG = 7 # 金刚
VSB_GEELY_SX7 = 8 # 吉利SX7
VSB_GEELY_HAOQING = 9 # 豪情
VSB_GEELY_MEIRI = 10 # 美日
VSB_GEELY_YINGLUNSC7 = 11 # 英伦SC7
VSB_GEELY_PANDA = 12 # 熊猫
VSB_GEELY_YUANJING = 13 # 远景
VSB_GEELY_ZIYOUJIAN = 14 # 自由舰

VSB_MITSUBISHI_OTHER = 0 # 其他（保留）
VSB_MITSUBISHI_GALANT = 1 # 戈蓝
VSB_MITSUBISHI_ZINGER = 2 # 君阁
VSB_MITSUBISHI_LANCER = 3 # 蓝瑟
VSB_MITSUBISHI_LANCEREX = 4 # 翼神
VSB_MITSUBISHI_PAJERO = 5 # 帕杰罗
VSB_MITSUBISHI_PAJEROSPORT = 6 # 帕杰罗 - 劲畅
VSB_MITSUBISHI_JINGXUANASX = 7 # 劲炫ASX
VSB_MITSUBISHI_GRANDIS = 8 # 三菱格蓝迪
VSB_MITSUBISHI_OUTLANDER = 9 # 欧蓝德
VSB_MITSUBISHI_QINXINGYUEYE = 10 # 三菱轻型越野
VSB_MITSUBISHI_GTO = 11 # 三菱GTO
VSB_MITSUBISHI_SOVERAN = 12 # 三菱菱绅
VSB_MITSUBISHI_LIONVEL = 13 # 三菱菱悦
VSB_MITSUBISHI_HAFEISIMBO = 14 # 哈飞赛马
VSB_MITSUBISHI_LANCEREX_1 = 15 # 三菱 - 三菱翼神 - 2012, 2011, 2010
VSB_MITSUBISHI_JINGXUAN_1 = 16 # 三菱 - 劲炫 - 2012, 2011
VSB_MITSUBISHI_ZINGER_1 = 17 # 三菱 - 君阁 - 2011, 2009
VSB_MITSUBISHI_PAJERO_1 = 18 # 三菱 - 帕杰罗 - 2004 国产
VSB_MITSUBISHI_PAJERO_2 = 19 # 三菱 - 帕杰罗 - 2004 进口
VSB_MITSUBISHI_PAJERO_3 = 20 # 三菱 - 帕杰罗 - 2010 进口
VSB_MITSUBISHI_PAJEROSPORT_1 = 21 # 三菱 - 帕杰罗劲畅 - 2011
VSB_MITSUBISHI_GALANT_1 = 22 # 三菱 - 戈蓝 - 2009
VSB_MITSUBISHI_GALANDI_1 = 23 # 三菱 - 格蓝迪 - 2007
VSB_MITSUBISHI_GALANDI_2 = 24 # 三菱 - 格蓝迪 - 2010
VSB_MITSUBISHI_OUTLANDER_1 = 25 # 三菱 - 欧蓝德 - 2012, 2011, 2010
VSB_MITSUBISHI_OUTLANDER_2 = 26 # 三菱 - 欧蓝德 - 2013
VSB_MITSUBISHI_LINGYUE_1 = 27 # 三菱 - 菱悦 - 未知
VSB_MITSUBISHI_LANCER_1 = 28 # 三菱 - 蓝瑟 - 2010

VSB_LEXUS_OTHER = 0 # 其他（保留）
VSB_LEXUS_ES = 1 # 雷克萨斯ES
VSB_LEXUS_CT = 2 # 雷克萨斯CT
VSB_LEXUS_RX = 3 # 雷克萨斯RX
VSB_LEXUS_IS = 4 # 雷克萨斯IS
VSB_LEXUS_LX = 5 # 雷克萨斯LX
VSB_LEXUS_GS = 6 # 雷克萨斯GS
VSB_LEXUS_GX = 7 # 雷克萨斯GX
VSB_LEXUS_LS = 8 # 雷克萨斯LS
VSB_LEXUS_CT_1 = 9 # 雷克萨斯 - CT - 2013, 2012, 2011
VSB_LEXUS_ES_1 = 10 # 雷克萨斯 - ES - 1994
VSB_LEXUS_ES_2 = 11 # 雷克萨斯 - ES - 2010, 2009, 2006
VSB_LEXUS_ES_3 = 12 # 雷克萨斯 - ES - 2013, 2012
VSB_LEXUS_GS_1 = 13 # 雷克萨斯 - GS - 2011, 2010, 2009, 2008, 2005
VSB_LEXUS_GX_1 = 14 # 雷克萨斯 - GX - 2012, 2010
VSB_LEXUS_IS_1 = 15 # 雷克萨斯 - IS - 2011
VSB_LEXUS_LS_1 = 16 # 雷克萨斯 - LS - 1994
VSB_LEXUS_LS_2 = 17 # 雷克萨斯 - LS - 2005, 2004
VSB_LEXUS_LS_3 = 18 # 雷克萨斯 - LS - 2009, 2007, 2006
VSB_LEXUS_LX_1 = 19 # 雷克萨斯 - LX - 2013, 2012
VSB_LEXUS_RX_1 = 20 # 雷克萨斯 - RX - 2011, 2010, 2009
VSB_LEXUS_RX_2 = 21 # 雷克萨斯 - RX - 2013, 2012
VSB_LEXUS_RX_3 = 22 # 雷克萨斯 - RX - 2007

VSB_ROEWE_OTHER = 0 # 其他（保留）
VSB_ROEWE_350 = 1 # 荣威350
VSB_ROEWE_550 = 2 # 荣威550
VSB_ROEWE_W5 = 3 # 荣威W5
VSB_ROEWE_950 = 4 # 荣威950
VSB_ROEWE_750 = 5 # 荣威750
VSB_ROEWE_350_1 = 6 # 荣威 - 350 - 2011 迅智版, 2010
VSB_ROEWE_350_2 = 7 # 荣威 - 350 - 2014, 2013, 2012, 2011
VSB_ROEWE_550_1 = 8 # 荣威 - 550 - 2012, 2010, 2009, 2008
VSB_ROEWE_750_1 = 9 # 荣威 - 750 - 2009, 2008, 2007, 2006
VSB_ROEWE_750_2 = 10 # 荣威 - 750 - 2012, 2011
VSB_ROEWE_950_1 = 11 # 荣威 - 950 - 2012

VSB_HAIMA_OTHER = 0 # 其他（保留）
VSB_HAIMA_PREMARIN = 1 # 普力马
VSB_HAIMA_S7 = 2 # 海马S7
VSB_HAIMA_PRINCE = 3 # 海马王子
VSB_HAIMA_CUPID = 4 # 海马2 - 丘比特
VSB_HAIMA_HATCHBACK = 5 # 海马3 - 欢动
VSB_HAIMA_KNIGHT = 6 # 骑士
VSB_HAIMA_HAPPIN = 7 # 海福星
VSB_HAIMA_FAMILY = 8 # 福美来
VSB_HAIMA_M3 = 9 # 海马M3
VSB_HAIMA_CUPID_1 = 10 # 海马 - 丘比特 - 2012, 2011, 2010
VSB_HAIMA_PREMARIN_1 = 11 # 海马 - 普力马 - 2007
VSB_HAIMA_PREMARIN_2 = 12 # 海马 - 普力马 - 2012, 2010
VSB_HAIMA_HATCHBACK_1 = 13 # 海马 - 欢动 - 2010, 2009
VSB_HAIMA_HAPPIN_1 = 14 # 海马 - 海福星 - 2010, 2009, 2008, 2007, 2004
VSB_HAIMA_HAPPIN_2 = 15 # 海马 - 海福星 - 2012, 2011
VSB_HAIMA_M3_1 = 16 # 海马 - 海马3 - 2010, 2008, 2007
VSB_HAIMA_FAMILY_1 = 17 # 海马 - 福美来 - 2007, 2006
VSB_HAIMA_FAMILY_2 = 18 # 海马 - 福美来 - 2010, 2009, 2008
VSB_HAIMA_FAMILY_3 = 19 # 海马 - 福美来 - 2011
VSB_HAIMA_FAMILY_4 = 20 # 海马 - 福美来 - 2014, 2013, 2012
VSB_HAIMA_KNIGHT_1 = 21 # 海马 - 骑士 - 2013_2012 A, 2011, 2010
VSB_HAIMA_KNIGHT_2 = 22 # 海马 - 骑士 - 2013_2012 B
VSB_HAIMA_NEWHONGDA_1 = 23 # 海马商用车 - 新鸿达 - 2009
VSB_HAIMA_NEWHONDGA_2 = 24 # 海马商用车 - 新鸿达 - 2012
VSB_HAIMA_PRINCE_1 = 25 # 海马商用车 - 海马王子 - 2010
VSB_HAIMA_RONGDA_1 = 26 # 海马商用车 - 荣达 - 2012

VSB_GREATWALL_OTHER = 0 # 其他（保留）
VSB_GREATWALL_SING = 1 # 赛影
VSB_GREATWALL_SAIJUN = 2 # 赛骏
VSB_GREATWALL_HAVAL = 3 # 哈弗
VSB_GREATWALL_SAFE = 4 # 赛弗
VSB_GREATWALL_SAIKU = 5 # 赛酷
VSB_GREATWALL_SAILING = 6 # 赛铃
VSB_GREATWALL_KINGDEER = 7 # 金迪尔
VSB_GREATWALL_DEER = 8 # 迪尔
VSB_GREATWALL_WINGLE = 9 # 风骏
VSB_GREATWALL_COOLBEAR = 10 # 酷熊
VSB_GREATWALL_LINGAO = 11 # 凌傲
VSB_GREATWALL_CROSS = 12 # 炫丽
VSB_GREATWALL_GWPERI = 13 # 精灵
VSB_GREATWALL_COWRY = 14 # 腾翼
VSB_GREATWALL_M4 = 15 # 长城M4
VSB_GREATWALL_LINGAO_1 = 16 # 长城 - 凌傲 - 2010
VSB_GREATWALL_HAVAL_1 = 17 # 长城 - 哈弗H3 - 2010, 2009
VSB_GREATWALL_HAVAL_2 = 18 # 长城 - 哈弗H3 - 2012, 2010, 2009 锐意版
VSB_GREATWALL_HAVAL_3 = 19 # 长城 - 哈弗H5 - 2012, 2011, 2010
VSB_GREATWALL_HAVAL_4 = 20 # 长城 - 哈弗H5 - 2012, 2011, 2010 绿静豪华型
VSB_GREATWALL_HAVAL_5 = 21 # 长城 - 哈弗H5 - 2012 舒适型
VSB_GREATWALL_HAVAL_6 = 22 # 长城 - 哈弗H5 - 2014, 2013
VSB_GREATWALL_HAVAL_8 = 23 # 长城 - 哈弗H6 - 2014, 2013 升级版
VSB_GREATWALL_HAVAL_9 = 24 # 长城 - 哈弗M2 - 2010
VSB_GREATWALL_HAVAL_10 = 25 # 长城 - 哈弗M2 - 2013, 2012
VSB_GREATWALL_HAVAL_11 = 26 # 长城 - 哈弗M4 - 2012
VSB_GREATWALL_HAVAL_12 = 27 # 长城 - 哈弗派 - 2011
VSB_GREATWALL_CROSS_1 = 28 # 长城 - 炫丽 - 2009, 2008
VSB_GREATWALL_CROSS_2 = 29 # 长城 - 炫丽CROSS - 2011, 2009
VSB_GREATWALL_JINGLING_1 = 30 # 长城 - 精灵 - 未知
VSB_GREATWALL_SING_1 = 31 # 长城 - 赛影 - 2003
VSB_GREATWALL_SAIKU_1 = 32 # 长城 - 赛酷 - 2004
VSB_GREATWALL_SAILING_1 = 33 # 长城 - 赛铃 - 未知
VSB_GREATWALL_DIER_1 = 34 # 长城 - 迪尔 - 未知
VSB_GREATWALL_COOLBEAR_1 = 35 # 长城 - 酷熊 - 2010, 2009
VSB_GREATWALL_KINGDEER_1 = 36 # 长城 - 金迪尔 - 2008, 2007, 2004, 2003
VSB_GREATWALL_GREATWALL_1 = 37 # 长城 - 长城C20R - 2013, 2011
VSB_GREATWALL_GREATWALL_2 = 38 # 长城 - 长城C30 - 2010
VSB_GREATWALL_GREATWALL_3 = 39 # 长城 - 长城C30 - 2012
VSB_GREATWALL_GREATWALL_4 = 40 # 长城 - 长城C30 - 2013
VSB_GREATWALL_GREATWALL_5 = 41 # 长城 - 长城C50 - 2013, 2012
VSB_GREATWALL_GREATWALL_6 = 42 # 长城 - 长城V80 - 2013, 2012, 2010, 2009, 2008
VSB_GREATWALL_WINGLE_1 = 43 # 长城 - 风骏3 - 2011, 2010, 2007, 2006
VSB_GREATWALL_WINGLE_2 = 44 # 长城 - 风骏5 - 2014, 2012, 2011, 2009
VSB_GREATWALL_HAVAL_7 = 45 # 长城 - 哈弗H6 - 2013, 2012, 2011

VSB_DS_OTHER = 0 # 其他（保留）
VSB_DS_KUBO_1 = 1 # 道奇 - 酷搏 - 2011, 2010, 2009, 2008
VSB_DS_KUWEI_1 = 2 # 道奇 - 酷威 - 2011, 2010, 2009
VSB_DS_KUWEI_2 = 3 # 道奇 - 酷威 - 2013

VSB_LANDROVER_OTHER = 0 # 其他（保留）
VSB_LANDROVER_FAXIAN_1 = 1 # 路虎 - 发现 - 2005, 2004
VSB_LANDROVER_FAXIAN_2 = 2 # 路虎 - 发现 - 2013, 2011, 2010
VSB_LANDROVER_LANSHENG_1 = 3 # 路虎 - 揽胜 - 2012, 2011, 2010
VSB_LANDROVER_LANSHENG_2 = 4 # 路虎 - 揽胜极光 - 2014, 2013, 2012, 2011
VSB_LANDROVER_LANSHENG_3 = 5 # 路虎 - 揽胜运动版 - 2013, 2012, 2011, 2010
VSB_LANDROVER_LANSHENG_4 = 6 # 路虎 - 揽胜运动版 - 2013 驭红限量版
VSB_LANDROVER_SXZ_1 = 7 # 路虎 - 神行者2代 - 2014, 2013, 2011

VSB_MG_OTHER = 0 # 其他（保留）
VSB_MG_3SW_1 = 1 # MG - MG - 3 SW - 2009, 2008
VSB_MG_MG3_1 = 2 # MG - MG3 - 2013, 2012, 2011
VSB_MG_MG5_1 = 3 # MG - MG5 - 2014, 2013, 2012
VSB_MG_MG6_1 = 4 # MG - MG6三厢 - 2012, 2011
VSB_MG_MG7_1 = 5 # MG - MG7 - 2010, 2009, 2008, 2007

VSB_FAW_OTHER = 0 # 其他（保留）
VSB_FAW_501_1 = 1 # 一汽 - 501 - 轻卡
VSB_FAW_N3_1 = 2 # 一汽 - N3 + 两厢 - 2006
VSB_FAW_N3_2 = 3 # 一汽 - N3 + 两厢 - 2008
VSB_FAW_JIABAO_1 = 4 # 一汽 - 佳宝货车 - 2011 T50, T57
VSB_FAW_JIABAO_2 = 5 # 一汽 - 佳宝面包车 - 2000
VSB_FAW_JIABAO_3 = 6 # 一汽 - 佳宝面包车 - 2006
VSB_FAW_JIABAO_4 = 7 # 一汽 - 佳宝面包车 - 2012, 2011 V50舒适版
VSB_FAW_JIABAO_5 = 8 # 一汽 - 佳宝面包车 - 2012, 2011 V70
VSB_FAW_JIABAO_6 = 9 # 一汽 - 佳宝面包车 - 2013, 2012, 2011 V52实用型
VSB_FAW_JIABAO_7 = 10 # 一汽 - 佳宝面包车 - 2014, 2013 V80
VSB_FAW_XIALI_1 = 11 # 一汽 - 夏利 - 1999, 1997
VSB_FAW_XIALI_2 = 12 # 一汽 - 夏利2000 - 2003, 2002
VSB_FAW_XIALI_3 = 13 # 一汽 - 夏利A + -2011, 2010, 2006, 2005
VSB_FAW_XIALI_4 = 14 # 一汽 - 夏利N3 - 2012
VSB_FAW_XIALI_5 = 15 # 一汽 - 夏利N5 - 2014, 2013, 2011, 2010, 2009
VSB_FAW_XIALI_6 = 16 # 一汽 - 夏利N7 - 2013
VSB_FAW_AOWEI_1 = 17 # 一汽 - 奥威J5P - 2005, 2004, 2003
VSB_FAW_AOWEI_2 = 18 # 一汽 - 奥威J5P - 4 X2复合型牵引车, 自卸车
VSB_FAW_AOWEI_3 = 19 # 一汽 - 奥威J5P - 4 X2牵引车, 卸货车
VSB_FAW_AOWEI_4 = 20 # 一汽 - 奥威J5P - 6 X6越野自卸车
VSB_FAW_AOXING_1 = 21 # 一汽 - 奥星 - 2004
VSB_FAW_WEILE_1 = 22 # 一汽 - 威乐 - 2004
VSB_FAW_WEILE_2 = 23 # 一汽 - 威乐 - 2008, 2007
VSB_FAW_WEIZI_1 = 24 # 一汽 - 威姿 - 2004
VSB_FAW_WEIZHI_1 = 25 # 一汽 - 威志V2 - 2012 手动CROSS
VSB_FAW_WEIZHI_2 = 26 # 一汽 - 威志V2 - 2012 自动CROSS, 2010
VSB_FAW_WEIZHI_3 = 27 # 一汽 - 威志V5 - 2013, 2012
VSB_FAW_WEIZHI_4 = 28 # 一汽 - 威志三厢 - 2009, 2008, 2007
VSB_FAW_WEIZHI_5 = 29 # 一汽 - 威志三厢 - 2011
VSB_FAW_XIAOJIEFANG_1 = 30 # 一汽 - 小解放 - 90, 109 马力轻卡
VSB_FAW_HANWEI_1 = 31 # 一汽 - 悍威J5M - 4 X4载货车
VSB_FAW_HANWEI_2 = 32 # 一汽 - 悍威J5M - 6 X6牵引车, 6 X4自卸车
VSB_FAW_HANWEI_3 = 33 # 一汽 - 悍威J5M - 8 X8自卸车
VSB_FAW_XINDAWEI_1 = 34 # 一汽 - 新大威 - 2010
VSB_FAW_XINHANWEI_1 = 35 # 一汽 - 新悍威 - 2011
VSB_FAW_SENYA_1 = 36 # 一汽 - 森雅M80 - 2012, 2011, 2009
VSB_FAW_TENGWEI_1 = 37 # 一汽 - 腾威L5M - 重卡
VSB_FAW_JIEFANG_1 = 38 # 一汽 - 解放J4R - A款
VSB_FAW_JIEFANG_2 = 39 # 一汽 - 解放J4R - 自卸车, 牵引车
VSB_FAW_JIEFANG_3 = 40 # 一汽 - 解放J6 - 2004
VSB_FAW_JIEFANG_4 = 41 # 一汽 - 解放J6 - 重卡
VSB_FAW_JIEFANG_5 = 42 # 一汽 - 解放J6L - 中卡
VSB_FAW_JIEFANG_6 = 43 # 一汽 - 解放L5 - A款
VSB_FAW_SAILONG_1 = 44 # 一汽 - 赛龙 - 中卡
VSB_FAW_JUNWEI_1 = 45 # 一汽 - 骏威J5K - 中卡
VSB_FAW_B50_1 = 46 # 一汽 - 奔腾B50 - 2012, 2011, 2009
VSB_FAW_B50_2 = 47 # 一汽 - 奔腾B50 - 2013

VSB_SAICMOTOR_OTHER = 0 # 其他（保留）
VSB_HONGYAN_JIESHI_1 = 1 # 上汽依维柯红岩 - 杰狮 - 2012
VSB_DATONG_V80_1 = 2 # 上汽大通 - V80 - 2014, 2013, 2012, 2011

VSB_SOUEAST_OTHER = 0 # 其他（保留）
VSB_SOUEAST_V3_1 = 1 # 东南 - V3菱悦 - 2011 超值幸福版, 2010, 2009, 2008
VSB_SOUEAST_V3_2 = 2 # 东南 - V3菱悦 - 2012
VSB_SOUEAST_V3_3 = 3 # 东南 - V3菱悦 - 2012 旗舰版, 2011, 2010 新风采版
VSB_SOUEAST_V3_4 = 4 # 东南 - V3菱悦 - 2012 风采版
VSB_SOUEAST_V5_1 = 5 # 东南 - V5菱致 - 2014, 2013, 2012
VSB_SOUEAST_XIWANG_1 = 6 # 东南 - 希旺 - 2011, 2010
VSB_SOUEAST_DELIKA_1 = 7 # 东南 - 得利卡 - 2003, 2002
VSB_SOUEAST_DELIKA_2 = 8 # 东南 - 得利卡 - 2005
VSB_SOUEAST_DELIKA_3 = 9 # 东南 - 得利卡 - 2008
VSB_SOUEAST_DELIKA_4 = 10 # 东南 - 得利卡 - 2009
VSB_SOUEAST_LINGSHUAI_1 = 11 # 东南 - 菱帅 - 2005, 2004 GLXi
VSB_SOUEAST_FULIKA_1 = 12 # 东南 - 富利卡 - 2005
VSB_SOUEAST_FULIKA_2 = 13 # 东南 - 富利卡 - 2007

VSB_ZTE_OTHER = 0 # 其他（保留）
VSB_ZTE_WEIHU_1 = 1 # 中兴 - 威虎 - 2012, 2010
VSB_ZTE_WEIHU_2 = 2 # 中兴 - 威虎TUV - 2010, 2006
VSB_ZTE_WUXIAN_1 = 3 # 中兴 - 无限 - 2008
VSB_ZTE_WUXIAN_2 = 4 # 中兴 - 无限 - 2012, 2011, 2010, 2009

VSB_ZHONGHUA_OTHER = 0 # 其他（保留）
VSB_ZHONGHUA_H230_1 = 1 # 中华 - H230 - 2012
VSB_ZHONGHUA_H320_1 = 2 # 中华 - H320 - 2012
VSB_ZHONGHUA_H330_1 = 3 # 中华 - H330 - 2013
VSB_ZHONGHUA_H530_1 = 4 # 中华 - H530 - 2012, 2011
VSB_ZHONGHUA_V5_1 = 5 # 中华 - V5 - 2012, 2011
VSB_ZHONGHUA_ZUNCHI_1 = 6 # 中华 - 尊驰 - 2004
VSB_ZHONGHUA_ZUNCHI_2 = 7 # 中华 - 尊驰 - 2005, 2003
VSB_ZHONGHUA_KUBAO_1 = 8 # 中华 - 酷宝 - 2007
VSB_ZHONGHUA_JUNJIE_1 = 9 # 中华 - 骏捷 - 2010, 2009, 2008, 2007, 2006
VSB_ZHONGHUA_JUNJIE_2 = 10 # 中华 - 骏捷 - 2012, 2011
VSB_ZHONGHUA_JUNJIECROSS_1 = 11 # 中华 - 骏捷cross - 2010, 2009
VSB_ZHONGHUA_JUNJIEFRV_1 = 12 # 中华 - 骏捷FRV - 2009, 2008
VSB_ZHONGHUA_JUNJIEFRV_2 = 13 # 中华 - 骏捷FRV - 2010
VSB_ZHONGHUA_JUNJIEFSV_1 = 14 # 中华 - 骏捷FSV - 2009
VSB_ZHONGHUA_JUNJIEFSV_2 = 15 # 中华 - 骏捷FSV - 2010
VSB_ZHONGHUA_JUNJIEFSV_3 = 16 # 中华 - 骏捷FSV - 2011

VSB_CNHTC_OTHER = 0 # 其他（保留）
VSB_CNHTC_HOKA_2 = 1 # 中国重汽 - HOKA - 牵引车, 自卸车
VSB_CNHTC_HOWO_1 = 2 # 中国重汽 - HOWO - A7
VSB_CNHTC_HOWO_2 = 3 # 中国重汽 - HOWO - T7H
VSB_CNHTC_HOWO_3 = 4 # 中国重汽 - HOWO - 轻卡
VSB_CNHTC_HOWO_4 = 5 # 中国重汽 - HOWO重卡 - 牵引车
VSB_CNHTC_HOWO_5 = 6 # 中国重汽 - HOWO重卡 - 自卸车A
VSB_CNHTC_HOWO_6 = 7 # 中国重汽 - HOWO重卡 - 自卸车B
VSB_CNHTC_HOWO_7 = 8 # 中国重汽 - HOWO重卡 - 载货车A
VSB_CNHTC_HOWO_8 = 9 # 中国重汽 - HOWO重卡 - 载货车C
VSB_CNHTC_SITAIERWANG_1 = 10 # 中国重汽 - 斯太尔王 - 牵引车A, 载货车, 搅拌车
VSB_CNHTC_HAOHAN_1 = 11 # 中国重汽 - 豪瀚 - A款
VSB_CNHTC_HAOYUN_1 = 12 # 中国重汽 - 豪运 - 牵引车B, 载货车, 自卸车
VSB_CNHTC_JINWANGZI_1 = 13 # 中国重汽 - 金王子重卡 - 牵引车B
VSB_CNHTC_HOKA_1 = 14 # 中国重汽 - HOKA - H7

VSB_ZHONGTONG_OTHER = 0 # 其他（保留）
VSB_ZHONGTONG_KAICHI_1 = 1 # 中通客车 - 凯驰A - A款
VSB_ZHONGTONG_LINGYU_1 = 2 # 中通客车 - 领御 - A款
VSB_ZHONGTONG_LINGXIU_1 = 3 # 中通客车 - 领秀 - A款
VSB_ZHONGTONG_LINGHANG_1 = 4 # 中通客车 - 领航 - A款
VSB_ZHONGTONG_SHIJI_1 = 5 # 中通客车 - 世纪 - A款
VSB_ZHONGTONG_KAIXUAN_1 = 6 # 中通客车 - 凯旋 - A款
VSB_ZHONGTONG_LINGYUN_1 = 7 # 中通客车 - 领韵A - A款
VSB_ZHONGTONG_YANGGUANG_1 = 8 # 中通客车 - 阳光 - A款

VSB_JIULONG_OTHER = 0 # 其他（保留）
VSB_JIULONG_JIULONGA5_1 = 1 # 九龙 - 九龙A5 - 2011

VSB_ZOTYE_OTHER = 0 # 其他（保留）
VSB_ZOTYE_2008_2 = 1 # 众泰 - 2008 - 2011, 2010, 2008
VSB_ZOTYE_5008_1 = 2 # 众泰 - 5008 - 2013, 2011, 2010, 2008
VSB_ZOTYE_Z300_1 = 3 # 众泰 - Z300 - 2013, 2012
VSB_ZOTYE_2008_1 = 4 # 众泰 - 2008 - 2007

VSB_NAVECO_OTHER = 0 # 其他（保留）
VSB_NAVECO_Daily_1 = 1 # 依维柯 - Daily - 2006, 2004, 2003
VSB_NAVECO_Power_1 = 2 # 依维柯 - Power - Daily
VSB_NAVECO_Turbo_1 = 3 # 依维柯 - Turbo - Daily - 2014, 2012, 2011
VSB_NAVECO_Venice_1 = 4 # 依维柯 - Venice - 2011, 2008
VSB_NAVECO_BAODI_1 = 5 # 依维柯 - 宝迪 - 2012, 2009
VSB_NAVECO_DEYIHUOCHE_1 = 6 # 依维柯 - 得意货车 - 2011
VSB_NAVECO_DULING_1 = 7 # 依维柯 - 都灵 - 2010, 2009, 2007

VSB_PORSCHE_OTHER = 0 # 其他（保留）
VBR_PORSCHE_PANAMERA_1 = 1 # 保时捷 - panamera - 2013, 2012, 2010
VBR_PORSCHE_CAYENNE_1 = 2 # 保时捷 - 卡宴Cayenne - 2014, 2013, 2011, 2010

VSB_CHRYSLER_OTHER = 0 # 其他（保留）
VSB_CHRYSLER_300C_1 = 1 # 克莱斯勒 - 300 C - 2007, 2006, 2004
VSB_CHRYSLER_PTMANBUZHE_1 = 2 # 克莱斯勒 - PT漫步者 - 2007

VSB_CADILLAC_OTHER = 0 # 其他（保留）
VSB_CADILLAC_ATS_1 = 1 # 凯迪拉克 - ATS - 2014
VSB_CADILLAC_CTS_1 = 2 # 凯迪拉克 - CTS - 2012
VSB_CADILLAC_CTS_3 = 3 # 凯迪拉克 - CTS - 2012 精英运动型, 2011, 2010, 2009, 2008
VSB_CADILLAC_SLS_1 = 4 # 凯迪拉克 - SLS赛威 - 2007, 2006
VSB_CADILLAC_SLS_2 = 5 # 凯迪拉克 - SLS赛威 - 2012, 2011, 2010
VSB_CADILLAC_SRX_1 = 6 # 凯迪拉克 - SRX - 2012, 2011, 2010, 2009
VSB_CADILLAC_CTS_2 = 7 # 凯迪拉克 - CTS - 2012, 2009 CTS
VSB_CADILLAC_KAILEIDE_1 = 8 # 凯迪拉克 - 凯雷德 - 2011, 2010, 2008, 2007, 2006

VSB_KAMA_OTHER = 0 # 其他（保留）
VSB_KAMA_QINGKA_2 = 1 # 凯马KAMA - 凯马 - 轻卡D
VSB_KAMA_FULAIKA_1 = 2 # 凯马KAMA - 福来卡 - 轻卡A
VSB_KAMA_JINYUNKA_1 = 3 # 凯马KAMA - 金运卡 - 轻卡
VSB_KAMA_JUNWEIKA_1 = 4 # 凯马KAMA - 骏威卡车 - 2014, 2011
VSB_KAMA_QINGKA_1 = 5 # 凯马KAMA - 凯马 - 轻卡C

VSB_LIFAN_OTHER = 0 # 其他（保留）
VSB_LIFAN_320_1 = 1 # 力帆 - 320 - 2012, 2011, 2009
VSB_LIFAN_520_1 = 2 # 力帆 - 520 - 2007, 2006
VSB_LIFAN_520_2 = 3 # 力帆 - 520 - 2013, 2011, 2010, 2008
VSB_LIFAN_620_1 = 4 # 力帆 - 620 - 2012, 2010, 2009, 2008
VSB_LIFAN_X60_1 = 5 # 力帆 - X60 - 2013, 2012, 2011
VSB_LIFAN_FENGSHUN_1 = 6 # 力帆 - 丰顺 - 2011

VSB_BEIJING_OTHER = 0 # 其他（保留）
VSB_BEIJING_E_1 = 1 # 北京汽车 - E系列两厢 - 2014, 2013, 2012

VSB_BEIBEN_OTHER = 0 # 其他（保留）
VSB_BEIBEN_NG80_1 = 1 # 北奔重汽 - NG80 - 重卡A
VSB_BEIBEN_NG80_2 = 2 # 北奔重汽 - NG80 - 重卡B
VSB_BEIBEN_NG80_3 = 3 # 北奔重汽 - NG80 - 重卡C
VSB_BEIBEN_V3_1 = 4 # 北奔重汽 - 北奔V3 - V3H1
VSB_BEIBEN_V3_2 = 5 # 北奔重汽 - 北奔V3 - 重卡A

VSB_BEIFANG_OTHER = 0 # 其他（保留）
VSB_BEIFANG_A_1 = 1  # 北方客车 - 客车车型1 - A款

VSB_BAW_OTHER = 0 # 其他（保留）
VSB_BAW_YUSHENG007_1 = 1 # 北汽制造 - 域胜007 - 2013, 2011
VSB_BAW_QILING_1 = 2 # 北汽制造 - 旗铃 - A款
VSB_BAW_LUBA_1 = 3 # 北汽制造 - 陆霸 - 2004
VSB_BAW_QISHI_1 = 4 # 北汽制造 - 骑士 - 2009, 2007

VSB_BQWEIWANG_OTHER = 0 # 其他（保留）
VSB_BQWEIWANG_205_1 = 1 # 北汽威旺 - 205 - 2013
VSB_BQWEIWANG_306_1 = 2 # 北汽威旺 - 306 - 2014, 2013, 2011

VSB_SMA_OTHER = 0 # 其他（保留）
VSB_SMA_HAIYU_1 = 1 # 华普 - 海域 - 2007, 2005, 2004
VSB_SMA_HAIYU_2 = 2 # 华普 - 海域 - 2007 海域MB
VSB_SMA_HAISHANG_1 = 3 # 华普 - 海尚 - 2008, 2005
VSB_SMA_HAIJING_1 = 5 # 华普 - 海景 - 2010, 2009
VSB_SMA_HAIXUN_1 = 4 # 华普 - 海迅 - 2005, 2004 飙风
VSB_SMA_HAIXUN_2 = 6 # 华普 - 海迅 - 2007, 2006

VSB_XINGMA_OTHER = 0 # 其他（保留）
VSB_XINGMA_XINGKAIMA_1 = 1 # 华菱星马 - 星凯马 - 牵引车型1, 载货车型1

VSB_SHUANGHUAN_OTHER = 0 # 其他（保留）
VSB_SHUANGHUAN_SCEO_1 = 1 # 双环 - SCEO - 2011, 2009, 2006, 2005

VSB_JEEP_OTHER = 0 # 其他（保留）
VSB_JEEP_DAQIENUOJI_1 = 1 # 吉普 - 大切诺基(进口) - 2014, 2013, 2012, 2011
VSB_JEEP_DAQIENUOJI_2 = 2 # 吉普 - 大切诺基(进口) - 2014 舒享导航版
VSB_JEEP_ZHINANZHE_1 = 3 # 吉普 - 指南者 - 2010, 2007
VSB_JEEP_ZHINANZHE_2 = 4 # 吉普 - 指南者 - 2014, 2013, 2012, 2011
VSB_JEEP_MUMAREN_1 = 5 # 吉普 - 牧马人 - 2012 使命召唤限量版, 2011
VSB_JEEP_MUMAREN_2 = 6 # 吉普 - 牧马人 - 2014, 2013, 2012, 2011, 2010, 2009, 2008
VSB_JEEP_ZIYOUKE = 7 # 吉普 - 自由客 - 2014, 2013, 2012, 2011

VSB_VENUCIA_OTHER = 0 # 其他（保留）
VSB_VENUCIA_D50_1 = 1  # 启辰 - D50 - 2014, 2013, 2012

VSB_HAFEI_OTHER = 0 # 其他（保留）
VSB_HAFEI_XINMINYI_1 = 1 # 哈飞 - 新民意货车 - 2010
VSB_HAFEI_XINMINYI_2 = 2 # 哈飞 - 新民意面包车 - 2012
VSB_HAFEI_MINYI_1 = 3 # 哈飞 - 民意货车 - 2006
VSB_HAFEI_MINYI_2 = 4 # 哈飞 - 民意面包车 - 2008
VSB_HAFEI_SAIBAO_1 = 5 # 哈飞 - 赛豹Ⅲ - 2012
VSB_HAFEI_SAIMA_1 = 6 # 哈飞 - 赛马 - 2002
VSB_HAFEI_SAIMA_2 = 7 # 哈飞 - 赛马 - 2004, 2003
VSB_HAFEI_SAIMA_3 = 8 # 哈飞 - 赛马 - 2009
VSB_HAFEI_LUBAO_1 = 9 # 哈飞 - 路宝 - 2004
VSB_HAFEI_LUBAO_2 = 10 # 哈飞 - 路宝 - 2008, 2007
VSB_HAFEI_LUBAO_3 = 11 # 哈飞 - 路宝 - 2012
VSB_HAFEI_LUZUNXIAOBAWANG_1 = 12 # 哈飞 - 路尊小霸王 - 2011, 2010
VSB_HAFEI_RUIYI_1 = 13 # 哈飞 - 锐意 - 2009
VSB_HAFEI_JUNYI_1 = 14 # 哈飞 - 骏意 - 2012, 2010

VSB_TKING_OTHER = 0 # 其他（保留）
VSB_TKING_OUGUAN_1 = 1 # 唐骏欧铃 - 欧冠 - 2011
VSB_TKING_OUGUAN_2 = 2 # 唐骏欧铃 - 欧冠 - 轻卡B
VSB_TKING_OUTENG_1 = 3 # 唐骏欧铃 - 欧腾 - 轻卡A
VSB_TKING_FUXING_1 = 4 # 唐骏欧铃 - 福星 - 2006
VSB_TKING_QINGKAWANG_1 = 5 # 唐骏欧铃 - 轻卡王 - 轻卡
VSB_TKING_AFANDA_1 = 6 # 唐骏欧铃 - 阿凡达 - 中重卡
VSB_TKING_JUNQI_1 = 7 # 唐骏欧铃 - 骏麒 - 中重卡A

VSB_DAEWOO_OTHER = 0 # 其他（保留）
VBR_DAEWOO_6960H3_1 = 1 # 大宇 - 6960 H3 - A款

VSB_DAYUN_OTHER = 0 # 其他（保留）
VBR_DAYUN_ZHONGKA_1 = 1 # 大运汽车 - 重卡 - A款

VSB_BESTURN_OTHER = 0 # 其他（保留）
VSB_BESTURN_B70_1 = 1 # 奔腾 - B70 - 2009, 2007, 2006
VSB_BESTURN_B70_2 = 2 # 奔腾 - B70 - 2011
VSB_BESTURN_B70_3 = 3 # 奔腾 - B70 - 2011 精英型, 2010
VSB_BESTURN_B70_4 = 4 # 奔腾 - B70 - 2012
VSB_BESTURN_B90_1 = 5 # 奔腾 - B90 - 2012
VSB_BESTURN_AOXING_1 = 6 # 一汽 - 奥星 - 2004

VSB_WEILIN_OTHER = 0 # 其他（保留）
VSB_WEILIN_H3_1 = 1 # 威麟 - H3 - 2011
VSB_WEILIN_V5_1 = 2 # 威麟 - V5 - 2012, 2009
VSB_WEILIN_X5_1 = 3 # 威麟 - X5 - 2012, 2011, 2010

VSB_YUTONG_OTHER = 0 # 其他（保留）
VSB_YUTONG_8XI_1 = 1 # 宇通 - 8 系 - 2012, 2005
VSB_YUTONG_KECHE_1 = 2 # 宇通 - 客车车型10 - 2013, 2010
VSB_YUTONG_KECHE_3 = 3 # 宇通 - 客车车型2 - A款
VSB_YUTONG_KECHE_4 = 4 # 宇通 - 客车车型8 - 2004
VSB_YUTONG_KECHE_5 = 5 # 宇通 - 客车车型9 - 2014
VSB_YUTONG_KECHE_2 = 6 # 宇通 - 客车车型12 - A款

VSB_ANKAI_OTHER = 0 # 其他（保留）
VSB_ANKAI_KECHE_1 = 1 # 安凯 - 客车车型1 - A款
VSB_ANKAI_KECHE_2 = 2 # 安凯 - 客车车型3 - A款

VSB_BAOJUN_OTHER = 0 # 其他（保留）
VSB_BAOJUN_630_1 = 1 # 宝骏 - 宝骏630 - 2014, 2013, 2012, 2011

VSB_BINLI_OTHER = 0 # 其他（保留）
VSB_BINLI_OULU_1 = 1 # 宾利 - 欧陆 - 2009, 2008

VSB_TRUMPCHE_OTHER = 0 # 其他（保留）
VSB_TRUMPCHE_GA5_1 = 1 # 广汽传祺 - GA5 - 2012, 2011
VSB_TRUMPCHE_GA5_2 = 3 # 广汽传祺 - GA5 - 2013, 2012 自动精英版
VSB_TRUMPCHE_GS5_1 = 2 # 广汽传祺 - GS5 - 2014, 2013, 2012

VSB_GONOW_OTHER = 0 # 其他（保留）
VSB_GONOW_G3_1 = 1 # 广汽吉奥 - G3 - 2011
VSB_GONOW_G5_1 = 2 # 广汽吉奥 - G5 - 2012, 2011
VSB_GONOW_SHUAIJIAN_1 = 4 # 广汽吉奥 - 帅舰 - 2012, 2009
VSB_GONOW_XINGWANGM1_1 = 3 # 广汽吉奥 - 星旺M1 - 2012
VSB_GONOW_CAIYUN500_1 = 5 # 广汽吉奥 - 财运500 - 2010

VSB_ISUZU_OTHER = 0 # 其他（保留）
VSB_ISUZU_ZHONGXINGSHANGYONG_1 = 1 # 庆铃 - 中型商用车 - 2011
VSB_ISUZU_WUSHILINGPIKA_1 = 2 # 庆铃 - 五十铃皮卡 - 2009
VSB_ISUZU_WUSHILINGPIKA_2 = 3 # 庆铃 - 五十铃皮卡 - 2014, 2009
VSB_ISUZU_JINGJIZHE_1 = 4 # 庆铃 - 竞技者 - 2004, 2002

VSB_KARRY_OTHER = 0 # 其他（保留）
VSB_KARRY_YOU_2 = 1 # 开瑞 - 优优 - 2013, 2012
VSB_KARRY_YOUJIN_1 = 2 # 开瑞 - 优劲 - 2012, 2011 基本型, 2010
VSB_KARRY_YOUSHENG_1 = 3 # 开瑞 - 优胜 - 2010
VSB_KARRY_YOUSHENG_2 = 4 # 开瑞 - 优胜 - 2012, 2011
VSB_KARRY_YOUYA = 5 # 开瑞 - 优雅 - 2012, 2011, 2007
VSB_KARRY_YOU_1 = 6 # 开瑞 - 优优 - 2011, 2010, 2009

VSB_GAGUAR_OTHER = 0 # 其他（保留）
VSB_GAGUAR_XF_1 = 1 # 捷豹 - XF - 2014, 2013
VSB_GAGUAR_XJ_1 = 2 # 捷豹 - XJ - 2014, 2013, 2012, 2011, 2010

VSB_SUBARU_OTHER = 0 # 其他（保留）
VSB_SUBARU_AOHU_1 = 1 # 斯巴鲁 - 傲虎 - 2012, 2011, 2010
VSB_SUBARU_LISHI_1 = 2 # 斯巴鲁 - 力狮轿车 - 2008, 2006
VSB_SUBARU_LISHI_2 = 3 # 斯巴鲁 - 力狮轿车 - 2011, 2010
VSB_SUBARU_XV_1 = 4 # 斯巴鲁 - 斯巴鲁XV - 2014, 2012
VSB_SUBARU_SENLINREN_1 = 5 # 斯巴鲁 - 森林人 - 2007, 2006
VSB_SUBARU_SENLINREN_2 = 6 # 斯巴鲁 - 森林人 - 2012, 2011, 2010, 2009, 2008

# 时代汽车子品牌类型
VSB_ERA_OTHER = 0
VSB_ERA_XIAOKA_1 = 1
VSB_ERA_XIAOKA_3 = 2
VSB_ERA_XIAOKA_4 = 3
VSB_ERA_KANGRUI_1 = 4
VSB_ERA_KANGRUI_2 = 5
VSB_ERA_KANGRUI_3 = 6
VSB_ERA_RUIWO_1 = 7
VSB_ERA_RUIWO_2 = 8
VSB_ERA_RUIWO_3 = 9
VSB_ERA_JINGANG = 10
VSB_ERA_LINGHANG_1 = 11
VSB_ERA_LINGHANG_2 = 12
VSB_ERA_YULING_1 = 13
VSB_ERA_YULING_2 = 14
VSB_ERA_YULING_3 = 15
VSB_ERA_YULING_4 = 17
VSB_ERA_XIAOKA_2 = 17

# 昌河子品牌类型
VSB_CHANGHE_OTHER = 0
VSB_CHANGHE_CH6321_1 = 1
VSB_CHANGHE_DANSHUANGPAI_1 = 2
VSB_CHANGHE_AIDIER_1 = 3
VSB_CHANGHE_AIDIER_2 = 4
VSB_CHANGHE_FURUIDA_1 = 5

# 欧宝子品牌类型
VSB_OPEL_OTHER = 0
VSB_OPEL_YATE_1 = 1

# 永源子品牌类型
VSB_JONWAY_OTHER = 0
VSB_JONWAY_A380_1 = 1

# 江南子品牌类型
VSB_JIANGNAN_OTHER = 0
VSB_JIANGNAN_TT_1 = 1

# 吉利全球鹰子品牌类型
VSB_GLEAGLE_OTHER = 0
VSB_GLEAGLE_EAGLE_GC7_1 = 1
VSB_GLEAGLE_EAGLE_GX2_1 = 2
VSB_GLEAGLE_EAGLE_GX7_1 = 3
VSB_GLEAGLE_EAGLE_PANDA_1 = 4
VSB_GLEAGLE_EAGLE_ZIYOUJIAN_1 = 5
VSB_GLEAGLE_EAGLE_ZIYOUJIAN_2 = 6
VSB_GLEAGLE_EAGLE_ZIYOUJIAN_3 = 7
VSB_GLEAGLE_EAGLE_YUANJING_1 = 8
VSB_GLEAGLE_EAGLE_YUANJING_2 = 9

# 吉利帝豪子品牌类型
VSB_EMGRAND_OTHER = 0
VSB_EMGRAND_EC7_2 = 1
VSB_EMGRAND_EC7_3 = 2
VSB_EMGRAND_EC8_1 = 3
VSB_EMGRAND_EC7_1 = 4

# 吉利英伦子品牌类型
VSB_ENGLON_OTHER = 0
VSB_ENGLON_SC3_1 = 1
VSB_ENGLON_SC5_1 = 2
VSB_ENGLON_SC6_1 = 3
VSB_ENGLON_SC7_1 = 4
VSB_ENGLON_SX7_1 = 5
VSB_ENGLON_JINGANG_1 = 6
VSB_ENGLON_JINYING_1 = 7

# 江淮-子品牌类型
VSB_JAC_OTHER = 0
VSB_JAC_TONGYUE_1 = 1
VSB_JAC_HEYUE_1 = 2
VSB_JAC_HEYUEA30_2 = 3
VSB_JAC_HEYUERS_3 = 4
VSB_JAC_HAOYUN_1 = 5
VSB_JAC_WEILING_2 = 6
VSB_JAC_WEILING_3 = 7
VSB_JAC_WEILING_4 = 8
VSB_JAC_KECHE_1 = 9
VSB_JAC_BINYUE_1 = 10
VSB_JAC_SHUAILING_2 = 11
VSB_JAC_KANGLING_1 = 12
VSB_JAC_KANGLING_2 = 13
VSB_JAC_YUEYUE_1 = 14
VSB_JAC_XINGRUI_1 = 15
VSB_JAC_GEERFA_H_1 = 16
VSB_JAC_GEERFA_K_2 = 17
VSB_JAC_GEERFA_K_3 = 18
VSB_JAC_GEERFA_M_4 = 19
VSB_JAC_RUIFENG_1 = 20
VSB_JAC_RUIFENG_2 = 21
VSB_JAC_RUIFENG_3 = 22
VSB_JAC_RUIFENG_4 = 23
VSB_JAC_RUIYING_1 = 24
VSB_JAC_RUIYING_2 = 25
VSB_JAC_JUNLING_2 = 26
VSB_JAC_WEILING_1 = 27
VSB_JAC_SHUAILING_1 = 28
VSB_JAC_RUILING_1 = 29
VSB_JAC_JUNLING_1 = 30

# 江铃子品牌类型
VSB_JMC_OTHER = 0
VSB_JMC_KAIYUN_1 = 1
VSB_JMC_KAIYUN_2 = 2
VSB_JMC_YUHU_1 = 3
VSB_JMC_BAODIAN_1 = 4
VSB_JMC_BAODIAN_2 = 5
VSB_JMC_BAODIAN_3 = 6
VSB_JMC_BAOWEI_1 = 7
VSB_JMC_BAOWEI_2 = 8
VSB_JMC_QUANSHUN_1 = 9
VSB_JMC_QUANSHUN_2 = 10
VSB_JMC_QUANSHUN_3 = 11
VSB_JMC_SHUNDA_1 = 12
VSB_JMC_SHUNDA_2 = 13
VSB_JMC_YUSHENG_1 = 14
VSB_JMC_YUSHENG_2 = 15

#  沃尔沃子品牌类型
VSB_VOLVO_OTHER = 0
VSB_VOLVO_C30_1 = 1
VSB_VOLVO_S40_1 = 2
VSB_VOLVO_S60_1 = 3
VSB_VOLVO_S60_2 = 4
VSB_VOLVO_S80L_1 = 5
VSB_VOLVO_XC60_1 = 6
VSB_VOLVO_XC90_1 = 7

#  海格子品牌类型
VSB_HIGER_OTHER = 0
VSB_HIGER_H8_1 = 1
VSB_HIGER_H92_1 = 2
VSB_HIGER_V7_1 = 3
VSB_HIGER_KECHE_1 = 4
VSB_HIGER_LONGWEI_1 = 5
VSB_HIGER_H7V_1 = 6

#  瑞麒子品牌类型
VSB_RUILIN_OTHER = 0
VSB_RUILIN_G3_1 = 1
VSB_RUILIN_G5_1 = 2
VSB_RUILIN_M1_1 = 3
VSB_RUILIN_X1_1 = 4
VSB_RUILIN_X1_2 = 5

#  申龙子品牌类型
VSB_SHENLON_OTHER = 0
VSB_SHENLONG_KECHE_1 = 1

#  福田子品牌类型
VSB_FOTON_OTHER = 0
VSB_FOTON_AOLING_1 = 1
VSB_FOTON_AOLING_2 = 2
VSB_FOTON_AOLING_3 = 3
VSB_FOTON_OUMAN_1 = 4
VSB_FOTON_OUMAN_2 = 5
VSB_FOTON_OUMAN_3 = 6
VSB_FOTON_OUMAN_4 = 7
VSB_FOTON_OUHUI_1 = 8
VSB_FOTON_OUMAKE_1 = 9
VSB_FOTON_OUMAKE_2 = 10
VSB_FOTON_SAPU_1 = 11
VSB_FOTON_SAPU_3 = 12
VSB_FOTON_MENGPAIKE_1 = 13
VSB_FOTON_MIDI_1 = 14
VSB_FOTON_FENGJING_1 = 15
VSB_FOTON_SAPU_2 = 16

# 福迪子品牌类型
VSB_FODAY_OTHER = 0
VSB_FODAY_CHAOREN_1 = 1
VSB_FODAY_CHAOREN_2 = 2
VSB_FODAY_TANSUOZHE_1 = 3
VSB_FODAY_TANSUOZHE_2 = 4
VSB_FODAY_TANSUOZHE_3 = 5
VSB_FODAY_XIONGSHI_1 = 6

#  红旗子品牌类型
VSB_HONGQI_OTHER = 0
VSB_HONGQI_MINGSHI_1 = 1

#  纳智捷 子品牌类型
VSB_LUXGEN_OTHER = 0
VSB_LUXGEN_DASEVEN_1 = 1

#  夏利子品牌类型
VSB_XIALI_OTHER = 0
VSB_XIALI_QIBING_1 = 1

#  舒驰客车子品牌类型
VSB_SHUCHI_OTHER = 0
VSB_SHUCHI_A_1 = 1

# 英菲尼迪子品牌类型
VSB_INFINITI_OTHER = 0
VSB_INFINITI_EX_1 = 1
VSB_INFINITI_FX_1 = 2
VSB_INFINITI_FX_2 = 3
VSB_INFINITI_FX_3 = 4
VSB_INFINITI_G_1 = 5
VSB_INFINITI_JX_1 = 6

#  莲花子品牌类型
VSB_LOTUS_OTHER = 0
VSB_LOTUS_L3_1 = 1
VSB_LOTUS_L3_2 = 2

# 菲亚特子品牌类型
VSB_FIAT_OTHER = 0
VSB_FIAT_FEIYUE_1 = 1

# 讴歌子品牌类型
VSB_OGA_OTHER = 0
VSB_OGA_MDX_1 = 1
VSB_OGA_MDX_2 = 2

#  跃进子品牌类型
VSB_YUEJIN_OTHER = 0
VSB_YUEJIN_SHUAIHU_1 = 1
VSB_YUEJIN_CAISHEN_1 = 2
VSB_YUEJIN_CAISHEN_2 = 3
VSB_YUEJIN_CAISHEN_3 = 4

# 野马子品牌类型
VSB_YEMA_OTHER = 0
VSB_YEMA_F99_1 = 1

# 金龙子品牌类型
VSB_SZKINGLONG_OTHER = 0
VSB_SZKINGLONG_BUS11_1 = 1
VSB_SZKINGLONG_BUS12_1 = 2
VSB_SZKINGLONG_BUS13_1 = 3
VSB_SZKINGLONG_BUS14_1 = 4
VSB_SZKINGLONG_BUS16_1 = 5
VSB_SZKINGLONG_BUS18_1 = 6
VSB_SZKINGLONG_BUS1_1 = 7
VSB_SZKINGLONG_BUS20_1 = 8
VSB_SZKINGLONG_BUS2_1 = 9
VSB_SZKINGLONG_BUS5_1 = 10
VSB_SZKINGLONG_BUS6_1 = 11
VSB_SZKINGLONG_BUS9_1 = 12
VSB_SZKINGLONG_BUS10_1 = 13
VSB_SZKINGLONG_BUS15_1 = 14

# 长丰猎豹子品牌类型
VSB_CHANGFENG_OTHER = 0
VSB_CHANGFENG_CS7_1 = 1
VSB_CHANGFENG_QIBING_1 = 2
VSB_CHANGFENG_LIEBAO_1 = 3
VSB_CHANGFENG_FULING_1 = 4
VSB_CHANGFENG_FEIYANG_1 = 5
VSB_CHANGFENG_FEITENG_1 = 6
VSB_CHANGFENG_BLACKJINGANG_1 = 7

# 陆风子品牌类型
VSB_LUFENG_OTHER = 0
VSB_LUFENG_X6_1 = 1
VSB_LUFENG_X6_2 = 2
VSB_LUFENG_X6_3 = 3
VSB_LUFENG_LUFENGX5_1 = 4
VSB_LUFENG_LUFENGX8_1 = 5
VSB_LUFENG_LUFENGX8_2 = 6
VSB_LUFENG_FENGHUA_1 = 7
VSB_LUFENG_X6_4 = 8
VSB_LUFENG_FENGSHANG_1 = 9

# 陕汽重卡子品牌类型
VSB_SHANQI_OTHER = 0
VSB_SHANQI_AOLONG_1 = 1
VSB_SHANQI_AOLONG_2 = 2
VSB_SHANQI_DELONG_1 = 3
VSB_SHANQI_DELONG_2 = 4
VSB_SHANQI_DELONG_3 = 5

# 野马子品牌类型
VSB_RENAULT_OTHER = 0
VSB_RENAULT_MEIGANNA_1 = 1
VSB_RENAULT_KELEIAO_1 = 2
VSB_RENAULT_KELEIAO_2 = 3
VSB_RENAULT_SCENE_1 = 4
VSB_RENAULT_FENGLANG_1 = 5
VSB_RENAULT_TAFEIKE_1 = 6

# 黄海子品牌类型
VSB_HUANGHAI_OTHER = 0
VSB_HUANGHAI_DACAISHEN_1 = 1
VSB_HUANGHAI_DACAISHEN_2 = 2
VSB_HUANGHAI_BUS4_1 = 3
VSB_HUANGHAI_CHALLENGER_1 = 4
VSB_HUANGHAI_AOLONGCUV_1 = 5
VSB_HUANGHAI_AOJUN_1 = 6
VSB_HUANGHAI_AOJUN_2 = 7
VSB_HUANGHAI_QISHENGV3_1 = 8
VSB_HUANGHAI_LINGHANGZHE_1 = 9
VSB_HUANGHAI_FENGCHI_1 = 10


# 车辆信息
class NET_DVR_VEHICLE_INFO(Structure):
    _fields_ = [
        ("dwIndex", DWORD), # 车辆序号
        ("byVehicleType", BYTE), # 车辆类型 0 表示其它车型，1 表示小型车，2 表示大型车 ,3表示行人触发 ,4表示二轮车触发 5表示三轮车触发(3.5Ver)  6表示机动车触发
        ("byColorDepth", BYTE), # 车身颜色深浅
        ("byColor", BYTE), # 车身颜色,参考VCR_CLR_CLASS
        # 雷达异常状态：
        # 0~雷达正常，
        # 1~雷达故障
        # 2~雷达一直发送某一个相同速度值
        # 3~雷达送出数据为0
        # 4~雷达送出数据过大或者过小
        #
        ("byRadarState", BYTE),
        ("wSpeed", WORD), # 单位km/h
        ("wLength", WORD), # 前一辆车的车身长度
        # 违规类型，0-正常，1-低速，2-超速，3-逆行，4-闯红灯,5-压车道线,6-不按导向，7-路口滞留，
        # 8-机占非，9-违法变道，10-不按车道 11-违反禁令，12-路口停车，13-绿灯停车, 14-未礼让行人(违法代码1357),
        # 15-违章停车，16-违章掉头,17-占用应急车道,18-禁右,19-禁左,20-压黄线,21-未系安全带,22-行人闯红灯,23-加塞,24-违法使用远光灯，
        # 25-驾驶时拨打接听手持电话，26-左转不让直行，27-右转不让左转，28-掉头不让直行，29-大弯小转, 30-闯绿灯，31-未带头盔，
        # 32-非机动车载人，33-非机动车占用机动车道，34-非机动车打伞棚, 35-黑烟车, 36-鸣笛,37-压线停车,38-跨位停车,39-压线且跨位停车
        # 40-不让右方道路来车先行 41-进入环形路口未让已在路口内的机动车先行 42-机动车从匝道进入主路未让行
        #
        ("byIllegalType", BYTE),
        ("byVehicleLogoRecog", BYTE), # 参考枚举类型 VLR_VEHICLE_CLASS
        ("byVehicleSubLogoRecog", BYTE), # 车辆品牌子类型识别；参考VSB_VOLKSWAGEN_CLASS等子类型枚举。
        ("byVehicleModel", BYTE), # 车辆子品牌年款，0-未知，参考"车辆子品牌年款.xlsx"
        ("byCustomInfo", BYTE * 16), # 自定义信息
        ("wVehicleLogoRecog", WORD), # 车辆主品牌，参考"车辆主品牌.xlsx" (该字段兼容byVehicleLogoRecog)
        ("byIsParking", BYTE), # 是否停车 0-无效，1-停车，2-未停车
        ("byRes", BYTE), # 保留字节
        ("dwParkingTime", DWORD), # 停车时间，单位：s
        ("byBelieve", BYTE), # byIllegalType置信度，1-100
        ("byCurrentWorkerNumber", BYTE), # 当前作业人数
        ("byCurrentGoodsLoadingRate", BYTE), # 当前货物装载率 0-空 1-少 2-中 3-多 4-满
        ("byDoorsStatus", BYTE), # 车门状态 0-车门关闭 1-车门开启
        ("byRes3", BYTE * 4),
    ]


LPNET_DVR_VEHICLE_INFO = POINTER(NET_DVR_VEHICLE_INFO)


# 车牌检测结果
class NET_DVR_PLATE_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byResultType", BYTE), # 0-视频识别结果，1图像识别结果 2 大于10M时走下载路线
        ("byChanIndex", BYTE), # 通道号
        ("wAlarmRecordID", WORD), # 报警录像ID(用于查询录像，仅当byResultType为2时有效)
        ("dwRelativeTime", DWORD), # 相对时间点
        ("byAbsTime", BYTE * 32), # 绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999（毫秒）
        ("dwPicLen", DWORD), # 图片长度(近景图)
        ("dwPicPlateLen", DWORD), # 车牌小图片长度
        ("dwVideoLen", DWORD), # 录像内容长度
        ("byTrafficLight", BYTE), # 0-非红绿灯抓拍，1-绿灯时抓拍；2-红灯时抓拍
        ("byPicNum", BYTE), # 连拍的图片序号
        ("byDriveChan", BYTE), # 触发车道号
        ("byVehicleType", BYTE), # 车辆类型，参考VTR_RESULT
        ("dwBinPicLen", DWORD), # 车牌二值图长度
        ("dwCarPicLen", DWORD), # 车辆原图长度
        ("dwFarCarPicLen", DWORD), # 远景图长度
        ("*pBuffer3", BYTE), # 车牌二值图
        ("*pBuffer4", BYTE), # 车辆原图
        ("*pBuffer5", BYTE), # 远景图
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byCarDirectionType", BYTE), # 车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
        ("byRes3", BYTE * 6),
        ("struPlateInfo", NET_DVR_PLATE_INFO), # 车牌信息结构
        ("struVehicleInfo", NET_DVR_VEHICLE_INFO), # 车辆信息
        ("*pBuffer1", BYTE), #  当上传的是图片(近景图)，指针指向图片信息，当上传的是视频，指针指向视频信息，如果不想获得图片或视频信息，传NULL(DVS车辆近景图)
        ("*pBuffer2", BYTE), #  当上传的是图片(车牌图)时，指向车牌图片的指针（DVS车牌彩图）
    ]


LPNET_DVR_PLATE_RESULT = POINTER(NET_DVR_PLATE_RESULT)


# 后面紧跟图片数据和录像数据，只传一种，图片数据为场景图片+车牌小图片
class NET_VPD_SHUTTER(Structure):
    _fields_ = [
        ("dwCommmand", DWORD), # 命令:0,不控制 1,调亮 2,调暗 3,保持 4,直接输入快门值
        ("dwCode", DWORD), # 快门值, 当参数dwCommmand为4, 该参数不能为空
        ("byRes", BYTE * 60), # 保留
    ]


LPNET_VPD_SHUTTER = POINTER(NET_VPD_SHUTTER)


# 图像叠加信息配置
class NET_DVR_IMAGEOVERLAYCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byOverlayInfo", BYTE), # 叠加使能开关，0-不叠加，1-叠加
        ("byOverlayMonitorInfo", BYTE), # 是否叠加监测点信息，0-不叠加，1-叠加
        ("byOverlayTime", BYTE), # 是否叠加时间，0-不叠加，1-叠加
        ("byOverlaySpeed", BYTE), # 是否叠加速度，0-不叠加，1-叠加
        ("byOverlaySpeeding", BYTE), # 是否叠加超速比例，0-不叠加，1-叠加
        ("byOverlayLimitFlag", BYTE), # 是否叠加限速标志，0-不叠加，1-叠加
        ("byOverlayPlate", BYTE), # 是否叠加车牌号，0-不叠加，1-叠加
        ("byOverlayColor", BYTE), # 是否叠加车身颜色，0-不叠加，1-叠加
        ("byOverlayLength", BYTE), # 是否叠加车长，0-不叠加，1-叠加
        ("byOverlayType", BYTE), # 是否叠加车型，0-不叠加，1-叠加
        ("byOverlayColorDepth", BYTE), # 是否叠加车身颜色深浅，0-不叠加，1-叠加
        ("byOverlayDriveChan", BYTE), # 是否叠加车道，0-不叠加，1-叠加
        ("byOverlayMilliSec", BYTE), # 叠加毫秒信息 0-不叠加，1-叠加
        ("byOverlayIllegalInfo", BYTE), # 叠加违章信息 0-不叠加，1-叠加
        ("byOverlayRedOnTime", BYTE), # 叠加红灯已亮时间 0-不叠加，1-叠加
        ("byFarAddPlateJpeg", BYTE), # 远景图是否叠加车牌截图,0-不叠加,1-叠加
        ("byNearAddPlateJpeg", BYTE), # 近景图是否叠加车牌截图,0-不叠加,1-叠加
        ("byRes1", BYTE * 3), # 保留
        ("byMonitorInfo1", BYTE * 32), # 监测点信息1
        ("byMonitorInfo2", BYTE * 44), # 检测点信息2
        ("byRes2", BYTE * 52), # 保留
    ]


LPNET_DVR_IMAGEOVERLAYCFG = POINTER(NET_DVR_IMAGEOVERLAYCFG)


# 单IO触发抓拍功能配置
class NET_DVR_SNAPCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRelatedDriveWay", BYTE), # 触发IO关联的车道号
        ("bySnapTimes", BYTE), # 线圈抓拍次数，0-不抓拍，非0-连拍次数，目前最大5次
        ("wSnapWaitTime", WORD), # 抓拍等待时间，单位ms，取值范围[0,60000]
        ("wIntervalTime", WORD * MAX_INTERVAL_NUM), # 连拍间隔时间，ms
        ("dwSnapVehicleNum", DWORD), # 抓拍车辆序号。
        ("struJpegPara", NET_DVR_JPEGPARA), # 抓拍图片参数
        ("byRes2", BYTE * 16), # 保留字节
    ]


LPNET_DVR_SNAPCFG = POINTER(NET_DVR_SNAPCFG)


ITC_MODE_UNKNOW = 0x0
ITC_POST_MODE = 0x1
ITC_EPOLICE_MODE = 0x2
ITC_POSTEPOLICE_MODE = 0x4


ITC_REGION_RECT = 0x0
ITC_REGION_POLYGON = 0x1


class NET_DVR_SNAP_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIoInNum", BYTE), # IO输入口数
        ("byIoOutNum", BYTE), # IO输出口数
        ("bySingleSnapNum", BYTE), # 单IO触发组数
        ("byLightModeArrayNum", BYTE), # 红绿灯模式组数
        ("byMeasureModeArrayNum", BYTE), # 测速模式组数
        ("byPlateEnable", BYTE), # 车牌识别能力
        ("byLensMode", BYTE), # 镜头模式0-CCD,1-CMOS
        ("byPreTriggerSupport", BYTE), # 是否支持原触发模式，0-支持，1-不支持
        ("dwAbilityType", DWORD), # 支持的触发模式能力，按位表示，定义见ITC_MAINMODE_ABILITY
        ("byIoSpeedGroup", BYTE), # 支持的IO测速组数
        ("byIoLightGroup", BYTE), # 支持的IO红绿灯组数
        ("byRecogRegionType", BYTE), # 牌识区域支持的类型，详见定义ITC_RECOG_REGION_TYPE
        ("bySupport", BYTE), # 设备能力，按位表示，0-不支持，1-支持
        # bySupport&0x1，表示是否支持扩展的字符叠加配置
        # bySupport&0x2，表示是否支持扩展的校时配置结构
        # bySupport&0x4, 表示是否支持多网卡(多网隔离)
        # bySupport&0x8, 表示是否支持网卡的bonding功能(网络容错)
        # bySupport&0x10, 表示是否支持语音对讲
        # 2013-07-09 能力集返回
        ("wSupportMultiRadar", WORD), #  设备能力，按位表示，0-不支持，1-支持
        # wSupportMultiRadar&0x1，表示 卡口RS485雷达 支持车道关联雷达处理
        # wSupportMultiRadar&0x2，表示 卡口虚拟线圈 支持车道关联雷达处理
        # wSupportMultiRadar&0x4，表示 混行卡口 支持车道关联雷达处理
        # wSupportMultiRadar&0x8，表示 视频检测 支持车道关联雷达处理
        ("byICRPresetNum", BYTE),
        # 表示支持的ICR预置点（滤光片偏移点）数
        ("byICRTimeSlot", BYTE), # 表示支持的ICR的时间段数（1～8）
        ("bySupportRS485Num", BYTE), # 表示支持的RS485口的数量
        ("byExpandRs485SupportSensor", BYTE), #  设备能力，按位表示，0-不支持，1-支持
        # byExpandRs485SupportSensor &0x1，表示电警车检器支持车检器
        # byExpandRs485SupportSensor &0x2，表示卡式电警车检器支持车检器
        ("byExpandRs485SupportSignalLampDet", BYTE), #  设备能力，按位表示，0-不支持，1-支持
        # byExpandRs485SupportSignalLampDet &0x1，表示电警车检器支持外接信号灯检测器
        # byExpandRs485SupportSignalLampDet &0x2，表示卡式电警车检器支持外接信号灯检测器
        ("byRelayNum", BYTE), #  表示支持继电器的个数 2013-11-04
        ("bySupport1", BYTE), # 设备能力，按位表示，0-不支持，1-支持
        # bySupport1&0x1，表示是否支持自定义校时信息配置
        # bySupport1&0x2,  表示是否支持视频触发优化方案
        # bySupport1&0x4,  表示是否支持DDNS配置方案
        # bySupport1&0x8,  表示是否支持获取设备当前触发模式接口命令
        # bySupport1&0x10, 表示是否支持出入口配置 2014-03-03
        # bySupport1&0x20,  表示是否支持GPS模块参数配置
        # bySupport1&0x40,  表示是否支持NTP校时间隔支持分钟设置
        # bySupport1&0x80,  表示是否支持tps报警数据上传
        ("bySupport2", BYTE), # 设备能力，按位表示，0-不支持，1-支持
        # bySupport2&0x01,  表示是否支持码流附加信息配置
        # bySupport2&0x02,  表示通道图像参数（INTER_PICCFG_V30）中是否支持视频叠加时间毫秒启用参数（byOSDMilliSecondEnable）
        # bySupport2&0x04,   表示道闸控制（NET_DVR_BARRIERGATE_CFG）中byBarrierGateCtrl字段支持索引4~解锁道闸，且支持byUnlock解锁使能。反之则标识不支持
        ("bySupportWhiteBalance", BYTE), # 白平衡能力，默认都是支持手动白平衡、自动白平衡、自动白平衡2这3种模式。
        # bySupportWhiteBalance &0x01,  表示是否支持日光灯模式
        # bySupportWhiteBalance &0x02,  表示是否支持自然光模式
        # bySupportWhiteBalance &0x04,  表示是否支持暖光灯模式
        # bySupportWhiteBalance &0x08,  表示是否支持白炽灯模式
        ("byRes", BYTE * 9),
    ]


LPNET_DVR_SNAP_ABILITY = POINTER(NET_DVR_SNAP_ABILITY)


class NET_DVR_TRANSFER_CAP(Structure):
    _fields_ = [
        ("byAbility", BYTE),
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_TRANSFER_CAP = POINTER(NET_DVR_TRANSFER_CAP)


class NET_ITC_ICRTIMECFG(Structure):
    _fields_ = [
        ("struTime", NET_DVR_SCHEDTIME),
        ("byAssociateRresetNo", BYTE), # 预置点号1～8 , 0代表无
        ("bySubSwitchMode", BYTE), # 1~白天，2~晚上 (当预置点等于0 的时候生效)
        ("byRes", BYTE * 10),
    ]


LPNET_ITC_ICRTIMECFG = POINTER(NET_ITC_ICRTIMECFG)


class NET_ITC_ICR_TIMESWITCH_PARAM(Structure):
    _fields_ = [
        ("struAutoCtrlTime", NET_ITC_ICRTIMECFG * MAX_TIMESEGMENT_V30), # 自动切换时间段 (自动切换下 时空下生效 现在支持4组，预留4组)
        ("byICRPreset", BYTE * MAX_ICR_NUM), # 实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
        ("byRes", BYTE * 20),
    ]


LPNET_ITC_ICR_TIMESWITCH_PARAM = POINTER(NET_ITC_ICR_TIMESWITCH_PARAM)


class NET_ITC_ICR_MANUALSWITCH_PARAM(Structure):
    _fields_ = [
        ("byICRPreset", BYTE * MAX_ICR_NUM), # 实际生效根据能力集动态显示 [0~100]
        ("bySubSwitchMode", BYTE), # 1~白天，2~晚上
        ("byRes", BYTE * 147),
    ]


LPNET_ITC_ICR_MANUALSWITCH_PARAM = POINTER(NET_ITC_ICR_MANUALSWITCH_PARAM)


class NET_ITC_ICR_AOTOSWITCH_PARAM(Structure):
    _fields_ = [
        ("byICRPreset", BYTE * MAX_ICR_NUM), # 实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
        ("byICRAutoSwitch", BYTE), #  ICR自动切换加阈值选项, 取值范围[0 100]
        ("byRes", BYTE * 147),
    ]


LPNET_ITC_ICR_AOTOSWITCH_PARAM = POINTER(NET_ITC_ICR_AOTOSWITCH_PARAM)


# 算法自动
class NET_ITC_ICR_ALGAOTOSWITCH_PARAM(Structure):
    _fields_ = [
        ("byDetectThreshold", BYTE), # 检测阈值,范围[0,100],默认 58
        ("byAbBrightnessThreshold", BYTE), # 异常亮度阈值，范围[0,100]，默认12
        ("byRes", BYTE * 154),
    ]


LPNET_ITC_ICR_ALGAOTOSWITCH_PARAM = POINTER(NET_ITC_ICR_ALGAOTOSWITCH_PARAM)


class NET_ITC_ICR_PARAM_UNION(Union):
    _fields_ = [
        ("uLen", BYTE * 156),
        ("struICRAutoSwitch", NET_ITC_ICR_AOTOSWITCH_PARAM),
        ("struICRManualSwitch", NET_ITC_ICR_MANUALSWITCH_PARAM),
        ("struICRTimeSwitch", NET_ITC_ICR_TIMESWITCH_PARAM),
        ("strICRAlgorithmAutoSwitch", NET_ITC_ICR_ALGAOTOSWITCH_PARAM),
    ]


LPNET_ITC_ICR_PARAM_UNION = POINTER(NET_ITC_ICR_PARAM_UNION)


class NET_ITC_ICRCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySwitchType", BYTE), # 1~自动切换，2~手动切换 ,3~定时切换,4~算法自动
        ("byRes", BYTE * 3),
        ("uICRParam", NET_ITC_ICR_PARAM_UNION),
    ]


LPNET_ITC_ICRCFG = POINTER(NET_ITC_ICRCFG)


# 2013-07-09 异常处理
class NET_DVR_TRIGCOORDINATE(Structure):
    _fields_ = [
        ("wTopLeftX", WORD), # 线圈左上角横坐标（2个字节）
        ("wTopLeftY", WORD), # 线圈左上角纵坐标（2个字节）
        ("wWdith", WORD), # 线圈宽度（2个字节）
        ("wHeight", WORD), # 线圈高度（2个字节）
    ]


LPNET_DVR_TRIGCOORDINATE = POINTER(NET_DVR_TRIGCOORDINATE)


ANHUI_PROVINCE = 0
AOMEN_PROVINCE = 1
BEIJING_PROVINCE = 2
CHONGQING_PROVINCE = 3
FUJIAN_PROVINCE = 4
GANSU_PROVINCE = 5
GUANGDONG_PROVINCE = 6
GUANGXI_PROVINCE = 7
GUIZHOU_PROVINCE = 8
HAINAN_PROVINCE = 9
HEBEI_PROVINCE = 10
HENAN_PROVINCE = 11
HEILONGJIANG_PROVINCE = 12
HUBEI_PROVINCE = 13
HUNAN_PROVINCE = 14
JILIN_PROVINCE = 15
JIANGSU_PROVINCE = 16
JIANGXI_PROVINCE = 17
LIAONING_PROVINCE = 18
NEIMENGGU_PROVINCE = 19
NINGXIA_PROVINCE = 20
QINGHAI_PROVINCE = 21
SHANDONG_PROVINCE = 22
SHANXI_JIN_PROVINCE = 23
SHANXI_SHAN_PROVINCE = 24
SHANGHAI_PROVINCE = 25
SICHUAN_PROVINCE = 26
TAIWAN_PROVINCE = 27
TIANJIN_PROVINCE = 28
XIZANG_PROVINCE = 29
XIANGGANG_PROVINCE = 30
XINJIANG_PROVINCE = 31
YUNNAN_PROVINCE = 32
ZHEJIANG_PROVINCE = 33


class NET_DVR_GEOGLOCATION(Structure):
    _fields_ = [
        ("iRes", INT * 2), # 保留
        ("dwCity", DWORD), # 城市，详见PROVINCE_CITY_IDX
    ]


LPNET_DVR_GEOGLOCATION = POINTER(NET_DVR_GEOGLOCATION)


# 场景模式
UNKOWN_SCENE_MODE = 0
HIGHWAY_SCENE_MODE = 1
SUBURBAN_SCENE_MODE = 2
URBAN_SCENE_MODE = 3
TUNNEL_SCENE_MODE = 4


#  私有信息模块类型
RENDER_ANA_INTEL_DATA = 0x00000001
RENDER_MD = 0x00000002
RENDER_ADD_POS = 0x00000004
RENDER_ADD_PIC = 0x00000008
RENDER_FIRE_DETCET = 0x00000010
RENDER_TEM = 0x00000020
RENDER_TRACK_TEM = 0x00000040


FIRE_MAX_TEMP = 0x00000002
FIRE_MAX_TEMP_POSITION = 0x00000004
FIRE_DISTANCE = 0x00000008


TEM_REGION_LINE = 0x00000002
TEM_REGION_POINT = 0x00000004


class NET_DVR_VTPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), #  是否使能虚拟线圈，0-不使用，1-使用
        ("byIsDisplay", BYTE), #  是否显示虚拟线圈，0-不显示，1-显示
        ("byLoopPos", BYTE), # 晚间触发线圈的偏向：0-向上，1-向下
        ("bySnapGain", BYTE), # 抓拍增益
        ("dwSnapShutter", DWORD), # 抓拍快门速度
        ("struTrigCoordinate", NET_DVR_TRIGCOORDINATE), # 保留
        ("struRes", NET_DVR_TRIGCOORDINATE * MAX_VL_NUM),
        ("byTotalLaneNum", BYTE), # 视频触发的车道数1
        ("byPolarLenType", BYTE), # 偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。
        ("byDayAuxLightMode", BYTE), # 白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明
        ("byLoopToCalRoadBright", BYTE), # 用以计算路面亮度的车道(虚拟线圈)
        ("byRoadGrayLowTh", BYTE), # 路面亮度低阈值初始化值1
        ("byRoadGrayHighTh", BYTE), # 路面亮度高阈值初始化值140
        ("wLoopPosBias", WORD), # 晚间触发线圈位移30
        ("dwHfrShtterInitValue", DWORD), # 连续图像曝光时间的初始值2000
        ("dwSnapShtterInitValue", DWORD), # 抓拍图像曝光时间的初始值500
        ("dwHfrShtterMaxValue", DWORD), # 连续图像曝光时间的最大值20000
        ("dwSnapShtterMaxValue", DWORD), # 抓拍图像曝光时间的最大值1500
        ("dwHfrShtterNightValue", DWORD), # 晚间连续图像曝光时间的设置值3000
        ("dwSnapShtterNightMinValue", DWORD), # 晚间抓拍图像曝光时间的最小值3000
        ("dwSnapShtterNightMaxValue", DWORD), # 晚间抓拍图像曝光时间的最大值5000
        ("dwInitAfe", DWORD), # 增益的初始值200
        ("dwMaxAfe", DWORD), # 增益的最大值400
        ("wResolutionX", WORD), #  设备当前分辨率宽
        ("wResolutionY", WORD), #  设备当前分辨率高
        ("dwGainNightValue", DWORD), # 晚间增益，默认值70
        ("dwSceneMode", DWORD), # 场景模式， 详见SCENE_MODE
        ("dwRecordMode", DWORD), # 录像标志：0-不录像，1-录像
        ("struGeogLocation", NET_DVR_GEOGLOCATION), # 地址位置
        ("byTrigFlag", BYTE * MAX_VL_NUM), # 触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发
        ("byTrigSensitive", BYTE * MAX_VL_NUM), # 触发灵敏度，1-100
        ("byRes2", BYTE * 62),
    ]


LPNET_DVR_VTPARAM = POINTER(NET_DVR_VTPARAM)


class NET_DVR_SNAPENABLECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPlateEnable", BYTE), # 是否支持车牌识别，0-不支持，1-支持
        ("byRes1", BYTE * 2), # 保留
        ("byFrameFlip", BYTE), # 图像是否翻转 0-不翻转，1-翻转
        ("wFlipAngle", WORD), # 图像翻转角度 0,90,180,270
        ("wLightPhase", WORD), # 相位，取值范围[0, 360]
        ("byLightSyncPower", BYTE), # 是否信号灯电源同步，0-不同步；1-同步
        ("byFrequency", BYTE), # 信号频率
        ("byUploadSDEnable", BYTE), # 是否自动上传SD图片，0-否；1-是
        ("byPlateMode", BYTE), # 识别模式参数:0-视频触发,1-外部触发
        ("byUploadInfoFTP", BYTE), # 是否上传抓拍附加信息到FTP，0-否，1-是
        ("byAutoFormatSD", BYTE), # 是否自动格式化SD卡，0-否，1-是
        ("wJpegPicSize", WORD), # Jpeg图片大小[64-8196]
        ("bySnapPicResolution", BYTE), # 抓拍图片分辨率(与NET_DVR_COMPRESSION_INFO_V30中分辨率保持一致)
        ("byRes", BYTE * 55), # 保留
    ]


LPNET_DVR_SNAPENABLECFG = POINTER(NET_DVR_SNAPENABLECFG)


# ftp上传参数
# 可用来命名图片的相关元素
PICNAME_ITEM_DEV_NAME = 1 # 设备名
PICNAME_ITEM_DEV_NO = 2 # 设备号
PICNAME_ITEM_DEV_IP = 3 # 设备IP
PICNAME_ITEM_CHAN_NAME = 4 # 通道名
PICNAME_ITEM_CHAN_NO = 5 # 通道号
PICNAME_ITEM_TIME = 6 # 时间
PICNAME_ITEM_CARDNO = 7 # 卡号
PICNAME_ITEM_PLATE_NO = 8 # 车牌号码
PICNAME_ITEM_PLATE_COLOR = 9 # 车牌颜色
PICNAME_ITEM_CAR_CHAN = 10 # 车道号
PICNAME_ITEM_CAR_SPEED = 11 # 车辆速度
PICNAME_ITEM_CARCHAN = 12 # 监测点
PICNAME_ITEM_PIC_NUMBER = 13 # 图片序号
PICNAME_ITEM_CAR_NUMBER = 14 # 车辆序号
PICNAME_MAXITEM = 15
PICNAME_ITEM_SPEED_LIMIT_VALUES = 15 # 限速值
PICNAME_ITEM_ILLEGAL_CODE = 16 # 国标违法代码
PICNAME_ITEM_CROSS_NUMBER = 17 # 路口编号
PICNAME_ITEM_DIRECTION_NUMBER = 18 # 方向编号
# (3.7Ver)
PICNAME_ITEM_CAR_COLOR = 19 # 车身颜色
PICNAME_ITEM_PLATE_COORDINATE = 20 # 车牌坐标
PICNAME_ITEM_CAR_TYPE = 21 # 车辆类型
PICNAME_ITEM_VIOLATION_TYPE = 22 # 违规类型
PICNAME_ITEM_CUSTOM = 255 # 自定义
# 图片命名
# 命名规则：2013-09-27
PICNAME_ITEM_PARK_DEV_IP = 1 # 设备IP
PICNAME_ITEM_PARK_PLATE_NO = 2 # 车牌号码
PICNAME_ITEM_PARK_TIME = 3 # 时间
PICNAME_ITEM_PARK_INDEX = 4 # 车位编号
PICNAME_ITEM_PARK_STATUS = 5 # 车位状态
PICNAME_ITEM_BUILDING_NUMBER = 6 # 栋号单元号
PICNAME_ITEM_OUTDOOR_UNIT_ID = 7 # 门口机编号
PICNAME_ITEM_UNLOCK_TYPE = 8 # 开锁方式
PICNAME_ITEM_DEVICE_NAME = 9 # 设备名称
PICNAME_ITEM_PERIOD_NO = 10 # 期号
PICNAME_ITEM_DEV_INDEX = 11 # 设备编号
PICNAME_PREFIX = 32 # 图片名自定义前缀长度
# 图片命名扩展 2013-09-27
#  串口抓图设置
# DVR抓图参数配置（基线）
# 抓拍触发请求结构(保留)
class NET_DVR_MANUALSNAP(Structure):
    _fields_ = [
        ("byOSDEnable", BYTE), # 0-不关闭(默认)，1-关闭
        ("byLaneNo", BYTE), # 车道号, 范围为1-6，默认为1(抓拍机内部测试使用)
        ("byChannel", BYTE), # 通道号
        ("byRes", BYTE * 21), # 保留
    ]


LPNET_DVR_MANUALSNAP = POINTER(NET_DVR_MANUALSNAP)


class NET_DVR_SPRCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDefaultCHN", BYTE * MAX_CHJC_NUM), # 设备运行省份的汉字简写
        ("byPlateOSD", BYTE), # 0:不发送车牌彩色图,1:发送车牌彩色图
        ("bySendJPEG1", BYTE), # 0-不传送近景JPEG图,1-传送近景JPEG图
        ("bySendJPEG2", BYTE), # 0-不传送远景JPEG图,1-传送远景JPEG图
        ("wDesignedPlateWidth", WORD), # 车牌设计宽度
        ("byTotalLaneNum", BYTE), # 识别的车道数
        ("byRes1", BYTE), # 保留
        ("wRecognizedLane", WORD), # 识别的车道号，按位表示，bit0表示车道1是否识别，0-不识别，1-识别
        ("struLaneRect", NET_VCA_RECT * MAX_LANERECT_NUM), # 车道识别区域
        ("dwRecogMode", DWORD), # 识别的类型，
        # bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ；
        # bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别 ；
        # bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别；
        # bit3-农用车识别：0-不采用农用车识别，1-农用车识别；
        # bit4-模糊识别：0-不采用模糊识别，1-模糊识别；
        # bit5-帧定位或场定位：0-帧定位，1-场定位；
        # bit6-帧识别或场识别：0-帧识别，1-场识别；
        # bit7-晚上或白天：0-白天，1-晚上
        ("bySendPRRaw", BYTE), # 是否发送原图：0-不发送，1-发送
        ("bySendBinImage", BYTE), # 是否发送车牌二值图：0-不发送，1-发送
        ("byDelayCapture", BYTE), # 延时抓拍控制,单位：帧
        ("byUseLED", BYTE), # 使用LED控制，0-否，1-是
        ("byRes2", BYTE * 68), # 保留
    ]


LPNET_DVR_SPRCFG = POINTER(NET_DVR_SPRCFG)


class NET_DVR_PLCCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPlcEnable", BYTE), # 是否启用车牌亮度补偿（默认启用）：0-关闭，1-启用
        ("byPlateExpectedBright", BYTE), # 车牌的预期亮度（默认值50）, 范围[0, 100]
        ("byRes1", BYTE * 2), # 保留
        ("byTradeoffFlash", BYTE), # 是否考虑闪光灯的影响: 0 - 否  1 - 是(默认)
        # 使用闪光灯补光时, 如果考虑减弱闪光灯的亮度增强效应, 则需要设为1;否则为0
        ("byCorrectFactor", BYTE), # 纠正系数, 范围[0, 100], 默认值50 (在tradeoff_flash切换时,恢复默认值）
        ("wLoopStatsEn", WORD), # 是否该线圈的亮度，按位表示，0-不统计，1-统计
        ("byPlcBrightOffset", BYTE), #  车牌亮度补偿灵敏度(虚拟线圈模式起效)，取值范围1~100
        ("byRes", BYTE * 19),
    ]


LPNET_DVR_PLCCFG = POINTER(NET_DVR_PLCCFG)


class NET_DVR_DEVICESTATECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wPreviewNum", WORD), # 预览连接个数
        ("wFortifyLinkNum", WORD), # 布防连接个数
        ("struPreviewIP", NET_DVR_IPADDR * MAX_LINK), # 预览的用户IP地址
        ("struFortifyIP", NET_DVR_IPADDR * MAX_FORTIFY_NUM), # 布防连接的用户IP地址
        ("dwVideoFrameRate", DWORD), # 帧率：0-全部 1-1/16 2-1/8 3-1/4 4-1/2 5-1 6-2 7-4 8-6 9-8 10-10 11-12 12-16 13-20 14-15 15-18 16-22
        ("byResolution", BYTE), # 分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
        ("bySnapResolution", BYTE), # 抓拍分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
        ("byStreamType", BYTE), # 传输类型：0-主码流；1-子码流
        ("byTriggerType", BYTE), # 触发模式：0-视频触发；1-普通触发
        ("dwSDVolume", DWORD), # SD卡容量
        ("dwSDFreeSpace", DWORD), # SD卡剩余空间
        ("byDetectorState", BYTE * MAX_DRIVECHAN_NUM), # 车检器状态：0-未使用；1-正常；2-异常
        ("byDetectorLinkState", BYTE), # 车检器连接状态：0-未连接；1-连接
        ("bySDStatus", BYTE), # SD卡状态 0－活动；1－休眠；2－异常，3-无sd卡
        ("byFortifyLevel", BYTE * MAX_FORTIFY_NUM), # 布防等级，0-无，1-一等级（高），2-二等级（中），3-三等级（低）
        ("byRes2", BYTE * 116), # 保留
    ]


LPNET_DVR_DEVICESTATECFG = POINTER(NET_DVR_DEVICESTATECFG)


class NET_DVR_POSTEPOLICECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDistance", DWORD), # 线圈距离,单位cm，取值范围[0,20000]
        ("dwLightChan", DWORD * MAX_SIGNALLIGHT_NUM), # 信号灯通道号
        ("byCapSpeed", BYTE), # 标志限速，单位km/h，取值范围[0,255]
        ("bySpeedLimit", BYTE), # 限速值，单位km/h，取值范围[0,255]
        ("byTrafficDirection", BYTE), # 车流方向，0-由东向西，1-由西向东，2-由南向北，3-由北向南
        ("byRes1", BYTE), # 保留
        ("wLoopPreDist", WORD), # 触发延迟距离 ，单位：分米
        ("wTrigDelay", WORD), # 触发硬延时时间 ，单位：毫秒
        ("byRes", BYTE * 124), # 保留字节
    ]


LPNET_DVR_POSTEPOLICECFG = POINTER(NET_DVR_POSTEPOLICECFG)


# 信号灯异常检测
class NET_DVR_SIGNALLAMP_DETCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        # 绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
        ("byAbsTime", BYTE * 32),
        ("struAlarmCamIP", NET_DVR_IPADDR), # 报警摄像机IP
        ("dwPic1Len", DWORD), # 异常图片1长度
        ("dwPic2Len", DWORD), # 异常图片2长度
        ("*pPic1Buffer", CHAR), # 数据指针  叠加车道线图片
        ("*pPic2Buffer", CHAR), # 数据指针  叠加信号灯状态图片
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_SIGNALLAMP_DETCFG = POINTER(NET_DVR_SIGNALLAMP_DETCFG)


class NET_DVR_EXDEVDET_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwChannel", DWORD), # 通道号
        ("byExternalDevType", BYTE), #  0-无效值（保留）1-信号灯,2-闪光灯
        ("byRes", BYTE * 63), #  保留字节
    ]


LPNET_DVR_EXDEVDET_COND = POINTER(NET_DVR_EXDEVDET_COND)


class NET_DVR_EXDEVDET_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byExternalDevStatus", BYTE), #  0-正常1-异常
        ("byRes", BYTE * 63), #  保留字节
    ]


LPNET_DVR_EXDEVDET_CFG = POINTER(NET_DVR_EXDEVDET_CFG)


IPC_PROTOCOL_NUM = 50 # ipc 协议最大个数
# 协议类型
class NET_DVR_PROTO_TYPE(Structure):
    _fields_ = [
        ("dwType", DWORD), # ipc协议值
        ("byDescribe", BYTE * DESC_LEN), # 协议描述字段
    ]


LPNET_DVR_PROTO_TYPE = POINTER(NET_DVR_PROTO_TYPE)


# 协议列表
class NET_DVR_IPC_PROTO_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwProtoNum", DWORD), # 有效的ipc协议数目
        ("struProto", NET_DVR_PROTO_TYPE * IPC_PROTOCOL_NUM), # 有效的ipc协议
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_IPC_PROTO_LIST = POINTER(NET_DVR_IPC_PROTO_LIST)


# 协议列表V41
class NET_DVR_IPC_PROTO_LIST_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwProtoNum", DWORD), # 有效的ipc协议数目
        ("*pBuffer", BYTE), # 协议列表缓冲区, dwProtoNum 个NET_DVR_PROTO_TYPE结构
        ("dwBufferLen", DWORD), # 缓冲区长度
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_IPC_PROTO_LIST_V41 = POINTER(NET_DVR_IPC_PROTO_LIST_V41)


class NET_DVR_PTZPOS_INFO(Structure):
    _fields_ = [
        ("dwPanPos", DWORD), #  P参数（水平参数）
        ("dwTiltPos", DWORD), #  T参数（垂直参数）
        ("dwZoomPos", DWORD), #  Z参数（变倍参数）
    ]


LPNET_DVR_PTZPOS_INFO = POINTER(NET_DVR_PTZPOS_INFO)


# 人体特征识别结果结构体
class NET_VCA_HUMAN_FEATURE(Structure):
    _fields_ = [
        ("byAgeGroup", BYTE), # 年龄段,参见 HUMAN_AGE_GROUP_ENUM
        ("bySex", BYTE), # 性别, 0-表示“未知”（算法不支持）,1 – 男 , 2 – 女, 0xff-算法支持，但是没有识别出来
        ("byEyeGlass", BYTE), # 是否戴眼镜 0-表示“未知”（算法不支持）,1 – 不戴, 2 – 戴,0xff-算法支持，但是没有识别出来
        # 抓拍图片人脸年龄的使用方式，如byAge为15,byAgeDeviation为1,表示，实际人脸图片年龄的为14-16之间
        ("byAge", BYTE), # 年龄 0-表示“未知”（算法不支持）,0xff-算法支持，但是没有识别出来
        ("byAgeDeviation", BYTE), # 年龄误差值
        ("byEthnic", BYTE),
        ("byMask", BYTE), # 是否戴口罩 0-表示“未知”（算法不支持）,1 – 不戴, 2 –戴普通眼镜, 3 –戴墨镜,0xff-算法支持，但是没有识别出来
        ("bySmile", BYTE), # 是否微笑 0-表示“未知”（算法不支持）,1 – 不微笑, 2 – 微笑, 0xff-算法支持，但是没有识别出来
        ("byFaceExpression", BYTE), #  表情,参见FACE_EXPRESSION_GROUP_ENUM
        ("byBeard", BYTE), #  胡子, 0-不支持，1-没有胡子，2-有胡子，0xff-unknow表示未知,算法支持未检出
        ("byRace", BYTE),
        ("byHat", BYTE), #  帽子, 0-不支持,1-不戴帽子,2-戴帽子,0xff-unknow表示未知,算法支持未检出
        ("byRes", BYTE * 4), # 保留
    ]


LPNET_VCA_HUMAN_FEATURE = POINTER(NET_VCA_HUMAN_FEATURE)


# 物体颜色属性
class NET_DVR_OBJECT_FEATURE(Structure):
    _fields_ = [
        ("byColorRatel", BYTE), # 颜色在移动物体中的占比阈值
        ("byRed", BYTE), #  RGB颜色三分量中的红色
        ("byGreen", BYTE), #  RGB颜色三分量中的绿色
        ("byBlue", BYTE), #  RGB颜色三分量中的兰色
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_OBJECT_FEATURE = POINTER(NET_DVR_OBJECT_FEATURE)


# 组合搜索条件
class NET_DVR_ADVANCE_COND_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 36), # 联合体长度
        ("struHumanFeature", NET_VCA_HUMAN_FEATURE), # 人体属性
        ("struObjectFeature", NET_DVR_OBJECT_FEATURE), # 物体属性
    ]


LPNET_DVR_ADVANCE_COND_UNION = POINTER(NET_DVR_ADVANCE_COND_UNION)


MAX_ALERTLINE_NUM = 8 # 最大警戒线条数
class NET_DVR_TRAVERSE_PLANE_SEARCHCOND(Structure):
    _fields_ = [
        ("struVcaTraversePlane", NET_VCA_TRAVERSE_PLANE * MAX_ALERTLINE_NUM), # 穿越境界面参数
        ("dwPreTime", DWORD), # 智能报警提前时间 单位:秒
        ("dwDelayTime", DWORD), # 智能报警延迟时间 单位:秒
        ("struPTZPosInfo", NET_DVR_PTZPOS_INFO), # PTZ坐标信息
        ("byAdvanceType", BYTE), # 组合方式，0-不使用组号，1-和人脸属性组合，2-与物体颜色占比组合
        ("byRes1", BYTE * 3), # 保留
        ("uAdvanceCond", NET_DVR_ADVANCE_COND_UNION), # 组合属性
        ("byRes", BYTE * 5604), # 保留
    ]


LPNET_DVR_TRAVERSE_PLANE_SEARCHCOND = POINTER(NET_DVR_TRAVERSE_PLANE_SEARCHCOND)


MAX_INTRUSIONREGION_NUM = 8 # 最大区域数数
class NET_DVR_INTRUSION_SEARCHCOND(Structure):
    _fields_ = [
        ("struVcaIntrusion", NET_VCA_INTRUSION * MAX_INTRUSIONREGION_NUM), # 入侵区域
        ("dwPreTime", DWORD), # 智能报警提前时间 单位:秒
        ("dwDelayTime", DWORD), # 智能报警延迟时间 单位:秒
        ("struPTZPosInfo", NET_DVR_PTZPOS_INFO), # PTZ坐标信息
        ("byAdvanceType", BYTE), # 组合方式，0-不使用组号，1-和人脸属性组合，2-与物体颜色占比组合
        ("byRes1", BYTE * 3), # 保留
        ("uAdvanceCond", NET_DVR_ADVANCE_COND_UNION), # 组合属性
        ("byRes", BYTE * 5348), # 保留
    ]


LPNET_DVR_INTRUSION_SEARCHCOND = POINTER(NET_DVR_INTRUSION_SEARCHCOND)


class NET_DVR_FACEDETECTION_SEARCHCOND(Structure):
    _fields_ = [
        ("struFacePolygon", NET_VCA_POLYGON), # 识别区域
        ("dwPreTime", DWORD), # 智能录像提前时间 单位:秒
        ("dwDelayTime", DWORD), # 智能录像延迟时间 单位:秒
        ("byRes", BYTE * 5972), # 保留
    ]


LPNET_DVR_FACEDETECTION_SEARCHCOND = POINTER(NET_DVR_FACEDETECTION_SEARCHCOND)


class NET_DVR_AREA_SMARTSEARCH_COND_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 6144), # 结构体长度
        ("byMotionScope", BYTE * 64), # 侦测区域 0-96位表示64行，共有96*64个小宏块，1-是移动侦测区域，0-非移动侦测区域
        ("struTraversPlaneCond", NET_DVR_TRAVERSE_PLANE_SEARCHCOND), # 越界侦测
        ("struIntrusionCond", NET_DVR_INTRUSION_SEARCHCOND), # 区域入侵
        ("struFaceSnapCond", NET_DVR_FACEDETECTION_SEARCHCOND), # 人脸侦测条件
    ]


LPNET_DVR_AREA_SMARTSEARCH_COND_UNION = POINTER(NET_DVR_AREA_SMARTSEARCH_COND_UNION)

# 智能搜索参数
class NET_DVR_SMART_SEARCH_PARAM(Structure):
    _fields_ = [
        ("byChan", BYTE), # 通道号
        ("bySearchCondType", BYTE), # 智能查找联合体NET_DVR_AREA_SMARTSEARCH_COND_UNION的索引
        # 0-移动侦测区域 ，1-越界侦测， 2-区域入侵, 3-人脸侦测
        ("wChan", WORD), # 通道号， 该字段是对byChan的扩展，使用该字段后byChan可以不再使用
        ("struStartTime", NET_DVR_TIME), # 录像开始的时间
        ("struEndTime", NET_DVR_TIME), # 录像停止的时间
        ("uSmartSearchCond", NET_DVR_AREA_SMARTSEARCH_COND_UNION), # 智能查找条件
        ("bySensitivity", BYTE), # 移动侦测搜索灵敏度,1    >80%  2 40%~80%  3 1%~40%
        ("byRes2", BYTE * 11),
    ]


LPNET_DVR_SMART_SEARCH_PARAM = POINTER(NET_DVR_SMART_SEARCH_PARAM)


class NET_DVR_SMART_SEARCH_PARAM_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struIDInfo", NET_DVR_STREAM_INFO), # 通道信息
        ("bySearchCondType", BYTE), # 智能查找联合体索引 0-侦测区域, 1-越界侦测, 2-区域入侵,3-人脸侦测, 4-车牌检测
        ("bySensitivity", BYTE), # 侦测区域动态分析灵敏度,1-100
        ("byRes1", BYTE * 2),
        ("struStartTime", NET_DVR_TIME_EX),
        ("struEndTime", NET_DVR_TIME_EX),
        ("uSmartSearchCond", NET_DVR_AREA_SMARTSEARCH_COND_UNION), # 智能查找条件
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区，byISO8601为1时有效
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区，byISO8601为1时有效
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区，byISO8601为1时有效
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区，byISO8601为1时有效
        ("byRes2", BYTE * 251),
    ]


LPNET_DVR_SMART_SEARCH_PARAM_V40 = POINTER(NET_DVR_SMART_SEARCH_PARAM_V40)


class NET_DVR_SMART_SEARCH_RET(Structure):
    _fields_ = [
        ("struStartTime", NET_DVR_TIME), # 移动侦测报警开始的时间
        ("struEndTime", NET_DVR_TIME), # 事件停止的时间
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("byRes", BYTE * 59),
    ]


LPNET_DVR_SMART_SEARCH_RET = POINTER(NET_DVR_SMART_SEARCH_RET)


#  IPSAN 文件目录查找
class NET_DVR_IPSAN_SERACH_PARAM(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), #  IPSAN IP地址
        ("wPort", WORD), #  IPSAN  端口
        ("byRes", BYTE * 10), #  保留字节
    ]


LPNET_DVR_IPSAN_SERACH_PARAM = POINTER(NET_DVR_IPSAN_SERACH_PARAM)


class NET_DVR_IPSAN_SERACH_RET(Structure):
    _fields_ = [
        ("byDirectory", BYTE * 128), #  返回的文件目录
        ("byRes", BYTE * 20),
    ]


LPNET_DVR_IPSAN_SERACH_RET = POINTER(NET_DVR_IPSAN_SERACH_RET)


# DVR设备参数
MAX_ZEROCHAN_NUM = 16
# 零通道压缩配置参数
class NET_DVR_ZEROCHANCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byEnable", BYTE), # 0-停止零通道编码，1-表示启用零通道编码
        ("byRes1", BYTE * 3), # 保留
        ("dwVideoBitrate", DWORD), # 视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
        # 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
        # 最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
        ("dwVideoFrameRate", DWORD), # 帧率 0-全部 1-1/16 2-1/8 3-1/4 4-1/2 5-1 6-2 7-4 8-6 9-8 10-10 11-12 12-16 13-20, V2.0增加14-15, 15-18, 16-22
        ("byRes2", BYTE * 32), # 保留
    ]


LPNET_DVR_ZEROCHANCFG = POINTER(NET_DVR_ZEROCHANCFG)


# 零通道缩放参数
class NET_DVR_ZERO_ZOOMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("struPoint", NET_VCA_POINT), # 画面中的坐标点
        ("byState", BYTE), # 现在的状态，0-缩小，1-放大
        ("byPreviewNumber", BYTE), # 预览数目,0-1画面,1-4画面,2-9画面,3-16画面 该参数只读
        ("byPreviewSeq", BYTE * MAX_WINDOW_V30), # 画面通道信息 该参数只读
        ("byRes", BYTE * 30), # 保留
    ]


LPNET_DVR_ZERO_ZOOMCFG = POINTER(NET_DVR_ZERO_ZOOMCFG)


DESC_LEN_64 = 64
class NET_DVR_SNMPCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byEnable", BYTE), # 0-禁用SNMP，1-表示启用SNMP
        ("byRes1", BYTE * 3), # 保留
        ("wVersion", WORD), # snmp 版本  v1 = 1, v2 =2, v3 =3，设备目前不支持 v3
        ("wServerPort", WORD), # snmp消息接收端口，默认 161
        ("byReadCommunity", BYTE * NAME_LEN), # 读共同体，最多31,默认"public"
        ("byWriteCommunity", BYTE * NAME_LEN), # 写共同体,最多31 字节,默认 "private"
        ("byTrapHostIP", BYTE), # 自陷主机ip地址描述，支持IPV4 IPV6和域名描述
        ("wTrapHostPort", WORD), #  trap主机端口
        ("byTrapName", BYTE * NAME_LEN),
        ("byRes2", BYTE * 70), # 保留
    ]


LPNET_DVR_SNMPCFG = POINTER(NET_DVR_SNMPCFG)


class NET_DVR_SNMPv3_USER(Structure):
    _fields_ = [
        ("byUserName", BYTE * NAME_LEN), #  用户名
        ("bySecLevel", BYTE), #  安全级别 0-保留 1-无校验 2-无授权校验 3-授权校验
        ("byAuthtype", BYTE), #  认证类型 0-MD5认证 1-SHA认证 2: none
        ("byPrivtype", BYTE), #  0: DES 1: AES 2: none
        ("byRes", BYTE * 5),
        ("byAuthpass", BYTE * PASSWD_LEN), #  认证密码
        ("byPrivpass", BYTE * PASSWD_LEN), #  加密密码
    ]


LPNET_DVR_SNMPv3_USER = POINTER(NET_DVR_SNMPv3_USER)


#  snmpv30
class NET_DVR_SNMPCFG_V30(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byEnableV1", BYTE), # 0-禁用SNMP V1，1-表示启用SNMP V1
        ("byEnableV2", BYTE), # 0-禁用SNMP V2，1-表示启用SNMP V2
        ("byEnableV3", BYTE), # 0-禁用SNMP V3，1-表示启用SNMP V3
        ("byRes1", BYTE * 3),
        ("wServerPort", WORD), # snmp消息接收端口，默认 161
        ("byReadCommunity", BYTE * NAME_LEN), # 读共同体，最多31,默认"public"
        ("byWriteCommunity", BYTE * NAME_LEN), # 写共同体,最多31 字节,默认 "private"
        ("byTrapHostIP", BYTE), # 自陷主机ip地址描述，支持IPV4 IPV6和域名描述
        ("wTrapHostPort", WORD), #  trap主机端口
        ("byRes2", BYTE * 2),
        ("struRWUser", NET_DVR_SNMPv3_USER), #  读写用户
        ("struROUser", NET_DVR_SNMPv3_USER), #  只读用户
        ("byTrapName", BYTE * NAME_LEN),
    ]


LPNET_DVR_SNMPCFG_V30 = POINTER(NET_DVR_SNMPCFG_V30)


PROCESSING = 0 # 正在处理
PROCESS_SUCCESS = 100 # 过程完成
PROCESS_EXCEPTION = 400 # 过程异常
PROCESS_FAILED = 500 # 过程失败
PROCESS_QUICK_SETUP_PD_COUNT = 501 # 一键配置至少3块硬盘
SOFTWARE_VERSION_LEN = 48
NET_SDK_DEVICE_MODEL_LEN = 24 # 设备型号长度
class NET_DVR_SADPINFO(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), #  设备IP地址
        ("wPort", WORD), #  设备端口号
        ("wFactoryType", WORD), #  设备厂家类型
        ("chSoftwareVersion", CHAR * SOFTWARE_VERSION_LEN),
        ("chSerialNo", CHAR * 16), #  序列号
        ("wEncCnt", WORD), #  编码通道个数
        ("byMACAddr", BYTE * MACADDR_LEN), #  MAC 地址
        ("struSubDVRIPMask", NET_DVR_IPADDR), #  DVR IP地址掩码
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关
        ("struDnsServer1IpAddr", NET_DVR_IPADDR), #  域名服务器1的IP地址
        ("struDnsServer2IpAddr", NET_DVR_IPADDR), #  域名服务器2的IP地址
        ("byDns", BYTE),
        ("byDhcp", BYTE),
        ("szGB28181DevID", BYTE * DEV_ID_LEN), # GB28181协议接入时的设备ID，用于IPC以GB28181协议接入
        ("byActivated", BYTE), # 0-无效，1-已激活，2-未激活
        ("byDeviceModel", BYTE * NET_SDK_DEVICE_MODEL_LEN), # 设备型号
        ("byRes", BYTE * 101), #  保留字节
    ]


LPNET_DVR_SADPINFO = POINTER(NET_DVR_SADPINFO)


MAX_SADP_NUM = 256 #  搜索到设备最大数目
class NET_DVR_SADPINFO_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), #   结构大小
        ("wSadpNum", WORD), #  搜索到设备数目
        ("byRes", BYTE * 6), #  保留字节
        ("struSadpInfo", NET_DVR_SADPINFO * MAX_SADP_NUM), #  搜索
    ]


LPNET_DVR_SADPINFO_LIST = POINTER(NET_DVR_SADPINFO_LIST)


class NET_DVR_SADP_VERIFY(Structure):
    _fields_ = [
        ("chPassword", CHAR * PASSWD_LEN),
        ("struOldIP", NET_DVR_IPADDR),
        ("wOldPort", WORD),
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_SADP_VERIFY = POINTER(NET_DVR_SADP_VERIFY)


# 获取备份设备信息接口定义
DESC_LEN_32 = 32 # 描述字长度
MAX_NODE_NUM = 256 # 节点个数
class NET_DVR_DESC_NODE(Structure):
    _fields_ = [
        ("iValue", INT),
        ("byDescribe", BYTE * DESC_LEN_32), # 描述字段
        ("dwFreeSpace", DWORD), # 获取磁盘列表专用,单位为M
        ("byRes", BYTE * 12), # 保留
    ]


LPNET_DVR_DESC_NODE = POINTER(NET_DVR_DESC_NODE)


class NET_DVR_DISKABILITY_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwNodeNum", DWORD), # 能力结点个数
        ("struDescNode", NET_DVR_DESC_NODE * MAX_NODE_NUM), # 描述参数
    ]


LPNET_DVR_DISKABILITY_LIST = POINTER(NET_DVR_DISKABILITY_LIST)


# 备份进度列表
BACKUP_SUCCESS = 100 # 备份完成
BACKUP_CHANGE_DEVICE = 101 # 备份设备已满，更换设备继续备份
BACKUP_SEARCH_DEVICE = 300 # 正在搜索备份设备
BACKUP_SEARCH_FILE = 301 # 正在搜索录像文件
BACKUP_SEARCH_LOG_FILE = 302 # 正在搜索日志文件
BACKUP_CHANGE_DISK = 303 # 正在更换光盘
BACKUP_EXCEPTION = 400 # 备份异常
BACKUP_FAIL = 500 # 备份失败
BACKUP_TIME_SEG_NO_FILE = 501 # 时间段内无录像文件
BACKUP_NO_RESOURCE = 502 # 申请不到资源
BACKUP_DEVICE_LOW_SPACE = 503 # 备份设备容量不足
BACKUP_DISK_FINALIZED = 504 # 刻录光盘封盘
BACKUP_DISK_EXCEPTION = 505 # 刻录光盘异常
BACKUP_DEVICE_NOT_EXIST = 506 # 备份设备不存在
BACKUP_OTHER_BACKUP_WORK = 507 # 有其他备份操作在进行
BACKUP_USER_NO_RIGHT = 508 # 用户没有操作权限
BACKUP_OPERATE_FAIL = 509 # 操作失败
BACKUP_NO_LOG_FILE = 510 # 硬盘中无日志
# 备份过程接口定义
class NET_DVR_BACKUP_NAME_PARAM(Structure):
    _fields_ = [
        ("dwFileNum", DWORD), # 文件个数
        ("struFileList", NET_DVR_FINDDATA_V30 * MAX_RECORD_FILE_NUM), # 文件列表
        ("byDiskDes", BYTE * DESC_LEN_32), # 备份磁盘描述
        ("byWithPlayer", BYTE), # 是否备份播放器
        ("byContinue", BYTE), # 是否继续备份 0不继续 1继续
        ("byRes", BYTE * 34), # 保留
    ]


LPNET_DVR_BACKUP_NAME_PARAM = POINTER(NET_DVR_BACKUP_NAME_PARAM)


class NET_DVR_BACKUP_TIME_PARAM(Structure):
    _fields_ = [
        ("lChannel", LONG), # 按时间备份的通道
        ("struStartTime", NET_DVR_TIME), # 备份的起始时间
        ("struStopTime", NET_DVR_TIME), # 备份的终止时间
        ("byDiskDes", BYTE * DESC_LEN_32), # 备份磁盘描述
        ("byWithPlayer", BYTE), # 是否备份播放器
        ("byContinue", BYTE), # 是否继续备份 0不继续 1继续
        ("byDrawFrame", BYTE), # 0 不抽帧  1 抽帧
        ("byUseBackCfgParam", BYTE), # 使用备份配置中的参数，0-无效，1-启用(启用后，通道号无效)，2-不启用
        ("dwStreamType", DWORD), # 备份码流类型，按位表示
        # &0x1-表示主码流
        # &0x2-表示子码流
        # &0x4-表示码流三
        ("byRes", BYTE * 28), #  保留字节
    ]


LPNET_DVR_BACKUP_TIME_PARAM = POINTER(NET_DVR_BACKUP_TIME_PARAM)


COMPRESSION_STREAM_ABILITY = 0
MAIN_RESOLUTION_ABILITY = 1
SUB_RESOLUTION_ABILITY = 2
EVENT_RESOLUTION_ABILITY = 3
FRAME_ABILITY = 4
BITRATE_TYPE_ABILITY = 5
BITRATE_ABILITY = 6
THIRD_RESOLUTION_ABILITY = 7
STREAM_TYPE_ABILITY = 8
PIC_QUALITY_ABILITY = 9
INTERVAL_BPFRAME_ABILITY = 10
VIDEO_ENC_ABILITY = 11
AUDIO_ENC_ABILITY = 12
VIDEO_ENC_COMPLEXITY_ABILITY = 13
FORMAT_ABILITY = 14


# 能力列表
class NET_DVR_ABILITY_LIST(Structure):
    _fields_ = [
        ("dwAbilityType", DWORD), # 能力类型 COMPRESSION_ABILITY_TYPE
        ("byRes", BYTE * 32), # 保留字节
        ("dwNodeNum", DWORD), # 能力结点个数
        ("struDescNode", NET_DVR_DESC_NODE * MAX_NODE_NUM), # 描述参数
    ]


LPNET_DVR_ABILITY_LIST = POINTER(NET_DVR_ABILITY_LIST)


MAX_ABILITYTYPE_NUM = 12 # 最大能力项
#  压缩参数能力列表
class NET_DVR_COMPRESSIONCFG_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwAbilityNum", DWORD), # 能力类型个数
        ("struAbilityNode", NET_DVR_ABILITY_LIST * MAX_ABILITYTYPE_NUM), # 描述参数
    ]


LPNET_DVR_COMPRESSIONCFG_ABILITY = POINTER(NET_DVR_COMPRESSIONCFG_ABILITY)

SUPPORT_PD_NUM = 16
SUPPORT_ARRAY_NUM = 8
SUPPORT_VD_NUM = 128
SUPPORT_PD_NUM_ = 16
SUPPORT_PD_NUM_PARTTWO = 8
RAID0 = 1
        # RAID1,
        # RAID10,
        # RAID1E,
        # RAID5,
        # RAID6,
        # RAID50,
        # JBOD,
        # RAID60


HD_TYPE_SATA = 0x01
HD_TYPE_PATA = 0x02
HD_TYPE_SAS = 0x04
HD_TYPE_ATAPI = 0x08
HD_TYPE_TAPE = 0x10
HD_TYPE_SES = 0x20


#  按位表示 位为0表示不支持  1表示支持
RAID0_ABILITY = 0x0001
RAID1_ABILITY = 0x0002
RAID10_ABILITY = 0x0004
RAID1E_ABILITY = 0x0008
RAID5_ABILITY = 0x0010
RAID6_ABILITY = 0x0020
RAID50_ABILITY = 0x0040
JBOD_ABILITY = 0x0080
RAID60_ABILITY = 0x0100


#  物理磁盘
class NET_DVR_PHY_DISK_INFO(Structure):
    _fields_ = [
        ("wPhySlot", WORD), #  硬盘槽位
        ("byType", BYTE), #  硬盘信息；0 普通，1全局热备，2-阵列热备 3-阵列盘
        ("byStatus", BYTE), #  硬盘状态；  0-正常 1-降级 2-已删除 3-磁盘丢失 4-下线 5-次正常 6-外来 7-异常 8-SMART状态异常 9-休眠 10-有坏块,11-SMR硬盘不支持阵列功能,0xff-不存在
        ("byMode", BYTE * 40), #  硬盘类型 字符串
        ("dwHCapacity", DWORD), #   磁盘总量高32位 单位kb
        ("dwLCapacity", DWORD), #   磁盘总量低32位
        ("byArrrayName", BYTE * MAX_NAMELEN),
        ("wArrayID", WORD), #  所属阵列ID
        ("byArrayInformation", BYTE), #  是否含有阵列信息：0 否，1是
        ("byRes", BYTE * 101), #  保留字节
    ]


LPNET_DVR_PHY_DISK_INFO = POINTER(NET_DVR_PHY_DISK_INFO)


class NET_DVR_PHY_DISK_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCount", DWORD),
        ("struPhyDiskInfo", NET_DVR_PHY_DISK_INFO * SUPPORT_PD_NUM),
    ]


LPNET_DVR_PHY_DISK_LIST = POINTER(NET_DVR_PHY_DISK_LIST)


BGA_REBUILD = 0x01
BGA_CONSISTENCY_FIX = 0x02
BGA_CONSISTENCY_CHECK = 0x04
BGA_INIT_QUICK = 0x08
BGA_INIT_BACK = 0x10
BGA_MIGRATION = 0x20
BGA_INIT_FORE = 0x40
BGA_COPYBACK = 0x80


BGA_STATE_NONE = 0
        # BGA_STATE_RUNNING,         后台任务正在运行
        # BGA_STATE_ABORTED,         后台任务取消
        # BGA_STATE_PAUSED           后台任务暂停


class NET_DVR_BGA_INFO(Structure):
    _fields_ = [
        ("byBga", BYTE), #  后台任务及类型
        ("byBgaState", BYTE), # 函数返回值--后台任务状态
        ("wBgaPercentage", WORD), # 函数返回值--后台任务执行百分比
        ("byRes", BYTE * 4), #  保留字节
    ]


LPNET_DVR_BGA_INFO = POINTER(NET_DVR_BGA_INFO)


#  阵列信息
class NET_DVR_ARRAY_INFO(Structure):
    _fields_ = [
        ("wArrayID", WORD), #  阵列ID
        ("byRaidMode", BYTE), #  raid模式  参照RAID_MODE
        ("byStatus", BYTE), #  0-在线 1-磁盘丢失 2-下线 3-降级 4-异常 5-次正常 6-外来盘  7-已删除 8-SMART状态异常 0xff-不存在
        ("dwHCapacity", DWORD), #  阵列容量高32位
        ("dwLCapacity", DWORD), #  阵列容量低32位
        ("dwHFreeSpace", DWORD), #  阵列剩余空间高32位
        ("dwLFreeSpace", DWORD), #  阵列剩余空间高32位
        ("byArrayName", BYTE * MAX_NAMELEN), #  阵列名称
        ("byPDCount", BYTE), #  物理磁盘数目
        ("bySpareCount", BYTE), #  热备数目
        ("byRes1", BYTE * 2),
        ("wPDSlots", WORD * SUPPORT_PD_NUM), #  物理磁盘索引
        ("wSparePDSlots", WORD * SUPPORT_PD_NUM), #  热备磁盘索引
        ("struBgaInfo", NET_DVR_BGA_INFO), #  后台任务运行状态
        ("wPDSlotsPartTwo", WORD * SUPPORT_PD_NUM_PARTTWO), # 物理磁盘索引扩展，0表示无效
        ("wSparePDSlotsPartTwo", WORD * SUPPORT_PD_NUM_PARTTWO), #  热备磁盘索引扩展，0表示无效
        ("byRes2", BYTE * 48), #  保留字节
    ]


LPNET_DVR_ARRAY_INFO = POINTER(NET_DVR_ARRAY_INFO)


class NET_DVR_ARRAY_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwCount", DWORD), #  阵列个数
        ("struArrayInfo", NET_DVR_ARRAY_INFO * SUPPORT_ARRAY_NUM),
    ]


LPNET_DVR_ARRAY_LIST = POINTER(NET_DVR_ARRAY_LIST)


# 虚拟磁盘信息
class NET_DVR_VD_INFO(Structure):
    _fields_ = [
        ("wSlot", WORD), # 虚拟磁盘槽位
        ("byStatus", BYTE), #  状态0-正常 1-降级 2-已删除 3-磁盘丢失 4-下线 5-次正常 6-外来 7-异常 8-SMART状态异常 0xff-不存在
        ("byRaidMode", BYTE), #  Raid 模式 参照 RAID_MODE
        ("wArrayID", WORD), #  所属阵列ID
        ("byRepair", BYTE), #  是否需要修复 0 不需要 1需要
        ("byUsage", BYTE), # LUN卷的使用方式  0-IPSAN 1-FCSAN 2-DVR网盘 3-NAS 4-录像卷
        ("byArrayName", BYTE * MAX_NAMELEN),
        ("byName", BYTE * MAX_NAMELEN), #  虚拟磁盘名名称
        ("dwHCapacity", DWORD), #  虚拟磁盘容量高32位
        ("dwLCapacity", DWORD), #  虚拟磁盘容量低32位
        ("dwHFreeSpace", DWORD), #  虚拟磁盘剩余空间高32位
        ("dwLFreeSpace", DWORD), #  虚拟磁盘剩余空间低32位
        ("struBgaInfo", NET_DVR_BGA_INFO), #  后台运行状态
        ("dwBlockSize", DWORD), # 最小存储单元块大小
        ("struWarrantIP", NET_DVR_IPADDR), #  授权的DVR网盘IP
        ("szArrayGroup", CHAR * NAME_LEN), # 使用的阵列名称组，以逗号隔开，为空则使用默认阵列
        ("byRes", BYTE * 20),
    ]


LPNET_DVR_VD_INFO = POINTER(NET_DVR_VD_INFO)


class NET_DVR_VD_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwCount", DWORD), #  虚拟磁盘个数
        ("struVDInfo", NET_DVR_VD_INFO * SUPPORT_VD_NUM), # 虚拟磁盘数组
    ]


LPNET_DVR_VD_LIST = POINTER(NET_DVR_VD_LIST)


class NET_DVR_ADAPTER_VERSION(Structure):
    _fields_ = [
        ("wMajorVersion", WORD),
        ("wMinorVersion", WORD),
        ("wRevisionNumber", WORD),
        ("wBuildNumber", WORD),
    ]


LPNET_DVR_ADAPTER_VERSION = POINTER(NET_DVR_ADAPTER_VERSION)


class NET_DVR_VD_SLOT(Structure):
    _fields_ = [
        ("wVDSlot", WORD),
        ("byAlloc", BYTE), #  是否已经分配
        ("byRes", BYTE * 5),
        ("dwHVDSlotSize", DWORD), #  虚拟磁盘空间大小高32位
        ("dwLVDSlotSize", DWORD), #  虚拟磁盘空间大小低32位
    ]


LPNET_DVR_VD_SLOT = POINTER(NET_DVR_VD_SLOT)


class NET_DVR_ARRAY_SPACE_ALLOC_INFO(Structure):
    _fields_ = [
        ("byVDSlotCount", BYTE), # current number of slots in DG
        ("byRes1", BYTE * 3), #  保留字节
        ("struVDSlots", NET_DVR_VD_SLOT * SUPPORT_VD_NUM),
    ]


LPNET_DVR_ARRAY_SPACE_ALLOC_INFO = POINTER(NET_DVR_ARRAY_SPACE_ALLOC_INFO)


class NET_DVR_RAID_ADAPTER_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struVersion", NET_DVR_ADAPTER_VERSION), #  适配器版本号
        ("bySlotCount", BYTE), # 适配器槽位数
        ("bySupportMigrate", BYTE), #  迁移(1-支持  0-不支持)
        ("bySupportExpand", BYTE), #  扩容  (1-支持  0-不支持)
        ("bySupportRebuild", BYTE), #  是否支持重建阵列 (1、支持 0-不支持)
        ("wSlotSupportType", WORD), #   按位表示 HD_SUPPORT_TYPE
        ("wSupportRaidType", WORD), #  支持Raid 类型 按位表示
        ("byAutoRebuild", BYTE), #  0 不自动重建 1自动重建 可设
        ("byRes", BYTE * 27), #  保留字节
    ]


LPNET_DVR_RAID_ADAPTER_INFO = POINTER(NET_DVR_RAID_ADAPTER_INFO)


class NET_DVR_OPERATE_ARRAY_PARAM(Structure):
    _fields_ = [
        # 是否一键创建  如果为一键创建，则创建时时候的之需要array名称，而不需要其他参数
        # 其他参数有设备自行创建
        ("byRaidMode", BYTE), #  创建/迁移时Raid的类型
        ("byPDCount", BYTE), #  物理磁盘数目
        ("wArrayID", WORD), #  迁移或者重建时需要指出阵列ID
        ("wPDSlots", WORD * SUPPORT_PD_NUM), #  物理磁盘
        ("byName", BYTE * MAX_NAMELEN), #  array 名称
        ("byInitMode", BYTE), # 初始化方式
        ("byRes1", BYTE),
        ("wPDSlotsPartTwo", WORD * SUPPORT_PD_NUM_PARTTWO), # 物理磁盘信息
        ("byRes2", BYTE * 2),
    ]


LPNET_DVR_OPERATE_ARRAY_PARAM = POINTER(NET_DVR_OPERATE_ARRAY_PARAM)


INIT_QUICK = 0 # 快速初始化
INIT_FULLFOREGROUND = 1 # 完全初始化(前台)
INIT_FULLBACKGROUND = 2 # 完全初始化(后台)
class NET_DVR_OPERATE_VD_PARAM(Structure):
    _fields_ = [
        ("wArrayID", WORD), #  阵列ID
        ("bySlot", BYTE), #  创建虚拟磁盘指定槽位
        ("byInitType", BYTE), #  创建虚拟磁盘时初始化类型 0 - 快速初始化 1 - 前台完全初始化 2 - 后台完全初始化
        ("dwHCapacity", DWORD), #  虚拟磁盘大小高32位
        ("dwLCapacity", DWORD), #  虚拟磁盘大小低32位
        ("byName", BYTE * MAX_NAMELEN), #  虚拟磁盘名称
        ("byRes2", BYTE * 16), #  保留字节
    ]


LPNET_DVR_OPERATE_VD_PARAM = POINTER(NET_DVR_OPERATE_VD_PARAM)


class NET_DVR_SPARE_DISK_PARAM(Structure):
    _fields_ = [
        ("wPDSlot", WORD), #  物理磁盘槽位
        ("wArrayID", WORD), #  所属的阵列
        ("bySpareType", BYTE), #  热备类型 1-全局热备  2 指定阵列  当为指定阵列的时候需要指出所属阵列的ID
        ("byRes", BYTE * 7), #  保留字节
    ]


LPNET_DVR_SPARE_DISK_PARAM = POINTER(NET_DVR_SPARE_DISK_PARAM)


MATRIX_MAXDECSUBSYSTEMCHAN = 4 # 视频综合平台解码子系统通道号
# 获取解码子系统关联信息
class NET_DVR_DECSUBSYSTEMJIONSTATUS(Structure):
    _fields_ = [
        ("byJoinStatus", BYTE), # 关联状态，0-没有关联，1-已经关联
        ("byJoinSubSystem", BYTE), # 所关联子系统槽位号
        ("byJoinDispNum", BYTE), # 所关联显示通道号
        ("byJoinSubWindowNum", BYTE), # 所关联子窗口号
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_DECSUBSYSTEMJIONSTATUS = POINTER(NET_DVR_DECSUBSYSTEMJIONSTATUS)


class NET_DVR_SINGLESUBSYSTEMJOININFO(Structure):
    _fields_ = [
        ("bySubSystemType", BYTE), # 子系统类型，0-无，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统,5-码分子系统，6-报警子系统
        ("byConnectStatus", BYTE), # 级联系统关联状态，1-连接正常，2-连接断开
        ("byMatrixNum", BYTE), # 级联视频综合平台号，子系统类型是3或4时可用
        ("bySubSystemNum", BYTE), # 级联子系统槽位号，0~79，子系统类型是3或4时可用
        ("struDecSub", NET_DVR_DECSUBSYSTEMJIONSTATUS),
        ("byBindStatus", BYTE), # 绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_SINGLESUBSYSTEMJOININFO = POINTER(NET_DVR_SINGLESUBSYSTEMJOININFO)


class NET_DVR_ALLDECSUBSYSTEMJOININFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSingleSubSystemJoinInfo", NET_DVR_SINGLESUBSYSTEMJOININFO * MAX_SUBSYSTEM_NUM), # 80
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_ALLDECSUBSYSTEMJOININFO = POINTER(NET_DVR_ALLDECSUBSYSTEMJOININFO)


# 2010-04-13 增加NAT功能相关配置
class NET_DVR_NATASSOCIATECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNatIpAddress", NET_DVR_NETCFG_V30 * 2), # NAT IP地址
        ("byNATEnable", BYTE), # 是否启用NAT功能，0-不启用，非0-启用
        ("byNATCfgMode", BYTE), # NAT配置模式，0-手动分配，1-自动分配
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_NATASSOCIATECFG = POINTER(NET_DVR_NATASSOCIATECFG)


# 2010-06-01 视频综合平台报警配置
class NET_DVR_TEMPERATUREALARMCFG(Structure):
    _fields_ = [
        ("byEnableTemperatureAlarm", BYTE), # 使能温度超限报警，0-报警，1-不报警
        ("byRes1", BYTE * 3),
        ("iTemperatureUpLimited", INT), # 精确到小数点后两位，如1234表示温度12.34度
        ("iTemperatureDownLimited", INT),
        ("struTempHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_TEMPERATUREALARMCFG = POINTER(NET_DVR_TEMPERATUREALARMCFG)


class NET_DVR_BOARDALARMCFG(Structure):
    _fields_ = [
        ("byEnablePullAlarm", BYTE), # 热插拔报警使能，1-报警，0-不报警
        ("byRes1", BYTE * 3),
        ("struBoardHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_BOARDALARMCFG = POINTER(NET_DVR_BOARDALARMCFG)


class NET_DVR_VIDEOPLATFORMALARMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTempAlarmCfg", NET_DVR_TEMPERATUREALARMCFG),
        ("struBoardAlarmCfg", NET_DVR_BOARDALARMCFG),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V30 * MAX_EXCEPTIONNUM), # 0-风扇异常，1-子系统异常，2-IP地址冲突，3-网线断，4-非法访问，5-光纤异常，6-前面板异常
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_VIDEOPLATFORMALARMCFG = POINTER(NET_DVR_VIDEOPLATFORMALARMCFG)


# 2010-05-17
class NET_DVR_CODESPLITTERASSOCIATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIP", NET_DVR_IPADDR), # 编码器IP地址
        ("wPort", WORD), # 编码器端口号
        ("byRes1", BYTE * 6),
        ("sUserName", BYTE * NAME_LEN), #  用户名（32）
        ("sPassword", BYTE * PASSWD_LEN), # 密码 （16）
        ("byChan", BYTE), # 编码器通道号
        ("byRes2", BYTE * 15),
    ]


LPNET_DVR_CODESPLITTERASSOCIATE = POINTER(NET_DVR_CODESPLITTERASSOCIATE)


# 2010-06-01 视频综合平台报警上传结构
class NET_DVR_MATRIXSUBSYSTEMINFO(Structure):
    _fields_ = [
        ("byMatrixNum", BYTE), # 视频综合平台号
        ("bySubSystemNum", BYTE), # 子系统槽位号
        ("byRes", BYTE),
    ]


LPNET_DVR_MATRIXSUBSYSTEMINFO = POINTER(NET_DVR_MATRIXSUBSYSTEMINFO)


class NET_DVR_VIDEOPLATFORM_ALRAMINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byAlarmType", BYTE), #  0-拔出子板，1-插入子板,2-温度超上限报警，3-温度超下限报警，4-风扇状态异常，5-子系统异常,6-非法访问，7-光纤异常报警,8-前面板异常报警
        ("byBoardNum", BYTE), # 子板号，从1起，B10不支持该字段，无效，置为0xff
        ("byRes1", BYTE * 2),
        ("bySubSystemChan", BYTE * 8), # 子板槽位号,一个子板中有8个子系统，其分别对应的槽位号，子系统异常时，bySubSystemChan[0]表示对应子系统序号
        ("iTemperature", INT), # 温度超限报警时有用，温度值
        ("byMainboardSeq", BYTE), # 温度超限报警时有用，0-非主板，1-主板
        ("byRes2", BYTE * 3),
        ("byFanSequence", BYTE * 32), # 异常风扇，byFanSequence[i] = 1表示风扇i+1异常，byFanSequence[i] = 0表示风扇i+1正常
        ("struInputNote", NET_DVR_MATRIXSUBSYSTEMINFO), #  光纤异常报警时使用，输入结点
        ("struOutputNote", NET_DVR_MATRIXSUBSYSTEMINFO), # 光纤异常报警时使用，输出结点
        ("byRes3", BYTE * 68),
    ]


LPNET_DVR_VIDEOPLATFORM_ALRAMINFO = POINTER(NET_DVR_VIDEOPLATFORM_ALRAMINFO)


MAX_INQUEST_PIP_NUM = 3 # 单通道显示的画中画数目
MAX_INQUEST_CDRW_NUM = 4 # 最大刻录机数目
MAX_INQUEST_PIP_NUM_EX = 16 # 审讯机画中画最大个数
# V40扩展，将画中画个数扩展为32个
class NET_DVR_INQUEST_PIP_PARAM_V40(Structure):
    _fields_ = [
        ("byPipChan", BYTE), # 画中画显示的通道 0xFF关闭
        ("byRes1", BYTE * 3),
        ("wTopLeftX", WORD), # 画中画的x坐标
        ("wTopLeftY", WORD), # 画中画的Y坐标
        ("wHeight", WORD), # 画中画的高
        ("wWidth", WORD), # 画中画的宽
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_INQUEST_PIP_PARAM_V40 = POINTER(NET_DVR_INQUEST_PIP_PARAM_V40)


class NET_DVR_INQUEST_PIP_STATUS_V40(Structure):
    _fields_ = [
        ("struStructHead", NET_DVR_STRUCTHEAD),
        ("byBaseChan", BYTE), # 显示画中画所在的通道
        ("byBackChan", BYTE), # 显示画中画背景通道
        ("byPIPMode", BYTE), # 是否开启, 0 当前窗口无小画面
        # 1 当前窗口有1个小画面
        # 2 当前窗口有2个小画面
        # 3 当前窗口有3个小画面
        # 4 当前窗口有4个小画面
        # 5 当前窗口有5个小画面
        # 6 当前画面有6个小画面
        # 7 当前窗口有7个小画面
        # 8 当前窗口有8个小画面
        # 9 当前窗口有9个小画面
        # 255  当前窗口关闭预览画面
        ("byPipCount", BYTE), # 小画面的个数
        ("byPicShowMode", BYTE), # 画面显示模式，0-画中画，1-画面均分2-画面拼接
        ("byRes", BYTE * 31), # 保留
        ("strPipPara", NET_DVR_INQUEST_PIP_PARAM_V40 * MAX_INQUEST_PIP_NUM_EX), # 画面位置的参数
    ]


LPNET_DVR_INQUEST_PIP_STATUS_V40 = POINTER(NET_DVR_INQUEST_PIP_STATUS_V40)


MAX_BIGSCREENNUM = 100 # 最多大屏拼接数
class NET_DVR_SINGLESCREENCFG(Structure):
    _fields_ = [
        ("byScreenSeq", BYTE), # 屏幕序号，0xff表示不用此屏,64-T解码器第一个表示主屏
        ("bySubSystemNum", BYTE), # 解码子系统槽位号,解码器此值没有用
        ("byDispNum", BYTE), # 解码子系统上对应显示通道号，64-T解码器中该值表示解码器的显示通道号
        ("byRes", BYTE * 9),
    ]


LPNET_DVR_SINGLESCREENCFG = POINTER(NET_DVR_SINGLESCREENCFG)


class NET_DVR_BIGSCREENCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 大屏拼接使能，0-不使能，1-使能
        ("byModeX", BYTE), # 大屏拼接模式
        ("byModeY", BYTE),
        ("byMainDecodeSystem", BYTE), # 综合平台的解码板中该值表示主屏槽位号，64-T解码器中该值表示解码通道号
        ("byMainDecoderDispChan", BYTE), # 主屏所用显示通道号，1.1netra版本新增，netra解码器有两个显示通道，都能够作为主屏。64-T中该值无效
        ("byVideoStandard", BYTE), # 大屏每个子屏制式相同 1:NTSC,2:PAL
        ("byRes1", BYTE * 2),
        ("dwResolution", DWORD), # 大屏每个子屏分辨率相同
        # 大屏拼接从屏幕信息
        ("struFollowSingleScreen", NET_DVR_SINGLESCREENCFG * MAX_BIGSCREENNUM),
        # 起始坐标必须为基准坐标的整数倍
        ("wBigScreenX", WORD), # 大屏在电视墙中起始X坐标
        ("wBigScreenY", WORD), # 大屏在电视墙中起始Y坐标
        ("byRes2", BYTE * 12),
    ]


LPNET_DVR_BIGSCREENCFG = POINTER(NET_DVR_BIGSCREENCFG)


DECODEPIC_LEFTADJUST = 1 # 图像左移
DECODEPIC_RIGHTADJUST = 2 # 图像右移
DECODEPIC_UPADJUST = 3 # 图像上移
DECODEPIC_DOWNADJUST = 4 # 图像下移
DECODEPIC_REDUCEADJUST = 5 # 图像缩小
DECODEPIC_FULL_SCREEN_ADJUST = 6 # 图像全屏
DECODEPIC_CANCEL_FULL_SCREEN_ADJUST = 7 # 图像取消全屏显示
DECODEPIC_AUTOADJUST = 8 #   图像自动调整
DECODEPIC_HEIGHTADJUST = 9 #  图像高度调整
DECODEPIC_WIDTHADJUST = 10 #  图像宽度调整
MAX_UNITEDMATRIX_NUM = 8 # 级联中最多视频综合平台数量
MAX_SUBDOMAIN_NUM = 4 # 级联中最多子域数量
class NET_DVR_SUBSERVERINFO(Structure):
    _fields_ = [
        ("bySequence", BYTE), # 序号，对于子域，是子域号，对于视频综合平台，是平台号，0表示无此平台\子域
        ("byBelongSubDomain", BYTE), # 对于平台有效，表示属于哪个子域
        ("byRes1", BYTE * 6),
        ("dwMaxIpcNums", DWORD), # 连接的最多IPC数量
        ("struSubMatrixIP", NET_DVR_IPADDR), # IP地址
        ("wSubMatrixPort", WORD), # 子系统端口号
        ("byRes2", BYTE * 6),
    ]


LPNET_DVR_SUBSERVERINFO = POINTER(NET_DVR_SUBSERVERINFO)


class NET_DVR_UNITEDMATRIXINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDomainInfo", NET_DVR_SUBSERVERINFO),
        ("struSubDomainInfo", NET_DVR_SUBSERVERINFO * MAX_SUBDOMAIN_NUM), # 子域信息
        ("struMatrixInfo", NET_DVR_SUBSERVERINFO * MAX_UNITEDMATRIX_NUM), # 视频综合平台信息
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_UNITEDMATRIXINFO = POINTER(NET_DVR_UNITEDMATRIXINFO)


class NET_DVR_REGCALLBACKPARAM(Structure):
    _fields_ = [
        ("sDeviceID", CHAR * NAME_LEN), # 设备ID串
        ("sPassword", CHAR * PASSWD_LEN),
        ("sSerialNumber", BYTE * SERIALNO_LEN), #  设备序列号
        ("dwDeviceType", DWORD), # 设备类型
        ("nStatus", BYTE), #  上下线状态（0下线，1上线）
        # net type, 0: unknow; 1: 2G wireless networks; 2: 3G wireless networks; 3: line networks
        ("byNetType", BYTE),
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_REGCALLBACKPARAM = POINTER(NET_DVR_REGCALLBACKPARAM)


class NET_DVR_LOGONREPONSEPARAM(Structure):
    _fields_ = [
        # 心跳时间间隔，单位：秒, 5的倍数，180秒以内。默认是15秒。
        ("wHeartbeatTime", WORD),
        ("byOvertimes", BYTE), #  设备心跳超时次数，默认是3次
        ("byRes", BYTE * 13),
    ]


LPNET_DVR_LOGONREPONSEPARAM = POINTER(NET_DVR_LOGONREPONSEPARAM)


class NET_DVR_PREVIEWPARAM(Structure):
    _fields_ = [
        ("byTransProtol", BYTE), # 传输协议，0-TCP, 1-UDP
        ("byTransMode", BYTE), #  传输码流模式 0－主码流 1－子码流
        ("struCuIp", NET_DVR_IPADDR), # CU端IP地址
        ("wPort", WORD), # CU端口
        ("wUdpPort", WORD),
        ("bySupportQos", BYTE), # 是否启用QOS,1-启用，0-不启用
        # 是否是NAT预览请求，0-否，1-是(只需byTransMode字段)
        ("byNatRequest", BYTE),
        ("byPreviewType", BYTE), #  0-普通预览 1-延时预览
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_PREVIEWPARAM = POINTER(NET_DVR_PREVIEWPARAM)


class NET_DVR_DEVICENATINFO(Structure):
    _fields_ = [
        ("struPuIp", NET_DVR_IPADDR), # PU端外网IP地址
        ("wOuterPort", WORD), # PU外网端口
        ("wInterPort", WORD), # PU发送视频的本地端口
        ("nSessionID", DWORD), # CMS分配的sessionID
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_DEVICENATINFO = POINTER(NET_DVR_DEVICENATINFO)


class NET_DVR_PREVIEWCALLBACKPARAM(Structure):
    _fields_ = [
        ("lChannel", LONG),
        ("nLinkProtocol", BYTE),
        ("nTransMode", BYTE),
        ("byPreviewType", BYTE), # 0-普通预览 1-延时预览
        ("byRes", BYTE * 5),
        ("nSessionID", DWORD), # CMS分配的sessionID
    ]


LPNET_DVR_PREVIEWCALLBACKPARAM = POINTER(NET_DVR_PREVIEWCALLBACKPARAM)


class NET_DVR_VOICEREQUESTPARAM(Structure):
    _fields_ = [
        ("nVoiceChannel", BYTE), # 对讲通道号
        ("byRes1", BYTE * 3),
        ("struCuIp", NET_DVR_IPADDR), # CU端IP地址
        ("wPort", WORD), # CU端口
        ("byRes2", BYTE * 10),
    ]


LPNET_DVR_VOICEREQUESTPARAM = POINTER(NET_DVR_VOICEREQUESTPARAM)


class NET_DVR_ALARMSETUPREQUESTPARAM(Structure):
    _fields_ = [
        ("struCuIp", NET_DVR_IPADDR), # CU端IP地址
        ("wPort", WORD), # CU端口
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_ALARMSETUPREQUESTPARAM = POINTER(NET_DVR_ALARMSETUPREQUESTPARAM)


class NET_DVR_GPSALARMINFO(Structure):
    _fields_ = [
        ("byDeviceID", BYTE * NAME_LEN), # 设备的ID串
        ("struGpsTime", NET_DVR_TIME_EX), # GPS上传的时间
        ("dwLongitude", DWORD), #  经度
        ("dwLatitude", DWORD), #  纬度
        ("iTimeZone", INT), # 时区，用分钟数表示，+60代表东1区，+480代表东8区，-60代表西区，-480代表西8区，该字段和GPSTime构成一个完整的时间描述
        ("dwDirection", DWORD), # 车辆方向=实际方向（以度为单位，正北方向为，顺时针方向计算）*100
        ("wSatellites", WORD), # 卫星数量
        ("wPrecision", WORD), # 精度
        ("dwHeight", DWORD), # 高度:厘米，预留
        ("dwGPSSeq", DWORD), # GPS序号，GPS补传时要用到
        ("wSpeed", WORD), # 速度，单位，km/h
        # direction[0]:'E'or'W'(东经/西经), direction[1]:'N'or'S'(北纬/南纬)
        ("sDirection", CHAR * 2),
        ("byLocateMode", BYTE), # 定位模式(初值0)，1,自主定位,2,差分3,估算,4,数据无效，65,有效定位，78，无效定位
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_GPSALARMINFO = POINTER(NET_DVR_GPSALARMINFO)


# 图片信息上传
class NET_DVR_PICTUREINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byChanIndex", BYTE), # 通道号
        ("byRes1", BYTE * 3), # 保留
        ("byDeviceID", BYTE * NAME_LEN), # 设备的ID串
        ("byAbsTime", BYTE * 32), # 绝对时间点, yyyymmddhhmmssxxx,
        ("dwPicLen", DWORD), # 图片长度
        ("byRes2", BYTE * 32),
        ("*pPicBuffer", BYTE),
    ]


LPNET_DVR_PICTUREINFO = POINTER(NET_DVR_PICTUREINFO)


# 平台参数
class NET_DVR_CMSPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struCmsAddr", NET_DVR_IPADDR),
        ("wCmsPort", WORD),
        ("byRes1", BYTE * 2),
        ("sDeviceID", BYTE * NAME_LEN),
        ("byPassword", BYTE * PASSWD_LEN),
        ("struPicServerAddr", NET_DVR_IPADDR),
        ("wPicServerPort", WORD),
        ("wCmsUdpPort", WORD), # CMS用于UDP外网查询的端口
        ("byRes2", BYTE * 12),
    ]


LPNET_DVR_CMSPARAM = POINTER(NET_DVR_CMSPARAM)


# /拨号功能
DIALPASSWD_LEN = 32 # 拨号密码长度
class NET_DVR_QOSPARAM(Structure):
    _fields_ = [
        ("wMaxBitUL", WORD), #  the maximum number of kbits/s in up-link traffic
        ("wMaxBitDL", WORD), #  the maximum number of kbits/s in down-link traffic
        ("byTrafficClass", BYTE), #  0: conversationnal 1: streaming 2: interactive3: background 4: subscribed value(default)
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_QOSPARAM = POINTER(NET_DVR_QOSPARAM)


class NET_DVR_PPPDPARAM(Structure):
    _fields_ = [
        ("byDialNum", BYTE * NAME_LEN), #  dial number, eg. "#777"
        ("byUserName", BYTE * NAME_LEN), #  user name, eg. "card"
        ("byPassword", BYTE * DIALPASSWD_LEN), #  password, eg. "card"
        ("byApn", BYTE * NAME_LEN), #  access point name, eg. "cmnet"
        ("struLocalIp", NET_DVR_IPADDR), #  local IP address
        ("struRemoteIp", NET_DVR_IPADDR), #  remote IP address
        ("wMtuSize", WORD), #  max transfer unit of ppp interface
        ("byVerifyProtocal", BYTE), #  IPCP verify protocal: 0: auto 1: CHAP 2: PAP
        ("byRes", BYTE * 25),
    ]


LPNET_DVR_PPPDPARAM = POINTER(NET_DVR_PPPDPARAM)


MAX_PHONE_NUM = 32 # 最长号码长度
class NET_DVR_DIALPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bEnable3G", BYTE), #  0: disable 1: enable 3g
        ("byDialMethod", BYTE), #  dial methold: 0: auto dial 1: manual dial
        ("bySwitchMethod", BYTE), #  switch methold: 0: auto switch1：3G优先，2: manual switch to 2G 3: manual switch to 3G
        ("byEnaAlarmInDial", BYTE), #  使能报警输入触发拨号 0: disable 1: enable
        ("byRes1", BYTE * 10),
        ("wOffLineTime", WORD), #  auto off line when no connection exist,单位：分钟，范围：5~65535分钟
        ("struPppdParam", NET_DVR_PPPDPARAM),
        ("struQosParam", NET_DVR_QOSPARAM),
        ("byUimNumber", BYTE * MAX_PHONE_NUM),
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_DIALPARAM = POINTER(NET_DVR_DIALPARAM)


class NET_DVR_DIALREQUEST(Structure):
    _fields_ = [
        ("byConnNum", BYTE), # 网卡序号
        ("byNetType", BYTE), #  指定获得某个网络的默认拨号参数，设置时此参数没用。0：自动；1：CDMA；2：EVDO；3：WCDMA；4：TD-SCDMA
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_DIALREQUEST = POINTER(NET_DVR_DIALREQUEST)


#  UIM card information
#  real 3g mode
class NET_DVR_DIALSTATUS(Structure):
    _fields_ = [
        ("byRealMode", BYTE), #  REAL_MODE ,real 3g mode networks
        ("byUimCard", BYTE), #  UIM_INFO ,UIM card information
        ("byRes1", BYTE * 6),
        ("dwSignal", DWORD), #  signal RSSI
        ("dwDialStatus", DWORD), #  dial status
        ("struLocalIp", NET_DVR_IPADDR), #  wireless networks IP address
        ("struRemoteIp", NET_DVR_IPADDR), #  wireless networks gateway
        ("struNetMask", NET_DVR_IPADDR), #  wireless networks netmask
        ("struDns", NET_DVR_IPADDR), #  wireless networks DNS
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_DIALSTATUS = POINTER(NET_DVR_DIALSTATUS)


# 短信功能
MAX_WHITELIST_NUM = 8 # 最大白名单数
NET_SDK_MAX_WHITELIST_NUM_32 = 32 # 最大白名单数
HARDDISKFULL_EXCEPTION = 0x0 # 硬盘满
HARDDISKERROR_EXCEPTION = 0x1 # 硬盘错
ETHERNETBROKEN_EXCEPTION = 0x2 # 网线断
IPADDRCONFLICT_EXCEPTION = 0x3 # IP地址冲突
ILLEGALACCESS_EXCEPTION = 0x4 # 非法访问
VI_EXCEPTION = 0x5 # 视频信号异常
VS_MISMATCH_EXCEPTION = 0x6 # 输入/输出视频制式不匹配
VIDEOCABLELOSE_EXCEPTION = 0x7 # 视频无信号
AUDIOCABLELOSE_EXCEPTION = 0x8 # 音频无信号
ALARMIN_EXCEPTION = 0x9 # 报警输入
MASKALARM_EXCEPTION = 0xa # 遮挡报警
MOTDET_EXCEPTION = 0xb # 移动侦测
RECORDING_EXCEPTION = 0xc # 录像异常
WIRELESS_EXCEPTION = 0xd # PIR报警
PIR_EXCEPTION = 0xe # 无线报警
CALLHELP_EXCEPTION = 0xf # 呼救报警
AUDIO_DETECTION_EXCEPTION = 0x10 # 音频异常侦测报警
SCENECHANGE_DETECTION_EXCEPTION = 0x11 # 场景侦测报警
DEFOCUS_DETECTION_EXCEPTION = 0x12 # 虚焦侦测报警
FACE_DETECTION_ENTRANCE_EXCEPTION = 0x13 # 人脸侦测报警
LINE_DETECTION_ENTRANCE_EXCEPTION = 0x14 # 越界侦测报警
FIELD_DETECTION_ENTRANCE_EXCEPTION = 0x15 # 区域入侵侦测报警
REGION_EXITING_EXCEPTION = 0x16 # 离开区域侦测报警
REGION_ENTRANCE_EXCEPTION = 0x17 # 进入区域报警
LOITERING_EXCEPTION = 0x18 # 人员徘徊侦测报警
GROUP_EXCEPTION = 0x19 # 人员聚集侦测报警
RAPIDMOVE_EXCEPTION = 0x1a # 快速移动侦测报警
PARKING_EXCEPTION = 0x1b # 停车侦测报警
UNATTENDEDBAGGAGE_EXCEPTION = 0x1c # 物品遗留侦测报警
ATTENDEDBAGGAGE_EXCEPTION = 0x1d # 物品拿取侦测报警
DATATRAFFIC_EXCESS = 0x1e # 流量超额
VOLTAGEINSTABLE_EXCEPTION = 0x1f # 电源电压异常报警
ALL_EXCEPTION = 0xff # 所有事件，根据事件联动方式判断是否开启短信联动
PHONECFG_RECEIVE_SMS = 0x0 #  支持接收报警短信
PHONECFG_SMS_CONTROL = 0x1 #  支持短信控制上下线
PHONECFG_CALL_CONTROL = 0x2 #  支持呼叫控制上线
PHONECFG_SMS_REBOOT = 0x3 # 支持短信重启
PHONECFG_DOOR_CONTROL = 0x4 #  支持门操作控制
PHONECFG_SMS_GET_DAIL_STATUS = 0x5 #  支持短信获取拨号状态
class NET_DVR_PHONECFG(Structure):
    _fields_ = [
        ("byWhiteList", BYTE * MAX_PHONE_NUM),
        ("byPhonePerssion", BYTE * 32), # 按字节表示是否使能该号码的某功能，具体位代表的含义
        # 见PHONECFG_RECEIVE_SMS等定义
        ("byAlarmHandler", BYTE * 32), # 按字节表示是否使能对某个报警类型的短信发送
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PHONECFG = POINTER(NET_DVR_PHONECFG)


class NET_DVR_SMSRELATIVEPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bEnableSmsAlarm", BYTE), #  0: disable 1: enable 3g
        ("byRes1", BYTE * 7),
        ("struWhiteList", NET_DVR_PHONECFG * MAX_WHITELIST_NUM),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_SMSRELATIVEPARAM = POINTER(NET_DVR_SMSRELATIVEPARAM)


class NET_DVR_PHONECFG_V50(Structure):
    _fields_ = [
        ("byWhiteList", BYTE * MAX_PHONE_NUM),
        ("byPhonePerssion", BYTE * 32), # 按字节表示是否使能该号码的某功能，具体位代表的含义
        # 见PHONECFG_RECEIVE_SMS等定义
        ("byAlarmHandler", BYTE * 32), # 按字节表示是否使能对某个报警类型的短信发送(门禁主机暂时用不到)
        ("byAcsPassword", BYTE * 16), # 开门命令
        ("byName", BYTE * NAME_LEN), # 姓名
        ("byRes", BYTE * 80),
    ]


LPNET_DVR_PHONECFG_V50 = POINTER(NET_DVR_PHONECFG_V50)


class NET_DVR_SMSRELATIVEPARAM_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bEnableSmsAlarm", BYTE), #  0: disable 1: enable 3g
        ("byRes1", BYTE * 7),
        ("struWhiteList", NET_DVR_PHONECFG_V50 * NET_SDK_MAX_WHITELIST_NUM_32),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_SMSRELATIVEPARAM_V50 = POINTER(NET_DVR_SMSRELATIVEPARAM_V50)


NET_SDK_MONITOR_ID_LEN = 64 # 监控点ID长度
class NET_DVR_ACS_EVENT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMajor", DWORD), # 报警主类型，参考事件上传宏定义，0-全部
        ("dwMinor", DWORD), # 报警次类型，参考事件上传宏定义，0-全部
        ("struStartTime", NET_DVR_TIME), # 开始时间
        ("struEndTime", NET_DVR_TIME), # 结束时间
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("byName", BYTE * NAME_LEN), # 持卡人姓名
        ("byPicEnable", BYTE), # 是否带图片，0-不带图片，1-带图片
        ("byTimeType", BYTE), # 时间类型：0-设备本地时间（默认），1-UTC时间（struStartTime和struEndTime的时间）
        ("byRes2", BYTE * 2), # 保留
        ("dwBeginSerialNo", DWORD), # 起始流水号（为0时默认全部）
        ("dwEndSerialNo", DWORD), # 结束流水号（为0时默认全部）
        ("dwIOTChannelNo", DWORD), # IOT通道号，0-无效
        ("wInductiveEventType", WORD), # 归纳事件类型，0-无效，其他值参见2.2章节，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
        ("bySearchType", BYTE), # 搜索方式：0-保留，1-按事件源搜索（此时通道号为非视频通道号），2-按监控点ID搜索
        ("byEventAttribute", BYTE), # 事件属性：0-未定义，1-合法事件，2-其它
        ("szMonitorID", CHAR * NET_SDK_MONITOR_ID_LEN), # 监控点ID（由设备序列号、通道类型、编号组成，例如门禁点：设备序列号+“DOOR”+门编号）
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
        ("byRes", BYTE * 140), # 保留
    ]


LPNET_DVR_ACS_EVENT_COND = POINTER(NET_DVR_ACS_EVENT_COND)


class NET_DVR_ACS_EVENT_DETAIL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号（mac地址），为0无效
        ("byCardType", BYTE), # 卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
        ("byWhiteListNo", BYTE), # 白名单单号,1-8，为0无效
        ("byReportChannel", BYTE), # 报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
        ("byCardReaderKind", BYTE), # 读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
        ("dwCardReaderNo", DWORD), # 读卡器编号，为0无效
        ("dwDoorNo", DWORD), # 门编号（楼层编号），为0无效
        ("dwVerifyNo", DWORD), # 多重卡认证序号，为0无效
        ("dwAlarmInNo", DWORD), # 报警输入号，为0无效
        ("dwAlarmOutNo", DWORD), # 报警输出号，为0无效
        ("dwCaseSensorNo", DWORD), # 事件触发器编号
        ("dwRs485No", DWORD), # RS485通道号，为0无效
        ("dwMultiCardGroupNo", DWORD), # 群组编号
        ("wAccessChannel", WORD), # 人员通道号
        ("byDeviceNo", BYTE), # 设备编号，为0无效（有效范围1-255）
        ("byDistractControlNo", BYTE), # 分控器编号，为0无效
        ("dwEmployeeNo", DWORD), # 工号，为0无效
        ("wLocalControllerID", WORD), # 就地控制器编号，0-门禁主机，1-64代表就地控制器
        ("byInternetAccess", BYTE), # 网口ID：（1-上行网口1,2-上行网口2,3-下行网口1）
        ("byType", BYTE), # 防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 0xff-无
        ("byMACAddr", BYTE * MACADDR_LEN), # 物理地址，为0无效
        ("bySwipeCardType", BYTE), # 刷卡类型，0-无效，1-二维码
        ("byEventAttribute", BYTE), # 事件属性：0-未定义，1-合法认证，2-其它
        ("dwSerialNo", DWORD), # 事件流水号，为0无效
        ("byChannelControllerID", BYTE), # 通道控制器ID，为0无效，1-主通道控制器，2-从通道控制器
        ("byChannelControllerLampID", BYTE), # 通道控制器灯板ID，为0无效（有效范围1-255）
        ("byChannelControllerIRAdaptorID", BYTE), # 通道控制器红外转接板ID，为0无效（有效范围1-255）
        ("byChannelControllerIREmitterID", BYTE), # 通道控制器红外对射ID，为0无效（有效范围1-255）
        ("dwRecordChannelNum", DWORD), # 录像通道数目
        ("*pRecordChannelData", CHAR), # 录像通道，大小为sizeof(DWORD)* dwRecordChannelNum
        ("byUserType", BYTE), # 人员类型：0-无效，1-普通人（主人），2-来宾（访客），3-黑名单人，4-管理员
        ("byCurrentVerifyMode", BYTE), # 读卡器当前验证方式：0-无效，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，
        # 13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码
        ("byAttendanceStatus", BYTE), # 考勤状态：0-未定义,1-上班，2-下班，3-开始休息，4-结束休息，5-开始加班，6-结束加班
        ("byStatusValue", BYTE), # 考勤状态值
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）（对于设备来说，如果使用了工号（人员ID）字段，byEmployeeNo一定要传递，如果byEmployeeNo可转换为dwEmployeeNo，那么该字段也要传递；对于上层平台或客户端来说，优先解析byEmployeeNo字段，如该字段为空，再考虑解析dwEmployeeNo字段）
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_ACS_EVENT_DETAIL = POINTER(NET_DVR_ACS_EVENT_DETAIL)


class NET_DVR_ACS_EVENT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMajor", DWORD), # 报警主类型，参考宏定义
        ("dwMinor", DWORD), # 报警次类型，参考宏定义
        ("struTime", NET_DVR_TIME), # 时间
        ("sNetUser", BYTE * MAX_NAMELEN), # 网络操作的用户名
        ("struRemoteHostAddr", NET_DVR_IPADDR), # 远程主机地址
        ("struAcsEventInfo", NET_DVR_ACS_EVENT_DETAIL), # 详细参数
        ("dwPicDataLen", DWORD), # 图片数据大小，不为0是表示后面带数据
        ("*pPicData", CHAR),
        ("wInductiveEventType", WORD), # 归纳事件类型，0-无效，其他值参见2.2章节，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
        ("byTimeType", BYTE), # 时间类型：0-设备本地时间（默认），1-UTC时间（struTime的时间）
        ("byRes", BYTE * 61),
    ]


LPNET_DVR_ACS_EVENT_CFG = POINTER(NET_DVR_ACS_EVENT_CFG)


class NET_DVR_SMSLISTINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTotalSmsNum", DWORD), # 短信条数
        ("byRes", BYTE * 8),
        ("*pSmsParam", BYTE),
        ("dwBufLen", DWORD), # 所分配指针长度，输入参数
    ]


LPNET_DVR_SMSLISTINFO = POINTER(NET_DVR_SMSLISTINFO)


class NET_DVR_SMSPARAM(Structure):
    _fields_ = [
        ("dwIndex", DWORD), #  the index of sms
        ("byStatus", BYTE), #  read yet or not
        ("byRes", BYTE * 7),
        ("struRecvTime", NET_DVR_TIME_EX), #  sms receive time
    ]


LPNET_DVR_SMSPARAM = POINTER(NET_DVR_SMSPARAM)


MAX_SMSCONTENT_LEN = 140 # 短信内容长度
class NET_DVR_SMSCONTENT(Structure):
    _fields_ = [
        ("byPhoneNum", BYTE * MAX_PHONE_NUM),
        ("byMsg", BYTE * MAX_SMSCONTENT_LEN),
    ]


LPNET_DVR_SMSCONTENT = POINTER(NET_DVR_SMSCONTENT)


# pin码配置
class NET_DVR_PINSTATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byStatus", BYTE), #  PIN status, defination see enum: PIN_READY
        ("byPinTimes", BYTE), #  remain input PIN times
        ("byPukTimes", BYTE), #  remain input PUK times
        ("bEnableLock", BYTE), #  now the PIN locking function is enabled or not: 0, not enabled lock 1, lock enabled
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_PINSTATUS = POINTER(NET_DVR_PINSTATUS)


MAX_PIN_LEN = 12 # PIN码最大长度
class NET_DVR_PINCODEPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPinCmd", BYTE), #  PIN command, defination see enum: PIN_CMD
        ("byRes1", BYTE * 3),
        ("byPinCode", BYTE * MAX_PIN_LEN), #  pin/puk code
        ("byNewPinCode", BYTE * MAX_PIN_LEN), #  new pin code
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_PINCODEPARAM = POINTER(NET_DVR_PINCODEPARAM)


# 图片质量
COM_PUSHALARM = 0x1200 # 设备基本报警信息上传，推模式设备使用
COM_PUSHALARM_V30 = 0x1201 # 设备基本报警信息上传v30，推模式设备使用
class NET_DVR_PUSHALARMINFO(Structure):
    _fields_ = [
        ("dwAlarmType", DWORD), # 0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问
        ("dwAlarmInputNumber", DWORD), # 报警输入端口
        ("dwAlarmOutputNumber", DWORD * MAX_ALARMOUT), # 触发的输出端口，哪一位为1表示对应哪一个输出
        ("dwAlarmRelateChannel", DWORD * MAX_CHANNUM), # 触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道
        ("dwChannel", DWORD * MAX_CHANNUM), # dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]对应第1个通道
        ("dwDiskNumber", DWORD * MAX_DISKNUM), # dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘
        ("byDeviceID", BYTE * NAME_LEN), # 设备的ID串
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_PUSHALARMINFO = POINTER(NET_DVR_PUSHALARMINFO)


# 2011-04-20
# 启动控制
class NET_DVR_MB_AUTOWORKPARA(Structure):
    _fields_ = [
        # 当前启动控制方式 0:  预留,  1:  延时关机,  2:  自动开关机
        ("byCurPowerCtrlType", BYTE),
        ("byRes", BYTE * 3),
        ("struWorkTime", NET_DVR_SCHEDTIME * MAX_DAYS),
    ]


LPNET_DVR_MB_AUTOWORKPARA = POINTER(NET_DVR_MB_AUTOWORKPARA)


class NET_DVR_MB_POWERCTRLPARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwHaltDelay", DWORD), #  关机延迟时间,单位min
        ("struAutoWorkPara", NET_DVR_MB_AUTOWORKPARA), # 启动控制相关参数设置
        ("byEnableUnderVoltProtect", BYTE), # 是否开启欠压保护
        ("byUnderVoltPercent", BYTE), # 欠压保护百分比，有85、90、95三个有效值
        ("byRes", BYTE * 34),
        # 注：1）、关机延迟时间, 可选时间为 0，5分钟，10分钟 ，20分钟 25分钟 30分钟 35分钟 40分钟 ，45 分钟 50分钟 ，60分钟 ，60*2分钟 ，60*3  60 *4   60*5  60*6
    ]


LPNET_DVR_MB_POWERCTRLPARA = POINTER(NET_DVR_MB_POWERCTRLPARA)


# 自动备份
class NET_DVR_MB_AUTOBACKUPPARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableAutoBackup", BYTE), #  是否开启自动备份 0 关闭 ，1 开启
        ("byRes1", BYTE * 3),
        ("byBackupChannel", BYTE * MAX_CHANNUM_V30), # 需要备份的通道
        ("byBackupDays", BYTE * MAX_CHANNUM_V30), # 备份天数
        # 备份文件类型
        # 0,ALL_RECORD_TYPE,全部,
        # 1,TIMING_REC,定时,
        # 2,MOTION_DETECT_REC,移动侦测 ,
        # 3,ALARM_REC,报警 ,
        # 4,MANUAL_REC,手动录像
        ("byBackupFileType", BYTE * MAX_CHANNUM_V30),
        ("struBackupTime", NET_DVR_SCHEDTIME * MAX_CHANNUM_V30), #  自动备份时间段
        ("byRes2", BYTE * 36), #  保留字节
    ]


LPNET_DVR_MB_AUTOBACKUPPARA = POINTER(NET_DVR_MB_AUTOBACKUPPARA)


class NET_DVR_MB_GPSPARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableGPS", BYTE), # 是否启用GPS
        ("byGpsInterface", BYTE), # gps接收接口0-rs232, 1-rs485, 2-frontpanel, 3-lcd
        ("bySpeedUnit", BYTE), # 速度单位，0：公里/小时，1 ：英里/小时
        ("byEnableRetrieve", BYTE), #  盲区补发(1启用，0不启用)
        ("iAdjustTime", INT), # 时区
        ("byEnableAdjustTime", BYTE), # 是否启用GPS校时， 1-启用, 0-不启动
        ("byRes1", BYTE * 5),
        ("wGpsUploadInterval", WORD), #  GPS上传间隔, 秒
        ("byGpsOsdChannel", BYTE * MAX_CHANNUM_V30), # OSD 显示，每字节代表一路
        ("dwSpeedLimit", DWORD), #  限速报警
        ("struGpsAlarm", NET_DVR_HANDLEEXCEPTION_V30),
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_MB_GPSPARA = POINTER(NET_DVR_MB_GPSPARA)


# 注：1）、当单位为公里/小时 时范围为（0 ,965）；当采用英里/小时做单位的时候 ，最大速度范围为：0-600
SENSOR_IN_NUMBER = 8
class NET_DVR_MB_SENSORINPARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byTriggerType", BYTE * SENSOR_IN_NUMBER), # 行车状态相关触发的联动，只用后4个，分别代表刹车、左转、右转、倒车，0-高电平，1-低电平
        ("byTriggerChannel", BYTE),
        ("byOsdDisplay", BYTE), # OSD显示,每位代表一路
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_MB_SENSORINPARA = POINTER(NET_DVR_MB_SENSORINPARA)


class NET_DVR_ACCELERATIONCFG(Structure):
    _fields_ = [
        ("dwMaxXAcc", DWORD), #  X轴加速度报警值 ，该取值为实际数值乘以10,最小为0
        ("dwMaxYAcc", DWORD), #  Y轴加速度报警值 ，该取值为实际数值乘以10.最小为0
        ("dwMaxZAcc", DWORD), #  Z轴加速度报警值， 该取值为实际数值乘以10,最小为0
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_ACCELERATIONCFG = POINTER(NET_DVR_ACCELERATIONCFG)


class NET_DVR_GSENSORPARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAccelerationCfg", NET_DVR_ACCELERATIONCFG),
        ("byModuleSelect", BYTE), # 模块选择：0内置/1外置
        ("byRes1", BYTE * 3),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V30),
        ("byRes2", BYTE * 24), # 保留扩展字节
    ]


LPNET_DVR_GSENSORPARA = POINTER(NET_DVR_GSENSORPARA)


class NET_DVR_MB_DOWNLOADSVRPARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDownloadSvrIp", NET_DVR_IPADDR), #  自动下载服务器地址
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_MB_DOWNLOADSVRPARA = POINTER(NET_DVR_MB_DOWNLOADSVRPARA)


#  车牌识别的相关参数
class NET_DVR_PLATERECOG_PARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPrMode", BYTE), #  车牌识别的模式, 静态图像0/动态视频1
        ("byPrScene", BYTE), #  车牌识别的场景, 低速场景0/高速场景1
        ("byPrDetRect", BYTE), #  0:全屏幕1:中心区域
        ("byPrPicQuality", BYTE), #  车牌识别返回的图片质量, 0:最低/3:最高
        ("byPrPicMode", BYTE), # 车牌识别返回的图片分辨率: JPEG_MODE_D1, JPEG_MODE_CIF, JPEG_MODE_QCIF
        ("byPlateOsdDisplay", BYTE), #  车牌OSD是否显示 0:不显示/1:显示
        ("byPrProvCharIndex", BYTE), #  车牌识别省份首汉字对应的索引
        ("byPrProvCharIndex1", BYTE), #  车牌识别常见首汉字1对应的索引
        ("byPrProvCharIndex2", BYTE), #  车牌识别常见首汉字2对应的索引
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_PLATERECOG_PARA = POINTER(NET_DVR_PLATERECOG_PARA)


#  动态取证系统,限速设置参数的结构
class NET_DVR_SPEEDLMT_PARA(Structure):
    _fields_ = [
        ("bStartMaxSpeedLimit", BYTE), #  开启高速限制
        ("bStartMinSpeedLimit", BYTE), #  开启低速限制
        ("byRes", BYTE * 6),
        ("dwMaxSpeedLimit", DWORD), #  最高限速
        ("dwMinSpeedLimit", DWORD), #  最低限速
    ]


LPNET_DVR_SPEEDLMT_PARA = POINTER(NET_DVR_SPEEDLMT_PARA)


#  动态取证系统,车牌比对参数的结构
class NET_DVR_PLATECHECK_PARA(Structure):
    _fields_ = [
        ("bAlarmWhenChecked", BYTE), #  稽查成功是否报警
        ("bInformWhenChecked", BYTE), #  稽查成功是否对话框提示
        ("byRes", BYTE * 6),
        ("struBlackFtpServer", NET_DVR_IPADDR), #  黑名单FTP服务器地址
    ]


LPNET_DVR_PLATECHECK_PARA = POINTER(NET_DVR_PLATECHECK_PARA)


class NET_DVR_ENFORCESYS_PARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSpeedLmtPara", NET_DVR_SPEEDLMT_PARA), # 限速设置
        ("struPlateCheckPara", NET_DVR_PLATECHECK_PARA), # 车牌比对
        ("bySelPeccType", BYTE), # 是否选择违章类型
        ("byEnfOptHabit", BYTE), # 取证操作习惯, 0:长按取证1:短按两次取证
        # 预览帧率调节模式分三种：
        # A 关闭 adjPrevFpsMode=0
        # 以固定高帧率(25FPS)预览
        # B 标准 adjPrevFpsMode=1
        # 以固定低帧率(6FPS)预览
        # C 自适应 adjPrevFpsMode=2
        # 根据GPS速度信息动态调整预览帧率，
        # 3秒无有效GPS的情况下，以固定高帧率预览
        ("byAdjPrevFpsMode", BYTE),
        ("byRes1", BYTE),
        ("struUploadServerIp", NET_DVR_IPADDR), # 上传服务器地址
        ("wUploadServerPort", WORD),
        ("byRes2", BYTE * 18),
    ]


LPNET_DVR_ENFORCESYS_PARA = POINTER(NET_DVR_ENFORCESYS_PARA)


class NET_DVR_PUSHMODEPARAM(Structure):
    _fields_ = [
        # 直连模式下UDP预览模式，1-同端口多路流，2-一端口一路流
        ("byUdpPreviewMode", BYTE),
        # 语音对讲工作模式，0-语音对讲，1-语音转发（SDK不进行语音的采集和播放）
        ("byVoiceWorkMode", BYTE),
        ("byRes", BYTE * 18),
    ]


LPNET_DVR_PUSHMODEPARAM = POINTER(NET_DVR_PUSHMODEPARAM)


MAX_ALARMHOST_ALARMIN_NUM = 512 # 网络报警主机最大报警输入口数
MAX_ALARMHOST_ALARMOUT_NUM = 512 # 网络报警主机最大报警输出口数
ALARMHOST_MAX_AUDIOOUT_NUM = 32 # 网络报警主机最大语音输出数
ALARMHOST_MAX_ELECTROLOCK_NUM = 32 # 网络报警主机最大电锁数
ALARMHOST_MAX_MOBILEGATE_NUM = 32 # 网络报警主机最大移动门数
ALARMHOST_MAX_SIREN_NUM = 8 #  最大警号数目
MAX_ALARMHOST_SUBSYSTEM = 32 # 报警主机最大子系统数
ALARMHOST_DETECTOR_SERIAL_LEN = 9 # 报警主机关联探测器序列号长度
ALARMHOST_DETECTOR_SERIAL_LEN_V50 = 16 # 报警主机关联探测器序列号V50长度
MAX_DETECTOR_NUM = 128 # 最大关联探测器数
MAX_DETECTOR_NUM_V51 = 256 # 最大关联探测器数
MAX_REPEATER_NUM = 16 # 最大中继器数
MAX_OUTPUT_MODULE_NUM = 64 # 最大输出模块数
MAX_ELECTRIC_LOCK_NUM = 64 # 最大电锁数量
# 传感器类型
SENSOR_TYPE_NONE = 0
SENSOR_TYPE_TEMPERATURE = 1
        # SENSOR_TYPE_HUMIDITY ,                   湿度
        # SENSOR_TYPE_WINDSPEED,                   风速
        # SENSOR_TYPE_GAS,                         气体
        # SENSOR_AC_VOLTAGE,                       交流电压
        # SENSOR_AC_CURRENT,                       交流电流
        # SENSOR_DC_VOLTAGE,                       直流电压
        # SENSOR_DC_CURRENT,                       直流电流
        # SENSOR_WATER_PRESSURE,                   水压
        # SENSOR_PRESSURE_TRANSMITTER,             压力变送器
        # SENSOR_FLOW_TRANSMITTER,                 流量变送器
        # SENSOR_WATER_LEAKAGE,                    漏水传感器
        # SENSOR_INTERGRATED_TEMPERATURE_DETECTOR,一体化温变
        # SENSOR_ISOLATION_TEMPERATURE_DETECTOR,  隔离式温变
        # SENSOR_RESIDUAL_CHLORINE,               在线余氯仪
SENSOR_TYPE_AC_TERMINAL = 16
SENSOR_TYPE_AC_SOCKET = 17
        # SENSOR_TYPE_HUMITURE,                    温湿度
        # SENSOR_TYPE_FLOW,                        流量
        # SENSOR_LIQUID_LEVEL,                     液位
        # SENSOR_TYPE_ARC,                         电弧
SENSOR_TYPE_UNKNOW = 255


class NET_DVR_SENSOR_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byName", BYTE * NAME_LEN), #  传感器名称
        ("byEnable", BYTE), #  是否启用
        ("byValid", BYTE), #  是否有效 传感器正常不正常(该参数只能获取不能个配置)
        ("byType", BYTE), #  模拟量类型 参照SENSOR_TYPE
        ("byAlarmMode", BYTE), # 报警模式，五种，15-HHHH、14-HHHL、12-HHLL、8HLLL、0-LLLL，即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
        ("fMeasureHigh", DOUBLE), #  量程上限
        ("fMeasureLow", DOUBLE), #  量程下限
        ("fAlarm1", DOUBLE), # 报警限1,报警限1-4 依次增大
        ("fAlarm2", DOUBLE), # 报警限2
        ("fAlarm3", DOUBLE), # 报警限3
        ("fAlarm4", DOUBLE), # 报警限4
        ("dwOsdCfg", DWORD), # 模拟量字符叠加，按位表示0-15对应视频通道1-16
        ("fSensitive", DOUBLE), #  灵敏度表示当实时值的变化超过灵敏度的范围时，则表示实时值发生了变化，否则认为没有发生变化。如：灵敏度为0.1，则表示前后检测的两个值之差大于0.1时，则认为数据发生变化大于0.1，需要上传。如果为1，则表示变化超过1时上报。
        ("bySensorStandard", BYTE), # 传感器规格，0- 0~20mA，1- 0~5V，2- 0~2.5Mpa，3- 0~1.6Mpa，4- 0~5m
        ("byChan", BYTE), # 模拟量通道号
        ("byRes3", BYTE * 114), #  保留字节
    ]


LPNET_DVR_SENSOR_INFO = POINTER(NET_DVR_SENSOR_INFO)


class NET_DVR_SIREN_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("byName", BYTE * NAME_LEN), #  名称
        ("wDelay", WORD), #  输出延迟 单位为秒, 范围 0~5599s 0表示一直有输出
        ("byRes1", BYTE * 2),
        ("dwOverallEventJointSirenOn", DWORD), # 全局事件联动警号输出开启，事件类型按位表示，bit0-主机防拆, bit1-全局键盘紧急报警,bit2-交流电断电，bit3-电池电压低,bit4-电话线掉线,bit5-有线网络异常,bit6-无线网络异常,  bit7-键盘485断线，bit8- WIFI通信故障，bit9-RF信号干扰故障
        ("dwSubsystemEventJointSirenOn", DWORD * MAX_ALARMHOST_SUBSYSTEM), # 子系统事件联动警号输出开启。数组下标表示子系统号，每一个元素按位表示事件类型，bit0-紧急报警
        ("byRes2", BYTE * 448), #  保留字节
    ]


LPNET_DVR_SIREN_PARAM = POINTER(NET_DVR_SIREN_PARAM)


class NET_DVR_AIR_CONDITION_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnable", BYTE), #  0--关机 1--开机
        ("byMode", BYTE), #  空调模式
        ("byTemperature", BYTE), #  温度，具体值表示 通常为16-30度
        ("byAirConditionNo", BYTE), #  空调编号
        ("byRes", BYTE * 8), #  保留字节
    ]


LPNET_DVR_AIR_CONDITION_PARAM = POINTER(NET_DVR_AIR_CONDITION_PARAM)


PANIC_BUTTON = 0
        # MAGNETIC_CONTACT,                门磁
        # SMOKE_DETECTOR,                  烟感探测器
        # ACTIVE_INFRARED_DETECTOR,        主动红外探测器
        # PASSIVE_INFRARED_DETECTOR,       被动红外探测器
        # GLASS_BREAK_DETECTOR,            玻璃破碎探测器
        # VIBRATION_DETECTOR,              震动探测器
        # DUAL_TECHNOLOGY_PIR_DETECTOR,    双鉴探测器
        # TRIPLE_TECHNOLOGY_PIR_DETECTOR,  三技术探测器
        # HUMIDITY_DETECTOR,               湿度探测器
        # TEMPERATURE_DETECTOR,            温感探测器
        # COMBUSTIBLE_GAS_DETECTOR,         可燃气体探测器
        # DYNAMIC_SWITCH,                    随动开关
        # CONTROL_SWITCH,                    控制开关
        # SMART_LOCK,                        智能锁
        # WATER_DETECTOR,                 水浸探测器
        # DISPLACEMENT_DETECTOR,    位移探测器
        # SINGLE_INFRARED_DETECTOR,    单体门磁探测器
        # SINGLE_ZONE_MODULE,    无线单防区模块
        # CURTAIN_INFRARED_DETECTOR,   幕帘红外人体探测器19
        # 20
DOORBELL_SWITCH = 21
        # MEDICAL_HELP_BUTTON,			医疗求助按钮
        # OUTDOOR_DUAL_TECH,				室外双鉴传感器
        #
OTHER_DETECTOR = 0xffff


class NET_DVR_ALARMIN_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byName", BYTE * NAME_LEN),
        ("wDetectorType", WORD), #  DETECTOR_TYPE
        ("byType", BYTE), # 防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 ，12-超时防区，13-紧急防区，0xff-无
        ("byUploadAlarmRecoveryReport", BYTE), # 是否上传防区报警恢复报告，0-不上传，1-上传
        ("dwParam", DWORD), #  防区参数  延时防区延时多长时间, 动环报警主机和自助行报警主机的延时时间通过这个参数来设置 , 具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间时间段
        ("byAssociateAlarmOut", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), #  报警输入关联报警输出
        ("byAssociateSirenOut", BYTE * 8), #   警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
        ("bySensitivityParam", BYTE), # 防区灵敏度参数, 0-10ms、1-250ms、2-500ms、3-750ms
        ("byArrayBypass", BYTE), # 是否加入旁路组,0-不支持组旁路,1-支持组旁路
        ("byJointSubSystem", BYTE), # 防区所属的子系统号，该参数只能获取
        ("byModuleStatus", BYTE), # 模块状态 1-在线 2-离线
        ("wModuleAddress", WORD), # 模块地址，扩展模块从0~255，0xFFFF表示无效
        ("byModuleChan", BYTE), # 模块通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
        ("byModuleType", BYTE), # 模块类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器, 7-1门就地控制器、8-2门就地控制器、9-4门就地控制器、10-8防区无线、11-键盘、12-8防区有线、13-扩展防区
        ("wZoneIndex", WORD), # 防区号，该参数只能获取
        ("wInDelay", WORD), # 进入延时，0-255秒
        ("wOutDelay", WORD), # 退出延时，0-255秒
        ("byAlarmType", BYTE), # 报警器类型 0-无效，1-常开，2-常闭
        ("byZoneResistor", BYTE), # 防区电阻，单位千欧  0-无效 1--2.2 ，2--3.3，3--4.7，4--5.6 ， 5--8.2 ，0xff-自定义
        ("fZoneResistorManual", DOUBLE), # 防区手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byZoneResistor为0xff时有效
        ("byDetectorSerialNo", BYTE * ALARMHOST_DETECTOR_SERIAL_LEN), # 探测器序列号，只读
        ("byZoneSignalType", BYTE), # 防区信号传输类型(只读)，0-有线防区，1-无线防区
        ("byDisableDetectorTypeCfg", BYTE), # 探测是类型是否不可配，0-可配，1-不可配
        ("byTimeOutRange", BYTE), #  超时时间范围，0:1~599s,1:1~65535s
        ("byAssociateLampOut", BYTE * 8), #   警灯输出 数组0 表示警灯1 值为1表示输出 0 表示不输出
        ("wTimeOut", WORD), # 超时时间，秒
        ("byDetectorSignalIntensity", BYTE), #  探测器信号强度（只读），0~100
        ("byTimeOutMethod", BYTE), # 超时防区计时方式：0-触发计时，1-恢复计时
        ("byRes3", BYTE * 8), #  保留字节
    ]


LPNET_DVR_ALARMIN_PARAM = POINTER(NET_DVR_ALARMIN_PARAM)


class NET_DVR_ALARMIN_PARAM_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byName", BYTE * NAME_LEN),
        ("wDetectorType", WORD), #  DETECTOR_TYPE
        ("byType", BYTE), # 防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区 ，12-超时防区，13-紧急防区，14-燃气防区，0xff-无
        ("byUploadAlarmRecoveryReport", BYTE), # 是否上传防区报警恢复报告，0-不上传，1-上传
        ("dwParam", DWORD), #  防区参数  延时防区延时多长时间, 动环报警主机和自助行报警主机的延时时间通过这个参数来设置 , 具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间时间段
        ("byAssociateAlarmOut", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), #  报警输入关联报警输出
        ("byAssociateSirenOut", BYTE * 8), #   警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
        ("bySensitivityParam", BYTE), # 防区灵敏度参数, 0-10ms、1-250ms、2-500ms、3-750ms
        ("byArrayBypass", BYTE), # 是否加入旁路组,0-不支持组旁路,1-支持组旁路
        ("byJointSubSystem", BYTE), # 防区所属的子系统号，该参数只能获取
        ("byModuleStatus", BYTE), # 模块状态 1-在线 2-离线
        ("wModuleAddress", WORD), # 模块地址，扩展模块从0~255，0xFFFF表示无效
        ("byModuleChan", BYTE), # 模块通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
        ("byModuleType", BYTE), # 模块类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器, 7-1门就地控制器、8-2门就地控制器、9-4门就地控制器、10-8防区无线、11-键盘、12-8防区有线、13-扩展防区
        ("wZoneIndex", WORD), # 防区号，该参数只能获取
        ("wInDelay", WORD), # 进入延时，0-255秒
        ("wOutDelay", WORD), # 退出延时，0-255秒
        ("byAlarmType", BYTE), # 报警器类型 0-无效，1-常开，2-常闭
        ("byZoneResistor", BYTE), # 防区电阻，单位千欧  0-无效 1--2.2 ，2--3.3，3--4.7，4--5.6 ， 5--8.2 ，0xff-自定义
        ("fZoneResistorManual", DOUBLE), # 防区手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byZoneResistor为0xff时有效
        ("byDetectorSerialNo", BYTE * ALARMHOST_DETECTOR_SERIAL_LEN_V50), # 探测器序列号，只读
        ("byZoneSignalType", BYTE), # 防区信号传输类型(只读)，0-有线防区，1-无线防区
        ("byDisableDetectorTypeCfg", BYTE), # 探测是类型是否不可配，0-可配，1-不可配
        ("wTimeOut", WORD), # 超时时间，秒
        ("byAssociateLampOut", BYTE * 8), #   警灯输出 数组0 表示警灯1 值为1表示输出 0 表示不输出
        ("byVoiceFileName", BYTE * 32), # 语音文件名
        ("byTimeOutRange", BYTE), #  超时时间范围，0:1~599s,1:1~65535s
        ("byDetectorSignalIntensity", BYTE), #  探测器信号强度（只读），0~100
        ("byTimeOutMethod", BYTE), # 超时防区计时方式：0-触发计时，1-恢复计时
        ("byAssociateFlashLamp", BYTE), #   闪光灯输出 0-无效，1-不输出，2-输出
        ("byStayAwayEnabled", BYTE), #   及时防区在家旁路使能 0-无效，1-不使能，2-使能
        ("bySilentModeEnabled", BYTE), #   静音模式使能 0-无效，1-不使能，2-使能
        ("byRelativeChannel", BYTE * RELATIVE_CHANNEL_LEN), #  关联的通道号，0表示无效，一个byte字节表示一个通道号
        ("byDetectorVersion", BYTE * VERSION_INFO_LEN), # 探测器版本，只读
        ("byDetectorMAC", BYTE * MACADDR_LEN), # 探测器MAC地址，只读
        ("byLinkageAlarmType", BYTE), # 关联报警类型：1-火警，2-监管，3-联动，4-屏蔽，5-故障
        ("byRes3", BYTE * 465), #  保留字节
    ]


LPNET_DVR_ALARMIN_PARAM_V50 = POINTER(NET_DVR_ALARMIN_PARAM_V50)


MAX_MAX_ALARMIN_NUM = 64 #  批量获取最大防区数
class NET_DVR_MULTI_ALARMIN_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("iZoneNo", INT * MAX_MAX_ALARMIN_NUM), # 防区号,从0开始，小于0表示无效
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_MULTI_ALARMIN_COND = POINTER(NET_DVR_MULTI_ALARMIN_COND)


class NET_DVR_SINGLE_ALARMIN_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wZoneNo", WORD), # 防区号，该参数只能获取
        ("byJointSubSystem", BYTE), # 防区所属的子系统号，该参数只能获取
        ("byType", BYTE), # 防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,12-超时防区,13-紧急防区14-燃气防区，0xff-无
        ("byName", BYTE * NAME_LEN),
        ("wDetectorType", WORD), #  DETECTOR_TYPE
        ("wInDelay", WORD), # 进入延时，0-255秒
        ("wOutDelay", WORD), # 退出延时，0-255秒
        ("byAlarmType", BYTE), # 报警器类型  0-无效 1-常开 1-常闭
        ("byZoneSignalType", BYTE), # 防区信号传输类型，0-有线防区，1-无线防区
        ("byDetectorSerialNo", BYTE * ALARMHOST_DETECTOR_SERIAL_LEN), # 探测器序列号，只读
        ("byDisableDetectorTypeCfg", BYTE), # 探测是类型是否不可配，0-可配，1-不可配
        ("byTimeOutRange", BYTE), #  超时时间范围，0:1~599s,1:1~65535s
        ("byDetectorSignalIntensity", BYTE), #  探测器信号强度（只读），0~100
        ("wTimeOut", WORD), # 超时时间，秒
        ("byTimeOutMethod", BYTE), # 超时防区计时方式：0-触发计时，1-恢复计时
        ("byAssociateFlashLamp", BYTE), #   闪光灯输出 0-无效，1-不输出，2-输出
        ("byStayAwayEnabled", BYTE), #   及时防区在家旁路使能 0-无效，1-不使能，2-使能
        ("bySilentModeEnabled", BYTE), #   静音模式使能 0-无效，1-不使能，2-使能
        ("byRes2", BYTE * 110), #  保留字节
    ]


LPNET_DVR_SINGLE_ALARMIN_PARAM = POINTER(NET_DVR_SINGLE_ALARMIN_PARAM)


class NET_DVR_SINGLE_ALARMIN_PARAM_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wZoneNo", WORD), # 防区号，该参数只能获取
        ("byJointSubSystem", BYTE), # 防区所属的子系统号，该参数只能获取
        ("byType", BYTE), # 防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,12-超时防区,13-紧急防区14-燃气防区，0xff-无
        ("byName", BYTE * NAME_LEN),
        ("wDetectorType", WORD), #  DETECTOR_TYPE
        ("wInDelay", WORD), # 进入延时，0-255秒
        ("wOutDelay", WORD), # 退出延时，0-255秒
        ("byAlarmType", BYTE), # 报警器类型  0-无效 1-常开 1-常闭
        ("byZoneSignalType", BYTE), # 防区信号传输类型，0-有线防区，1-无线防区
        ("byDetectorSerialNo", BYTE * ALARMHOST_DETECTOR_SERIAL_LEN), # 探测器序列号，只读
        ("byDisableDetectorTypeCfg", BYTE), # 探测是类型是否不可配，0-可配，1-不可配
        ("byTimeOutRange", BYTE), #  超时时间范围，0:1~599s,1:1~65535s
        ("byDetectorSignalIntensity", BYTE), #  探测器信号强度（只读），0~100
        ("wTimeOut", WORD), # 超时时间，秒
        ("byTimeOutMethod", BYTE), # 超时防区计时方式：0-触发计时，1-恢复计时
        ("byAssociateFlashLamp", BYTE), #   闪光灯输出 0-无效，1-不输出，2-输出
        ("byStayAwayEnabled", BYTE), #   及时防区在家旁路使能 0-无效，1-不使能，2-使能
        ("bySilentModeEnabled", BYTE), #   静音模式使能 0-无效，1-不使能，2-使能
        ("byRes3", BYTE * 2),
        ("byAssociateAlarmOut", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), #  报警输入关联报警输出
        ("byRes2", BYTE * 128), #  保留字节
    ]


LPNET_DVR_SINGLE_ALARMIN_PARAM_V50 = POINTER(NET_DVR_SINGLE_ALARMIN_PARAM_V50)


class NET_DVR_ALARMIN_PARAM_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSingleAlarmInParam", NET_DVR_SINGLE_ALARMIN_PARAM * MAX_MAX_ALARMIN_NUM),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ALARMIN_PARAM_LIST = POINTER(NET_DVR_ALARMIN_PARAM_LIST)


class NET_DVR_ALARMIN_PARAM_LIST_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSingleAlarmInParam", NET_DVR_SINGLE_ALARMIN_PARAM_V50 * MAX_MAX_ALARMIN_NUM),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ALARMIN_PARAM_LIST_V50 = POINTER(NET_DVR_ALARMIN_PARAM_LIST_V50)


class NET_DVR_ALARMOUT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byName", BYTE * NAME_LEN), #  名称
        ("wDelay", WORD), #  输出延迟 单位s, 范围：0~3599s 0 表示一直有输出
        ("wTriggerIndex", WORD), # 触发器号，该参数只能获取
        ("byAssociateAlarmIn", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 表示警号跟随的报警输入通道 （多个报警输入同时触发一个警号输出）数组下标0表示报警输入1，依次类推 0-不跟随 1-跟随
        ("byModuleType", BYTE), # 外接触发器类型，1-本地触发器， 2-4路触发器，3-8路触发器 4-单防区触发器，5-32路触发器，6-1门就地控制器、7-2门就地控制器、8-4门就地控制器,9-2路触发器，10-键盘，11-扩展触发器
        ("byModuleStatus", BYTE), # 外接触发器状态 1-在线 2-离线
        ("wModuleAddress", WORD), # 外接触发器地址，扩展模块从0~255，0xFFFF表示无效
        ("byModuleChan", BYTE), # 外接触发器通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
        ("byWorkMode", BYTE), # 工作模式，1-联动，2-随动
        ("byAlarmOutMode", BYTE), # 输出模式，1-非脉冲模式，2-脉冲模式
        ("byTimeOn", BYTE), # 开时间 1~60s
        ("byTimeOff", BYTE), # 关时间 1~60s
        ("byRes2", BYTE * 51), # 保留字节
    ]


LPNET_DVR_ALARMOUT_PARAM = POINTER(NET_DVR_ALARMOUT_PARAM)


class NET_DVR_ALARMIN_SETUP(Structure):
    _fields_ = [
        ("byAssiciateAlarmIn", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 报警输入通道 数组下标0对应报警输入口1，依次类推
        ("byRes", BYTE * 100), # 保留字节
    ]


LPNET_DVR_ALARMIN_SETUP = POINTER(NET_DVR_ALARMIN_SETUP)


class NET_DVR_ALARMHOST_MAIN_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySetupAlarmStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 报警输入口布防状态，(最大支持512个报警输入口查询)，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
        ("byAlarmInStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 报警输入口报警状态，(最大支持512个报警输入口查询)，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
        ("byAlarmOutStatus", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 报警输出口状态，(最大支持512个报警输出口查询)，0-对应报警输出口无报警，1-对应报警输出口有报警
        ("byBypassStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), #  旁路状态 数组下标表示0对应报警输入口1 0-表示报警输入口没有旁路 1-表示报警输入口旁路
        ("bySubSystemGuardStatus", BYTE * MAX_ALARMHOST_SUBSYSTEM), # 子系统布防状态,0-对应子系统处于撤防状态，1-对应子系统处于布防状态
        ("byAlarmInFaultStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 报警输入口故障状态，0-对应报警输入口处于正常状态，1-对应报警输入口处于故障状态
        ("byRes", BYTE * 56), #   保留字节
    ]


LPNET_DVR_ALARMHOST_MAIN_STATUS = POINTER(NET_DVR_ALARMHOST_MAIN_STATUS)


class NET_DVR_ALARMHOST_MAIN_STATUS_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySetupAlarmStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区布防状态，(最大支持512个防区查询)，0-对应防区处于撤防状态，1-对应防区处于布防状态
        ("byAlarmInStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区报警状态，(最大支持512个防区查询)，0-对应防区当前无报警，1-对应防区当前有报警
        ("byAlarmOutStatus", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 触发器状态，(最大支持512个触发器查询)，0-对应触发器无报警，1-对应触发器有报警
        ("byBypassStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 旁路状态 数组下标表示0对应防区1 0-表示防区没有旁路 1-表示防区旁路
        ("bySubSystemGuardStatus", BYTE * MAX_ALARMHOST_SUBSYSTEM), # 子系统布防状态,0-对应子系统处于撤防状态，1-对应子系统处于布防状态
        ("byAlarmInFaultStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区故障状态，0-对应防区处于正常状态，1-对应防区处于故障状态
        ("byAlarmInMemoryStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区报警记忆状态， 0-对应防区当前无报警，1-对应防区当前有报警
        ("byAlarmInTamperStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区防拆状态，0-对应防区无报警，1-对应防区有报警
        ("byEnableSubSystem", BYTE * MAX_ALARMHOST_SUBSYSTEM), # 子系统启用状态，0-无效，1-对应子系统未启用，2-对应子系统启用
        ("bySubSystemGuardType", BYTE * MAX_ALARMHOST_SUBSYSTEM), # 子系统布放状态，0-无效，1-外出布防，2-即时布防，3-在家布防
        ("byRes", BYTE * 448), # 保留字节
    ]


LPNET_DVR_ALARMHOST_MAIN_STATUS_V40 = POINTER(NET_DVR_ALARMHOST_MAIN_STATUS_V40)


class NET_DVR_ALARMHOST_MAIN_STATUS_V51(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySetupAlarmStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区布防状态，(最大支持512个防区查询)，0xff-无效，0-对应防区处于撤防状态，1-对应防区处于布防状态，2-对应防区处于布防中
        ("byAlarmInStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区报警状态（触发状态），(最大支持512个防区查询)，0xff-无效，0-对应防区当前无报警，1-对应防区当前有报警
        ("byAlarmOutStatus", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 触发器状态，(最大支持512个触发器查询)，0xff-无效，0-对应触发器无报警，1-对应触发器有报警，2-未关联，3-离线，4-心跳异常
        ("byBypassStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区旁路状态，数组下标表示0对应防区1，0xff-无效，0-表示防区没有旁路 1-表示防区旁路
        ("bySubSystemGuardStatus", BYTE * MAX_ALARMHOST_SUBSYSTEM), # 子系统布防状态，0xff-无效，0-对应子系统处于撤防状态，1-对应子系统处于布防状态，2-对应子系统处于布防中
        ("byAlarmInFaultStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区故障状态，0xff-无效，0-对应防区处于正常状态，1-对应防区处于故障状态
        ("byAlarmInMemoryStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区报警记忆状态（报警状态）， 0xff-无效，0-对应防区当前无报警，1-对应防区当前有报警
        ("byAlarmInTamperStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区防拆状态，0xff-无效，0-对应防区无报警，1-对应防区有报警
        ("byEnableSubSystem", BYTE * MAX_ALARMHOST_SUBSYSTEM), # 子系统启用状态，0-无效，1-对应子系统未启用，2-对应子系统启用
        ("bySubSystemGuardType", BYTE * MAX_ALARMHOST_SUBSYSTEM), # 子系统布防类型，0-无效，1-外出布防，2-即时布防，3-在家布防
        ("bySubSystemAlarm", BYTE * MAX_ALARMHOST_SUBSYSTEM), # 子系统报警状态，0-无效，1-正常，2-报警
        ("byAlarmOutCharge", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 触发器电量状态，(最大支持512个触发器查询)，0-无效，1-正常，2-电量低
        ("byAlarmOutTamperStatus", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 触发器防拆状态，(最大支持512个触发器查询)，0-无效，1-防拆，2-无防拆
        ("byAlarmInShieldedStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区屏蔽状态，0-无效，1-屏蔽，2-非屏蔽
        ("byAlarmOutLinkage", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 触发器联动事件类型，(最大支持512个触发器查询)，0-无效，1-报警，2-布防，3-撤防，4-手动控制
        ("byRes", BYTE * 512), # 保留字节
    ]


LPNET_DVR_ALARMHOST_MAIN_STATUS_V51 = POINTER(NET_DVR_ALARMHOST_MAIN_STATUS_V51)


class NET_DVR_ALARMHOST_OTHER_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySirenStatus", BYTE * ALARMHOST_MAX_SIREN_NUM), #  警号输出状态 0-警号处于无报警状态，1-警号处于有报警状态
        ("byRes", BYTE * 92), #  保留字节
    ]


LPNET_DVR_ALARMHOST_OTHER_STATUS = POINTER(NET_DVR_ALARMHOST_OTHER_STATUS)


class NET_DVR_ALARMHOST_OTHER_STATUS_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 对于DS-PEA系列一键式紧急报警产品，数组下标0对应警灯状态，数组下标1对应电锁状态,数组下标2开始对应警号输出状态
        ("bySirenStatus", BYTE * ALARMHOST_MAX_SIREN_NUM), # 警号输出状态，0xff-无效，0-警号处于无报警状态，1-警号处于有报警状态，2-未关联，3-离线，4-心跳异常
        ("byDetetorPower", BYTE * MAX_DETECTOR_NUM), # 探测器电量状态，0xff-无效，电量值为0-100，默认电量小于20为欠压状态
        ("byDetetorConnection", BYTE * MAX_DETECTOR_NUM), # 探测器连接状态，0xff-无效，0-表示未注册，1-表示不在线， 2-表示在线，3-心跳异常
        ("bySirenPower", BYTE * ALARMHOST_MAX_SIREN_NUM), # 警号电量状态，0-无效，1-正常，2-欠压
        ("bySirenTamperStatus", BYTE * ALARMHOST_MAX_SIREN_NUM), # 警号防拆状态，0-无效，1-防拆，2-无防拆
        ("byPowerStausEnabled", BYTE * MAX_DETECTOR_NUM), # 探测器电量状态是否有效，按位表示，0-无效，1-有效
        ("byDetetorPowerStatus", BYTE * MAX_DETECTOR_NUM), # 探测器电量状态，按位表示，0-正常，1-电量低
        ("byDetetorPowerType", BYTE), # 探测器电量的表示类型，0-按照电量值表示，使用byDetetorPower 字段，1-按照电量状态表示，使用byPowerStausEnabled和byDetetorPowerStatus字段
        ("byRes", BYTE * 975), # 保留字节
    ]


LPNET_DVR_ALARMHOST_OTHER_STATUS_V50 = POINTER(NET_DVR_ALARMHOST_OTHER_STATUS_V50)


class NET_DVR_ALARMHOST_OTHER_STATUS_V51(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 对于DS-PEA系列一键式紧急报警产品，数组下标0对应警灯状态，数组下标1对应电锁状态,数组下标2开始对应警号输出状态
        ("bySirenStatus", BYTE * ALARMHOST_MAX_SIREN_NUM), # 警号输出状态，0xff-无效，0-警号处于无报警状态，1-警号处于有报警状态，2-未关联，3-离线
        ("byDetetorPower", BYTE * MAX_DETECTOR_NUM_V51), # 探测器电量，0xff-无效，电量值为0-100，默认电量小于20为欠压状态，byDetetorPowerType为0时有效
        ("byDetetorConnection", BYTE * MAX_DETECTOR_NUM_V51), # 探测器连接状态，0xff-无效，0-表示未注册，1-表示不在线， 2-表示在线
        ("bySirenPower", BYTE * ALARMHOST_MAX_SIREN_NUM), # 警号电量状态，0-无效，1-正常，2-欠压
        ("bySirenTamperStatus", BYTE * ALARMHOST_MAX_SIREN_NUM), # 警号防拆状态，0-无效，1-防拆，2-无防拆
        ("byPowerStausEnabled", BYTE * MAX_DETECTOR_NUM_V51), # 探测器电量状态是否有效，按位表示，0-无效，1-有效
        ("byDetetorPowerStatus", BYTE * MAX_DETECTOR_NUM_V51), # 探测器电量状态，按位表示，0-正常，1-电量低
        ("byDetetorPowerType", BYTE), # 探测器电量的表示类型，0-按照电量值表示，使用byDetetorPower 字段，1-按照电量状态表示，使用byPowerStausEnabled和byDetetorPowerStatus字段
        ("byRes2", BYTE * 3),
        ("byRepeaterStatus", BYTE * MAX_REPEATER_NUM), # 中继器状态，0-无效，1-离线，2-在线，3-未关联
        ("byRepeaterTamperStatus", BYTE * MAX_REPEATER_NUM), # 中继器防拆状态，按位表示，0-对应中继器无报警，1-对应中继器有报警
        ("byAlarmOutTamperStatus", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 报警输出（继电器）防拆状态，按位表示，0-对应报警输出无报警，1-对应报警输出有报警
        ("byOutputModuleTamperStatus", BYTE * MAX_OUTPUT_MODULE_NUM), # 输出模块防拆状态，按位表示，0-对应输出模块无报警，1-对应输出模块有报警
        ("byElectricLockStatus", BYTE * MAX_ELECTRIC_LOCK_NUM), # 电锁状态 0-关闭，1 –打开，为确保兼容性，第一个电锁的状态在bySirenStatus第0位也需要填写
        ("byRes", BYTE * 274), # 保留字节
    ]


LPNET_DVR_ALARMHOST_OTHER_STATUS_V51 = POINTER(NET_DVR_ALARMHOST_OTHER_STATUS_V51)


# 使能状态配置
class NET_DVR_ALARMHOST_ENABLECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAudioOutEnable", BYTE * ALARMHOST_MAX_AUDIOOUT_NUM), # 语音输出使能，0-禁能，1-使能
        ("byElectroLockEnable", BYTE * ALARMHOST_MAX_ELECTROLOCK_NUM), # 电锁使能，0-禁能，1-使能
        ("byMobileGateEnable", BYTE * ALARMHOST_MAX_MOBILEGATE_NUM), # 移动门使能，0-禁能，1-使能
        ("bySirenEnable", BYTE * ALARMHOST_MAX_SIREN_NUM), # 警号使能， 0-禁能，1-使能
        ("bySerialPurpose", BYTE), # 串口用途，0-用于级联报警主机，1-用于PTZ控制
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_ALARMHOST_ENABLECFG = POINTER(NET_DVR_ALARMHOST_ENABLECFG)


class NET_DVR_ALARMHOST_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("wTotalAlarmInNum", WORD), #  报警输入口总数(防区),包括级联
        ("wLocalAlarmInNum", WORD), #  本地报警输入口
        ("wExpandAlarmInNum", WORD), #  可扩展的报警输入口
        ("wTotalAlarmOutNum", WORD), #  报警输出口总数 （设备支持的总数）
        ("wLocalAlarmOutNum", WORD), #  本地报警输出口个数
        ("wExpandAlarmOutNum", WORD), #  可扩展的报警输出口
        ("wTotalRs485Num", WORD), #  报警输出口总数 （设备支持的总数）
        ("wLocalRs485Num", WORD), #  本地485口数
        ("wExpandRs485Num", WORD), #  可扩展的485口数
        ("wFullDuplexRs485Num", WORD), #  全双工的485口数
        ("wTotalSensorNum", WORD), #  模拟量最大个数 (设备支持的总数)
        ("wLocalSensorNum", WORD), #  本地模拟量个数
        ("wExpandSensorNum", WORD), #  可扩展的模拟量个数
        ("wAudioOutNum", WORD), # 语音输出个数
        ("wGatewayNum", WORD), # 门禁个数
        ("wElectroLockNum", WORD), # 电锁个数
        ("wSirenNum", WORD), #  主机警号数目
        ("wSubSystemNum", WORD), #  可划分子系统数目
        ("wNetUserNum", WORD), #  网络用户数
        ("wKeyboardNum", WORD), #  键盘数
        ("wOperatorUserNum", WORD), #  操作用户数
        ("bySupportDetector", BYTE), # 是否支持常开、常闭探测器，1-支持，0-不支持
        ("bySupportSensitivity", BYTE), # 是否支持防区灵敏度，1-支持，0-不支持
        ("bySupportArrayBypass", BYTE), # 是否支持组旁路，1-支持，0-不支持
        ("bySupportAlarmInDelay", BYTE), # 是否支持防区延迟,1-支持，0-不支持
        # 如果bySupportAlarmInDelay为1时，表示客户端应该使用NET_DVR_ALARMIN_PARAM 中的dwParam来设置延时时间，动环报警主机和自助行报警主机使用这种配置延时方式;
        # 如果bySupportAlarmInDelay为0时，表示通过NET_DVR_ALARMSUBSYSTEMPARAM 中的wEnterDelay 、wExitDelay 来设置
        ("bySupportAlarmInType", BYTE * 16), # 支持的防区类型,数组0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区 8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区15-无
        ("byTelNum", BYTE), # 支持电话个数
        ("byCenterGroupNum", BYTE), # 中心组个数
        ("byGPRSNum", BYTE), # GPRS中心数，最多4个
        ("byNetNum", BYTE), # 网络中心数，最多4个
        ("byAudioNum", BYTE), # 音频个数
        ("by3GNum", BYTE), # 3G模块个数
        ("byAnalogVideoChanNum", BYTE), # 模拟视频通道个数
        ("byDigitalVideoChanNum", BYTE), # 数字视频通道个数
        ("bySubSystemArmType", BYTE), # 子系统布防类型，0-表示不支持，1-表示支持。bit0-普通布防（注：网络小主机只支持普通布防，在能力集中加这个字段的时候网络小主机已经发布，所以网络小主机中该字段为0，所以用0表示支持，1表示不支持。对外接口中SDK内部会做兼容），bit1-即时布防，bit2-留守布防。
        ("byPublicSubSystemNum", BYTE), # 公共子系统个数
        ("dwSupport1", DWORD), # 按位表示，结果非0表示支持，0表示不支持
        # bit0:     是否支持子系统内配置警号输出时间，如果支持则警号输出时间在每个子系统内配置，如果不支持，警号时间在警号参数配置里面设置
        # bit1:    是否支持事件触发报警输出开启
        # bit2:    是否支持事件触发报警输出关闭
        # bit3:    是否支持子系统使能
        # bit4;    是否支持防区布防
        # bit5;    是否支持子系统自动布撤防
        # bit6:    是否支持具体故障关联声音输出
        # bit7:    是否支持故障状态查询
        # bit8:    是否支持子系统扩展配置
        # bit9:    是否支持钥匙防区操作子系统
        # bit10:   是否支持"键盘提示成功发送报告"配置
        # bit11:   是否支持导入导出参数配置
        # bit12:   是否支持LED屏幕参数配置
        # bit13: 是否支持故障关联本地故障灯输出
        ("dwSubSystemEvent", DWORD), # 子系统事件，按位表示，0表示不支持，非0表示支持,bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆
        ("dwOverallEvent", DWORD), # 全局事件，按位表示，0表示不支持，非0表示支持，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常，bit5-硬盘故障,bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线,bit8-WIFI通信故障，bit9-RF信号干扰故障
        ("dwFaultType", DWORD), # 设备支持的故障类型，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-主键盘掉线，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常
        ("byPublicSubsystemAssociateSubsystemNum", BYTE), # 公共子系统可关联的子系统个数
        ("byOverallKeyboard", BYTE), # 全局键盘个数
        ("wSafetyCabinSupport", WORD), # 防护舱控制器能力，按位表示，结果非0表示支持，0表示不支持
        # bit0: 是否支持防护舱控制器工作模式配置
        # bit1: 是否支持人信号传感器类型配置
        # bit2: 是否支持幕帘传感器参数配置（探测延迟时间、人状态变化响应时间）
        # bit3: 是否支持红外对射传感器参数配置（滤波）
        # bit4: 是否支持防护舱使用超时时间配置
        ("by485SlotNum", BYTE), # 485虚拟槽位号
        ("bySubSystemAttributeAbility", BYTE), #  值恒为1，禁止1号子系统关闭使能
        ("wKeyboardAddrNum", WORD), #  键盘地址数
        ("byAlarmLampNum", BYTE), # 警灯数目
        ("byRes", BYTE * 117), #   保留字节
    ]


LPNET_DVR_ALARMHOST_ABILITY = POINTER(NET_DVR_ALARMHOST_ABILITY)


MAX_485CHAN = 256 # 485通道号
MAX_485SLOT = 256 # 485槽位号
class NET_DVR_485_SLOT_LIST_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAll", BYTE), # 0-不是全部获取，1-全部获取
        ("byres", BYTE * 3),
        ("byIndex", BYTE * MAX_485SLOT), # 485槽位号
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_485_SLOT_LIST_INFO = POINTER(NET_DVR_485_SLOT_LIST_INFO)


class NET_DVR_485LIST_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAll", BYTE), # 0-不是全部获取，1-全部获取
        ("byres", BYTE * 3),
        ("byIndex", BYTE * MAX_485CHAN), # 485通道号 下标表示通道号，值0-表示不使用，1表示使用
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_485LIST_INFO = POINTER(NET_DVR_485LIST_INFO)


class NET_DVR_ALARM_RS485CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("sDeviceName", BYTE * NAME_LEN), #  前端设备名称
        ("wDeviceType", WORD), #  前端设备类型,通过NET_DVR_GetDeviceTypeList获取
        ("wDeviceProtocol", WORD), #  前端设备协议 通过获取协议列表获取
        ("dwBaudRate", DWORD), # 波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k
        ("byDataBit", BYTE), #  数据有几位：0-5位，1-6位，2-7位，3-8位
        ("byStopBit", BYTE), #  停止位：0-1位，1-2位
        ("byParity", BYTE), # 是否校验：0-无校验，1-奇校验，2-偶校验
        ("byFlowcontrol", BYTE), #  是否流控：0-无，1-软流控,2-硬流控
        ("byDuplex", BYTE), #  0 - 半双工1- 全双工  只有通道1可以是全双工其他都只能是半双工
        ("byWorkMode", BYTE), #  工作模式 0-控制台 1-透明通道,2-梯控，3-读卡器,4-门禁安全模块,0xfe-自定义，0xff-禁用
        ("byChannel", BYTE), # 485通道号
        ("bySerialType", BYTE), # 串口类型: 0--485, 1--232
        ("byMode", BYTE), # 模式 0-连接读卡器 1-连接客户端 2-连接扩展模块 3-连接门禁主机 4-连接梯控主机  0xff-禁用
        ("byOutputDataType", BYTE), # 0-无效，1-输出卡号，2-输出工号
        ("byAddress", BYTE), # 串口地址
        ("byRes", BYTE * 33), #  保留字节
    ]


LPNET_DVR_ALARM_RS485CFG = POINTER(NET_DVR_ALARM_RS485CFG)


MAX_DEVICE_PROTO_NUM = 256
MAX_DEVICE_TYPE_NUM = 256
#  485前端设备支持协议列表
class NET_DVR_DEVICE_PROTO_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwProtoNum", DWORD), #  协议个数
        ("struProtoType", NET_DVR_PROTO_TYPE * MAX_DEVICE_PROTO_NUM), #  协议类型
        ("byRes", BYTE * 12), #  保留字节
    ]


LPNET_DVR_DEVICE_PROTO_LIST = POINTER(NET_DVR_DEVICE_PROTO_LIST)


class NET_DVR_DEVICE_TYPE(Structure):
    _fields_ = [
        ("dwType", DWORD),
        ("byDescribe", BYTE * DESC_LEN),
    ]


LPNET_DVR_DEVICE_TYPE = POINTER(NET_DVR_DEVICE_TYPE)


class NET_DVR_DEVICE_TYPE_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwTypeNum", DWORD), #  类型个数
        ("struDeviceType", NET_DVR_DEVICE_TYPE * MAX_DEVICE_TYPE_NUM),
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_DEVICE_TYPE_LIST = POINTER(NET_DVR_DEVICE_TYPE_LIST)


MAX_ALARMHOST_VIDEO_CHAN = 64
class NET_DVR_ALARM_DEVICE_USER(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("struUserIP", NET_DVR_IPADDR), #  用户IP地址(为0时表示允许任何地址)
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
        ("byUserType", BYTE), #  0-普通用户 1-管理员用户
        ("byAlarmOnRight", BYTE), #  布防权限
        ("byAlarmOffRight", BYTE), #  撤防权限
        ("byBypassRight", BYTE), #  旁路权限
        ("byOtherRight", BYTE * MAX_RIGHT), #  其他权限
        # 0 -- 日志权限
        # 1 -- 重启关机
        # 2 -- 参数设置权限
        # 3 --    参数获取权限
        # 4 -- 恢复默认参数权限
        # 5 -- 警号输出权限
        # 6 -- PTZ 控制权限
        # 7 -- 远程升级权限
        # 8 -- 远程预览
        # 9 -- 远程手动录像
        # 10 -- 远程回放
        ("byNetPreviewRight", BYTE * int(MAX_ALARMHOST_VIDEO_CHAN/8)), #  远程可以预览的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
        ("byNetRecordRight", BYTE * int(MAX_ALARMHOST_VIDEO_CHAN/8)), #  远程可以录像的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
        ("byNetPlaybackRight", BYTE * int(MAX_ALARMHOST_VIDEO_CHAN/8)), #  远程可以回放的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
        ("byNetPTZRight", BYTE * int(MAX_ALARMHOST_VIDEO_CHAN/8)), #  远程可以PTZ的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
        # BYTE    byPriority;                                         优先级，0xff-无，0--低，1--中，2--高
        # 无（表示不支持优先级的设置）
        # 低（默认权限：包括远程回放，远程查看日志和状态，远程关机/重启）
        # 中（包括远程控制云台，远程手动录像，远程回放，语音对讲和远程预览，本地备份，本地/远程关机/重启）
        # 高（管理员）
        ("sOriginalPassword", BYTE * PASSWD_LEN), #  原始密码
        ("byRes2", BYTE * 152), #  保留字节
    ]


LPNET_DVR_ALARM_DEVICE_USER = POINTER(NET_DVR_ALARM_DEVICE_USER)


class NET_DVR_KEYBOARD_USER(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwID", DWORD), #  键盘用户ID
        ("byDefanceArea", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区权限  按数组下标表示 最大支持512个防区 0 - 无权限 1- 有权限
        ("byRes", BYTE * 560), #  保留字节
    ]


LPNET_DVR_KEYBOARD_USER = POINTER(NET_DVR_KEYBOARD_USER)


class NET_DVR_OPERATE_USER(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("bySubSystemPermission", BYTE), # 0-安装员权限 操作员权限（所有子系统）如下： 1-单布防，无布防报告，不能旁路 2-单撤防，无撤防报告，不能旁路 3-布撤防，无布撤防报告，不能旁路
        # 4-单布防，有布防报告，不能旁路 5-单撤防，有撤防报告，不能旁路 6-布撤防，有布撤防报告，不能旁路  7-单布防，无布撤防报告，允许旁路
        # 8-单撤防，无布撤防报告，允许旁路 9-布撤防，无布撤防报告，允许旁路 10-单布防，有布防报告，允许旁路 11-单撤防，有撤防报告，允许旁路 1
        # 2-布撤防，有布撤防报告，允许旁路
        ("byRes", BYTE * 63), #   保留字节
    ]


LPNET_DVR_OPERATE_USER = POINTER(NET_DVR_OPERATE_USER)


class NET_DVR_GATEWAY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byName", BYTE * NAME_LEN), #   门禁名称
        ("byEnable", BYTE), #  是否启用
        ("byLocalEnable", BYTE), #   本地是否启用
        ("wDelayTime", WORD), #  开启延时时间    单位为秒0-65535 0为一直开启
        ("byLockWorkMode", BYTE), # 电锁工作模式，0-通电启动，1-断电启动
        ("byRes", BYTE * 31), #  保留字节
    ]


LPNET_DVR_GATEWAY_CFG = POINTER(NET_DVR_GATEWAY_CFG)


class NET_DVR_SENSOR_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwAbsTime", DWORD), #  绝对时标信息  OSD显示信息
        ("byName", BYTE * NAME_LEN), #  sensor 名称
        ("bySensorChannel", BYTE), #  模拟量通道
        ("byType", BYTE), #  模拟量类型
        ("byAlarmType", BYTE), #  1-上4、2-上3、3-上2、4-上1、5-下1、6-下2、7-下3、8-下4 和当前模式有关
        # 例如当为1000时,有上1下1，2，3报警四种报警
        ("byAlarmMode", BYTE), # 报警模式，五种，-HHHH、-HHHL、-HHLL、HLLL、-LLLL， 作为平台报警程度判断功能,即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
        ("fValue", DOUBLE), #  但前模拟量的值
        ("fOriginalValue", DOUBLE), # 原始电流电压值，保留小数点后三位，具体值表示电流还是电压根据NET_DVR_SENSOR_INFO的bySensorStandard类型
        ("byRes2", BYTE * 28), #  保留字节
    ]


LPNET_DVR_SENSOR_ALARM = POINTER(NET_DVR_SENSOR_ALARM)


PROTOCOL_VERTION_LEN = 32
class NET_DVR_RS485_PROTOCOL_VERSION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byProtocleVersion", BYTE * PROTOCOL_VERTION_LEN), # RS485协议库版本信息
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_RS485_PROTOCOL_VERSION = POINTER(NET_DVR_RS485_PROTOCOL_VERSION)


#  开关量报警上传
class NET_DVR_SWITCH_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byName", BYTE * NAME_LEN), #  switch 名称
        ("wSwitchChannel", WORD), #  开关量通道, 0-255
        ("byAlarmType", BYTE), #  报警类型 0--正常，1--短路，2--断路,3-异常
        ("byRes", BYTE * 41), #  保留字节
    ]


LPNET_DVR_SWITCH_ALARM = POINTER(NET_DVR_SWITCH_ALARM)


class NET_DVR_ALARMHOST_EXCEPTION_PARAM(Union):
    _fields_ = [
        ("dwUnionSize", DWORD * 20), #  联合体大小
    ]


LPNET_DVR_ALARMHOST_EXCEPTION_PARAM = POINTER(NET_DVR_ALARMHOST_EXCEPTION_PARAM)


class NET_DVR_ALARMHOST_EXCEPTION_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        # 异常参数  1-设备防拆报警 2-设备防拆后后恢复正常 3-主电源掉电报警 4-主电源掉电后恢复正常 5-内部通信故障报警
        # 6-内部通信故障后恢复正常  7-电话线断线 8-电话线断线恢复 9-自检失败报警  10-自检失败后恢复正常
        # 11蓄电池欠压  12蓄电池电压恢复正常，13-蓄电池故障；14-MBUS模块掉线；15-MBUS模块掉线恢复；16-键盘掉线；
        # 17-键盘掉线恢复；18-设备被移动；19-设备被移动复位  20-485外设线路断报警  21-485外设线路断后恢复正常
        # 25-子板1插上,26-子板1拔出, 27-子板2插上,28-子板2拔出
        ("dwExceptionType", DWORD),
        ("byRes", BYTE * 36), #  保留
    ]


LPNET_DVR_ALARMHOST_EXCEPTION_ALARM = POINTER(NET_DVR_ALARMHOST_EXCEPTION_ALARM)


# 自助行拨号参数配置及启用方式配置
MAX_CENTERNUM = 4 # G1,G2 G3 G4或者N1，N2，N3，N4或者T1，T2，T3，T4
class NET_DVR_PHONECENTERDIALCFG(Structure):
    _fields_ = [
        ("sCenterName", BYTE * NAME_LEN),
        ("byPhoneNum", BYTE * MAX_PHONE_NUM), # 中心号码
        ("byRepeatCall", BYTE), # 重复拨号次数，1~15次
        ("byPstnProtocol", BYTE), # 通信协议，0-CID；
        ("byDialDelay", BYTE), # 拨号延时，最大150s, 0-150
        ("byPstnTransMode", BYTE), # 传输方式，0-DTMF 5/S，1-DTMF 10/S；
        ("byEnable", BYTE), # 使能，0-关闭，1-启用
        ("byRes1", BYTE * 5),
        ("byReceiverId", BYTE * 6), # 接收机识别账号；
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_PHONECENTERDIALCFG = POINTER(NET_DVR_PHONECENTERDIALCFG)


class NET_DVR_ALARMHOSTDIALCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struPhoneCenterParam", NET_DVR_PHONECENTERDIALCFG * MAX_CENTERNUM), # 主中心参数
        ("wReportPeriod", WORD), # 测试报告上传周期，小时，（最大值支持7天，即168小时), 范围；1-168
        ("wFirstReportTime", WORD), # 从设备启动到第一条测试报告上传，1~3600分钟
        ("byReportValid", BYTE), # 0-不启用测试报告上传 1-启用测试报告上传
        ("byRes", BYTE * 19),
    ]


LPNET_DVR_ALARMHOSTDIALCFG = POINTER(NET_DVR_ALARMHOSTDIALCFG)


class NET_DVR_ALARMHOSTDIALSETUPMODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableMode", BYTE), # 启用方式，0：不启用，1：一直启用，2:网线断启用，正常时关闭；
        ("byCallType", BYTE), # 上传中心方式，1-单中心，2-双中心，3，一报一备
        ("byRes1", BYTE * 14),
    ]


LPNET_DVR_ALARMHOSTDIALSETUPMODE = POINTER(NET_DVR_ALARMHOSTDIALSETUPMODE)


MAX_PU_CHAN_NUM = 512
class NET_DVR_PU_CHAN_INFO(Structure):
    _fields_ = [
        ("struIpAddr", NET_DVR_IPADDR), #  ip地址
        ("wPort", WORD), #  端口
        ("wChannel", WORD), #  通道
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_PU_CHAN_INFO = POINTER(NET_DVR_PU_CHAN_INFO)


class NET_DVR_PU_CHAN_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体
        ("dwNum", DWORD), #  前端通道个数
        ("struPuChanInfo", NET_DVR_PU_CHAN_INFO * MAX_PU_CHAN_NUM),
    ]


LPNET_DVR_PU_CHAN_LIST = POINTER(NET_DVR_PU_CHAN_LIST)


MAX_ALARM_CAM_NUM = 32 #  报警触发CAM最大个数
class NET_DVR_PTZ_CTRL(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否启用PTZ控制
        ("byType", BYTE), #  PTZ 控制的类型 1- 预置点 2 -巡航  3-轨迹
        ("byPtzNo", BYTE), #   ptz 控制的预置点 巡航 轨迹号
        ("byRes", BYTE * 5), #  保留字节
    ]


LPNET_DVR_PTZ_CTRL = POINTER(NET_DVR_PTZ_CTRL)


class NET_DVR_ALARM_CAM_INFO(Structure):
    _fields_ = [
        ("dwCamID", DWORD), #  触发的CAM通道操作
        ("dwRecordTime", DWORD), #  触发录像时间 单位为s  -1表示一直录像 0 表示不录像
        ("dwMonID", DWORD), #  触发Cam到Mon号显示
        ("dwResidentTime", DWORD), #  轮巡停留时间单位为s  -1表示一直停留 0 表示不停留
        ("struPtzCtrl", NET_DVR_PTZ_CTRL), #  PTZ控制信息
        ("byAlarmOffMode", BYTE), #  报警切换上墙取消模式   0-立即取消，1-自动取消，2-手动取消 立即取消，报警取消时立即取消解码上墙   自动取消，报警取消时等待一定时间后取消解码上墙，我们约定是20秒  手动取消，用户通过手动的方式取消
        ("byDevType", BYTE), #  当设备为智能设备时，生效表示智能报警设备取流源 1-解码卡     2-编码卡
        ("byDecChan", BYTE), #  当为解码通道为解码通道号
        ("byRes", BYTE * 17), #  保留字节
    ]


LPNET_DVR_ALARM_CAM_INFO = POINTER(NET_DVR_ALARM_CAM_INFO)


class NET_DVR_ALARM_CAM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnable", BYTE), #  是否启用报警触发CAM联动 设备默认不启用
        ("byRes", BYTE * 7), #  保留字节
        ("dwNum", DWORD), #  触发CAM联动的个数 即取数组的前几个有效处理
        ("struAlarmCam", NET_DVR_ALARM_CAM_INFO * MAX_ALARM_CAM_NUM),
    ]


LPNET_DVR_ALARM_CAM_CFG = POINTER(NET_DVR_ALARM_CAM_CFG)


MAX_GATEWAY_NUM = 8 #  最大门禁个数
class NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnterDoor", BYTE * 8), #  下标表示门禁号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
        ("byExitDoor", BYTE * 8), #  下标表示门禁号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
        ("byAlarmIn", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 关联报警输入，下标表示报警输入号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM = POINTER(NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM)


# 数据上传下载（语音上传下载的扩展）
class NET_DVR_UPLOAD_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byUploadType", BYTE), # 上传方式，1-根据文件名绝对地址读取数据文件上传， 2-从缓冲区读取数据上传
        ("byDataType", BYTE), # 数据类型：1-音频数据
        ("byDataNum", BYTE), # 数据编号，如：上传语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
        ("byAudioType", BYTE), # 语音格式，0-wave
        ("sFileName", CHAR * 260), # 数据文件的全路径
        ("*lpBuffer", CHAR), # 数据缓冲区
        ("dwBufferSize", DWORD), # 缓冲区大小
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_UPLOAD_PARAM = POINTER(NET_DVR_UPLOAD_PARAM)

DATADOWNLOAD = WINFUNCTYPE(None, LONG, DWORD, VOIDP, DWORD, VOIDP)
class NET_DVR_DOWNLOAD_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDownType", BYTE), # 下载的数据保存方式，1-根据文件名绝对地址保存数据， 2-通过回调函数获取数据
        ("byDataType", BYTE), # 数据类型：1-音频数据
        ("byDataNum", BYTE), # 数据编号，如：下载语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
        ("byRes1", BYTE),
        ("sFileName", CHAR * 260), # 数据文件的全路径
        ("lpDataCallBack", DATADOWNLOAD), # 下载时的回调函数句柄
        ("pUserData", VOIDP), # 用户数据，将在回调函数中传回
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_DOWNLOAD_PARAM = POINTER(NET_DVR_DOWNLOAD_PARAM)


class NET_DVR_ALARMHOST_DOWNLOAD_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDownType", BYTE), # 下载的数据保存方式，1-根据文件名绝对地址保存数据， 2-通过回调函数获取数据
        ("byDataType", BYTE), # 数据类型：1-音频数据
        ("byDataNum", BYTE), # 数据编号，如：下载语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
        ("byRes1", BYTE),
        ("sFileName", CHAR * 260), # 数据文件的全路径
        ("lpDataCallBack", DATADOWNLOAD), # 下载时的回调函数句柄
        ("pUserData", VOIDP), # 用户数据，将在回调函数中传回
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM = POINTER(NET_DVR_ALARMHOST_DOWNLOAD_PARAM)


# LED屏幕参数
class NET_DVR_LED_SCREEN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sLEDName", BYTE * NAME_LEN), #  LED屏幕名称
        ("byTransMode", BYTE), #  现只支持串口通讯 1-串口通信
        ("byProtocolType", BYTE), #  协议类型，对应LED屏的厂家
        ("byLEDColor", BYTE), #  1-单色， 2-双色， 3-256级灰度双基色， 4- 全彩色（目前只用单色）
        ("byDataPolarity", BYTE), #  数据极性 .0-负极，1-正极
        ("byOEPolarity", BYTE), #  0-低有效 1-高有效
        ("byScanMode", BYTE), #  1-1/16,  2-1/8,  3-1/4,  4-1/2,  5-静态
        ("byRes1", BYTE * 2),
        # 屏幕宽度和高度最小是16*16点，间隔是8个点
        ("wLEDWidth", WORD), #  16~2048
        ("wLEDHeight", WORD), #  16~2048
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_LED_SCREEN_CFG = POINTER(NET_DVR_LED_SCREEN_CFG)


# LED屏显内容
MAX_CONTENT_LEN = 512
class NET_DVR_LED_CONTENT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sLEDContent", BYTE * MAX_CONTENT_LEN), #  LED屏幕显示内容
        ("byContentAct", BYTE), #  1-静态，2-快速打出，3-向左移动，4-向右移动， 5-向上移动， 6-向下移动
        ("byContentSpeed", BYTE), #  1-24（1最快，24最慢）
        ("byContentStayTime", BYTE), #  0-127.5s(精度0.5s， SDK传送时候*2，即传送数值0-255，设备端在使用的时候需除以2)
        ("byRes", BYTE * 33),
    ]


LPNET_DVR_LED_CONTENT_CFG = POINTER(NET_DVR_LED_CONTENT_CFG)


# LED定时开关机
LED_TIMER_NUM = 3 #  LED开机、关机时间组数
TIME_SEGMENT_A_DAY = 48 #  时间段个数，一天24小时，半小时一个段
class NET_DVR_SWITCH_TIME(Structure):
    _fields_ = [
        ("byValid", BYTE), #  该组定时时间是否有效，时间是成对设置的
        ("byRes", BYTE * 3),
        ("struTimeOn", NET_DVR_TIME_EX), #  开机时间
        ("struTimeOff", NET_DVR_TIME_EX), #  关机时间
    ]


LPNET_DVR_SWITCH_TIME = POINTER(NET_DVR_SWITCH_TIME)


class NET_DVR_LED_SWITCH_TIME(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTimer", NET_DVR_SWITCH_TIME * LED_TIMER_NUM), # 定时开关机时间，结构体中只有小时和分钟两个参数有效，每组开机时间要早于该组的关机时间，但比前一组的关机时间要晚，例如：struTimer[0]的关机时间是10：00那么，struTimer[0]的开机时间须设置为10:00之前， struTimer[1]的开机时间须设置为10：:00以后。
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_LED_SWITCH_TIME = POINTER(NET_DVR_LED_SWITCH_TIME)


# 分时亮度调节
class NET_DVR_LED_BRIGHTNESS_STEP(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), # 分时亮度调节是否有效
        ("byRes1", BYTE * 3),
        ("byBrightnessStep", BYTE * TIME_SEGMENT_A_DAY), # 将全天24个小时分为48个时段，每30分钟一个时段，用48个字节表示每个时段的亮度级别，亮度共16级，用0~15表示。
        ("byRes2", BYTE * 48),
    ]


LPNET_DVR_LED_BRIGHTNESS_STEP = POINTER(NET_DVR_LED_BRIGHTNESS_STEP)


class NET_DVR_LED_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySwitchState", BYTE), # 1-开机状态 2-关机状态
        ("byBrightness", BYTE), # 亮度值，范围0-15
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_LED_STATUS = POINTER(NET_DVR_LED_STATUS)


class NET_DVR_DECCARD_ABILITY(Structure):
    _fields_ = [
        ("byCardType", BYTE), # 解码卡类型(0:MD,1:MD+,2:HD)
        ("byDecNums", BYTE), # 解码通道数
        ("byDispNums", BYTE), # 显示通道数
        ("byDecStartIdx", BYTE), # 首个解码通道在所有解码通道中的索引
        ("byDispStartIdx", BYTE), # 首个显示通道在所有显示通道中的索引
        ("byDispResolution", BYTE * 80), # 输出模式支持的分辨率
        ("byDispFormat", BYTE * 8), # 支持的输出模式(按HD_DISPLAY_FORMAT)
        ("byWindowMode", BYTE * 4), # 支持的窗口模式(比如1,2,4,9,16))
        ("byRes", BYTE * 35),
    ]


LPNET_DVR_DECCARD_ABILITY = POINTER(NET_DVR_DECCARD_ABILITY)

MAX_DECODE_CARD_NUM = 6   # 最多高清解码卡数
class NET_DVR_DECODESVR_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byCardNums", BYTE), #  解码卡数
        ("byStartChan", BYTE), #  起始通道号
        ("byRes1", BYTE * 2),
        ("struDecCardAbility", NET_DVR_DECCARD_ABILITY * MAX_DECODE_CARD_NUM),
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_DECODESVR_ABILITY = POINTER(NET_DVR_DECODESVR_ABILITY)


class NET_MATRIX_DEV_CHAN_INFO(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), # DVR IP地址
        ("wDVRPort", WORD), # 端口号
        ("byChannel", BYTE), # 通道号
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP，1-UDP
        ("byTransMode", BYTE), # 传输码流模式 0－主码流 1－子码流
        ("byFactoryType", BYTE), # 前端设备厂家类型,通过接口获取
        ("byUsedSlotNum", BYTE), # 是否使用槽位号，0-不使用，1-使用
        ("bySlotNum", BYTE), # 槽位号
        ("byRes", BYTE * 68),
        ("sUserName", BYTE * NAME_LEN), # 监控主机登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), # 监控主机密码
    ]


LPNET_MATRIX_DEV_CHAN_INFO = POINTER(NET_MATRIX_DEV_CHAN_INFO)


class NET_MATRIX_PU_STREAM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamMediaSvrCfg", NET_DVR_STREAM_MEDIA_SERVER_CFG),
        ("struDevChanInfo", NET_MATRIX_DEV_CHAN_INFO),
    ]


LPNET_MATRIX_PU_STREAM_CFG = POINTER(NET_MATRIX_PU_STREAM_CFG)


# camera配置单元结构
class NET_DVR_MATRIX_CAMERACFG(Structure):
    _fields_ = [
        ("dwGlobalIndex", DWORD), # 全局编号
        ("dwInterIndex", DWORD), # 局部编号
        ("sCamName", BYTE * NAME_LEN),
        ("struPuStreamCfg", NET_MATRIX_PU_STREAM_CFG),
    ]


LPNET_DVR_MATRIX_CAMERACFG = POINTER(NET_DVR_MATRIX_CAMERACFG)


class NET_DVR_MATRIX_CAMERALIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 12),
        ("dwCamNum", DWORD), # CAM数量
        ("*pBuffer", BYTE),
        ("dwBufLen", DWORD), # 所分配指针长度，输入参数
    ]


LPNET_DVR_MATRIX_CAMERALIST = POINTER(NET_DVR_MATRIX_CAMERALIST)


class NET_DVR_DISP_CHAN_INFO(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), #  解码器 IP地址
        ("wDVRPort", WORD), #  端口号
        ("byDispChannel", BYTE), #  显示通道号
        ("byUsedSlotNum", BYTE), # 是否使用槽位号，0-使用，1-不使用
        ("bySlotNum", BYTE), # 槽位号
        ("byRes", BYTE * 7),
        ("sUserName", BYTE * NAME_LEN), # 登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), # 密码
    ]


LPNET_DVR_DISP_CHAN_INFO = POINTER(NET_DVR_DISP_CHAN_INFO)


# monitor配置单元结构
class NET_DVR_MATRIX_MONITORCFG(Structure):
    _fields_ = [
        ("dwGlobalIndex", DWORD), # 全局编号
        ("dwInterIndex", DWORD),
        ("sMonName", BYTE * NAME_LEN),
        ("struDispChanCfg", NET_DVR_DISP_CHAN_INFO),
    ]


LPNET_DVR_MATRIX_MONITORCFG = POINTER(NET_DVR_MATRIX_MONITORCFG)


class NET_DVR_MATRIX_MONITORLIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 12),
        ("dwMonNum", DWORD), # MON数量
        ("*pBuffer", BYTE),
        ("dwBufLen", DWORD), # 所分配指针长度，输入参数
    ]


LPNET_DVR_MATRIX_MONITORLIST = POINTER(NET_DVR_MATRIX_MONITORLIST)


MAX_SUBMATRIX_NUM = 8 # 级联中子最多从系统数量
class NET_DVR_SUBMATRIXINFO(Structure):
    _fields_ = [
        ("byMainMatrix", BYTE), # 是否是主系统，1-是，0-否
        ("bySubMatrixSequence", BYTE), # 级联子视频综合平台系统序号
        ("byLoginType", BYTE), # 注册类型，1-直连，2-DNS，3-花生壳
        ("byRes1", BYTE * 9),
        ("struSubMatrixIP", NET_DVR_IPADDR), # IP地址（可修改）
        ("wSubMatrixPort", WORD), # 子系统端口号（可修改）
        ("byRes2", BYTE * 6),
        ("struSubMatrixIPMask", NET_DVR_IPADDR), # IP地址掩码
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关地址
        ("sUserName", BYTE * NAME_LEN), #  用户名 （此参数只能获取）
        ("sPassword", BYTE * PASSWD_LEN), # 密码 （此参数只能获取）
        ("sDomainName", CHAR * MAX_DOMAIN_NAME), # 域名(可修改)
        ("sDnsAddress", CHAR * MAX_DOMAIN_NAME), # DNS域名或IP地址
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号（此参数只能获取）
        ("byRes3", BYTE * 16),
    ]


LPNET_DVR_SUBMATRIXINFO = POINTER(NET_DVR_SUBMATRIXINFO)


class NET_DVR_ALLUNITEDMATRIXINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSubMatrixInfo", NET_DVR_SUBMATRIXINFO * MAX_SUBMATRIX_NUM),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_ALLUNITEDMATRIXINFO = POINTER(NET_DVR_ALLUNITEDMATRIXINFO)


MAX_GATEWAYTRUNKNUM = 1024 # 级联视频综合平台中最大路由干线数
class NET_DVR_MATRIXGATEWAYNOTE(Structure):
    _fields_ = [
        ("wTrunkInToOutAbility", WORD), # 干线带宽，按D1的标准衡量，如4表示支持4个D1
        ("wTrunkOutToInAbility", WORD), # 干线带宽，按D1的标准衡量，如4表示支持4个D1，双向光纤时用到此值
        ("byRes", BYTE * 4),
        ("struInputNote", NET_DVR_MATRIXSUBSYSTEMINFO),
        ("struOutputNote", NET_DVR_MATRIXSUBSYSTEMINFO),
    ]


LPNET_DVR_MATRIXGATEWAYNOTE = POINTER(NET_DVR_MATRIXGATEWAYNOTE)


class NET_DVR_MATRIXGATEWAYINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struGatewayNote", NET_DVR_MATRIXGATEWAYNOTE * MAX_GATEWAYTRUNKNUM),
        ("byRes", BYTE),
    ]


LPNET_DVR_MATRIXGATEWAYINFO = POINTER(NET_DVR_MATRIXGATEWAYINFO)


class NET_DVR_MATRIXCODESYSTEMINFO(Structure):
    _fields_ = [
        ("byMatrixNum", BYTE), # 视频综合平台号
        ("bySubSystemNum", BYTE), # 子系统槽位号
        ("byChan", BYTE), # 编码通道
        ("byRes", BYTE),
    ]


LPNET_DVR_MATRIXCODESYSTEMINFO = POINTER(NET_DVR_MATRIXCODESYSTEMINFO)


class NET_DVR_MATRIXDECODESYSTEMINFO(Structure):
    _fields_ = [
        ("byMatrixNum", BYTE), # 视频综合平台号
        ("bySubSystemNum", BYTE), # 子系统槽位号
        ("byDispChan", BYTE), # 显示通道
        ("bySubDispChan", BYTE), # 显示通道子通道号
        ("byRes", BYTE),
    ]


LPNET_DVR_MATRIXDECODESYSTEMINFO = POINTER(NET_DVR_MATRIXDECODESYSTEMINFO)


class NET_DVR_MATRIXSWITCH(Structure):
    _fields_ = [
        ("struInputNote", NET_DVR_MATRIXCODESYSTEMINFO),
        ("struOutputNote", NET_DVR_MATRIXDECODESYSTEMINFO),
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_MATRIXSWITCH = POINTER(NET_DVR_MATRIXSWITCH)


        # DEC_CARD,
        # SD_DEC_CARD,
        # FPGA_CARD,
        # CS_CARD,
        # ALERTOR_CARD,
        # NAT_0,
        # NAT_1,
        # VCA_CARD,
        # VGA_DEC_CARD,
        # VGA_ENC_CARD,
        # ERR_CARD,


class NET_DVR_MATRIXSWITCHCTRL(Structure):
    _fields_ = [
        ("dwCamId", DWORD), # 摄像机全局编号
        ("dwMonId", DWORD), # 监视器全局编号
        ("bySubWindowNum", BYTE), # 监视器对应子窗口号
        ("bySwitchType", BYTE), # 切换类型，0:正常切换，1:报警触发切换，2:报警取消，0xff:表示此MON上所有报警全部取消
        ("wAlarmType", WORD), # 报警设备类型，1:报警主机，2：智能设备
        ("dwResidentTime", DWORD), #  显示驻留时间，0xFFFFFFFF 时 为常驻情况，保持显示
        ("byVcaDevType", BYTE), # 当报警设备类型是"智能设备"时，按DEV_TYPE类型
        ("byWallNo", BYTE), # 墙号
        ("byRes", BYTE * 18),
    ]


LPNET_DVR_MATRIXSWITCHCTRL = POINTER(NET_DVR_MATRIXSWITCHCTRL)


class NET_DVR_MATRIXDATABASE(Structure):
    _fields_ = [
        # 配置文件类型，1-域数据库配置文件，2-子域数据库配置文件，3-平台数据库配置文件，4-场景配置文件，0xff最后一次失败的数据库语句
        ("dwDevType", DWORD),
        ("dwParam", DWORD), # 参数，代表域号、子域号、平台号，场景配置文件时此值无用
        ("byFileType", BYTE), # 文件类型，1-sql语句，2-db语句，3-场景配置文件
        ("byRes", BYTE),
    ]


LPNET_DVR_MATRIXDATABASE = POINTER(NET_DVR_MATRIXDATABASE)


class NET_DVR_SUBSYSTEMINFO_V40(Structure):
    _fields_ = [
        # 子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，
        # 9-V6子系统，10-转码子系统，11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板，14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，19-音频子系统，0-NULL（此参数只能获取）
        ("bySubSystemType", BYTE),
        # 子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
        ("byChan", BYTE),
        ("byLoginType", BYTE), # 注册类型，1-直连，2-DNS，3-花生壳
        ("bySlotNum", BYTE), # 槽位号，此参数只能获取
        ("byRes1", BYTE * 4),
        ("struSubSystemIP", NET_DVR_IPADDR), # IP地址（可修改）
        ("struSubSystemIPMask", NET_DVR_IPADDR), # 子网掩码
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关地址
        ("wSubSystemPort", WORD), # 子系统端口号（可修改）
        ("byRes2", BYTE * 6),
        ("sUserName", BYTE * NAME_LEN), #  用户名 （此参数只能获取）
        ("sPassword", BYTE * PASSWD_LEN), # 密码(可修改)
        ("sDomainName", CHAR * MAX_DOMAIN_NAME), # 域名(可修改)
        ("sDnsAddress", CHAR * MAX_DOMAIN_NAME), # DNS域名或IP地址
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号（此参数只能获取）
        ("byBelongBoard", BYTE), # 所属子板号，从1开始，0xff表示无效
        ("byInterfaceType", BYTE), # 接口类型，0-无类型，1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI, 11-VGA/DVI自适应，12-HDTVI，13-HDBaseT，14-DP，15-DVIT，16-TVI,17-VSCREEN,18-miniDP,0xff-无效
        ("byInterfaceNums", BYTE), # 接口个数，0xff表示无效
        ("byInterfaceStartNum", BYTE), # 接口起始号，0xff表示无效
        ("byDeviceName", BYTE * 20), # 子系统名称
        ("byAudioChanNums", BYTE), # 音频通道个数
        ("byAudioChanStartNum", BYTE), # 音频通道起始号
        ("byAudioChanType", BYTE), # 音频通道类型，0-无效，1-音频输入，2-音频输出
        ("byRes3", BYTE * 33),
    ]


LPNET_DVR_SUBSYSTEMINFO_V40 = POINTER(NET_DVR_SUBSYSTEMINFO_V40)


MAX_SUBSYSTEM_NUM_V40 = 120
class NET_DVR_ALLSUBSYSTEMINFO_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSubSystemInfo", NET_DVR_SUBSYSTEMINFO_V40 * MAX_SUBSYSTEM_NUM_V40),
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_ALLSUBSYSTEMINFO_V40 = POINTER(NET_DVR_ALLSUBSYSTEMINFO_V40)


class NET_DVR_SUBSYSTEM_BASIC_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-Fpga解码子系统，9-Fpga子系统，10-转码子系统，11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板， 14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，19-信号接入子系统,0-NULL（此参数只能获取）
        ("bySubSystemType", BYTE),
        # 子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
        ("bySubSystemNo", BYTE), # 子系统号，此参数只能获取
        ("byInterfaceType", BYTE), # 接口类型，0-无类型，1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YprPb, 9-VGA/HDMI/DVI自适应，10-3GSDI, 11-VGA/DVI自适应，12-HDTVI，13-HDBaseT，14-DP，15-DVIT，0xff-无效
        ("byRes1", BYTE),
        ("dwChan", DWORD),
        ("struSubSystemIP", NET_DVR_IPADDR), # IP地址（可修改）
        ("struSubSystemIPMask", NET_DVR_IPADDR), # 子网掩码
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关地址
        ("wSubSystemPort", WORD), # 子系统端口号（可修改）
        ("byRes2", BYTE * 6),
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 序列号（此参数只能获取）
        ("byBelongBoard", BYTE), # 所属子板号，从1开始，0xff表示无效，但当byBelongBoardH不为0时该字段可以为0xff
        ("byBelongBoardH", BYTE), # 所属子板号高位
        ("byRes3", BYTE * 2),
        ("byDeviceName", BYTE * 20), # 子系统名称
        ("dwStartChanNo", DWORD), # 起始通道号
        ("byDevNo", BYTE), # 设备号
        ("byRes4", BYTE * 63),
    ]


LPNET_DVR_SUBSYSTEM_BASIC_INFO = POINTER(NET_DVR_SUBSYSTEM_BASIC_INFO)


class NET_DVR_AUDIO_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAudioChanType", BYTE), # 音频通道类型，1-音频输入，2-音频输出
        ("byRes1", BYTE * 3),
        ("dwAudioNo", DWORD), # 音频号(1字节设备号+1字节子板号+2字节音频口号)
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_AUDIO_INFO = POINTER(NET_DVR_AUDIO_INFO)


class NET_DVR_SINGLESUBSYSTEMJOININFO_V40(Structure):
    _fields_ = [
        # 子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）
        ("bySubSystemType", BYTE),
        ("byConnectStatus", BYTE), # 级联系统关联状态，1-连接正常，2-连接断开
        ("byMatrixNum", BYTE), # 级联视频综合平台号，子系统类型是3或4时可用
        ("bySubSystemNum", BYTE), # 级联子系统槽位号，0~79，子系统类型是3或4时可用
        ("struDecSub", NET_DVR_DECSUBSYSTEMJIONSTATUS),
        ("byBindStatus", BYTE), # 绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
        ("bySlotNum", BYTE), # 槽位号，此参数只能获取
        # 子系统类型为1的时可用，0-未关联，1-D1，2-720，3-1080
        ("byDecodeAbility", BYTE),
        ("byUsedTrunk", BYTE),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SINGLESUBSYSTEMJOININFO_V40 = POINTER(NET_DVR_SINGLESUBSYSTEMJOININFO_V40)


class NET_DVR_ALLDECSUBSYSTEMJOININFO_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSingleSubSystemJoinInfo", NET_DVR_SINGLESUBSYSTEMJOININFO_V40 * MAX_SUBSYSTEM_NUM_V40),
        ("byRes", BYTE * 48),
    ]


LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40 = POINTER(NET_DVR_ALLDECSUBSYSTEMJOININFO_V40)


MAX_OPTICALFIBER_NUM = 16

# class NET_DVR_VIDEOPLATFORM_ABILITY_V40(Structure):
#     _fields_ = [
#         ("dwSize", DWORD),
#         ("byCodeSubSystemNums", BYTE), # 编码子系统数量
#         ("byDecodeSubSystemNums", BYTE), # 解码子系统数量
#         ("bySupportNat", BYTE), # 是否支持NAT，0-不支持，1-支持
#         ("byInputSubSystemNums", BYTE), # 级联输入子系统数量
#         ("byOutputSubSystemNums", BYTE), # 级联输出子系统数量
#         ("byCodeSpitterSubSystemNums", BYTE), # 码分子系统数量
#         ("byAlarmHostSubSystemNums", BYTE), # 报警子系统数量
#         ("bySupportBigScreenNum", BYTE), # 所支持最多组成大屏的个数
#         ("byVCASubSystemNums", BYTE), # 智能子系统数量
#         ("byV6SubSystemNums", BYTE), # V6子系统数量
#         ("byV6DecoderSubSystemNums", BYTE), # V6解码子系统数量
#         ("bySupportBigScreenX", BYTE), # 大屏拼接的模式：m×n
#         ("bySupportBigScreenY", BYTE),
#         ("bySupportSceneNums", BYTE), # 支持场景模式的个数
#         ("byVcaSupportChanMode", BYTE), # 智能支持的通道使用模式，0-使用解码通道，1-使用显示通道及子通道号
#         ("bySupportScreenNums", BYTE), # 所支持的大屏的屏幕最大个数
#         ("bySupportLayerNums", BYTE), # 所支持的图层数，0xff-无效
#         ("byNotSupportPreview", BYTE), # 是否支持预览,1-不支持，0-支持
#         ("byNotSupportStorage", BYTE), # 是否支持存储,1-不支持，0-支持
#         ("byUploadLogoMode", BYTE), # 上传logo模式，0-上传给解码通道，1-上传给显示通道
#         ("struSubSystemAbility", NET_DVR_SUBSYSTEM_ABILITY * MAX_SUBSYSTEM_NUM_V40),
#         ("by485Nums", BYTE), # 485串口个数
#         ("by232Nums", BYTE), # 232串口个数
#         ("bySerieStartChan", BYTE), # 起始通道
#         ("byScreenMode", BYTE), # 大屏模式，0-主屏由客户端分配，1-主屏由设备端分配
#         ("byDevVersion", BYTE), # 设备版本，0-B10/B11/B12，1-B20
#         ("bySupportBaseMapNums", BYTE), # 所支持的底图数，底图号从1开始
#         ("wBaseLengthX", WORD), # 每个屏大小的基准值，B20使用
#         ("wBaseLengthY", WORD),
#         ("bySupportPictureTrans", BYTE), # 是否支持图片回显，0-不支持，1-支持
#         ("bySupportPreAllocDec", BYTE), # 是否支持智能解码资源预分配，0-不支持，1-支持
#         ("bySupportDecAutoManage", BYTE), # 是否支持解码资源管理
#         ("byTranDevSubSystemNums", BYTE), # 转码子系统数量
#         ("byFiberSwitchNums", BYTE), # 网络光纤子系统数量
#         ("byRes2", BYTE * 625),
#     ]
#
#
# LPNET_DVR_VIDEOPLATFORM_ABILITY_V40 = POINTER(NET_DVR_VIDEOPLATFORM_ABILITY_V40)


# class NET_DVR_VIDEOPLATFORM_ABILITY(Structure):
#     _fields_ = [
#         ("dwSize", DWORD),
#         ("byCodeSubSystemNums", BYTE), # 编码子系统数量
#         ("byDecodeSubSystemNums", BYTE), # 解码子系统数量
#         ("bySupportNat", BYTE), # 是否支持NAT，0-不支持，1-支持
#         ("byInputSubSystemNums", BYTE), # 级联输入子系统数量
#         ("byOutputSubSystemNums", BYTE), # 级联输出子系统数量
#         ("byCodeSpitterSubSystemNums", BYTE), # 码分子系统数量
#         ("byAlarmHostSubSystemNums", BYTE), # 报警子系统数量
#         ("bySupportBigScreenNum", BYTE), # 所支持最多大屏拼接数量
#         ("byVCASubSystemNums", BYTE), # 智能子系统数量
#         ("byRes1", BYTE * 11),
#         ("struSubSystemAbility", NET_DVR_SUBSYSTEM_ABILITY * MAX_SUBSYSTEM_NUM),
#         ("by485Nums", BYTE), # 485串口个数
#         ("by232Nums", BYTE), # 485串口个数
#         ("bySerieStartChan", BYTE), # 起始通道
#         ("byRes2", BYTE * 637),
#     ]
#
#
# LPNET_DVR_VIDEOPLATFORM_ABILITY = POINTER(NET_DVR_VIDEOPLATFORM_ABILITY)


# 获取能力集接口
# 模式A
class NET_DVR_HOLIDATE_MODEA(Structure):
    _fields_ = [
        ("byStartMonth", BYTE), #  开始月 从1开始
        ("byStartDay", BYTE), #  开始日 从1开始
        ("byEndMonth", BYTE), #  结束月
        ("byEndDay", BYTE), #  结束日
        ("byRes", BYTE * 4), #  保留字节
    ]


LPNET_DVR_HOLIDATE_MODEA = POINTER(NET_DVR_HOLIDATE_MODEA)


class NET_DVR_HOLIDATE_MODEB(Structure):
    _fields_ = [
        ("byStartMonth", BYTE), #  从1开始
        ("byStartWeekNum", BYTE), #  第几个星期 从1开始
        ("byStartWeekday", BYTE), #  星期几
        ("byEndMonth", BYTE), #  从1开始
        ("byEndWeekNum", BYTE), #  第几个星期 从1开始
        ("byEndWeekday", BYTE), #  星期几
        ("byRes", BYTE * 2), #  保留字节
    ]


LPNET_DVR_HOLIDATE_MODEB = POINTER(NET_DVR_HOLIDATE_MODEB)


class NET_DVR_HOLIDATE_MODEC(Structure):
    _fields_ = [
        ("wStartYear", WORD), #  年
        ("byStartMon", BYTE), #  月
        ("byStartDay", BYTE), #  日
        ("wEndYear", WORD), #  年
        ("byEndMon", BYTE), #  月
        ("byEndDay", BYTE), #  日
    ]


LPNET_DVR_HOLIDATE_MODEC = POINTER(NET_DVR_HOLIDATE_MODEC)


class NET_DVR_HOLIDATE_UNION(Union):
    _fields_ = [
        # 联合体大小 12字节
        ("dwSize", DWORD * 3),
        ("struModeA", NET_DVR_HOLIDATE_MODEA), #  模式A
        ("struModeB", NET_DVR_HOLIDATE_MODEB), #  模式B
        ("struModeC", NET_DVR_HOLIDATE_MODEC), #  模式C
    ]


LPNET_DVR_HOLIDATE_UNION = POINTER(NET_DVR_HOLIDATE_UNION)


HOLIDATE_MODEA = 0
        # HOLIDATE_MODEB,
        # HOLIDATE_MODEC


class NET_DVR_HOLIDAY_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否启用
        ("byDateMode", BYTE), #  日期模式 0-模式A 1-模式B 2-模式C
        ("byRes1", BYTE * 2), #  保留字节
        ("uHolidate", NET_DVR_HOLIDATE_UNION), #  假日日期
        ("byName", BYTE * NAME_LEN), #  假日名称
        ("byRes2", BYTE * 20), #  保留字节
    ]


LPNET_DVR_HOLIDAY_PARAM = POINTER(NET_DVR_HOLIDAY_PARAM)


MAX_HOLIDAY_NUM = 32
class NET_DVR_HOLIDAY_PARAM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struHolidayParam", NET_DVR_HOLIDAY_PARAM * MAX_HOLIDAY_NUM), #  假日参数
        ("byRes", DWORD * 40), #  保留参数
    ]


LPNET_DVR_HOLIDAY_PARAM_CFG = POINTER(NET_DVR_HOLIDAY_PARAM_CFG)


#  假日报警处理方式
class NET_DVR_HOLIDAY_HANDLE(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), #  布防时间段
        ("byRes2", BYTE * 240), #  保留字节
    ]


LPNET_DVR_HOLIDAY_HANDLE = POINTER(NET_DVR_HOLIDAY_HANDLE)


class NET_DVR_HOLIDAY_HANDLE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwChannel", DWORD), # 通道号
        ("dwSMDHandleType", DWORD), # 简易智能假日布防类型 0-音频异常侦测，1-虚焦侦测，2-场景变更侦测
        ("byRes2", BYTE * 32), #  保留字节
    ]


LPNET_DVR_HOLIDAY_HANDLE_COND = POINTER(NET_DVR_HOLIDAY_HANDLE_COND)


class NET_DVR_HOLIDAY_RECORD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRecDay", NET_DVR_RECORDDAY), #  录像参数
        ("struRecordSched", NET_DVR_RECORDSCHED * MAX_TIMESEGMENT_V30), #  录像时间段
        ("byRes", BYTE * 20), #   保留字节
    ]


LPNET_DVR_HOLIDAY_RECORD = POINTER(NET_DVR_HOLIDAY_RECORD)


MAX_LINK_V30 = 128
class NET_DVR_ONE_LINK(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), #  客户端IP
        ("lChannel", LONG), #  通道号
        ("byRes", BYTE * 32), #  保留字节
    ]


LPNET_DVR_ONE_LINK = POINTER(NET_DVR_ONE_LINK)


class NET_DVR_LINK_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("wLinkNum", WORD), #  连接的数目
        ("byRes1", BYTE * 2), #  保留字节
        ("struOneLink", NET_DVR_ONE_LINK * MAX_LINK_V30), #  连接的客户端信息
        ("byRes", BYTE * 32), #  保留字节
    ]


LPNET_DVR_LINK_STATUS = POINTER(NET_DVR_LINK_STATUS)


MAX_BOND_NUM = 2
class NET_DVR_ONE_BONDING(Structure):
    _fields_ = [
        ("byMode", BYTE), #  工作模式0 - 网络容错 1 - 负载均衡
        ("byUseDhcp", BYTE), #  是否使能dhcp
        ("byMasterCard", BYTE), #   指定哪张网卡为主网卡
        ("byStatus", BYTE), #  BONDING的状态  0 - 异常 1-正常 只能获取不能设置
        ("byBond", BYTE * MAX_NETWORK_CARD), #  byBond[0]== 1 表示使用eh0  0表示不使用eh0
        ("struEtherNet", NET_DVR_ETHERNET_V30), #  网卡参数
        ("struGatewayIpAddr", NET_DVR_IPADDR), #  网关地址
        ("byEnableDNS", BYTE), # DNS使能, 0-关闭，1-打开
        ("byBondMode", BYTE), # 绑定方式, 0-无效，1-主备模式，2-轮转模式，3-XOR模式，4-广播模式，5-802.3ad模式，6-T1b模式，7-虚拟化模式
        ("byRes1", BYTE * 2),
        ("byBond2", BYTE * MAX_NETWORK_CARD_EX), #  byBond2[0]== 1 表示使用eh4  0表示不使用eh4，基于byBond扩展
        ("byRes", BYTE * 4), #  保留字节
    ]


LPNET_DVR_ONE_BONDING = POINTER(NET_DVR_ONE_BONDING)


class NET_DVR_NETWORK_BONDING(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnable", BYTE), #  是否启用bonding功能
        ("byNum", BYTE), #  Bonding网卡的个数
        ("byRes1", BYTE * 2), #   保留字节
        ("struOneBond", NET_DVR_ONE_BONDING * MAX_BOND_NUM),
        ("byRes2", BYTE * 40), #  保留字节
    ]


LPNET_DVR_NETWORK_BONDING = POINTER(NET_DVR_NETWORK_BONDING)


#  磁盘配额
class NET_DVR_DISK_QUOTA(Structure):
    _fields_ = [
        ("byQuotaType", BYTE), #  磁盘配额类型,1 - 按容量 2-按比例，3-按时间
        ("byRes1", BYTE * 5), #  保留字节
        ("wStoragePeriod", WORD), # 录像存储周期，单位天，配额类型为按时间时有效
        ("dwHCapacity", DWORD), #  分配的磁盘容量高32位 单位MB
        ("dwLCapacity", DWORD), #  分配的磁盘容量低32位 单位MB
        ("dwHUsedSpace", DWORD), #  已使用的磁盘大小高32位 单位MB
        ("dwLUsedSpace", DWORD), #  已使用的磁盘大小低32位 单位MB
        ("byQuotaRatio", BYTE), #     分配的磁盘比例,单位:%
        ("byRes2", BYTE * 21), #  保留字节
    ]


LPNET_DVR_DISK_QUOTA = POINTER(NET_DVR_DISK_QUOTA)


class NET_DVR_DISK_QUOTA_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struPicQuota", NET_DVR_DISK_QUOTA), #   图片配额
        ("struRecordQuota", NET_DVR_DISK_QUOTA), #   录像配额
        ("struAddInfoQuota", NET_DVR_DISK_QUOTA), #   附加信息配额 (用于云存储服务器，目前支持的附加信息有：热度图、客流量)
        ("byRes", BYTE * 12), # 保留字节
    ]


LPNET_DVR_DISK_QUOTA_CFG = POINTER(NET_DVR_DISK_QUOTA_CFG)


class NET_DVR_DISK_QUOTA_V60(Structure):
    _fields_ = [
        ("byQuotaType", BYTE), #  磁盘配额类型,1 - 按容量 2-按比例，3-按时间
        ("byRes1", BYTE * 5), #  保留字节
        ("wStoragePeriod", WORD), # 录像存储周期，单位天，配额类型为按时间时有效
        ("dwHCapacity", DWORD), #  分配的磁盘容量高32位 单位MB
        ("dwLCapacity", DWORD), #  分配的磁盘容量低32位 单位MB
        ("dwHUsedSpace", DWORD), #  已使用的磁盘大小高32位 单位MB
        ("dwLUsedSpace", DWORD), #  已使用的磁盘大小低32位 单位MB
        ("byQuotaRatio", BYTE), #     分配的磁盘比例,单位:%
        ("byRes2", BYTE * 23), #  保留字节
    ]


LPNET_DVR_DISK_QUOTA_V60 = POINTER(NET_DVR_DISK_QUOTA_V60)


class NET_DVR_DISK_QUOTA_CFG_V60(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struPicQuota", NET_DVR_DISK_QUOTA_V60), #   图片配额
        ("struRecordQuota", NET_DVR_DISK_QUOTA_V60), #   录像配额
        ("struAddInfoQuota", NET_DVR_DISK_QUOTA_V60), #   附加信息配额 (用于云存储服务器，目前支持的附加信息有：热度图、客流量)
        ("struPubInfoFile", NET_DVR_DISK_QUOTA_V60), #  发布信息文件配额百分比
        ("byRes", BYTE * 256), # 保留字节字节
    ]


LPNET_DVR_DISK_QUOTA_CFG_V60 = POINTER(NET_DVR_DISK_QUOTA_CFG_V60)


class NET_DVR_TIMING_CAPTURE(Structure):
    _fields_ = [
        ("struJpegPara", NET_DVR_JPEGPARA), #  定时抓图图片质量
        ("dwPicInterval", DWORD), #  定时抓图时间间隔,单位s   1-1s 2-2s 3-3s 4-4s 5-5s
        # 6-10m 7-30m 8-1h 9-12h 10-24h
        ("byRes", BYTE * 12), #  保留字节
    ]


LPNET_DVR_TIMING_CAPTURE = POINTER(NET_DVR_TIMING_CAPTURE)


class NET_DVR_REL_CAPTURE_CHAN(Structure):
    _fields_ = [
        ("byChan", BYTE * 16), #  按位表示
        ("byRes", BYTE * 20), #  保留字节
    ]


LPNET_DVR_REL_CAPTURE_CHAN = POINTER(NET_DVR_REL_CAPTURE_CHAN)


MAX_PIC_EVENT_NUM = 32
MAX_ALARMIN_CAPTURE = 16
class NET_DVR_REL_CAPTURE_CHAN_V40(Structure):
    _fields_ = [
        ("dwMaxRelCaptureChanNum", DWORD), # 最大可触发的关联通道数-只读属性
        ("dwChanNo", DWORD * MAX_CHANNUM_V40), # 触发的关联抓图通道号，按值表示，采用紧凑型排列,0xffffffff表示后续无效
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_REL_CAPTURE_CHAN_V40 = POINTER(NET_DVR_REL_CAPTURE_CHAN_V40)


class NET_DVR_EVENT_CAPTURE_V40(Structure):
    _fields_ = [
        ("struJpegPara", NET_DVR_JPEGPARA), #  事件抓图图片质量
        ("dwPicInterval", DWORD), #  事件抓图时间间隔  单位为秒
        ("struRelCaptureChan", NET_DVR_REL_CAPTURE_CHAN_V40 * MAX_PIC_EVENT_NUM), #  数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图 2 视频丢失触发抓图,数组3表示PIR报警抓图，数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图
        ("struAlarmInCapture", NET_DVR_REL_CAPTURE_CHAN_V40 * MAX_ALARMIN_CAPTURE), #  报警输入触发抓图，下标0 代表报警输入1 依次类推
        ("dwMaxGroupNum", DWORD), # 设备支持的最大报警输入组数，每组16个报警输入
        ("byCapTimes", BYTE), # 抓图张数
        ("byRes", BYTE * 59),
    ]


LPNET_DVR_EVENT_CAPTURE_V40 = POINTER(NET_DVR_EVENT_CAPTURE_V40)


class NET_DVR_EVENT_CAPTURE(Structure):
    _fields_ = [
        ("struJpegPara", NET_DVR_JPEGPARA), #  事件抓图图片质量
        ("dwPicInterval", DWORD), #  事件抓图时间间隔  单位为秒  1-1s 2-2s 3-3s 4-4s 5-5s
        # 6-10m 7-30m 8-1h 9-12h 10-24h
        #
        # 数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图，2 视频丢失触发抓图,数组3表示PIR报警抓图，
        # 数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图,数组7 表示人脸侦测抓图，
        # 数组8 表示-越界侦测侦测抓图，数组9 表示区域入侵侦测抓图,数组10表示场景变更侦测抓图,
        # 数组11-进入区域侦测,数组12-离开区域侦测,数组13-徘徊侦测,数组14-人员聚集侦测,数组15-快速运动侦测,
        # 数组16-停车侦测,数组17-物品遗留侦测,数组18-物品拿取侦测。
        #
        ("struRelCaptureChan", NET_DVR_REL_CAPTURE_CHAN * MAX_PIC_EVENT_NUM),
        ("struAlarmInCapture", NET_DVR_REL_CAPTURE_CHAN * MAX_ALARMIN_CAPTURE), #  报警输入触发抓图，下标0 代表报警输入1 依次类推
        ("byCapTimes", BYTE), # 抓图张数
        ("byRes", BYTE * 59),
    ]


LPNET_DVR_EVENT_CAPTURE = POINTER(NET_DVR_EVENT_CAPTURE)


class NET_DVR_JPEG_CAPTURE_CFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("struTimingCapture", NET_DVR_TIMING_CAPTURE),
        ("struEventCapture", NET_DVR_EVENT_CAPTURE_V40),
        ("byStreamType", BYTE), # 抓图码流类型 0-主码流，1-子码流
        ("byRes3", BYTE * 19), #  保留字节
    ]


LPNET_DVR_JPEG_CAPTURE_CFG_V40 = POINTER(NET_DVR_JPEG_CAPTURE_CFG_V40)


class NET_DVR_JPEG_CAPTURE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struTimingCapture", NET_DVR_TIMING_CAPTURE),
        ("struEventCapture", NET_DVR_EVENT_CAPTURE),
        ("byStreamType", BYTE), # 抓图码流类型 0-主码流，1-子码流
        ("byRes3", BYTE * 19), #  保留字节
    ]


LPNET_DVR_JPEG_CAPTURE_CFG = POINTER(NET_DVR_JPEG_CAPTURE_CFG)


class NET_DVR_CAPTURE_DAY(Structure):
    _fields_ = [
        ("byAllDayCapture", BYTE), #  是否全天抓图
        ("byCaptureType", BYTE), #  抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图,7-智能侦测抓图，8-全部事件 ,39-离线测温抓图,40-防区报警，41-紧急求助,42业务咨询  43-废气排放监测 44-灰度报警
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_CAPTURE_DAY = POINTER(NET_DVR_CAPTURE_DAY)


class NET_DVR_CAPTURE_SCHED(Structure):
    _fields_ = [
        ("struCaptureTime", NET_DVR_SCHEDTIME), #  抓图时间段
        ("byCaptureType", BYTE), #  抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图,7-智能侦测抓图，8-全部事件  ,39-离线测温抓图 ,40-防区报警，41-紧急求助,42业务咨询 43-废气排放监测 44-灰度报警
        ("byRes", BYTE * 3), #  保留字节
    ]


LPNET_DVR_CAPTURE_SCHED = POINTER(NET_DVR_CAPTURE_SCHED)


#  通道抓图计划
class NET_DVR_SCHED_CAPTURECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体
        ("byEnable", BYTE), #  是否抓图
        ("byRes1", BYTE * 3), #  保留字节
        ("struCaptureDay", NET_DVR_CAPTURE_DAY * MAX_DAYS), #  全天抓图计划
        ("struCaptureSched", NET_DVR_CAPTURE_SCHED * MAX_DAYS), #  时间段抓图布防计划
        ("struCaptureHoliday", NET_DVR_CAPTURE_DAY), #  假日抓图计划
        ("struHolidaySched", NET_DVR_CAPTURE_SCHED * MAX_TIMESEGMENT_V30), #  时间段假日抓图布防计划
        ("dwRecorderDuration", DWORD), #  抓图保存最长时间 0xffffffff表示该值无效
        ("dwDelayTime", DWORD), #  抓图延时时间 0- 无延时， 1-3秒， 2-4秒， 3-5秒， 4-10秒， 5-30秒， 6-60秒， 7- 120秒，8-300秒
        ("byRes", BYTE * 36), #  保留字节
    ]


LPNET_DVR_SCHED_CAPTURECFG = POINTER(NET_DVR_SCHED_CAPTURECFG)


class NET_DVR_FLOW_TEST_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("lCardIndex", LONG), # 网卡索引
        ("dwInterval", DWORD), # 设备上传流量时间间隔, 单位:100ms
        ("byRes", BYTE * 8), # 保留字节
    ]


LPNET_DVR_FLOW_TEST_PARAM = POINTER(NET_DVR_FLOW_TEST_PARAM)


class NET_DVR_FLOW_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwSendFlowSize", DWORD), # 发送流量大小,单位kbps
        ("dwRecvFlowSize", DWORD), # 接收流量大小,单位kbps
        ("byRes", BYTE * 20), # 保留
    ]


LPNET_DVR_FLOW_INFO = POINTER(NET_DVR_FLOW_INFO)


#   录像标签
LABEL_NAME_LEN = 40
class NET_DVR_RECORD_LABEL(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struTimeLabel", NET_DVR_TIME), #  标签的时间
        ("byQuickAdd", BYTE), #  是否快速添加 快速添加时标签名称无效
        ("byRes1", BYTE * 3), #  保留字节
        ("sLabelName", BYTE * LABEL_NAME_LEN), #  标签的名称 长度为40字节
        ("byRes2", BYTE * 40), #  保留字节
    ]


LPNET_DVR_RECORD_LABEL = POINTER(NET_DVR_RECORD_LABEL)


LABEL_IDENTIFY_LEN = 64
class NET_DVR_LABEL_IDENTIFY(Structure):
    _fields_ = [
        ("sLabelIdentify", BYTE * LABEL_IDENTIFY_LEN), #  64字节标识
        ("byRes", BYTE * 8), #  保留字节
    ]


LPNET_DVR_LABEL_IDENTIFY = POINTER(NET_DVR_LABEL_IDENTIFY)


MAX_DEL_LABEL_IDENTIFY = 20 #  删除的最大标签标识个数
class NET_DVR_DEL_LABEL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byMode", BYTE), #  按位表示,0x01表示按标识删除
        ("byRes1", BYTE),
        ("wLabelNum", WORD), #  标签数目
        ("struIndentify", NET_DVR_LABEL_IDENTIFY * MAX_DEL_LABEL_IDENTIFY), #  标签标识
        ("byRes2", BYTE * 160), # 保留字节
    ]


LPNET_DVR_DEL_LABEL_PARAM = POINTER(NET_DVR_DEL_LABEL_PARAM)


class NET_DVR_MOD_LABEL_PARAM(Structure):
    _fields_ = [
        ("struIndentify", NET_DVR_LABEL_IDENTIFY), # 要修改的标签标识
        ("byRes1", BYTE * 24),
        ("sLabelName", BYTE * LABEL_NAME_LEN), # 修改后的标签名称
        ("byRes2", BYTE * 40),
    ]


LPNET_DVR_MOD_LABEL_PARAM = POINTER(NET_DVR_MOD_LABEL_PARAM)


#  标签搜索结构体
class NET_DVR_FIND_LABEL(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("lChannel", LONG), #  查找的通道
        ("struStartTime", NET_DVR_TIME), #  开始时间
        ("struStopTime", NET_DVR_TIME), #  结束时间
        ("sLabelName", BYTE * LABEL_NAME_LEN), #   录像标签名称 如果标签名称为空，则搜索起止时间所有标签
        ("byDrawFrame", BYTE), # 0:不抽帧，1：抽帧
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("byRes", BYTE * 34), #  保留字节
    ]


LPNET_DVR_FIND_LABEL = POINTER(NET_DVR_FIND_LABEL)


#  标签信息结构体
class NET_DVR_FINDLABEL_DATA(Structure):
    _fields_ = [
        ("sLabelName", BYTE * LABEL_NAME_LEN), #  标签名称
        ("struTimeLabel", NET_DVR_TIME), #  标签时间
        ("struLabelIdentify", NET_DVR_LABEL_IDENTIFY), #  标签标识
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("byRes", BYTE * 29), #  保留字节
    ]


LPNET_DVR_FINDLABEL_DATA = POINTER(NET_DVR_FINDLABEL_DATA)


CARDNUM_LEN_V30 = 40
# 国家枚举
COUNTRY_NONSUPPORT = 0
        # 五大洲 一共有235国家和地区
        # 欧洲 48个国家和地区 其中 塞浦路斯(Cyprus)属于亚欧两洲交界国家
COUNTRY_CZE = 1
COUNTRY_FRA = 2
COUNTRY_DEU = 3
COUNTRY_ESP = 4
COUNTRY_ITA = 5
COUNTRY_NLD = 6
COUNTRY_POL = 7
COUNTRY_SVK = 8
COUNTRY_BLR = 9
COUNTRY_MDA = 10
COUNTRY_RUS = 11
COUNTRY_UKR = 12
COUNTRY_BEL = 13
COUNTRY_BGR = 14
COUNTRY_DNK = 15
COUNTRY_FIN = 16
COUNTRY_GBR = 17
COUNTRY_GRC = 18
COUNTRY_HRV = 19
COUNTRY_HUN = 20
COUNTRY_ISR = 21
COUNTRY_LUX = 22
COUNTRY_MKD = 23
COUNTRY_NOR = 24
COUNTRY_PRT = 25
COUNTRY_ROU = 26
COUNTRY_SRB = 27
COUNTRY_AZE = 28
COUNTRY_GEO = 29
COUNTRY_KAZ = 30
COUNTRY_LTU = 31
COUNTRY_TKM = 32
COUNTRY_UZB = 33
COUNTRY_LVA = 34
COUNTRY_EST = 35
COUNTRY_ALB = 36
COUNTRY_AUT = 37
COUNTRY_BIH = 38
COUNTRY_IRL = 39
COUNTRY_ISL = 40
COUNTRY_VAT = 41
COUNTRY_MLT = 42
COUNTRY_SWE = 43
COUNTRY_CHE = 44
COUNTRY_CYP = 45
COUNTRY_TUR = 46
COUNTRY_SVN = 47
COUNTRY_MTG = 48
COUNTRY_KOV = 49
COUNTRY_ADR = 50
COUNTRY_ARM = 51
COUNTRY_MON = 52
COUNTRY_LIE = 53
COUNTRY_SMO = 54
COUNTRY_ORN = 55
COUNTRY_RES2 = 56
COUNTRY_RES3 = 57
COUNTRY_RES4 = 58
        # 亚洲 48个国家 其中 塞浦路斯(Cyprus)属于亚欧两洲交界国家
COUNTRY_CHI = 59
COUNTRY_IBN = 60
COUNTRY_SKR = 61
COUNTRY_LEB = 62
COUNTRY_NEP = 63
COUNTRY_THA = 64
COUNTRY_PAK = 65
COUNTRY_EMI = 66
COUNTRY_BHU = 67
COUNTRY_OMA = 68
COUNTRY_KOR = 69
COUNTRY_PHI = 70
COUNTRY_CAM = 71
COUNTRY_QAT = 72
COUNTRY_KYR = 73
COUNTRY_MAL = 74
COUNTRY_MLY = 75
COUNTRY_MOG = 76
COUNTRY_ARA = 77
COUNTRY_BRU = 78
COUNTRY_LAO = 79
COUNTRY_JAP = 80
COUNTRY_RES19 = 81
COUNTRY_PAS = 82
COUNTRY_TAJ = 83
COUNTRY_KUW = 84
COUNTRY_SYR = 85
COUNTRY_IND = 86
COUNTRY_ISA = 87
COUNTRY_AFG = 88
COUNTRY_LAN = 89
COUNTRY_IRQ = 90
COUNTRY_VIE = 91
COUNTRY_IRA = 92
COUNTRY_YEM = 93
COUNTRY_JOR = 94
COUNTRY_BUR = 95
COUNTRY_SIK = 96
COUNTRY_BAN = 97
COUNTRY_SGA = 98
COUNTRY_EAT = 99
COUNTRY_RES5 = 100
COUNTRY_RES6 = 101
COUNTRY_RES7 = 102
COUNTRY_RES8 = 103
        # 非洲 60个国家和地区
COUNTRY_EGT = 104
COUNTRY_LIY = 105
COUNTRY_SUA = 106
COUNTRY_TUN = 107
COUNTRY_ALG = 108
COUNTRY_MCC = 109
COUNTRY_ETH = 110
COUNTRY_ERI = 111
COUNTRY_SDE = 112
COUNTRY_DJI = 113
COUNTRY_KEN = 114
COUNTRY_TAI = 115
COUNTRY_UGA = 116
COUNTRY_RWA = 117
COUNTRY_BUD = 118
COUNTRY_SEY = 119
COUNTRY_CHA = 120
COUNTRY_CEA = 121
COUNTRY_CON = 122
COUNTRY_EQG = 123
COUNTRY_GAB = 124
COUNTRY_TCO = 125
COUNTRY_DRC = 126
COUNTRY_STP = 127
COUNTRY_MAN = 128
COUNTRY_WSA = 129
COUNTRY_SEL = 130
COUNTRY_TGA = 131
COUNTRY_MAI = 132
COUNTRY_BUF = 133
COUNTRY_GUI = 134
COUNTRY_GUB = 135
COUNTRY_CAV = 136
COUNTRY_SLE = 137
COUNTRY_LIR = 138
COUNTRY_IVC = 139
COUNTRY_GHA = 140
COUNTRY_TGO = 141
COUNTRY_BEN = 142
COUNTRY_NIG = 143
COUNTRY_ZAB = 144
COUNTRY_ANG = 145
COUNTRY_ZBE = 146
COUNTRY_MAW = 147
COUNTRY_MOQ = 148
COUNTRY_BOT = 149
COUNTRY_NAM = 150
COUNTRY_SAF = 151
COUNTRY_SWD = 152
COUNTRY_LES = 153
COUNTRY_MAG = 154
COUNTRY_UOC = 155
COUNTRY_MAT = 156
COUNTRY_NGE = 157
COUNTRY_SSD = 158
COUNTRY_SAH = 159
COUNTRY_MYT = 160
COUNTRY_REN = 161
COUNTRY_CAI = 162
COUNTRY_AZO = 163
COUNTRY_MAD = 164
COUNTRY_RES9 = 165
COUNTRY_RES10 = 166
COUNTRY_RES11 = 167
COUNTRY_RES12 = 168
        # 美洲 55个国家和地区
COUNTRY_CAD = 169
COUNTRY_GRE = 170
COUNTRY_PIE = 171
COUNTRY_USA = 172
COUNTRY_BER = 173
COUNTRY_MEX = 174
COUNTRY_GUA = 175
COUNTRY_BLI = 176
COUNTRY_SAR = 177
COUNTRY_HOR = 178
COUNTRY_NIC = 179
COUNTRY_COR = 180
COUNTRY_PAN = 181
COUNTRY_TBM = 182
COUNTRY_TCI = 183
COUNTRY_CUB = 184
COUNTRY_JAM = 185
COUNTRY_CAY = 186
COUNTRY_HAT = 187
COUNTRY_TDO = 188
COUNTRY_PUR = 189
COUNTRY_VIL = 190
COUNTRY_BVI = 191
COUNTRY_ATV = 192
COUNTRY_ANB = 193
COUNTRY_CSM = 194
COUNTRY_ACY = 195
COUNTRY_SBY = 196
COUNTRY_SKN = 197
COUNTRY_MOT = 198
COUNTRY_GLP = 199
COUNTRY_DOM = 200
COUNTRY_MTE = 201
COUNTRY_LUC = 202
COUNTRY_SVG = 203
COUNTRY_GRD = 204
COUNTRY_BAR = 205
COUNTRY_TRT = 206
COUNTRY_CUR = 207
COUNTRY_ARB = 208
COUNTRY_NEA = 209
COUNTRY_COL = 210
COUNTRY_VEN = 211
COUNTRY_GUY = 212
COUNTRY_SUR = 213
COUNTRY_FRN = 214
COUNTRY_ECU = 215
COUNTRY_PER = 216
COUNTRY_BOL = 217
COUNTRY_PAR = 218
COUNTRY_CLE = 219
COUNTRY_BRA = 220
COUNTRY_UGY = 221
COUNTRY_ARG = 222
COUNTRY_RES13 = 223
COUNTRY_RES14 = 224
COUNTRY_RES15 = 225
COUNTRY_RES16 = 226
        # 大洋洲 25个国家和地区
COUNTRY_ATN = 227
COUNTRY_NED = 228
COUNTRY_PNG = 229
COUNTRY_SAN = 230
COUNTRY_VAU = 231
COUNTRY_NCN = 232
COUNTRY_PAU = 233
COUNTRY_FSM = 234
COUNTRY_MRI = 235
COUNTRY_CNM = 236
COUNTRY_TEG = 237
COUNTRY_NUR = 238
COUNTRY_KIB = 239
COUNTRY_FID = 240
COUNTRY_TNG = 241
COUNTRY_TUV = 242
COUNTRY_WEF = 243
COUNTRY_TIS = 244
COUNTRY_EAS = 245
COUNTRY_TOE = 246
COUNTRY_NUE = 247
COUNTRY_TCD = 248
COUNTRY_PFP = 249
COUNTRY_PID = 250
COUNTRY_HAW = 251
COUNTRY_RES17 = 252
COUNTRY_INVALID = 0xfd
COUNTRY_UNRECOGNIZED = 0xfe
COUNTRY_ALL = 0xff


#  国家 / 区域枚举
CR_NONSUPPORT = 0
        # 五大洲 一共有235国家和地区
        # 欧洲 48个国家和地区 其中 塞浦路斯(Cyprus)属于亚欧两洲交界国家
CR_CZE = 1
CR_FRA = 2
CR_DEU = 3
CR_ESP = 4
CR_ITA = 5
CR_NLD = 6
CR_POL = 7
CR_SVK = 8
CR_BLR = 9
CR_MDA = 10
CR_RUS = 11
CR_UKR = 12
CR_BEL = 13
CR_BGR = 14
CR_DNK = 15
CR_FIN = 16
CR_GBR = 17
CR_GRC = 18
CR_HRV = 19
CR_HUN = 20
CR_ISR = 21
CR_LUX = 22
CR_MKD = 23
CR_NOR = 24
CR_PRT = 25
CR_ROU = 26
CR_SRB = 27
CR_AZE = 28
CR_GEO = 29
CR_KAZ = 30
CR_LTU = 31
CR_TKM = 32
CR_UZB = 33
CR_LVA = 34
CR_EST = 35
CR_ALB = 36
CR_AUT = 37
CR_BIH = 38
CR_IRL = 39
CR_ISL = 40
CR_VAT = 41
CR_MLT = 42
CR_SWE = 43
CR_CHE = 44
CR_CYP = 45
CR_TUR = 46
CR_SVN = 47
CR_MTG = 48
CR_KOV = 49
CR_ADR = 50
CR_ARM = 51
CR_MON = 52
CR_LIE = 53
CR_SMO = 54
CR_ORN = 55
CR_RES2 = 56
CR_RES3 = 57
CR_RES4 = 58
        # 亚洲 48个国家 其中 塞浦路斯(Cyprus)属于亚欧两洲交界国家
CR_CHI = 59
CR_IBN = 60
CR_SKR = 61
CR_LEB = 62
CR_NEP = 63
CR_THA = 64
CR_PAK = 65
CR_EMI = 66
CR_BHU = 67
CR_OMA = 68
CR_KOR = 69
CR_PHI = 70
CR_CAM = 71
CR_QAT = 72
CR_KYR = 73
CR_MAL = 74
CR_MLY = 75
CR_MOG = 76
CR_ARA = 77
CR_BRU = 78
CR_LAO = 79
CR_JAP = 80
CR_RES19 = 81
CR_PAS = 82
CR_TAJ = 83
CR_KUW = 84
CR_SYR = 85
CR_IND = 86
CR_ISA = 87
CR_AFG = 88
CR_LAN = 89
CR_IRQ = 90
CR_VIE = 91
CR_IRA = 92
CR_YEM = 93
CR_JOR = 94
CR_BUR = 95
CR_SIK = 96
CR_BAN = 97
CR_SGA = 98
CR_EAT = 99
CR_RES5 = 100
CR_RES6 = 101
CR_RES7 = 102
CR_RES8 = 103
        # 非洲 60个国家和地区
CR_EGT = 104
CR_LIY = 105
CR_SUA = 106
CR_TUN = 107
CR_ALG = 108
CR_MCC = 109
CR_ETH = 110
CR_ERI = 111
CR_SDE = 112
CR_DJI = 113
CR_KEN = 114
CR_TAI = 115
CR_UGA = 116
CR_RWA = 117
CR_BUD = 118
CR_SEY = 119
CR_CHA = 120
CR_CEA = 121
CR_CON = 122
CR_EQG = 123
CR_GAB = 124
CR_TCO = 125
CR_DRC = 126
CR_STP = 127
CR_MAN = 128
CR_WSA = 129
CR_SEL = 130
CR_TGA = 131
CR_MAI = 132
CR_BUF = 133
CR_GUI = 134
CR_GUB = 135
CR_CAV = 136
CR_SLE = 137
CR_LIR = 138
CR_IVC = 139
CR_GHA = 140
CR_TGO = 141
CR_BEN = 142
CR_NIG = 143
CR_ZAB = 144
CR_ANG = 145
CR_ZBE = 146
CR_MAW = 147
CR_MOQ = 148
CR_BOT = 149
CR_NAM = 150
CR_SAF = 151
CR_SWD = 152
CR_LES = 153
CR_MAG = 154
CR_UOC = 155
CR_MAT = 156
CR_NGE = 157
CR_SSD = 158
CR_SAH = 159
CR_MYT = 160
CR_REN = 161
CR_CAI = 162
CR_AZO = 163
CR_MAD = 164
CR_RES9 = 165
CR_RES10 = 166
CR_RES11 = 167
CR_RES12 = 168
        # 美洲 55个国家和地区
CR_CAD = 169
CR_GRE = 170
CR_PIE = 171
CR_USA = 172
CR_BER = 173
CR_MEX = 174
CR_GUA = 175
CR_BLI = 176
CR_SAR = 177
CR_HOR = 178
CR_NIC = 179
CR_COR = 180
CR_PAN = 181
CR_TBM = 182
CR_TCI = 183
CR_CUB = 184
CR_JAM = 185
CR_CAY = 186
CR_HAT = 187
CR_TDO = 188
CR_PUR = 189
CR_VIL = 190
CR_BVI = 191
CR_ATV = 192
CR_ANB = 193
CR_CSM = 194
CR_ACY = 195
CR_SBY = 196
CR_SKN = 197
CR_MOT = 198
CR_GLP = 199
CR_DOM = 200
CR_MTE = 201
CR_LUC = 202
CR_SVG = 203
CR_GRD = 204
CR_BAR = 205
CR_TRT = 206
CR_CUR = 207
CR_ARB = 208
CR_NEA = 209
CR_COL = 210
CR_VEN = 211
CR_GUY = 212
CR_SUR = 213
CR_FRN = 214
CR_ECU = 215
CR_PER = 216
CR_BOL = 217
CR_PAR = 218
CR_CLE = 219
CR_BRA = 220
CR_UGY = 221
CR_ARG = 222
CR_RES13 = 223
CR_RES14 = 224
CR_RES15 = 225
CR_RES16 = 226
        # 大洋洲 25个国家和地区
CR_ATN = 227
CR_NED = 228
CR_PNG = 229
CR_SAN = 230
CR_VAU = 231
CR_NCN = 232
CR_PAU = 233
CR_FSM = 234
CR_MRI = 235
CR_CNM = 236
CR_TEG = 237
CR_NUR = 238
CR_KIB = 239
CR_FID = 240
CR_TNG = 241
CR_TUV = 242
CR_WEF = 243
CR_TIS = 244
CR_EAS = 245
CR_TOE = 246
CR_NUE = 247
CR_TCD = 248
CR_PFP = 249
CR_PID = 250
CR_HAW = 251
CR_RES17 = 252
CR_RES18 = 253
CR_UNRECOGNIZED = 0xfe
CR_ALL = 0xff
        #
        # 下面是新增的区域
CR_TAIWAN = 256


# 阿拉伯联合酋长国区域枚举
EMI_AREA_UNKNOWN = 0
        # EMI_AREA_AD,                阿布扎比
        # EMI_AREA_FJR,               富查伊哈
        # EMI_AREA_DB,                迪拜
        # EMI_AREA_RAK,               哈伊马角
        # EMI_AREA_AM,                阿治曼
        # EMI_AREA_SJ,                沙迦
        # EMI_AREA_UMW,               乌姆盖万
EMI_AREA_OTHER = 0xff


class NET_DVR_FIND_PICTURE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("lChannel", LONG), #  通道号
        # 查找的图片类型:0定时抓图1 移动侦测抓图 2 报警抓图，
        # 3 报警 | 移动侦测抓图 4 报警 & 移动侦测抓图 6 手动抓图 ,
        # 9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,
        # 0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，
        # 0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测,
        # 0x13-进入区域侦测,0x14-离开区域侦测,0x15-徘徊侦测,
        # 0x16-人员聚集侦测,0x17-快速运动侦测,0x18-停车侦测,
        # 0x19-物品遗留侦测,0x1a-物品拿取侦测, 0x1b-车牌侦测,
        # 0x1c-混行检测,0x1d-取证事件,0x1e-火点检测,0x1f-防破坏检测,
        # 0x20-船只检测，0x21-测温预警，0x22-测温报警, 0x23测差报警,
        # 0x24违停检测,0x25-人脸抓拍,0x26-离线测温报警,0x2a-起身检测,
        # 0x2b-折线攀高,0x2c-如厕超时,0x2d-安全帽检测,0x2e-周界抓拍,
        # 0x2f-人体目标抓拍,0x30-人脸抓拍建模, 0x31-混合目标检测,
        # 0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询,0x35-非法摆摊,
        # 0x36-人员密度（人数预警）,0x37-离岗检测,0x38-人数异常检测,
        # 0x39-剧烈运动检测, 0x3a-违停, 0x3b-逆行,0x3c-压线,0x3d-机占非,0x3e-变道,0x3f-掉头,0x40-行人检测,0x41-路障,
        # 0x42-抛洒物,0x43-浓雾检测,0x44-施工,0x45-拥堵,0x46-交通事故检测, 0x47-侧方停车，0x48-手动触发报警,
        # 0x49-玩手机检测,0x4b-司机驾驶行为,0x4c-高级辅助驾驶,0x4d-挖沙船检测报警,
        # 0x52-排队检测人数,0x53-排队检测时长,0x54-车辆布控(包括手动布控，日常布控以及平台布控), 0x55-定时唤醒抓拍, 0x56-废气排放监测 ,
        # 0x57-灰度报警, 0x58-振动侦测,0x59-人员奔跑,0x5a-人员滞留,0x5b-间距异常,0x5c-人员倒地,0xff- 全部类型
        ("byFileType", BYTE),
        ("byNeedCard", BYTE), #  是否需要卡号
        #
        # 0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，
        # 8-贵，9-琼，10-冀，11-豫，12-黑，13-鄂，14-湘，
        # 15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，
        # 22-鲁，23-晋，24-陕，25-沪，26-川，27-台，28-津，
        # 29-藏，30-港，31-新，32-云，33-浙，34-皖，0xff-全部
        #
        ("byProvince", BYTE), # 省份索引值
        ("byEventType", BYTE), #  事件类型：0保留，1-交通事件；2-违章取证；3-其他事件
        ("sCardNum", BYTE * CARDNUM_LEN_V30), #  卡号
        ("struStartTime", NET_DVR_TIME), # 查找图片的开始时间
        ("struStopTime", NET_DVR_TIME), #  查找图片的结束时间
        # ITC3.7 新增
        ("dwTrafficType", DWORD), # 图片检索生效项 参考 VCA_OPERATE _TYPE
        ("dwVehicleType", DWORD), # 车辆类型 参考 VCA_VEHICLE_TYPE
        # 违规检测类型参考 VCA_ILLEGAL_TYPE 当前不支持复选
        ("dwIllegalType", DWORD),
        ("byLaneNo", BYTE), # 车道号(1~99)
        ("bySubHvtType", BYTE), # 0-保留,1-机动车(机动车子类型中支持车牌检索，省份检索),2-非机动车,3-行人
        ("bySubDriveType", BYTE), # 驾驶子类型
        # 当byFileType为0x4b-司机驾驶行为时，含义为司机驾驶行为类型，具体定义：0-保留、1-抽烟、2-接打电话、3-疲劳驾驶、4-分神提醒、5-驾驶员异常、6-未系安全带、7-红外阻断墨镜、8-双手脱离方向盘、9-单手脱离方向盘、10-驾驶员身份异常、11-超时驾驶、12-驾驶员变更
        # 当byFileType为0x4c-高级辅助驾驶时，含义为高级辅助驾驶类型，具体定义：0-保留、1-前向碰撞、2-车道偏离(左)、3-车道偏离(右)、4-车距过近、5-行人防撞、6-盲区检测(右后方)、7-盲区检测(左后方)、8-盲区检测(后方)
        ("byRes2", BYTE), # 保留字节
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("byRegion", BYTE), #  区域索引值 0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS), 4-中东(Middle East),0xff-所有
        ("byCountry", BYTE), #  国家索引值，参照：COUNTRY_INDEX
        ("byArea", BYTE), # 地区
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    ]


LPNET_DVR_FIND_PICTURE_PARAM = POINTER(NET_DVR_FIND_PICTURE_PARAM)


# PC NVR的文件搜索条件
class NET_DVR_FILE_COND_PCNVR(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struIpAddr", NET_DVR_IPADDR), # IP地址
        ("wIpPort", WORD), # 端口号
        ("byRes", BYTE * 2), # 保留字节
        ("sDomainName", CHAR * MAX_DOMAIN_NAME), # 域名(暂时没用)
        ("sSerial", CHAR * SERIALNO_LEN), # 序列号
        #
        ("lChannel", DWORD), # 通道号
        ("dwFileType", DWORD), # 录象文件类型0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，
        # 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像
        ("dwIsLocked", DWORD), # 是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
        ("dwUseCardNo", DWORD), # 是否使用卡号
        ("sCardNumber", BYTE * CARDNUM_LEN_V30), # 卡号
        ("struStartTime", NET_DVR_TIME), # 开始时间
        ("struStopTime", NET_DVR_TIME), # 结束时间
    ]


LPNET_DVR_FILE_COND_PCNVR = POINTER(NET_DVR_FILE_COND_PCNVR)


# PCNVR的录像搜索结果文件
class NET_DVR_FINDDATA_PCNVR(Structure):
    _fields_ = [
        ("sFileName", CHAR * 100), # 文件名
        ("struStartTime", NET_DVR_TIME), # 文件的开始时间
        ("struStopTime", NET_DVR_TIME), # 文件的结束时间
        ("dwFileSize", DWORD), # 文件的大小
        ("sCardNum", CHAR * CARDNUM_LEN_V30),
        ("byLocked", BYTE), # 9000设备支持,1表示此文件已经被锁定,0表示正常的文件
        ("byFileType", BYTE), # 文件类型
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_FINDDATA_PCNVR = POINTER(NET_DVR_FINDDATA_PCNVR)


PICTURE_NAME_LEN = 64
PICTURE_INFO_MAX_SIZE = 640*960*1.5

class NET_DVR_FIND_PICTURE(Structure):
    _fields_ = [
        ("sFileName", CHAR * PICTURE_NAME_LEN), # 图片名
        ("struTime", NET_DVR_TIME), # 图片的时间
        ("dwFileSize", DWORD), # 图片的大小
        ("sCardNum", CHAR * CARDNUM_LEN_V30), # 卡号
        ("byPlateColor", BYTE), # 参考结构 VCA_PLATE_COLOR
        ("byVehicleLogo", BYTE), # 参考结构 VLR_VEHICLE_CLASS
        ("byEventSearchStatus", BYTE), # 连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
        ("byRecogResult", BYTE), # 识别结果参考结构VTR_RESULT
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_FIND_PICTURE = POINTER(NET_DVR_FIND_PICTURE)


MAX_RECORD_PICTURE_NUM = 50 #   最大备份图片张数
class NET_DVR_BACKUP_PICTURE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwPicNum", DWORD),
        ("struPicture", NET_DVR_FIND_PICTURE * MAX_RECORD_PICTURE_NUM),
        ("byDiskDes", BYTE * DESC_LEN_32),
        ("byWithPlayer", BYTE),
        ("byContinue", BYTE), # 是否继续备份 0不继续 1继续
        ("byRes", BYTE * 34),
    ]


LPNET_DVR_BACKUP_PICTURE_PARAM = POINTER(NET_DVR_BACKUP_PICTURE_PARAM)


STEP_READY = 0 # 准备升级
STEP_RECV_DATA = 1 # 接收升级包数据
STEP_UPGRADE = 2 # 升级系统
STEP_BACKUP = 3 # 备份系统
STEP_SEARCH = 255 # 搜索升级文件
class NET_DVR_VIDEO_EFFECT(Structure):
    _fields_ = [
        ("dwBrightValue", DWORD), # 亮度[0,255]
        ("dwContrastValue", DWORD), # 对比度[0,255]
        ("dwSaturationValue", DWORD), # 饱和度[0,255]
        ("dwHueValue", DWORD), # 色调[0,255]
        ("dwSharpness", DWORD), # 锐度[0,255]
        ("dwDenoising", DWORD), # 去噪[0,255]
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_VIDEO_EFFECT = POINTER(NET_DVR_VIDEO_EFFECT)


class NET_DVR_VIDEO_INPUT_EFFECT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("wEffectMode", WORD), # 模式 0-标准 1-室内 2-弱光 3-室外  255-自定义
        ("byRes1", BYTE * 146), # 保留
        ("struVideoEffect", NET_DVR_VIDEO_EFFECT), # 视频效果参数
        ("byRes2", BYTE * 60), # 保留
    ]


LPNET_DVR_VIDEO_INPUT_EFFECT = POINTER(NET_DVR_VIDEO_INPUT_EFFECT)


class NET_DVR_VIDEOPARA_V40(Structure):
    _fields_ = [
        ("dwChannel", DWORD), #  通道号
        ("dwVideoParamType", DWORD), #  视频参数类型 0-亮度 1-对比度 2-饱和度 3-色度 4-锐度 5-去噪
        ("dwVideoParamValue", DWORD), # 对应的视频参数值，范围依据能力集
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_VIDEOPARA_V40 = POINTER(NET_DVR_VIDEOPARA_V40)


class NET_DVR_DEFAULT_VIDEO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwChannel", DWORD), #  通道号
        ("dwVideoMode", DWORD), #  模式
        ("byRes", BYTE * 32), #  保留
    ]


LPNET_DVR_DEFAULT_VIDEO_COND = POINTER(NET_DVR_DEFAULT_VIDEO_COND)


class NET_DVR_ENCODE_JOINT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byJointed", BYTE), #   0 没有关联 1 已经关联
        ("byDevType", BYTE), #  被关联的设备类型  1 代表智能设备
        ("byRes1", BYTE * 2), #  保留字节
        ("struIP", NET_DVR_IPADDR), #  关联的被取流设备IP地址
        ("wPort", WORD), #  关联的被取流设备端口号
        ("wChannel", WORD), #  关联的被取流设备通道号
        ("byRes2", BYTE * 20), #  保留字节
    ]


LPNET_DVR_ENCODE_JOINT_PARAM = POINTER(NET_DVR_ENCODE_JOINT_PARAM)


class NET_DVR_VCA_CHAN_WORKSTATUS(Structure):
    _fields_ = [
        ("byJointed", BYTE), #  0-没有关联  1-已经关联
        ("byRes1", BYTE * 3),
        ("struIP", NET_DVR_IPADDR), #  关联的取流设备IP地址
        ("wPort", WORD), #  关联的取流设备端口号
        ("wChannel", WORD), #  关联的取流设备通道号
        ("byVcaChanStatus", BYTE), #  0 - 未启用 1 - 启用
        ("byRes2", BYTE * 19), #  保留字节
    ]


LPNET_DVR_VCA_CHAN_WORKSTATUS = POINTER(NET_DVR_VCA_CHAN_WORKSTATUS)


class NET_DVR_VCA_DEV_WORKSTATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byDeviceStatus", BYTE), #  设备的状态0 - 正常工作 1- 不正常工作
        ("byCpuLoad", BYTE), #  CPU使用率0-100 分别代表使用百分率
        ("struVcaChanStatus", NET_DVR_VCA_CHAN_WORKSTATUS * MAX_VCA_CHAN),
        ("dwRes", DWORD * 40), #  保留字节
    ]


LPNET_DVR_VCA_DEV_WORKSTATUS = POINTER(NET_DVR_VCA_DEV_WORKSTATUS)


class NET_DVR_V6SUBSYSTEMPARAM(Structure):
    _fields_ = [
        ("bySerialTrans", BYTE), # 是否透传，0-否，1-是
        ("byRes", BYTE * 35),
    ]


LPNET_DVR_V6SUBSYSTEMPARAM = POINTER(NET_DVR_V6SUBSYSTEMPARAM)


class NET_DVR_CORRECT_DEADPIXEL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCommand", DWORD), # 命令：0-进入坏点模式，1-添加坏点，2-保存坏点，3-退出坏点
        ("dwDeadPixelX", DWORD), # 坏点X坐标
        ("dwDeadPixelY", DWORD), # 坏点Y坐标
        ("byRes", BYTE * 12), # 保留
    ]


LPNET_DVR_CORRECT_DEADPIXEL_PARAM = POINTER(NET_DVR_CORRECT_DEADPIXEL_PARAM)


MAX_REDAREA_NUM = 6 # 最大红绿灯区域个数
class NET_DVR_CORRECT_PARAMS(Structure):
    _fields_ = [
        ("byYellowIntervalTime", BYTE), # 黄灯的间隔时间，单位是秒（s）
        ("byDigTrafficLight", BYTE), # 是否是交通数字黄灯，0-不是，1-是
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_CORRECT_PARAMS = POINTER(NET_DVR_CORRECT_PARAMS)


class NET_DVR_REDAREACFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCorrectEnable", DWORD), # 是否开启校正功能，0-关闭，1-开启
        ("dwCorrectLevel", DWORD), # 校正级别，1(校正度最低)-10(校正度最高),默认为5
        ("dwAreaNum", DWORD), # 校正区域个数
        ("struLaneRect", NET_VCA_RECT * MAX_REDAREA_NUM), # 校正区域
        ("struCorrectParam", NET_DVR_CORRECT_PARAMS * MAX_REDAREA_NUM), # 校正区域属性和校正区域对应
        ("byRes2", BYTE * 8), # 保留
    ]


LPNET_DVR_REDAREACFG = POINTER(NET_DVR_REDAREACFG)


class NET_DVR_HISTORICDATACFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTotalNum", DWORD), # 历史数据个数
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_HISTORICDATACFG = POINTER(NET_DVR_HISTORICDATACFG)


INQUEST_MESSAGE_LEN = 44 # 审讯重点标记信息长度
INQUEST_MAX_ROOM_NUM = 2 # 最大审讯室个数
MAX_RESUME_SEGMENT = 2 # 支持同时恢复的片段数目
class NET_DVR_INQUEST_ROOM(Structure):
    _fields_ = [
        ("byRoomIndex", BYTE), # 审讯室编号
        ("byFileType", BYTE), # 0-审讯文件，1-开庭上传文件
        ("byMode", BYTE), #  0 使用已有常规配置 非0，按照mode值，  1-电影 2-画中画1  3-画中画2    4-双画面   5-三画面1   6-三画面2   7-四画面1   8-四画面2
        ("byQuick", BYTE), #  是否为快速配置， 1-快速配置（不配置参数到flash），0-常规配置（配置参数到Flash） ， 仅在mode 非 0 有效
        ("byRes", BYTE * 20), # 保留
    ]


LPNET_DVR_INQUEST_ROOM = POINTER(NET_DVR_INQUEST_ROOM)


class NET_DVR_INQUEST_MESSAGE(Structure):
    _fields_ = [
        ("sMessage", CHAR * INQUEST_MESSAGE_LEN), # 重点标记信息
        ("byRes", BYTE * 46), # 保留
    ]


LPNET_DVR_INQUEST_MESSAGE = POINTER(NET_DVR_INQUEST_MESSAGE)


class NET_DVR_INQUEST_SENSOR_DEVICE(Structure):
    _fields_ = [
        ("wDeviceType", WORD), # 数据采集设备型号:0-无 1-米乐 2-镭彩 3-优力 4-佳盟 5-永控、6-垅上、7-维纳斯达
        ("wDeviceAddr", WORD), # 数据采集设备地址
        ("byRes", BYTE * 28), # 保留
    ]


LPNET_DVR_INQUEST_SENSOR_DEVICE = POINTER(NET_DVR_INQUEST_SENSOR_DEVICE)


class NET_DVR_INQUEST_SENSOR_INFO(Structure):
    _fields_ = [
        ("struSensorDevice", NET_DVR_INQUEST_SENSOR_DEVICE * INQUEST_MAX_ROOM_NUM),
        ("dwSupportPro", DWORD), # 支持协议类型,按位表示, 新版本走能力集，不再扩展此字段
        # 0x1:米乐 0x2:镭彩 0x4:优力
        ("byRes", BYTE * 120), # 保留
    ]


LPNET_DVR_INQUEST_SENSOR_INFO = POINTER(NET_DVR_INQUEST_SENSOR_INFO)

# class NET_DVR_INQUEST_SYSTEM_INFO(Structure):
#     _fields_ = [
#         ("dwRecordMode", DWORD), # 刻录模式:1 单室双刻模式 2 单室轮刻模式 3 双室双刻模式（修改需要重启设备）
#         ("dwWorkMode", DWORD), # 工作模式:0 标准模式 1 通用模式(保留，目前只有标准模式)
#         ("dwResolutionMode", DWORD), # 设备分辨率，0:标清 1:D1 2:720P 3:1080P（高清审讯机不用此字段）
#         ("struSensorInfo", NET_DVR_INQUEST_SENSOR_INFO), # 温湿度传感器配置
#         ("struInquestRoomInfo", NET_DVR_INQUEST_ROOM_INFO * INQUEST_MAX_ROOM_NUM),
#         ("byEnableHashCheck", BYTE), # 是否启用对光盘数据HASH值校验 0-无意义，1-不启用，2-启用
#         ("byEnableInitCD", BYTE), # 是否启用初始化光盘 0-无意义，1-不启用，2-启用
#         ("byRes", BYTE * 22), # 保留
#     ]
#
#
# LPNET_DVR_INQUEST_SYSTEM_INFO = POINTER(NET_DVR_INQUEST_SYSTEM_INFO)


class NET_DVR_INQUEST_RESUME_SEGMENT(Structure):
    _fields_ = [
        ("struStartTime", NET_DVR_TIME), # 事件起始时间
        ("struStopTime", NET_DVR_TIME), # 事件终止时间
        ("byRoomIndex", BYTE), # 审讯室编号,从1开始
        ("byDriveIndex", BYTE), # 刻录机编号,从1开始
        ("wSegmetSize", WORD), # 本片断的大小, 单位M
        ("dwSegmentNo", DWORD), # 本片断在本次审讯中的序号,从1开始
        ("byRes", BYTE * 24), # 保留
    ]


LPNET_DVR_INQUEST_RESUME_SEGMENT = POINTER(NET_DVR_INQUEST_RESUME_SEGMENT)


class NET_DVR_INQUEST_RESUME_EVENT(Structure):
    _fields_ = [
        ("dwResumeNum", DWORD), # 需恢复的事件个数
        ("struResumeSegment", NET_DVR_INQUEST_RESUME_SEGMENT * MAX_RESUME_SEGMENT),
        ("byResumeMode", BYTE), # 恢复模式，0-单光盘恢复，1-双光盘恢复
        ("byRes", BYTE * 199), # 保留
    ]


LPNET_DVR_INQUEST_RESUME_EVENT = POINTER(NET_DVR_INQUEST_RESUME_EVENT)


class NET_DVR_INQUEST_DEVICE_VERSION(Structure):
    _fields_ = [
        ("byMainVersion", BYTE), # 基线主版本.
        # 0 : 未知
        # 1 : 8000审讯DVR
        # 次版本: 1 : 8000HD-S
        # 2 : 8100审讯DVR
        # 次版本: 1 : 审讯81SNL
        # 2 : 审讯81SH
        # 3 : 审讯81SFH
        # 3 : 8608高清审讯机NVR
        # 次版本: 1 : DS-8608SN-SP
        # 2 : DS-8608SN-ST
        #
        ("bySubVersion", BYTE), # 基线次版本
        ("byUpgradeVersion", BYTE), # 升级版本,未升级为0
        ("byCustomizeVersion", BYTE), # 定制版本,非定制为0
        ("byRes", BYTE * 60), # 保留
    ]


LPNET_DVR_INQUEST_DEVICE_VERSION = POINTER(NET_DVR_INQUEST_DEVICE_VERSION)


class NET_DVR_DISK_RAID_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 磁盘Raid是否禁用
        ("bySleepStatus", BYTE), # 0-无效， 1-休眠，2-不休眠
        ("byRes", BYTE * 34), # 保留字节
    ]


LPNET_DVR_DISK_RAID_INFO = POINTER(NET_DVR_DISK_RAID_INFO)


class NET_DVR_SYNCHRONOUS_IPC(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用：为前端IPC同步设备参数
        ("byRes", BYTE * 7), # 保留
    ]


LPNET_DVR_SYNCHRONOUS_IPC = POINTER(NET_DVR_SYNCHRONOUS_IPC)


class NET_DVR_IPC_PASSWD(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sOldPasswd", CHAR * PASSWD_LEN), # IPC的旧密码，传给DVR让DVR验证
        ("sNewPasswd", CHAR * PASSWD_LEN), # IPC的新密码
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_IPC_PASSWD = POINTER(NET_DVR_IPC_PASSWD)


# 通过获取DVR的网络状态：单位bps
class NET_DVR_DEVICE_NET_USING_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwPreview", DWORD), # 预览
        ("dwPlayback", DWORD), # 回放
        ("dwIPCModule", DWORD), # IPC接入
        ("dwNetDiskRW", DWORD), # 网盘读写
        ("res", BYTE * 32),
    ]


LPNET_DVR_DEVICE_NET_USING_INFO = POINTER(NET_DVR_DEVICE_NET_USING_INFO)


# 通过DVR设置前端IPC的IP地址
class NET_DVR_IPC_NETCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struIP", NET_DVR_IPADDR), # IPC的IP地址
        ("wPort", WORD), # IPC的端口
        ("res", CHAR * 126),
    ]


LPNET_DVR_IPC_NETCFG = POINTER(NET_DVR_IPC_NETCFG)


# 按时间锁定
class NET_DVR_TIME_LOCK(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("strBeginTime", NET_DVR_TIME),
        ("strEndTime", NET_DVR_TIME),
        ("dwChannel", DWORD), # 通道号, 0xff表示所有通道
        ("dwRecordType", DWORD), # 录像类型:  0xffffffff－全部，0－定时录像，1-移动侦测，2－报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，7-智能录像(同文件查找)
        ("dwLockDuration", DWORD), # 锁定持续时间,单位秒,0xffffffff表示永久锁定
        ("strUnlockTimePoint", NET_DVR_TIME_EX), # 加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_TIME_LOCK = POINTER(NET_DVR_TIME_LOCK)


class NET_DVR_LOCK_RETURN(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("strBeginTime", NET_DVR_TIME),
        ("strEndTime", NET_DVR_TIME),
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效,0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45，+表示东区, byISO8601为1时有效
        ("byRes", BYTE * 17),
    ]


LPNET_DVR_LOCK_RETURN = POINTER(NET_DVR_LOCK_RETURN)


# 67DVS
# 证书下载类型
# 下载状态
# 下载控制命令类型
ENUM_DOWNLOAD_CONTROL_ERR = -1
ENUM_DOWNLOAD_CONTROL_QOS = 1


class NET_DVR_PANORAMIC_STITCH_UPLOAD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), #  通道号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PANORAMIC_STITCH_UPLOAD = POINTER(NET_DVR_PANORAMIC_STITCH_UPLOAD)


class NET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byType", BYTE), # 日志类型，0-全部，1-精简，2-默认
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM = POINTER(NET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM)


class NET_DVR_BONJOUR_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnableBonjour", BYTE), #  Bonjour使能 0 ：开启 1：关闭
        ("byRes1", BYTE * 3),
        ("byFriendlyName", BYTE * MAX_DOMAIN_NAME), #  服务名
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_BONJOUR_CFG = POINTER(NET_DVR_BONJOUR_CFG)


class NET_DVR_SOCKS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnableSocks", BYTE), #  使能 0：关闭 1：开启
        ("byVersion", BYTE), #  SOCKS版本 4：SOCKS4   5：SOCKS5
        ("wProxyPort", WORD), #  代理端口，默认1080
        ("byProxyaddr", BYTE * MAX_DOMAIN_NAME), #  代理IP地址，可以是域名
        ("byUserName", BYTE * MAX_DOMAIN_NAME), #  用户名 SOCKS才用
        ("byPassword", BYTE * NAME_LEN), #  密码SOCKS5才用
        ("byLocalAddr", BYTE * MAX_LOCAL_ADDR_LEN), # 不使用socks代理的网段，格式为"ip/netmaskip/netmask…"
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_SOCKS_CFG = POINTER(NET_DVR_SOCKS_CFG)


class NET_DVR_QOS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byManageDscp", BYTE), #  管理数据的DSCP值 [0-63]
        ("byAlarmDscp", BYTE), #  报警数据的DSCP值 [0-63]
        ("byVideoDscp", BYTE), #  视频数据的DSCP值 [0-63]，byFlag为0时，表示音视频
        ("byAudioDscp", BYTE), #  音频数据的DSCP值 [0-63]，byFlag为1时有效
        ("byFlag", BYTE), #  0：音视频合一，1：音视频分开
        ("byEnable", BYTE),
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_QOS_CFG = POINTER(NET_DVR_QOS_CFG)


class NET_DVR_HTTPS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wHttpsPort", WORD), #  HTTPS端口
        ("byEnable", BYTE), #  使能 0：关闭 1：开启
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_HTTPS_CFG = POINTER(NET_DVR_HTTPS_CFG)


# 证书相关
class NET_DVR_CERT_NAME(Structure):
    _fields_ = [
        ("byCountry", BYTE * MAX_COUNTRY_NAME_LEN), # 国家代号 CN等
        ("byState", BYTE * MAX_DOMAIN_NAME), # 洲或省
        ("byLocality", BYTE * MAX_DOMAIN_NAME), # 地区
        ("byOrganization", BYTE * MAX_DOMAIN_NAME), # 组织
        ("byUnit", BYTE * MAX_DOMAIN_NAME), # 单位
        ("byCommonName", BYTE * MAX_DOMAIN_NAME),
        ("byEmail", BYTE * MAX_DOMAIN_NAME),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CERT_NAME = POINTER(NET_DVR_CERT_NAME)


class NET_DVR_CERT_ADDITION_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("csCustomID", CHAR * 64), # 用户自定义ID
        ("byRes1", BYTE * 2),
        ("byCertificateMode", BYTE), # wCertType为1-Certificate时有效，0-自签名证书，1-证书和私钥方式
        ("byPrivateKeyMode", BYTE), #  byCertificateMode为1-证书和私钥方式时有效 0-独立key 1-PKCS#12
        ("byPassword", BYTE * 64), # 密码，当PrivateKeyMode为0时为私钥的密码，为1时为PKCS#12的密码
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CERT_ADDITION_PARAM = POINTER(NET_DVR_CERT_ADDITION_PARAM)


class NET_DVR_CERT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wCertFunc", WORD), # 证书种类，0-802.1x(应用于WIFI接入证书),1-HTTPS, 3-ieee802.1x(应用于有线LAN接入认证)
        ("wCertType", WORD), # 证书类型，0-CA，1-Certificate,2-私钥文件
        ("byFileType", BYTE), # 证书文件类型，0-PEM,1-PFX
        ("byRes1", BYTE * 2), # 保留字节
        ("byAddition", BYTE), # 是否使用附加结构体，0-不使用1-使用
        ("*", NET_DVR_CERT_ADDITION_PARAM), # 附加信息结构体指针
        ("byRes", BYTE * 28),
    ]


LPNET_DVR_CERT_PARAM = POINTER(NET_DVR_CERT_PARAM)


UPLOAD_CERTIFICATE = 1 # 上传证书
class NET_DVR_CERT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struCertParam", NET_DVR_CERT_PARAM), # 证书参数
        ("dwValidDays", DWORD), # 有效天数，类型为自签名时有效
        ("byPasswd", BYTE * NAME_LEN), # 私钥密码
        ("struCertName", NET_DVR_CERT_NAME), #  证书名称
        ("struIssuerName", NET_DVR_CERT_NAME), #  证书发行者名称（自签名证书信息获取时有效）
        ("struBeginTime", NET_DVR_TIME_EX), # 证书创建时间（自签名证书信息获取时有效）
        ("struEndTime", NET_DVR_TIME_EX), # 证书截止时间（自签名证书信息获取时有效）
        ("serialNumber", BYTE * NAME_LEN), # 证书标识码（自签名证书信息获取时有效）
        ("byVersion", BYTE),
        ("byKeyAlgorithm", BYTE), # 加密类型 0-RSA  1-DSA
        ("byKeyLen", BYTE), # 加密长度 0-512  1-1024、 2-2048
        ("bySignatureAlgorithm", BYTE), # 签名算法类型（自签名证书信息获取时有效）
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CERT_INFO = POINTER(NET_DVR_CERT_INFO)


# channel record status
# ***通道录像状态****/
class NET_DVR_CHANS_RECORD_STATUS(Structure):
    _fields_ = [
        ("byValid", BYTE), # 是否有效
        # (只读)录像类型:0: 不在录像；1：在录像 2-空闲
        # 3-无连接 4-无输入视频 5-未加载 6-存档中 7-回传中
        # 8-用户名或密码错 9-未验证,10-存档中和录像中 11-录像回传中和录像中 12-token认证失败
        ("byRecord", BYTE),
        ("wChannelNO", WORD), # 通道号
        ("dwRelatedHD", DWORD), # 关联磁盘
        ("byOffLineRecord", BYTE), # 断网录像功能 0-关闭 1-开启
        ("byRes", BYTE * 7), # 保留字节
    ]


LPNET_DVR_CHANS_RECORD_STATUS = POINTER(NET_DVR_CHANS_RECORD_STATUS)


class NET_DVR_IP_ALARM_GROUP_NUM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwIPAlarmInGroup", DWORD), # IP通道报警输入组数
        ("dwIPAlarmInNum", DWORD), # IP通道报警输入个数
        ("dwIPAlarmOutGroup", DWORD), # IP通道报警输出组数
        ("dwIPAlarmOutNum", DWORD), # IP通道报警输出个数
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_IP_ALARM_GROUP_NUM = POINTER(NET_DVR_IP_ALARM_GROUP_NUM)


# ****NVR end**/
class NET_DVR_CHAN_GROUP_RECORD_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struChanStatus", NET_DVR_CHANS_RECORD_STATUS * MAX_CHANNUM_V30), # 一组64个
    ]


LPNET_DVR_CHAN_GROUP_RECORD_STATUS = POINTER(NET_DVR_CHAN_GROUP_RECORD_STATUS)


class NET_DVR_RECTCFG(Structure):
    _fields_ = [
        ("wXCoordinate", WORD), # 矩形左上角起始点X坐标
        ("wYCoordinate", WORD), # 矩形左上角Y坐标
        ("wWidth", WORD), # 矩形宽度
        ("wHeight", WORD), # 矩形高度
    ]


LPNET_DVR_RECTCFG = POINTER(NET_DVR_RECTCFG)


# 窗口信息
class NET_DVR_WINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byVaild", BYTE),
        ("byInputIdx", BYTE), # 输入源索引
        ("byLayerIdx", BYTE), # 图层，0为最底层
        ("byTransparency", BYTE), # 透明度，0～100
        ("struWin", NET_DVR_RECTCFG), # 目的窗口(相对显示墙)
        ("wScreenHeight", WORD), # 大屏高
        ("wScreenWidth", WORD), # 大屏宽
        ("byRes", BYTE * 20),
    ]


LPNET_DVR_WINCFG = POINTER(NET_DVR_WINCFG)


MAX_LAYERNUMS = 32
class NET_DVR_ALLWINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struWinCfg", NET_DVR_WINCFG * MAX_LAYERNUMS),
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_ALLWINCFG = POINTER(NET_DVR_ALLWINCFG)


class NET_DVR_SCREENZOOM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwScreenNum", DWORD), # 大屏号
        ("struPointFrame", NET_DVR_POINT_FRAME),
        ("byLayer", BYTE), # 图层号
        ("byRes", BYTE * 11),
    ]


LPNET_DVR_SCREENZOOM = POINTER(NET_DVR_SCREENZOOM)


# 2011-04-18
# 摄像机信息,最多9999个，从1开始
class NET_MATRIX_CAMERAINFO(Structure):
    _fields_ = [
        ("dwGlobalCamId", DWORD), #  cam的全局编号
        ("sCamName", BYTE * NAME_LEN), # cam的名称
        ("dwMatrixId", DWORD), # cam对应矩阵的编号
        ("dwLocCamId", DWORD), # cam对应矩阵的内部编号
        ("byValid", BYTE), # 是否有效，0-否，1-是
        ("byPtzCtrl", BYTE), #  是否可控，0-否，1-是
        ("byUseType", BYTE), # *使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤
        ("byUsedByTrunk", BYTE), # 当前使用状态，0-没有被使用，1-被干线使用
        ("byTrunkReq", BYTE), # 摄像机分辨率,以D1为单位：1 - 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽
        ("byRes1", BYTE * 3),
        ("struInstallTime", NET_DVR_TIME), # 安装时间
        ("sPurpose", BYTE * NAME_LEN), # 用途描述
        ("byRes2", BYTE * 20),
    ]


LPNET_MATRIX_CAMERAINFO = POINTER(NET_MATRIX_CAMERAINFO)


# 监视器信息，最多2048个
class NET_MATRIX_MONITORINFO(Structure):
    _fields_ = [
        ("dwGloalMonId", DWORD), # mon 的统一编号
        ("sMonName", BYTE * NAME_LEN),
        ("dwMatrixId", DWORD), # mon所在矩阵的编号
        ("dwLocalMonId", DWORD), # mon的内部编号
        ("byValid", BYTE), # 是否有效，0-否，1-是
        ("byTrunkType", BYTE), # 使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤
        ("byUsedByTrunk", BYTE), # 当前使用状态，0-没有被使用，1-被干线使用
        ("byTrunkReq", BYTE), # 分辨率, 以D1为单位：1- 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽
        ("struInstallTime", NET_DVR_TIME), # 安装时间
        ("sPurpose", BYTE * NAME_LEN), # 用途描述
        ("byRes", BYTE * 20),
    ]


LPNET_MATRIX_MONITORINFO = POINTER(NET_MATRIX_MONITORINFO)


class NET_MATRIX_DIGITALMATRIX(Structure):
    _fields_ = [
        ("struAddress", NET_DVR_IPADDR), # 设备为数字设备时的IP信息
        ("wPort", WORD),
        ("byNicNum", BYTE), # 0 - eth0, 1 - eth1, 考虑双网口如何通信加入绑定的网口
        ("byRes", BYTE * 69),
    ]


LPNET_MATRIX_DIGITALMATRIX = POINTER(NET_MATRIX_DIGITALMATRIX)


class NET_MATRIX_ANALOGMATRIX(Structure):
    _fields_ = [
        ("bySerPortNum", BYTE), # 连接的串口号  0xff-环通接入
        ("byMatrixSerPortType", BYTE), #  矩阵接入网关的串口与模拟矩阵的键盘口(键盘协议)连接还是与矩阵通信口（矩阵协议）连接 ，0 --- 矩阵协议通讯口 1 --- 键盘通讯口
        ("byRes1", BYTE * 2),
        ("struRS232", NET_DVR_SINGLE_RS232), # 232串口参数  环通接入时此参数无效
        ("byRes2", BYTE * 200),
    ]


LPNET_MATRIX_ANALOGMATRIX = POINTER(NET_MATRIX_ANALOGMATRIX)


class NET_MATRIX_UNION(Union):
    _fields_ = [
        ("struDigitalMatrix", NET_MATRIX_DIGITALMATRIX),
        ("struAnalogMatrix", NET_MATRIX_ANALOGMATRIX),
    ]


LPNET_MATRIX_UNION = POINTER(NET_MATRIX_UNION)


# 矩阵配置信息，最多20个
class NET_MATRIX_MATRIXINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMatrixId", DWORD), # 矩阵编号
        ("sDevName", BYTE * NAME_LEN),
        ("byCtrlType", BYTE), # 指通讯方式是串口通信, 还是网络通信
        ("byProtocolType", BYTE), # 设置通信控制协议
        ("byRes1", BYTE * 6), # 预留
        ("struMatrixUnion", NET_MATRIX_UNION),
        ("dwMaxPortsIn", DWORD), # 矩阵输入数
        ("dwMaxPortsOut", DWORD), # 矩阵输出数
        ("sUserName", BYTE * NAME_LEN), # 登录用户名
        ("sPassword", BYTE * PASSWD_LEN), # 登录密码
        ("struInstallTime", NET_DVR_TIME), # 安装时间
        ("sPurpose", BYTE * NAME_LEN), # 用途描述
        ("byRes2", BYTE * 20), # 预留
    ]


LPNET_MATRIX_MATRIXINFO = POINTER(NET_MATRIX_MATRIXINFO)


class NET_DVR_MATRIXLIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 12),
        ("dwMatrixNum", DWORD), # 设备返回的矩阵数量
        ("*pBuffer", BYTE), # 矩阵信息缓冲区
        ("dwBufLen", DWORD), # 所分配指针长度，输入参数
    ]


LPNET_DVR_MATRIXLIST = POINTER(NET_DVR_MATRIXLIST)


# 串口配置信息
class NET_MATRIX_UARTPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPortName", BYTE * NAME_LEN),
        ("wUserId", WORD), # 用户编号，当连接设备为键盘时，绑定一个用户，用于权限管理
        ("byPortType", BYTE), # 串口类型，三种0-RS232/1-RS485/2-RS422
        ("byFuncType", BYTE), # 串口连接的设备的类型0-空闲，1-键盘，2-用作透明通道(485串口不可配置成透明通道),3-模拟矩阵
        ("byProtocolType", BYTE), # 串口支持的协议类型, 当连接键盘设备时需要该信息,获取键盘支持协议的编号及描述符
        ("byBaudRate", BYTE),
        ("byDataBits", BYTE),
        ("byStopBits", BYTE), # 停止位
        ("byParity", BYTE), # 校验
        ("byFlowCtrl", BYTE), # 流控，软件流控，无流控
        ("byRes", BYTE * 22), # 预留
    ]


LPNET_MATRIX_UARTPARAM = POINTER(NET_MATRIX_UARTPARAM)


# 最多256个用户，1～256
class NET_MATRIX_USERPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sUserName", BYTE * NAME_LEN),
        ("sPassword", BYTE * PASSWD_LEN),
        ("byRole", BYTE), # 用户角色:0-管理员,1-操作员；只有一个系统管理员，255个操作员
        ("byLevel", BYTE), # 统一级别，用于操作级别管理,1- 255
        ("byRes", BYTE * 18),
    ]


LPNET_MATRIX_USERPARAM = POINTER(NET_MATRIX_USERPARAM)


# 最多255个资源组
class NET_MATRIX_RESOURCEGROUPPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byGroupName", BYTE * NAME_LEN),
        ("byGroupType", BYTE), # 0-摄像机CAM组，1-监视器MON组
        ("byRes1", BYTE),
        ("wMemNum", WORD),
        ("dwGlobalId", DWORD * 512),
        ("byRes2", BYTE * 20),
    ]


LPNET_MATRIX_RESOURCEGROUPPARAM = POINTER(NET_MATRIX_RESOURCEGROUPPARAM)


# 最多255个用户组
class NET_MATRIX_USERGROUPPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sGroupName", BYTE * NAME_LEN),
        ("wUserMember", WORD * 255), # 包含的用户成员
        ("wResorceGroupMember", WORD * 255), # 包含的资源组成员
        ("byPermission", BYTE * 32), # 权限，数组0-ptz权限、切换权限、查询权限
        ("byRes", BYTE * 20),
    ]


LPNET_MATRIX_USERGROUPPARAM = POINTER(NET_MATRIX_USERGROUPPARAM)


class NET_MATRIX_TRUNKPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTrunkId", DWORD),
        ("sTrunkName", BYTE * NAME_LEN),
        ("dwSrcMonId", DWORD),
        ("dwDstCamId", DWORD),
        ("byTrunkType", BYTE), # 使用类型  1-BNC，2-SP3光纤高清，3-SP3光纤D1， 4-V6光纤，5-其他光纤
        ("byAbility", BYTE), # 表示光纤的带宽，可以传输几路
        ("bySubChan", BYTE), # 针对光纤干线而言，表示子通道号
        ("byLevel", BYTE), #  干线级别 1-255
        ("wReserveUserID", WORD), # 预留的用户ID： 1~256 ，0表示释放预留
        ("byRes", BYTE * 18),
    ]


LPNET_MATRIX_TRUNKPARAM = POINTER(NET_MATRIX_TRUNKPARAM)


class NET_DVR_MATRIX_TRUNKLIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 12),
        ("dwTrunkNum", DWORD), # 设备返回的干线数量
        ("*pBuffer", BYTE), # 干线信息缓冲区
        ("dwBufLen", DWORD), # 所分配指针长度，输入参数
    ]


LPNET_DVR_MATRIX_TRUNKLIST = POINTER(NET_DVR_MATRIX_TRUNKLIST)


MATRIX_PROTOCOL_NUM = 20 # 支持的最大矩阵协议数
KEYBOARD_PROTOCOL_NUM = 20 # 支持的最大键盘协议数
class NET_DVR_PROTO_TYPE_EX(Structure):
    _fields_ = [
        ("wType", WORD), # ipc协议值
        ("wCommunitionType", WORD), # 0：模拟 1：数字 2：兼容模拟、数字
        ("byDescribe", BYTE * DESC_LEN), # 协议描述字段
    ]


LPNET_DVR_PROTO_TYPE_EX = POINTER(NET_DVR_PROTO_TYPE_EX)


class NET_DVR_MATRIXMANAGE_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMaxCameraNum", DWORD), # 最大Camera数量
        ("dwMaxMonitorNum", DWORD), # 最大监视器数量
        ("wMaxMatrixNum", WORD), # 最大矩阵数量
        ("wMaxSerialNum", WORD), # 串口数量
        ("wMaxUser", WORD), # 最大用户数
        ("wMaxResourceArrayNum", WORD), # 最大资源组数
        ("wMaxUserArrayNum", WORD), # 最大用户组数
        ("wMaxTrunkNum", WORD), # 最大干线数
        ("nStartUserNum", BYTE), # 起始用户号
        ("nStartUserGroupNum", BYTE), # 起始用户组号
        ("nStartResourceGroupNum", BYTE), # 起始资源组号
        ("nStartSerialNum", BYTE), # 起始串口号
        ("dwMatrixProtoNum", DWORD), # 有效的矩阵协议数目，从0开始
        ("struMatrixProto", NET_DVR_PROTO_TYPE_EX * MATRIX_PROTOCOL_NUM), # 最大协议列表长度
        ("dwKeyBoardProtoNum", DWORD), # 有效的键盘协议数目，从0开始
        ("struKeyBoardProto", NET_DVR_PROTO_TYPE_EX * KEYBOARD_PROTOCOL_NUM), # 最大协议列表长度
        ("byDelMonitorLongCfg", BYTE), # 是否支持删除monitor长连接配置
        ("byDelCamonitorLongCfg", BYTE), # 是否支持删除camera长连接配置
        ("byAudioSwitchContorl", BYTE), # 是否支持音频开关控制
        ("byRes", BYTE * 29),
    ]


LPNET_DVR_MATRIXMANAGE_ABILITY = POINTER(NET_DVR_MATRIXMANAGE_ABILITY)


# 人脸抓拍规则(单条)
class NET_VCA_SINGLE_FACESNAPCFG(Structure):
    _fields_ = [
        ("byActive", BYTE), # 是否激活规则：0-否，1-是
        # ******** IPC5.1.7 新增参数 Begin 2014-03-21**********
        # 人脸自动ROI开关使能
        ("byAutoROIEnable", BYTE), # 0-关闭,1-开启
        ("byRes", BYTE * 2), # 保留
        # ******** IPC5.1.7 新增参数 End 2014-03-21**********
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struVcaPolygon", NET_VCA_POLYGON), # 人脸识别区域
    ]


LPNET_VCA_SINGLE_FACESNAPCFG = POINTER(NET_VCA_SINGLE_FACESNAPCFG)


# 人脸抓拍规则参数
class NET_VCA_FACESNAPCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySnapTime", BYTE), # 单个目标人脸的抓拍次数0-10
        ("bySnapInterval", BYTE), # 抓拍间隔，单位：帧
        ("bySnapThreshold", BYTE), # 抓拍阈值，0-100
        ("byGenerateRate", BYTE), # 目标生成速度,范围[1, 5]
        ("bySensitive", BYTE), # 目标检测灵敏度，范围[1, 5]
        ("byReferenceBright", BYTE), # 2012-3-27参考亮度[0,100]
        ("byMatchType", BYTE), # 2012-5-3比对报警模式，0-目标消失后报警，1-实时报警
        ("byMatchThreshold", BYTE), # 2012-5-3实时比对阈值，0~100
        ("struPictureParam", NET_DVR_JPEGPARA), # 图片规格结构
        ("struRule", NET_VCA_SINGLE_FACESNAPCFG * MAX_RULE_NUM), # 人脸抓拍规则
        # 人脸曝光最短持续时间（两个字节）
        ("wFaceExposureMinDuration", WORD), # 范围(1~3600秒，默认60)生效于自动模式下
        # 人脸曝光模式
        ("byFaceExposureMode", BYTE), # 1-关闭，2-开启，0-自动（根据人脸判断）
        ("byBackgroundPic", BYTE), # 背景图上传使能 0-默认值（开启），1-禁止
        ("dwValidFaceTime", DWORD), # 有效人脸最短持续时间，单位：秒
        ("dwUploadInterval", DWORD), # 人脸抓拍统计数据上传间隔时间，单位：秒，默认900秒
        ("dwFaceFilteringTime", DWORD), # 人脸停留时间过滤,默认5秒，范围0-100秒。0秒表示不过滤
        ("bySceneID", BYTE), # 场景号,目前支持1~4场景，0为无效
        ("byInvalCapFilterEnable", BYTE), # 无效抓拍过滤使能，0为关闭，1为开启，默认为0
        ("byInvalCapFilterThreshold", BYTE), # 无效抓拍过滤阈值，0~100，当byInvalCapFilterEnable为1时生效
        ("byRes2", BYTE * 81),
    ]


LPNET_VCA_FACESNAPCFG = POINTER(NET_VCA_FACESNAPCFG)


class NET_DVR_FIRMWARE_VERSION_IFNO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("szFirmwareVersion", CHAR * LEN_PROPERTY), # 主控版本属性 只读
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_FIRMWARE_VERSION_IFNO = POINTER(NET_DVR_FIRMWARE_VERSION_IFNO)


# 年龄段
ENUM_AGE_GROUP_INFANT = 1
ENUM_AGE_GROUP_CHILD = 2
ENUM_AGE_GROUP_YOUNGSTER = 3
ENUM_AGE_GROUP_ADOLESCENT = 4
ENUM_AGE_GROUP_YOUTH = 5
ENUM_AGE_GROUP_PRIME = 6
ENUM_AGE_GROUP_MIDLIFE = 7
ENUM_AGE_GROUP_MIDAGE = 8
ENUM_AGE_GROUP_OLD = 9
ENUM_AGE_GROUP_ALL = 0xfe
ENUM_AGE_GROUP_UNKNOW = 0xff


# 人脸表情
ENUM_EXPRESSION_GROUP_SURPRISED = 1
ENUM_EXPRESSION_GROUP_PANIC = 2
ENUM_EXPRESSION_GROUP_DISGUUSTED = 3
ENUM_EXPRESSION_GROUP_HAPPY = 4
ENUM_EXPRESSION_GROUP_SAD = 5
ENUM_EXPRESSION_GROUP_ANGRY = 6
ENUM_EXPRESSION_GROUP_POKER = 7
ENUM_EXPRESSION_GROUP_ALL = 0xfe
ENUM_EXPRESSION_GROUP_UNKNOW = 0xff


# 人脸抓拍附加信息结构体
class NET_VCA_FACESNAP_ADDINFO(Structure):
    _fields_ = [
        # 人脸矩形框,该坐标为人脸小图(头肩照)中人脸的坐标
        ("struFacePicRect", NET_VCA_RECT),
        ("iSwingAngle", INT), # 旋转角, -90~90度
        ("iTiltAngle", INT), # 俯仰角, -90~90度
        ("dwPupilDistance", DWORD), # 瞳距,范围为：最小值为10像素,最大值为当前分辨率宽度/1.6
        ("byBlockingState", BYTE), # 目标遮挡状态， 0-表示“未知”（算法不支持）,1~无遮挡,2~瞬时轻度遮挡，3~持续轻度遮挡，4~严重遮挡
        ("byFaceSnapThermometryEnabled", BYTE), # 人脸抓拍测温使能 1-开启 0-关闭
        ("byIsAbnomalTemperature", BYTE), # 人脸抓拍测温是否温度异常 1-是 0-否
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
        ("struEnterTime", NET_DVR_TIME_EX), #  最佳抓拍下进入时间
        ("struExitTime", NET_DVR_TIME_EX), #  最佳抓拍下离开时间
        ("fFaceTemperature", DOUBLE), #  人脸温度（ - 20.0℃~150.0℃，精确到小数点后1位）
        ("fAlarmTemperature", DOUBLE), #  测温报警警阈值（精确到小数点后1位）
        ("byRes", BYTE * 472), #  保留字节
    ]


LPNET_VCA_FACESNAP_ADDINFO = POINTER(NET_VCA_FACESNAP_ADDINFO)


# 人脸抓拍结果
class NET_VCA_FACESNAP_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("dwRelativeTime", DWORD), #  相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("dwFacePicID", DWORD), # 人脸图ID
        ("dwFaceScore", DWORD), # 人脸评分,0-100
        ("struTargetInfo", NET_VCA_TARGET_INFO), # 报警目标信息
        ("struRect", NET_VCA_RECT), # 人脸子图区域
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("dwFacePicLen", DWORD), # 人脸子图的长度，为0表示没有图片，大于0表示有图片
        ("dwBackgroundPicLen", DWORD), # 背景图的长度，为0表示没有图片，大于0表示有图片(保留)
        ("bySmart", BYTE), # IDS设备返回0(默认值)，Smart Functiom Return 1
        ("byAlarmEndMark", BYTE), # 报警结束标记0-保留，1-结束标记（该字段结合人脸ID字段使用，表示该ID对应的下报警结束，主要提供给NVR使用，用于判断报警结束，提取识别图片数据中，清晰度最高的图片）
        ("byRepeatTimes", BYTE), # 重复报警次数，0-无意义
        ("byUploadEventDataType", BYTE), # 人脸图片数据长传方式：0-二进制数据，1-URL
        ("struFeature", NET_VCA_HUMAN_FEATURE), # 人体属性
        ("fStayDuration", DOUBLE), # 停留画面中时间(单位: 秒)
        ("sStorageIP", CHAR * 16), # 存储服务IP地址
        ("wStoragePort", WORD), # 存储服务端口号
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        # 人脸子图图片质量评估等级，0-低等质量,1-中等质量,2-高等质量,
        # 新增人脸抓拍质量评分机制与原有的人脸评分区别：
        # 原有的人脸评分是在人脸抓拍中实现，目的是确保一次人脸抓拍中获取最好的图像效果，是一个相对图像质量的评分；新增人脸抓拍质量评分机制是针对已经抓拍完成的人脸图片，使用图像算法对图像中人脸，人眼，肩宽等相对重要的信息进行分析，按照统一的标准对人脸图片效果质量进行评分
        ("byFacePicQuality", BYTE),
        ("byUIDLen", BYTE), #  上传报警的标识长度
        ("byLivenessDetectionStatus", BYTE), #  活体检测状态：0-保留，1-未知(检测失败)，2-非真人人脸，3-真人人脸，4-未开启活体检测
        # 附加信息标识位（即是否有NET_VCA_FACESNAP_ADDINFO结构体）,0-无附加信息, 1-有附加信息。
        ("byAddInfo", BYTE),
        ("*pUIDBuffer", BYTE), # 标识指针
        # 附加信息指针,指向NET_VCA_FACESNAP_ADDINFO结构体
        ("*pAddInfoBuffer", BYTE),
        ("byTimeDiffFlag", BYTE), # 时差字段是否有效  0-时差无效， 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
        ("byBrokenNetHttp", BYTE), # 断网续传标志位，0-不是重传数据，1-重传数据
        ("pBuffer1", CHARP), # 人脸子图的图片数据
        ("pBuffer2", CHARP), # 背景图的图片数据（保留，通过查找背景图接口可以获取背景图）
    ]


LPNET_VCA_FACESNAP_RESULT = POINTER(NET_VCA_FACESNAP_RESULT)


class NET_VCA_SUB_PROCIMG_V50(Structure):
    _fields_ = [
        ("dwImageLen", DWORD), # 图片数据长度
        ("dwFaceScore", DWORD), # 人脸评分,0-100
        ("struVcaRect", NET_VCA_RECT), # 人脸子图区域
        ("struLeftEyePoint", NET_VCA_POINT), # 左眼位置
        ("struRightEyePoint", NET_VCA_POINT), # 右眼位置
        ("byDistance", BYTE), # 两眼间距
        ("bySex", BYTE),
        ("byAgeGroup", BYTE),
        ("byEyeGlass", BYTE),
        ("struPosRect", NET_VCA_RECT), # 人脸位置区域
        ("byRes", BYTE * 20), # 保留
        ("*pImage", BYTE), # 图片数据
    ]


LPNET_VCA_SUB_PROCIMG_V50 = POINTER(NET_VCA_SUB_PROCIMG_V50)


class NET_DVR_FACE_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("dwBackgroundPicLen", DWORD), # 背景图的长度，为0表示没有图片，大于0表示有图片
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("struFacePic", NET_VCA_RECT * MAX_FACE_PIC_NUM), # 人脸子图区域
        ("byFacePicNum", BYTE), # 子图数量
        ("byUploadEventDataType", BYTE), # 图片数据长传方式：0-二进制数据，1-URL
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byTimeDiffFlag", BYTE), # 时差字段是否有效  0-时差无效， 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
        ("byRes", BYTE * 249),
        ("pBackgroundPicpBuffer", CHARP), # 背景图的图片数据
    ]


LPNET_DVR_FACE_DETECTION = POINTER(NET_DVR_FACE_DETECTION)


class NET_DVR_UPGRADE_PARAM(Structure):
    _fields_ = [
        ("dwUpgradeType", DWORD),
        ("sFileName", CHARP),
        ("pInbuffer", VOIDP),
        ("dwBufferLen", DWORD),
        ("pUnitIdList", CHARP * 64),
        ("byRes", BYTE * 112),
    ]


LPNET_DVR_UPGRADE_PARAM = POINTER(NET_DVR_UPGRADE_PARAM)


class NET_VCA_FD_PROCIMG_RESULT_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwImageId", DWORD), # 大图ID
        ("byRes", BYTE * 20), # 保留
        ("dwSubImageNum", DWORD), # 人脸子图张数
        ("struProcImg", NET_VCA_SUB_PROCIMG_V50 * MAX_TARGET_NUM), # 单张子图信息
    ]


LPNET_VCA_FD_PROCIMG_RESULT_V50 = POINTER(NET_VCA_FD_PROCIMG_RESULT_V50)


# 虚焦侦测结果
class NET_DVR_DEFOCUS_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("struDevInfo", NET_VCA_DEV_INFO), # 设备信息
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byRes1", BYTE * 2), # 保留字节
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("byTimeDiffFlag", BYTE), # 时差字段是否有效  0-时差无效， 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
        ("byRes", BYTE * 49), #  保留字节
    ]


LPNET_DVR_DEFOCUS_ALARM = POINTER(NET_DVR_DEFOCUS_ALARM)


# 大雾侦测结果
class NET_DVR_DENSEFOGDETECTION_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("struDevInfo", NET_VCA_DEV_INFO), # 设备信息
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("byFogLevel", BYTE), # 雾的等级，0-无雾~薄雾 ，1-薄雾~中雾， 2-大雾~浓雾， 3-浓雾及以上
        ("byRes", BYTE * 259), #  保留字节
    ]


LPNET_DVR_DENSEFOGDETECTION_ALARM = POINTER(NET_DVR_DENSEFOGDETECTION_ALARM)


class NET_DVR_AUDIOEXCEPTION_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byAlarmType", BYTE), # 报警类型，1-音频输入异常，2-音频输入突变（声强陡升），3-声强陡降，4-音频丢失
        ("byRes1", BYTE),
        ("wAudioDecibel", WORD), # 声音强度（音频输入突变时用到）
        ("struDevInfo", NET_VCA_DEV_INFO), # 设备信息
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byRes", BYTE * 62), #  保留字节
    ]


LPNET_DVR_AUDIOEXCEPTION_ALARM = POINTER(NET_DVR_AUDIOEXCEPTION_ALARM)


class NET_BUTTON_DOWN_EXCEPTION_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("struDevInfo", NET_VCA_DEV_INFO), # 设备信息
        ("byRes", BYTE * 64), #  保留字节
    ]


LPNET_BUTTON_DOWN_EXCEPTION_ALARM = POINTER(NET_BUTTON_DOWN_EXCEPTION_ALARM)


class NET_VCA_FD_IMAGE_CFG(Structure):
    _fields_ = [
        ("dwWidth", DWORD), # 灰度图像数据宽度
        ("dwHeight", DWORD), # 灰度图像高度
        ("dwImageLen", DWORD), # 灰度图像数据长度
        ("byRes", BYTE * 20), # 保留
        ("*pImage", BYTE), # 灰度图像数据
    ]


LPNET_VCA_FD_IMAGE_CFG = POINTER(NET_VCA_FD_IMAGE_CFG)


class NET_VCA_FD_PROCIMG_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byEnable", BYTE), # 是否激活规则
        ("bySensitivity", BYTE), # 检测灵敏度，[0,5]
        ("byRes1", BYTE * 22), # 保留字节
        ("struSizeFilter", NET_VCA_SIZE_FILTER), # 尺寸过滤器
        ("struPolygon", NET_VCA_POLYGON), # 多边形
        ("struFDImage", NET_VCA_FD_IMAGE_CFG), # 图片信息
        ("byRes2", BYTE * 20), # 保留
    ]


LPNET_VCA_FD_PROCIMG_CFG = POINTER(NET_VCA_FD_PROCIMG_CFG)


class NET_VCA_SUB_PROCIMG(Structure):
    _fields_ = [
        ("dwImageLen", DWORD), # 图片数据长度
        ("dwFaceScore", DWORD), # 人脸评分,0-100
        ("struVcaRect", NET_VCA_RECT), # 人脸子图区域
        ("byRes", BYTE * 20), # 保留
        ("*pImage", BYTE), # 图片数据
    ]


LPNET_VCA_SUB_PROCIMG = POINTER(NET_VCA_SUB_PROCIMG)


class NET_VCA_FD_PROCIMG_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwImageId", DWORD), # 大图ID
        ("byRes", BYTE * 20), # 保留
        ("dwSubImageNum", DWORD), # 人脸子图张数
        ("struProcImg", NET_VCA_SUB_PROCIMG * MAX_TARGET_NUM), # 单张子图信息
    ]


LPNET_VCA_FD_PROCIMG_RESULT = POINTER(NET_VCA_FD_PROCIMG_RESULT)


class NET_VCA_PICMODEL_RESULT(Structure):
    _fields_ = [
        ("dwImageLen", DWORD), # 图片数据长度
        ("dwModelLen", DWORD), # 模型数据长度
        ("byRes", BYTE * 20), # 保留
        ("*pImage", BYTE), # 人脸图片数据指针
        ("*pModel", BYTE), # 模型数据指针
    ]


LPNET_VCA_PICMODEL_RESULT = POINTER(NET_VCA_PICMODEL_RESULT)


class NET_VCA_REGISTER_PIC(Structure):
    _fields_ = [
        ("dwImageID", DWORD), # 大图ID
        ("dwFaceScore", DWORD), # 人脸评分,0-100
        ("struVcaRect", NET_VCA_RECT), # 人脸子图区域
        ("byRes", BYTE * 20), # 保留
    ]


LPNET_VCA_REGISTER_PIC = POINTER(NET_VCA_REGISTER_PIC)


MAX_HUMAN_PICTURE_NUM = 10 # 最大照片数
MAX_HUMAN_BIRTHDATE_LEN = 10 # 最大出生年月长度
class NET_DVR_AREAINFOCFG(Structure):
    _fields_ = [
        ("wNationalityID", WORD), # 国籍
        ("wProvinceID", WORD), # 省
        ("wCityID", WORD), # 市
        ("wCountyID", WORD), # 县
        #
        # if (dwCode != 0) dwCode 赋值参照 “全国各省份城市列表.txt”
        # else dwCode 赋值解析参照 PROVINCE_CITY_IDX
        #
        ("dwCode", DWORD),
    ]


LPNET_DVR_AREAINFOCFG = POINTER(NET_DVR_AREAINFOCFG)


class NET_VCA_HUMAN_ATTRIBUTE(Structure):
    _fields_ = [
        ("bySex", BYTE), # 性别：0-男，1-女，0xff-未知
        ("byCertificateType", BYTE), # 证件类型：0-身份证，1-警官证，2-军官证，3-护照，4-其他，0xff-未知
        ("byBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 出生年月，如：201106
        ("byName", BYTE * NAME_LEN), # 姓名
        ("struNativePlace", NET_DVR_AREAINFOCFG), # 籍贯参数
        ("byCertificateNumber", BYTE * NAME_LEN), # 证件号
        #
        # dwPersonInfoExtendLen && pPersonInfoExtend 对应URL(/ISAPI/System/Video/inputs/channels/<ID>/faceContrast/personInfoExtend)表示的 PersonInfoExtendList XML Block
        # 意义所在：平台中心管理的时候，导入picture数据的自定义信息，在设备检测匹配报警后，携带作为匹配信息一并上传；平台中心管理匹配；
        #
        ("dwPersonInfoExtendLen", DWORD), #  人员标签信息扩展长度
        ("*pPersonInfoExtend", BYTE), # 人员标签信息扩展信息
        ("byAgeGroup", BYTE), # 年龄段，详见HUMAN_AGE_GROUP_ENUM，如传入0xff表示未知
        ("byRes2", BYTE * 11),
    ]


LPNET_VCA_HUMAN_ATTRIBUTE = POINTER(NET_VCA_HUMAN_ATTRIBUTE)


class NET_VCA_HUMANATTRIBUTE_COND(Structure):
    _fields_ = [
        ("bySex", BYTE), # 性别：0-不启用，1-男，2-女
        ("byCertificateType", BYTE), # 证件类型：0-不启用，1-身份证，2-警官证
        ("byStartBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 起始出生年月，如：201106
        ("byEndBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 截止出生年月，如201106
        ("byName", BYTE * NAME_LEN), # 姓名
        ("struNativePlace", NET_DVR_AREAINFOCFG), # 籍贯参数
        ("byCertificateNumber", BYTE * NAME_LEN), # 证件号
        ("byRes", BYTE * 20),
    ]


LPNET_VCA_HUMANATTRIBUTE_COND = POINTER(NET_VCA_HUMANATTRIBUTE_COND)


class NET_VCA_BLACKLIST_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwRegisterID", DWORD), # 名单注册ID号（只读）
        ("dwGroupNo", DWORD), # 分组号
        ("byType", BYTE), # 黑白名单标志：0-全部，1-白名单，2-黑名单
        ("byLevel", BYTE), # 黑名单等级，0-全部，1-低，2-中，3-高
        ("byRes1", BYTE * 2), # 保留
        ("struAttribute", NET_VCA_HUMAN_ATTRIBUTE), # 人员信息
        ("byRemark", BYTE * NAME_LEN), # 备注信息
        ("dwFDDescriptionLen", DWORD), # 人脸库描述数据长度
        ("*pFDDescriptionBuffer", BYTE), # 人脸库描述数据指针
        ("dwFCAdditionInfoLen", DWORD), # 抓拍库附加信息长度
        ("*pFCAdditionInfoBuffer", BYTE), # 抓拍库附加信息数据指针（FCAdditionInfo中包含相机PTZ坐标）
        ("byRes2", BYTE * 4),
    ]


LPNET_VCA_BLACKLIST_INFO = POINTER(NET_VCA_BLACKLIST_INFO)


class NET_VCA_BLACKLIST_PARA(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("struBlackListInfo", NET_VCA_BLACKLIST_INFO), # 黑名单基本参数
        ("dwRegisterPicNum", DWORD), # 黑名单图个数
        ("struRegisterPic", NET_VCA_PICMODEL_RESULT * MAX_HUMAN_PICTURE_NUM), # 黑名单图片信息
        ("byRes", BYTE * 40), # 保留
    ]


LPNET_VCA_BLACKLIST_PARA = POINTER(NET_VCA_BLACKLIST_PARA)


class NET_VCA_BLACKLIST_COND(Structure):
    _fields_ = [
        ("lChannel", LONG), # 通道号
        ("dwGroupNo", DWORD), # 分组号
        ("byType", BYTE), # 黑白名单标志：0-全部，1-白名单，2-黑名单
        ("byLevel", BYTE), # 黑名单等级，0-全部，1-低，2-中，3-高
        ("byRes1", BYTE * 2), # 保留
        ("struAttribute", NET_VCA_HUMAN_ATTRIBUTE), # 人员信息
        ("byRes", BYTE * 20),
    ]


LPNET_VCA_BLACKLIST_COND = POINTER(NET_VCA_BLACKLIST_COND)


class NET_VCA_BLACKLIST_PIC(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwFacePicNum", DWORD), # 人脸图个数
        ("byRes", BYTE * 20), # 保留
        ("struBlackListPic", NET_VCA_PICMODEL_RESULT * MAX_HUMAN_PICTURE_NUM), # 单张照片信息
    ]


LPNET_VCA_BLACKLIST_PIC = POINTER(NET_VCA_BLACKLIST_PIC)


class NET_VCA_FIND_PICTURECOND(Structure):
    _fields_ = [
        ("lChannel", LONG), # 通道号
        ("struStartTime", NET_DVR_TIME), # 开始时间
        ("struStopTime", NET_DVR_TIME), # 结束时间
        ("byRes", BYTE * 12), # 保留
    ]


LPNET_VCA_FIND_PICTURECOND = POINTER(NET_VCA_FIND_PICTURECOND)


MAX_FACE_PIC_LEN = 6144 # 最大人脸图片数据长度
class NET_VCA_SUB_SNAPPIC_DATA(Structure):
    _fields_ = [
        ("dwFacePicID", DWORD), # 人脸图ID
        ("dwFacePicLen", DWORD), # 人脸图数据长度
        ("struSnapTime", NET_DVR_TIME), # 抓拍时间
        ("dwSimilarity", DWORD), # 相似度
        ("byRes", BYTE * 16), # 保留
        ("sPicBuf", CHAR * MAX_FACE_PIC_LEN), # 图片数据
    ]


LPNET_VCA_SUB_SNAPPIC_DATA = POINTER(NET_VCA_SUB_SNAPPIC_DATA)


class NET_VCA_ADVANCE_FIND(Structure):
    _fields_ = [
        ("dwFacePicID", DWORD), # 人脸图片ID
        ("byRes", BYTE * 36),
    ]


LPNET_VCA_ADVANCE_FIND = POINTER(NET_VCA_ADVANCE_FIND)


class NET_VCA_NORMAL_FIND(Structure):
    _fields_ = [
        ("dwImageID", DWORD), # 大图ID
        ("dwFaceScore", DWORD), # 人脸评分
        ("struVcaRect", NET_VCA_RECT), # 人脸子图区域
        ("byRes", BYTE * 20),
    ]


LPNET_VCA_NORMAL_FIND = POINTER(NET_VCA_NORMAL_FIND)


class NET_VCA_FIND_SNAPPIC_UNION(Union):
    _fields_ = [
        ("struNormalFind", NET_VCA_NORMAL_FIND), # 普通检索
        ("struAdvanceFind", NET_VCA_ADVANCE_FIND), # 高级检索
    ]


LPNET_VCA_FIND_SNAPPIC_UNION = POINTER(NET_VCA_FIND_SNAPPIC_UNION)


VCA_NORMAL_FIND = 0x00000000
VCA_ADVANCE_FIND = 0x00000001


class NET_VCA_FIND_PICTURECOND_ADVANCE(Structure):
    _fields_ = [
        ("lChannel", LONG), # 通道号
        ("struStartTime", NET_DVR_TIME), # 开始时间
        ("struStopTime", NET_DVR_TIME), # 结束时间
        ("byThreshold", BYTE), # 阈值，0-100
        ("byRes", BYTE * 23), # 保留
        ("dwFindType", DWORD), # 检索类型，详见VCA_FIND_SNAPPIC_TYPE
        ("uFindParam", NET_VCA_FIND_SNAPPIC_UNION), # 检索参数
    ]


LPNET_VCA_FIND_PICTURECOND_ADVANCE = POINTER(NET_VCA_FIND_PICTURECOND_ADVANCE)


class NET_VCA_FACESNAP_INFO_ALARM(Structure):
    _fields_ = [
        ("dwRelativeTime", DWORD), #  相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("dwSnapFacePicID", DWORD), # 抓拍人脸图ID
        ("dwSnapFacePicLen", DWORD), # 抓拍人脸子图的长度，为0表示没有图片，大于0表示有图片
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("byFaceScore", BYTE), # 人脸评分，指人脸子图的质量的评分,0-100
        ("bySex", BYTE), # 性别，0-未知，1-男，2-女,0xff-算法支持，但是没有识别出来
        ("byGlasses", BYTE), # 是否带眼镜，0-未知，1-是，2-否,3-戴墨镜, 0xff-算法支持，但是没有识别出来
        #
        # 识别人脸的年龄段范围[byAge-byAgeDeviation,byAge+byAgeDeviation]
        #
        ("byAge", BYTE), # 年龄,0-表示“未知”（算法不支持）,0xff-算法支持，但是没有识别出来
        ("byAgeDeviation", BYTE), # 年龄误差值
        ("byAgeGroup", BYTE), # 年龄段，详见HUMAN_AGE_GROUP_ENUM，若传入0xff表示未知
        # 人脸子图图片质量评估等级，0-低等质量,1-中等质量,2-高等质量,
        # 该质量评估算法仅针对人脸子图单张图片,具体是通过姿态、清晰度、遮挡情况、光照情况等可影响人脸识别性能的因素综合评估的结果
        ("byFacePicQuality", BYTE),
        ("byEthnic", BYTE),
        ("dwUIDLen", DWORD), #  上传报警的标识长度
        ("*pUIDBuffer", BYTE), # 标识指针
        ("fStayDuration", DOUBLE), # 停留画面中时间(单位: 秒)
        ("*pBuffer1", BYTE), # 抓拍人脸子图的图片数据
    ]


LPNET_VCA_FACESNAP_INFO_ALARM = POINTER(NET_VCA_FACESNAP_INFO_ALARM)


class NET_VCA_BLACKLIST_INFO_ALARM(Structure):
    _fields_ = [
        ("struBlackListInfo", NET_VCA_BLACKLIST_INFO), # 黑名单基本信息
        ("dwBlackListPicLen", DWORD), # 黑名单人脸子图的长度，为0表示没有图片，大于0表示有图片
        ("dwFDIDLen", DWORD), #  人脸库ID长度
        ("*pFDID", BYTE), # 人脸库Id指针
        ("dwPIDLen", DWORD), #  人脸库图片ID长度
        ("*pPID", BYTE), # 人脸库图片ID指针
        ("wThresholdValue", WORD), # 人脸库阈值[0,100]
        ("byIsNoSaveFDPicture", BYTE), # 0-保存人脸库图片,1-不保存人脸库图片, 若开启了导入图片或者建模时不保存原图功能时,该字段返回1,此时人脸库图片将不再返回
        ("byRealTimeContrast", BYTE), # 是否实时报警 0-实时 1-非实时
        ("*pBuffer1", BYTE), # 黑名单人脸子图的图片数据
    ]


LPNET_VCA_BLACKLIST_INFO_ALARM = POINTER(NET_VCA_BLACKLIST_INFO_ALARM)


class NET_VCA_FACESNAP_MATCH_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("fSimilarity", DOUBLE), # 相似度，[0.001,1]
        ("struSnapInfo", NET_VCA_FACESNAP_INFO_ALARM), # 抓拍信息
        ("struBlackListInfo", NET_VCA_BLACKLIST_INFO_ALARM), # 黑名单信息
        ("sStorageIP", CHAR * 16), # 存储服务IP地址
        ("wStoragePort", WORD), # 存储服务端口号
        ("byMatchPicNum", BYTE), # 匹配图片的数量，0-保留（老设备这个值默认0，新设备这个值为0时表示后续没有匹配的图片信息）
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("dwSnapPicLen", DWORD), # 设备识别抓拍图片长度
        ("*pSnapPicBuffer", BYTE), # 设备识别抓拍图片指针
        ("struRegion", NET_VCA_RECT), # 目标边界框，设备识别抓拍图片中，人脸子图坐标
        ("dwModelDataLen", DWORD), # 建模数据长度
        ("*pModelDataBuffer", BYTE), #  建模数据指针
        ("byModelingStatus", BYTE), #  建模状态
        ("byLivenessDetectionStatus", BYTE), # 活体检测状态：0-保留，1-未知（检测失败），2-非真人人脸，3-真人人脸，4-未开启活体检测
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14， +表示东区,0xff无效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45， +表示东区，0xff无效
        ("byMask", BYTE), # 抓拍图是否戴口罩，0-保留，1-未知，2-不戴口罩，3-戴口罩
        ("bySmile", BYTE), # 抓拍图是否微笑，0-保留，1-未知，2-不微笑，3-微笑
        ("byContrastStatus", BYTE), # 比对结果，0-保留，1-比对成功，2-比对失败
        ("byBrokenNetHttp", BYTE), # 断网续传标志位，0-不是重传数据，1-重传数据
    ]


LPNET_VCA_FACESNAP_MATCH_ALARM = POINTER(NET_VCA_FACESNAP_MATCH_ALARM)


class NET_VCA_BLACKLIST_INFO_ALARM_LOG(Structure):
    _fields_ = [
        ("struBlackListInfo", NET_VCA_BLACKLIST_INFO), # 黑名单基本信息
        ("dwBlackListPicID", DWORD), # 黑名单人脸子图ID，用于查找图片
        ("byRes", BYTE * 20), #  保留字节
    ]


LPNET_VCA_BLACKLIST_INFO_ALARM_LOG = POINTER(NET_VCA_BLACKLIST_INFO_ALARM_LOG)


class NET_VCA_FACESNAP_INFO_ALARM_LOG(Structure):
    _fields_ = [
        ("dwRelativeTime", DWORD), #  相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("dwSnapFacePicID", DWORD), # 抓拍人脸图ID
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("byRes", BYTE * 20), #  保留字节
    ]


LPNET_VCA_FACESNAP_INFO_ALARM_LOG = POINTER(NET_VCA_FACESNAP_INFO_ALARM_LOG)


class NET_VCA_FACESNAP_MATCH_ALARM_LOG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("fSimilarity", DOUBLE), # 相似度，[0.001,1]
        ("struSnapInfoLog", NET_VCA_FACESNAP_INFO_ALARM_LOG), # 抓拍信息
        ("struBlackListInfoLog", NET_VCA_BLACKLIST_INFO_ALARM_LOG), # 黑名单信息
        ("byRes", BYTE * 60), #  保留字节
    ]


LPNET_VCA_FACESNAP_MATCH_ALARM_LOG = POINTER(NET_VCA_FACESNAP_MATCH_ALARM_LOG)


class NET_VCA_FACEMATCH_PICCOND(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("dwSnapFaceID", DWORD), # 抓拍人脸子图ID
        ("dwBlackListID", DWORD), # 匹配的黑名单ID
        ("dwBlackListFaceID", DWORD), # 比对的黑名单人脸子图ID
        ("byRes", BYTE * 20), #  保留字节
    ]


LPNET_VCA_FACEMATCH_PICCOND = POINTER(NET_VCA_FACEMATCH_PICCOND)


class NET_VCA_FACEMATCH_PICTURE(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("dwSnapFaceLen", DWORD), # 抓拍人脸子图长度
        ("dwBlackListFaceLen", DWORD), # 比对的黑名单人脸子图长度
        ("byRes", BYTE * 20), # 保留字节
        ("*pSnapFace", BYTE), # 抓拍人脸子图的图片数据
        ("*pBlackListFace", BYTE), # 比对的黑名单人脸子图数据
    ]


LPNET_VCA_FACEMATCH_PICTURE = POINTER(NET_VCA_FACEMATCH_PICTURE)


class NET_VCA_BLACKLIST_FASTREGISTER_PARA(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("struBlackListInfo", NET_VCA_BLACKLIST_INFO), # 黑名单基本参数
        ("dwImageLen", DWORD), # 图像数据长度
        ("byRes", BYTE * 124), # 保留
        ("*pImage", BYTE), # 图像数据
    ]


LPNET_VCA_BLACKLIST_FASTREGISTER_PARA = POINTER(NET_VCA_BLACKLIST_FASTREGISTER_PARA)


# ******PJ01C20170209084超脑录播NVS软件功能开发定制项目专用*****
# 单帧画面人数统计结果上传
class NET_DVR_FRAMES_PEOPLE_COUNTING(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("dwPeopleCountingNum", DWORD), # 画面中的人数统计数量
        ("dwPicLen", DWORD), # 设备识别抓拍的全景图片数据长度
        ("*pPicBuffer", BYTE), # 设备识别抓拍的全景图片数据指针
        ("byRes", BYTE * 512), #  保留字节
    ]


LPNET_DVR_FRAMES_PEOPLE_COUNTING = POINTER(NET_DVR_FRAMES_PEOPLE_COUNTING)


# ******PJ01C20170209084超脑录播NVS软件功能开发定制项目专用*****
# 单个分区配置
class NET_VCA_SINGLE_PATH(Structure):
    _fields_ = [
        ("byActive", BYTE), #  是否可用,0-否,1-是
        ("byType", BYTE), # 0-存储抓拍，1-存储黑名单比对报警，2-存储抓拍和黑名单比对报警，0xff-无效
        ("bySaveAlarmPic", BYTE), # 是否用于保存断网的报警图片，0-否，1-是
        ("byRes1", BYTE * 5), # 保留
        ("dwDiskDriver", DWORD), # 盘符号，从0开始
        ("dwLeftSpace", DWORD), # 预留容量（单位为G）
        ("byRes2", BYTE * 8), # 保留
    ]


LPNET_VCA_SINGLE_PATH = POINTER(NET_VCA_SINGLE_PATH)


# 存储路径设置
class NET_VCA_SAVE_PATH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("struPathInfo", NET_VCA_SINGLE_PATH * MAX_DISKNUM_V30), # 单个分区
        ("byRes", BYTE * 40), # 保留
    ]


LPNET_VCA_SAVE_PATH_CFG = POINTER(NET_VCA_SAVE_PATH_CFG)


class NET_DVR_DEV_ACCESS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIP", NET_DVR_IPADDR), # 接入设备的IP地址
        ("wDevicePort", WORD), # 端口号
        ("byEnable", BYTE), # 是否启用，0-否，1-是
        ("byRes1", BYTE), # 保留
        ("sUserName", BYTE * NAME_LEN), # 接入设备的登录帐号
        ("sPassword", BYTE * PASSWD_LEN), # 接入设备的登录密码
        ("byRes2", BYTE * 60),
    ]


LPNET_DVR_DEV_ACCESS_CFG = POINTER(NET_DVR_DEV_ACCESS_CFG)


# 显示通道画面分割模式
MAX_WINDOWS_NUM = 12 # 画面分割模式的数量
MAX_SUPPORT_RES = 32
MAX_DISPNUM_V41 = 32
MAX_SDI_RES = 16 # SDI显示通道最大支持分辨率数
class NET_DVR_DISPWINDOWMODE(Structure):
    _fields_ = [
        ("byDispChanType", BYTE), # 显示通道类型：0-BNC, 1-VGA, 2-HDMI, 3-DVI 4-SDI
        ("byDispChanSeq", BYTE), # 显示通道序号,从1开始，如果类型是VGA，则表示第几个VGA
        ("byRes", BYTE * 2),
        ("byDispMode", BYTE * MAX_WINDOWS_NUM),
    ]


LPNET_DVR_DISPWINDOWMODE = POINTER(NET_DVR_DISPWINDOWMODE)


class NET_DVR_DISPINFO(Structure):
    _fields_ = [
        ("byChanNums", BYTE), # 通道个数
        ("byStartChan", BYTE), # 起始通道
        ("byRes", BYTE * 2),
        ("dwSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持分辨率
    ]


LPNET_DVR_DISPINFO = POINTER(NET_DVR_DISPINFO)


# 大屏拼接信息
class NET_DVR_SCREENINFO(Structure):
    _fields_ = [
        ("bySupportBigScreenNums", BYTE), # 最多大屏拼接数量
        ("byStartBigScreenNum", BYTE), # 大屏拼接起始号
        ("byMaxScreenX", BYTE), # 大屏拼接模式
        ("byMaxScreenY", BYTE),
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_SCREENINFO = POINTER(NET_DVR_SCREENINFO)


class NET_DVR_SDI_INFO(Structure):
    _fields_ = [
        ("byChanNums", BYTE), # 通道个数
        ("byStartChan", BYTE), # 起始通道
        ("byRes", BYTE * 2),
        ("dwSupportResolution", DWORD * MAX_SDI_RES), # 支持分辨率
    ]


LPNET_DVR_SDI_INFO = POINTER(NET_DVR_SDI_INFO)


class NET_DVR_MATRIX_ABILITY_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDspNums", BYTE), # DSP个数
        ("byDecChanNums", BYTE), # 解码通道数
        ("byStartChan", BYTE), # 起始解码通道
        ("byRes1", BYTE * 5),
        ("struVgaInfo", NET_DVR_DISPINFO), # VGA显示通道信息
        ("struBncInfo", NET_DVR_DISPINFO), # BNC显示通道信息
        ("struHdmiInfo", NET_DVR_DISPINFO), # HDMI显示通道信息
        ("struDviInfo", NET_DVR_DISPINFO), # DVI显示通道信息
        ("struDispMode", NET_DVR_DISPWINDOWMODE * MAX_DISPNUM_V41),
        ("struBigScreenInfo", NET_DVR_SCREENINFO),
        ("bySupportAutoReboot", BYTE), # 是否支持自动重启，0-不支持，1-支持
        ("byRes2", BYTE * 3),
        ("struSDIInfo", NET_DVR_SDI_INFO), # SDI显示通道信息
        ("byRes3", BYTE * 48),
    ]


LPNET_DVR_MATRIX_ABILITY_V41 = POINTER(NET_DVR_MATRIX_ABILITY_V41)


# 显示通道配置
MAX_WINDOWS = 16
MAX_WINDOWS_V41 = 36
STARTDISPCHAN_VGA = 1
STARTDISPCHAN_BNC = 9
STARTDISPCHAN_HDMI = 25
STARTDISPCHAN_DVI = 29
# class NET_DVR_MATRIX_VOUTCFG(Structure):
#     _fields_ = [
#         ("dwSize", DWORD),
#         ("byAudio", BYTE), # 音频是否开启
#         ("byAudioWindowIdx", BYTE), # 音频开启子窗口
#         ("byDispChanType", BYTE), # 显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI，4-YPbPr(解码卡服务器DECODER_SERVER专用)
#         ("byVedioFormat", BYTE), # 1:NTSC,2:PAL，0-NULL
#         ("dwResolution", DWORD), # 分辨率
#         ("dwWindowMode", DWORD), # 画面模式，能力集获取
#         ("byJoinDecChan", BYTE * MAX_WINDOWS_V41), # 各个子窗口关联的解码通道,设备支持解码资源自动分配时此参数不用填充
#         ("byEnlargeStatus", BYTE), # 是否处于放大状态，0：不放大，1：放大
#         ("byEnlargeSubWindowIndex", BYTE), # 放大的子窗口号
#         ("byScale", BYTE), # 显示模式，0---真实显示，1---缩放显示( 针对BNC )
#         ("byUnionType", BYTE), # 区分共用体,0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置
#         ("struDiff", NET_DVR_VIDEO_PLATFORM),
#         ("dwDispChanNum", DWORD), # 显示输出号，此参数在全部获取时有效
#         ("wLEDWidth", WORD), # LED分辨率宽，0为无效
#         ("wLEDHeight", WORD), # LED分辨率高，0为无效
#         ("byEnableVideoEffect", BYTE), # 显示效果使能， 0-不使能， !0-使能
#         ("byRes", BYTE * 3), # 保留字段
#         ("struVideoEffect", NET_DVR_VIDEOEFFECT), # 显示效果
#         ("byRes2", BYTE * 60),
#     ]
#
#
# LPNET_DVR_MATRIX_VOUTCFG = POINTER(NET_DVR_MATRIX_VOUTCFG)


# 解码器设备状态
class NET_DVR_DISP_CHAN_STATUS_V41(Structure):
    _fields_ = [
        ("byDispStatus", BYTE), # 显示状态：0：未显示，1：启动显示
        ("byBVGA", BYTE), # 0-BNC，1-VGA， 2-HDMI，3-DVI，4-SDI 0xff-无效
        ("byVideoFormat", BYTE), # 视频制式，1:NTSC,2:PAL,0-NON
        ("byWindowMode", BYTE), # 画面模式
        ("byJoinDecChan", BYTE * MAX_WINDOWS_V41), # 各个子画面关联的解码通道
        ("byFpsDisp", BYTE * MAX_WINDOWS_V41), # 每个子画面的显示帧率
        ("byScreenMode", BYTE), # 屏幕模式0-普通 1-大屏
        ("byRes1", BYTE * 3),
        ("dwDispChan", DWORD), # 获取全部显示通道状态时有效，设置时可填0
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_DISP_CHAN_STATUS_V41 = POINTER(NET_DVR_DISP_CHAN_STATUS_V41)


# 解码器设备状态
class NET_DVR_DECODER_WORK_STATUS_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDecChanStatus", NET_DVR_MATRIX_CHAN_STATUS * 32), # 解码通道状态
        # 显示通道状态
        ("struDispChanStatus", NET_DVR_DISP_CHAN_STATUS_V41 * MAX_DISPNUM_V41),
        ("byAlarmInStatus", BYTE * 32), # 报警输入状态
        ("byAlarmOutStatus", BYTE * 32), # 报警输出状态
        ("byAudioInChanStatus", BYTE), # 语音对讲状态
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_DECODER_WORK_STATUS_V41 = POINTER(NET_DVR_DECODER_WORK_STATUS_V41)


class NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIP", NET_DVR_IPADDR), #  DVR IP地址
        ("wDVRPort", WORD), #  端口号
        ("byChannel", BYTE), #  通道号
        ("byReserve", BYTE),
        ("sUserName", BYTE * NAME_LEN), #  用户名
        ("sPassword", BYTE * PASSWD_LEN), #  密码
        ("dwPlayMode", DWORD), #  0－按文件 1－按时间
        ("StartTime", NET_DVR_TIME),
        ("StopTime", NET_DVR_TIME),
        ("sFileName", CHAR * 128),
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41 = POINTER(NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41)


MAX_BIGSCREENNUM_SCENE = 100
MAX_LAYERNUMS = 32
# 显示通道配置结构
class NET_DVR_RECTCFG_SCENE(Structure):
    _fields_ = [
        ("wXCoordinate", WORD), # 矩形左上角起始点X坐标
        ("wYCoordinate", WORD), # 矩形左上角Y坐标
        ("wWidth", WORD), # 矩形宽度
        ("wHeight", WORD), # 矩形高度
    ]


LPNET_DVR_RECTCFG_SCENE = POINTER(NET_DVR_RECTCFG_SCENE)


class NET_DVR_SCENEDISPCFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("bySoltNum", BYTE), # 槽位号
        ("byRes1", BYTE * 2),
        ("byDispChanNum", BYTE),
        ("byAudio", BYTE), # 音频是否开启,0-否，1-是
        ("byAudioWindowIdx", BYTE), # 音频开启子窗口
        ("byVedioFormat", BYTE), # 1:NTSC,2:PAL，0-NULL
        ("byWindowMode", BYTE), # 画面模式，从能力集获取
        ("byEnlargeStatus", BYTE), # 是否处于放大状态，0：不放大，1：放大
        ("byEnlargeSubWindowIndex", BYTE), # 放大的子窗口号
        ("byScale", BYTE), # 显示模式，0-真实显示，1-缩放显示( 针对BNC )
        ("dwResolution", DWORD), # 分辨率
        ("byJoinDecChan", BYTE * MAX_WINDOWS_V41), # 各个子窗口关联的解码通道
        ("byJoinDecoderId", BYTE * MAX_WINDOWS_V41), # 槽位号
        # 显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通道都分配给此解码通道
        ("byDecResolution", BYTE * MAX_WINDOWS_V41),
        ("byRow", BYTE), # 大屏所在的行的序号
        ("byColumn", BYTE), # 大屏所在的列的序号
        ("byRes2", BYTE * 5),
        ("struDisp", NET_DVR_RECTCFG), # 电视墙显示位置
    ]


LPNET_DVR_SCENEDISPCFG = POINTER(NET_DVR_SCENEDISPCFG)


class NET_DVR_DEV_CHAN_INFO_SCENE(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), #  DVR IP地址
        ("wDVRPort", WORD), #  端口号
        ("byChannel", BYTE), #  通道号，对于9000等设备的IPC接入，通道号从33开始
        ("byTransProtocol", BYTE), #  传输协议类型0-TCP，1-UDP ，2-MCAST，3-RTP
        ("byTransMode", BYTE), #  传输码流模式 0－主码流 1－子码流
        ("byFactoryType", BYTE), # 前端设备厂家类型
        ("byDeviceType", BYTE), # 设备类型，1-IPC，2- ENCODER
        ("byRes", BYTE * 5),
        ("sUserName", BYTE * NAME_LEN), #  监控主机登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), #  监控主机密码
    ]


LPNET_DVR_DEV_CHAN_INFO_SCENE = POINTER(NET_DVR_DEV_CHAN_INFO_SCENE)


# 流媒体服务器基本配置
class NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE(Structure):
    _fields_ = [
        ("byValid", BYTE), # 是否启用流媒体服务器取流,0表示无效
        ("byRes1", BYTE * 3),
        ("struDevIP", NET_DVR_IPADDR), # 流媒体服务器地址
        ("wDevPort", WORD), # 流媒体服务器端口
        ("byTransmitType", BYTE), # 传输协议类型0-TCP，1-UDP
        ("byRes2", BYTE * 5),
    ]


LPNET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE = POINTER(NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE)


class NET_DVR_PU_STREAM_CFG_SCENE(Structure):
    _fields_ = [
        ("streamMediaServerCfg", NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE),
        ("struDevChanInfo", NET_DVR_DEV_CHAN_INFO_SCENE),
    ]


LPNET_DVR_PU_STREAM_CFG_SCENE = POINTER(NET_DVR_PU_STREAM_CFG_SCENE)


class NET_DVR_CYC_SUR_CHAN_ELE_SCENE(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  是否启用 0－否 1－启用
        ("byRes", BYTE * 3),
        ("struStreamMediaSvrCfg", NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE),
        ("struDecChanInfo", NET_DVR_DEV_CHAN_INFO_SCENE), # 轮巡解码通道信息
    ]


LPNET_DVR_CYC_SUR_CHAN_ELE_SCENE = POINTER(NET_DVR_CYC_SUR_CHAN_ELE_SCENE)


# 轮巡解码结构
class NET_DVR_MATRIX_LOOP_DECINFO_SCENE(Structure):
    _fields_ = [
        ("wPoolTime", WORD), # 轮询间隔
        ("byRes1", BYTE * 2),
        ("struChanArray", NET_DVR_CYC_SUR_CHAN_ELE_SCENE * MAX_CYCLE_CHAN),
        ("byRes2", BYTE * 4),
    ]


LPNET_DVR_MATRIX_LOOP_DECINFO_SCENE = POINTER(NET_DVR_MATRIX_LOOP_DECINFO_SCENE)


class NET_DVR_BIGSCREENCFG_SCENE(Structure):
    _fields_ = [
        ("byAllValid", BYTE), # 漫游使能标志
        ("byAssociateBaseMap", BYTE), # 关联的底图序号，0代表不关联
        ("byEnableSpartan", BYTE), # 大屏畅显使能，1-开，0-关
        ("byRes", BYTE),
        ("struWinCfg", NET_DVR_WINCFG * MAX_LAYERNUMS),
        ("struBigScreen", NET_DVR_BIGSCREENCFG),
    ]


LPNET_DVR_BIGSCREENCFG_SCENE = POINTER(NET_DVR_BIGSCREENCFG_SCENE)


class NET_DVR_MATRIX_SCENECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sSceneName", BYTE * NAME_LEN),
        ("byBigScreenNums", BYTE), # 大屏的个数，最大值通过能力集获取
        ("byRes1", BYTE * 3),
        ("wDecChanNums", WORD), # 场景中解码通道的个数
        ("wDispChanNums", WORD), # 场景中显示通道的个数
        ("byRes2", BYTE * 12),
        ("*pBigScreenBuffer", BYTE), # 大屏配置缓冲区, byBigScreenNums×sizeof(NET_DVR_BIGSCREENCFG_SCENE)
        ("*pDecChanBuffer", BYTE), # 解码通道配置缓冲区, wDecChanNums×sizeof(NET_DVR_DECODECHANCFG_SCENE)
        ("*pDispChanBuffer", BYTE), # 显示通道配置缓冲区, wDispChanNums×sizeof(NET_DVR_SCENEDISPCFG)
    ]


LPNET_DVR_MATRIX_SCENECFG = POINTER(NET_DVR_MATRIX_SCENECFG)


class NET_DVR_BIGSCREENASSOCIATECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableBaseMap", BYTE), # 使能底图显示
        ("byAssociateBaseMap", BYTE), # 关联的底图序号，0代表不关联
        ("byEnableSpartan", BYTE), # 大屏畅显使能，1-开，0-关
        ("byRes", BYTE * 21),
    ]


LPNET_DVR_BIGSCREENASSOCIATECFG = POINTER(NET_DVR_BIGSCREENASSOCIATECFG)

MAX_WIN_COUNT = 224 # 支持的最大开窗数
class NET_DVR_SCREEN_WINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byVaild", BYTE),
        ("byInputType", BYTE), # 见CAM_MDOE
        ("wInputIdx", WORD), # 输入源索引
        ("dwLayerIdx", DWORD), # 图层，0为最底层
        ("struWin", NET_DVR_RECTCFG), # 目的窗口(相对显示墙)
        ("byWndIndex", BYTE), # 窗口号
        ("byCBD", BYTE), # 0-无，1-带背景，2-不带背景
        ("bySubWnd", BYTE), # 0不是，1是
        ("byRes1", BYTE),
        ("dwDeviceIndex", DWORD), # 设备序号
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_SCREEN_WINCFG = POINTER(NET_DVR_SCREEN_WINCFG)


class NET_DVR_WINLIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wScreenSeq", WORD), # 设备序号
        ("byRes", BYTE * 10),
        ("dwWinNum", DWORD), # 设备返回的窗口数量
        ("*pBuffer", BYTE), # 窗口信息缓冲区，最大为224*sizeof(NET_DVR_WINCFG)
        ("dwBufLen", DWORD), # 所分配指针长度
    ]


LPNET_DVR_WINLIST = POINTER(NET_DVR_WINLIST)


MAX_LAYOUT_COUNT = 16 # 最大布局数
class NET_DVR_LAYOUTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), # 布局是否有效
        ("byRes1", BYTE * 3),
        ("byLayoutName", BYTE * NAME_LEN), # 布局名称
        ("struWinCfg", NET_DVR_SCREEN_WINCFG * MAX_WIN_COUNT), # 布局内窗口参数
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_LAYOUTCFG = POINTER(NET_DVR_LAYOUTCFG)


class NET_DVR_LAYOUT_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struLayoutInfo", NET_DVR_LAYOUTCFG * MAX_LAYOUT_COUNT), # 所有布局
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_LAYOUT_LIST = POINTER(NET_DVR_LAYOUT_LIST)


MAX_CAM_COUNT = 224
MAX_CAM_COUNT_V50 = 512
NET_DVR_UNKNOW = 0
        # NET_DVR_CAM_BNC,
        # NET_DVR_CAM_VGA,
        # NET_DVR_CAM_DVI,
        # NET_DVR_CAM_HDMI,
        # NET_DVR_CAM_IP,
        # NET_DVR_CAM_RGB,
        # NET_DVR_CAM_DECODER,
        # NET_DVR_CAM_MATRIX,
        # NET_DVR_CAM_YPBPR,
        # NET_DVR_CAM_USB,
        # NET_DVR_CAM_SDI,
        # NET_DVR_CAM_HDI,
        # NET_DVR_CAM_DP, 此类型视频综合平台不返回
        # NET_DVR_CAM_HDTVI,
        # NET_DVR_CAM_JOINT, 拼接信号源
        # NET_DVR_CAM_HDBASET,
        # NET_DVR_CAM_DVIT, DVI双链路，此类型视频综合平台不返回
        # NET_DVR_CAM_FUSION, 多IPC拼接
        # NET_DVR_CAM_VSCREEN, 虚拟屏
        # NET_DVR_CAM_FIBER, 光纤
        # NET_DVR_CAM_3GSDI, 3G-SDI
        # NET_DVR_CAM_DISTRIBUTED_IP, 分布式网络源
        # NET_DVR_CAM_JONIT_X86, x86拼接子系统的拼接通道
        # NET_DVR_CAM_TVI, TVI信号源


class NET_DVR_INPUTSTREAMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE),
        ("byCamMode", BYTE), # 信号输入源类型，见NET_DVR_CAM_MODE
        ("wInputNo", WORD), # 信号源序号0-224
        ("sCamName", BYTE * NAME_LEN), # 信号输入源名称
        ("struVideoEffect", NET_DVR_VIDEOEFFECT), # 视频参数
        ("struPuStream", NET_DVR_PU_STREAM_CFG), # ip输入时使用
        ("wBoardNum", WORD), # 信号源所在的板卡号
        ("wInputIdxOnBoard", WORD), # 信号源在板卡上的位置
        ("dwResolution", DWORD), # 分辨率
        ("byVideoFormat", BYTE), # 视频制式，见VIDEO_STANDARD
        ("byStatus", BYTE), # 信号源状态，0-字段无效 1-有信号 2-无信号 3-异常
        ("sGroupName", BYTE * NAME_LEN), # 网络信号源分组 组名
        ("byJointMatrix", BYTE), #   关联矩阵 ，0-不关联  1-关联
        ("byRes", BYTE),
    ]


LPNET_DVR_INPUTSTREAMCFG = POINTER(NET_DVR_INPUTSTREAMCFG)


class NET_DVR_INPUTSTREAM_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struInputStreamInfo", NET_DVR_INPUTSTREAMCFG * MAX_CAM_COUNT), # 所有信号源
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_INPUTSTREAM_LIST = POINTER(NET_DVR_INPUTSTREAM_LIST)


# ******************************输出参数配置******************************
# 输出通道管理
class NET_DVR_OUTPUTPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMonMode", BYTE), # 输出连接模式,1-BNC,2-VGA,3-DVI,4-HDMI
        ("byRes1", BYTE * 3),
        ("dwResolution", DWORD), # 分辨率，根据能力集获取所支持的进行设置
        ("struVideoEffect", NET_DVR_VIDEOEFFECT), # 输出通道视频参数配置
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_OUTPUTPARAM = POINTER(NET_DVR_OUTPUTPARAM)


class NET_DVR_OUTPUTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byScreenLayX", BYTE), # 大屏布局-横坐标
        ("byScreenLayY", BYTE), # 大屏布局-纵坐标
        ("wOutputChanNum", WORD), # 输出通道个数，0表示设备支持的最大输出通道个数，最大个数从能力集获取，其他值表示实际输出通道个数
        ("byRes1", BYTE * 4),
        ("struOutputParam", NET_DVR_OUTPUTPARAM), # 输出通道视频参数配置
        ("sWallName", BYTE * 16), # 电视墙名称
        ("byRes2", BYTE * 8),
    ]


LPNET_DVR_OUTPUTCFG = POINTER(NET_DVR_OUTPUTCFG)


# ******************************能力集******************************
SCREEN_PROTOCOL_NUM = 20 # 支持的最大大屏控制器协议数
# 多屏服务器能力集
class NET_DVR_SCREENSERVER_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byIsSupportScreenNum", BYTE), # 所支持大屏控制器的数目
        ("bySerialNums", BYTE), # 串口个数
        ("byMaxInputNums", BYTE),
        ("byMaxLayoutNums", BYTE),
        ("byMaxWinNums", BYTE),
        ("byRes1", BYTE * 19),
        ("byMaxScreenLayX", BYTE), # 大屏布局-最大横坐标大屏数
        ("byMaxScreenLayY", BYTE), # 大屏布局-最大纵坐标大屏数
        ("wMatrixProtoNum", WORD), # 有效的大屏协议数目
        ("struScreenProto", NET_DVR_PROTO_TYPE * SCREEN_PROTOCOL_NUM), # 最大协议列表
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_SCREENSERVER_ABILITY = POINTER(NET_DVR_SCREENSERVER_ABILITY)


# 多屏控制器能力集
class NET_DVR_SCREENCONTROL_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byLayoutNum", BYTE), #  布局个数
        ("byWinNum", BYTE), # 屏幕窗口个数
        ("byOsdNum", BYTE), # OSD个数
        ("byLogoNum", BYTE), # Logo个数
        ("byInputStreamNum", BYTE), # 输入源个数 ---设备支持最大输入通道个数（包括本地输入源和网络输入源）
        ("byOutputChanNum", BYTE), # 输出通道个数---设备支持最大输出通道个数
        ("byCamGroupNum", BYTE), # 分组个数
        ("byPlanNum", BYTE), # 预案个数
        ("byRes1", BYTE * 5),
        ("byIsSupportPlayBack", BYTE), # 是否支持回放
        ("byMatrixInputNum", BYTE), # 支持输入矩阵最大个数
        ("byMatrixOutputNum", BYTE), # 支持输出矩阵最大个数
        ("struVgaInfo", NET_DVR_DISPINFO), # VGA输出信息
        ("struBncInfo", NET_DVR_DISPINFO), # BNC输出信息
        ("struHdmiInfo", NET_DVR_DISPINFO), # HDMI输出信息
        ("struDviInfo", NET_DVR_DISPINFO), # DVI输出信息
        ("byMaxUserNums", BYTE), # 支持用户数
        ("byPicSpan", BYTE), # 底图跨度，一张底图最多可覆盖的屏幕数
        ("wDVCSDevNum", WORD), # 分布式大屏控制器最大设备数
        ("wNetSignalNum", WORD), # 最大网络输入源个数
        ("wBaseCoordinateX", WORD), # 基准坐标
        ("wBaseCoordinateY", WORD),
        ("byExternalMatrixNum", BYTE), # 最大外接矩阵个数
        ("byRes2", BYTE * 49),
    ]


LPNET_DVR_SCREENCONTROL_ABILITY = POINTER(NET_DVR_SCREENCONTROL_ABILITY)


# ******************************输入信号状态******************************
class NET_DVR_ANALOGINPUTSTATUS(Structure):
    _fields_ = [
        ("dwLostFrame", DWORD), # 视频输入丢帧数
        ("byHaveSignal", BYTE), # 是否有视频信号输入
        ("byVideoFormat", BYTE), # 视频制式，1：NTSC,2：PAL,0：无
        ("byRes", BYTE * 46),
    ]


LPNET_DVR_ANALOGINPUTSTATUS = POINTER(NET_DVR_ANALOGINPUTSTATUS)


class NET_DVR_INPUTSTATUS_UNION(Union):
    _fields_ = [
        ("struIpInputStatus", NET_DVR_MATRIX_CHAN_STATUS),
        ("struAnalogInputStatus", NET_DVR_ANALOGINPUTSTATUS),
    ]


LPNET_DVR_INPUTSTATUS_UNION = POINTER(NET_DVR_INPUTSTATUS_UNION)


class NET_DVR_INPUTSTATUS(Structure):
    _fields_ = [
        ("wInputNo", WORD), # 信号源序号
        ("byInputType", BYTE), # 见NET_DVR_CAM_MODE
        ("byRes1", BYTE * 9),
        ("struStatusUnion", NET_DVR_INPUTSTATUS_UNION),
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_INPUTSTATUS = POINTER(NET_DVR_INPUTSTATUS)


class NET_DVR_SCREENINPUTSTATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 12),
        ("dwNums", DWORD), # 设备返回的输入源状态的数量
        ("*pBuffer", BYTE), # 缓冲区
        ("dwBufLen", DWORD), # 所分配指针长度，输入参数
    ]


LPNET_DVR_SCREENINPUTSTATUS = POINTER(NET_DVR_SCREENINPUTSTATUS)


class NET_DVR_SCREENALARMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAlarmType", BYTE), # 报警类型，1-子板拔出，2-子板插入，3-子系统状态异常，4-子系统恢复恢复 5-输入源异常   6-温度报警 7-FPGA版本不匹配 8-预案开始 9-预案结束 10-解码板断网 11-解码板IP地址冲突，12-风扇异常
        ("byBoardType", BYTE), #  1-输入板 2-输出板 ，3-主板，4-背板，报警类型为1，2，3，6的时候使用
        ("bySubException", BYTE), # 输入异常时具体子异常 1- 分辨率正常改变 2-输入端口类型改变3-分辨率错误4-分辨率改变导致解码资源不足，关闭该输入源对应窗口。5-分辨率改变，导致已开窗的缩放比例不在1/8到8倍范围。6-分辨率恢复正常,7-分辨率改变导致输出板数据量超限,设备关闭窗口
        ("byRes1", BYTE),
        ("wStartInputNum", WORD), #  异常输入源（异常起点）
        ("wEndInputNum", WORD), #  异常输入源（异常终点）
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_SCREENALARMCFG = POINTER(NET_DVR_SCREENALARMCFG)


class NET_DVR_MATRIX_CFG(Structure):
    _fields_ = [
        ("byValid", BYTE), # 判断是否是模拟矩阵（是否有效）
        ("byCommandProtocol", BYTE), # 模拟矩阵的指令（4种）
        ("byScreenType", BYTE), # 保留
        ("byRes1", BYTE),
        ("byScreenToMatrix", BYTE * 32), # 模拟矩阵的输出与屏幕的对应关系
        ("byRes2", BYTE * 4),
    ]


LPNET_DVR_MATRIX_CFG = POINTER(NET_DVR_MATRIX_CFG)


class NET_DVR_DIGITALSCREEN(Structure):
    _fields_ = [
        ("struAddress", NET_DVR_IPADDR), # 设备为数字设备时的IP信息
        ("wPort", WORD), # 通道号
        ("byRes", BYTE * 26), # 保留
    ]


LPNET_DVR_DIGITALSCREEN = POINTER(NET_DVR_DIGITALSCREEN)


class NET_DVR_ANALOGSCREEN(Structure):
    _fields_ = [
        ("byDevSerPortNum", BYTE), # 连接设备的串口号
        ("byScreenSerPort", BYTE), # 连接大屏的串口号
        ("byRes", BYTE * 130),
        ("struMatrixCfg", NET_DVR_MATRIX_CFG),
    ]


LPNET_DVR_ANALOGSCREEN = POINTER(NET_DVR_ANALOGSCREEN)


class NET_DVR_SCREEN_UNION(Union):
    _fields_ = [
        ("struDigitalScreen", NET_DVR_DIGITALSCREEN),
        ("struAnalogScreen", NET_DVR_ANALOGSCREEN),
    ]


LPNET_DVR_SCREEN_UNION = POINTER(NET_DVR_SCREEN_UNION)


class NET_DVR_SCREEN_SCREENINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), # 是否有效
        ("nLinkMode", BYTE), # 连接方式，0-串口，1-网口
        ("byDeviceType", BYTE), # 设备型号，能力集获取
        ("byScreenLayX", BYTE), # 大屏布局-横坐标
        ("byScreenLayY", BYTE), # 大屏布局-纵坐标
        ("byRes1", BYTE * 3),
        ("sUserName", BYTE * NAME_LEN), # 登录用户名
        ("sPassword", BYTE * PASSWD_LEN), # 登录密码
        ("sDevName", BYTE * NAME_LEN), # 设备名称
        ("struScreenUnion", NET_DVR_SCREEN_UNION),
        ("byInputNum", BYTE), #  输入源个数
        ("byOutputNum", BYTE), #  输出源个数
        ("byCBDNum", BYTE), # CBD个数
        ("byRes2", BYTE * 29),
    ]


LPNET_DVR_SCREEN_SCREENINFO = POINTER(NET_DVR_SCREEN_SCREENINFO)


# ******************************底图上传******************************
class NET_DVR_BASEMAP_CFG(Structure):
    _fields_ = [
        ("byScreenIndex", BYTE), # 屏幕的序号
        ("byMapNum", BYTE), # 被分割成了多少块
        ("res", BYTE * 2),
        ("wSourWidth", WORD), #  原图片的宽度
        ("wSourHeight", WORD), #  原图片的高度
    ]


LPNET_DVR_BASEMAP_CFG = POINTER(NET_DVR_BASEMAP_CFG)


class NET_DVR_PICTURECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 大小
        ("byUseType", BYTE), # 1-底图，2-GIF图片，3-CAD图片 4-输出口图片
        ("bySequence", BYTE), # 序号
        ("byOverlayEnabled", BYTE), # 图片叠加使能，是否在上传图片包含图片叠加参数 1-包含叠加参数，0-不包含
        ("byRes", BYTE * 1),
        ("struBasemapCfg", NET_DVR_BASEMAP_CFG),
        ("sPicName", BYTE * NAME_LEN), # 图片名称
        ("dwVideoWall", DWORD), # 墙号（1字节墙号（对于合码器，该值固定为1即可）+1字节通道输出+2字节窗口号）
        ("byFlash", BYTE), # 图片闪烁使能，1-闪烁，0-不闪烁
        ("byTranslucent", BYTE), # 图片半透明使能，1-半透明，0-不半透明
        ("byShowEnabled", BYTE), # 图片显示使能，1-显示，0-隐藏
        ("byPictureType", BYTE), # 图片类型，1-bmp，2-jpg，3-png，……
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_PICTURECFG = POINTER(NET_DVR_PICTURECFG)


# ******************************OSD******************************
MAX_OSDCHAR_NUM = 256
class NET_DVR_OSDCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), # 是否有效 0无效 1有效
        ("byDispMode", BYTE), # 显示模式，1-透明，2-半透明，3-覆盖三种模式
        ("byFontColorY", BYTE), # 字体颜色Y,0-255
        ("byFontColorU", BYTE), # 字体颜色U,0-255
        ("byFontColorV", BYTE), # 字体颜色V,0-255
        ("byBackColorY", BYTE), # 背景颜色Y,0-255
        ("byBackColorU", BYTE), # 背景颜色U,0-255
        ("byBackColorV", BYTE), # 背景颜色V,0-255
        ("wXCoordinate", WORD), # OSD在屏幕左上角位置x
        ("wYCoordinate", WORD), # OSD在屏幕左上角位置y
        ("wWidth", WORD), # OSD宽度
        ("wHeight", WORD), # OSD高度
        ("dwCharCnt", DWORD), # 字符的个数
        ("wOSDChar", WORD * MAX_OSDCHAR_NUM), # OSD字符内容
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_OSDCFG = POINTER(NET_DVR_OSDCFG)


# ******************************获取串口信息******************************
class NET_DVR_SERIAL_CONTROL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySerialNum", BYTE), #  串口个数
        ("byRes1", BYTE * 3),
        ("bySerial", BYTE * 32),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_SERIAL_CONTROL = POINTER(NET_DVR_SERIAL_CONTROL)


# ******************************屏幕控制******************************
# 屏幕输入源控制
INTERFACE_VGA = 0
        # INTERFACE_SVIDEO,  2046NL不支持，2046NH支持
        # INTERFACE_YPBPR,
        # INTERFACE_DVI ,
        # INTERFACE_BNC ,
        # INTERFACE_DVI_LOOP,(环通) 2046NH不支持，2046NL支持
        # INTERFACE_BNC_LOOP, (环通) 2046NH不支持，2046NL.支持
        # INTERFACE_HDMI,
        # INTERFACE_IP,
        # INTERFACE_USB,
        # INTERFACE_SDI,
        # INTERFACE_DP,
        # INTERFACE_HDBASET


class NET_DVR_INPUT_INTERFACE_CTRL(Structure):
    _fields_ = [
        ("byInputSourceType", BYTE), # 见INPUT_INTERFACE_TYPE
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_INPUT_INTERFACE_CTRL = POINTER(NET_DVR_INPUT_INTERFACE_CTRL)


# 显示单元颜色控制
class NET_DVR_DISPLAY_COLOR_CTRL(Structure):
    _fields_ = [
        ("byColorType", BYTE), # 1-亮度 2-对比度 3-饱和度 4-清晰度
        ("byScale", CHAR), # -1 、0、+1三个值
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_DISPLAY_COLOR_CTRL = POINTER(NET_DVR_DISPLAY_COLOR_CTRL)


# 显示单元位置控制
class NET_DVR_DISPLAY_POSITION_CTRL(Structure):
    _fields_ = [
        ("byPositionType", BYTE), # 1-水平位置 2-垂直位置，
        ("byScale", CHAR), # -1 、0、+1三个值
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_DISPLAY_POSITION_CTRL = POINTER(NET_DVR_DISPLAY_POSITION_CTRL)


# ******************************屏幕控制V41******************************
class NET_DVR_RECTCFG_EX(Structure):
    _fields_ = [
        ("dwXCoordinate", DWORD), # 矩形左上角起始点X坐标
        ("dwYCoordinate", DWORD), # 矩形左上角Y坐标
        ("dwWidth", DWORD), # 矩形宽度
        ("dwHeight", DWORD), # 矩形高度
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_RECTCFG_EX = POINTER(NET_DVR_RECTCFG_EX)


# ******************************预案管理******************************
MAX_PLAN_ACTION_NUM = 32 # 预案动作个数
DAYS_A_WEEK = 7 # 一周7天
MAX_PLAN_COUNT = 16 # 预案个数
# 预案项信息
class NET_DVR_PLAN_INFO(Structure):
    _fields_ = [
        ("byValid", BYTE), #  该项是否有效
        ("byType", BYTE), #  见定义NET_DVR_PLAN_OPERATE_TYPE
        ("wLayoutNo", WORD), #  布局号
        ("byScreenStyle", BYTE), # 屏幕型号，开关机所用，1是低亮，2是高亮
        ("byBaseMapType", BYTE), # 底图类型，1-图片底图，2-超高清输入底图，底图切换时有效
        ("byRes1", BYTE * 2),
        ("dwDelayTime", DWORD), #  一个项的运行时间, 单位秒
        ("dwSerialNo", DWORD), # 串口号，屏幕控制时使用
        ("dwBaseMapWndNo", DWORD), # 底图窗口号，底图切换时有效
        ("dwBaseMapNo", DWORD), # 底图号，底图切换时有效；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入号（1字节设备号+1字节子板号+2字节显示输入序号）
        ("byRes2", BYTE * 20),
    ]


LPNET_DVR_PLAN_INFO = POINTER(NET_DVR_PLAN_INFO)


class NET_DVR_CYCLE_TIME(Structure):
    _fields_ = [
        ("byValid", BYTE),
        ("byRes", BYTE * 3),
        ("struTime", NET_DVR_TIME_EX),
    ]


LPNET_DVR_CYCLE_TIME = POINTER(NET_DVR_CYCLE_TIME)


# 预案管理
class NET_DVR_PLAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), #  该预案是否有效
        ("byWorkMode", BYTE), #  预案工作模式 1表示手动，2自动，3预案循环
        ("byWallNo", BYTE), # 电视墙号，从1开始
        ("byPlanNo", BYTE), # 预案号，获取预案列表时有效，0-无效或不支持
        ("byPlanName", BYTE * NAME_LEN), # 预案名称
        ("struTime", NET_DVR_TIME_EX), #  工作模式为自动时使用
        ("struTimeCycle", NET_DVR_CYCLE_TIME * DAYS_A_WEEK), # 循环时间，周期为一个星期，年、月、日三个参数不使用。如：struTimeCycle[0]中的byValid的值是1，表示星期天执行该预案。星期取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推
        ("dwWorkCount", DWORD), #  预案内容执行次数
        ("strPlanEntry", NET_DVR_PLAN_INFO * MAX_PLAN_ACTION_NUM), #  预案执行的内容
        ("dwPlanNo", DWORD), # 4字节预案号，客户端统一使用4字节的预案号，单字节的预案号不再使用
        ("byRes2", BYTE * 60),
    ]


LPNET_DVR_PLAN_CFG = POINTER(NET_DVR_PLAN_CFG)


# ******************************获取设备状态******************************
# 预案列表
class NET_DVR_PLAN_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPlanNums", DWORD), # 设备输入信号源数量
        ("*pBuffer", BYTE), # 指向dwInputSignalNums个NET_DVR_PLAN_CFG结构大小的缓冲区
        ("byWallNo", BYTE), # 墙号，从1开始
        ("byRes1", BYTE * 2),
        ("dwBufLen", DWORD), # 所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_PLAN_CFG结构大小）
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_PLAN_LIST = POINTER(NET_DVR_PLAN_LIST)


# ******************************预案控制******************************
# 该结构体可作为通用控制结构体
class NET_DVR_CONTROL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sDeviceID", BYTE * NAME_LEN), # 被控设备的设备ID
        ("wChan", WORD), # 被控通道
        ("byIndex", BYTE), # 控制索引，根据命令确定具体表示什么索引
        ("byRes1", BYTE),
        ("dwControlParam", DWORD),
        ("byMandatoryAlarm", BYTE), # 1-使能  0-不使能
        ("byRes2", BYTE),
        ("wZoneIndex", WORD), # 防区号
        ("byOperatorCode", BYTE * 16), # 回控码
        ("dwPlanNo", DWORD), # 4字节预案号，客户端统一使用4字节的预案号，单字节的预案号不再使用
        ("byRes3", BYTE * 8),
    ]


LPNET_DVR_CONTROL_PARAM = POINTER(NET_DVR_CONTROL_PARAM)


# ******************************获取设备状态******************************
class NET_DVR_DEVICE_RUN_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMemoryTotal", DWORD), # 内存总量，单位Kbyte
        ("dwMemoryUsage", DWORD), # 内存使用量，单位Kbyte
        ("byCPUUsage", BYTE), # CPU使用率，0-100
        ("byMainFrameTemp", BYTE), # 机箱温度，单位：摄氏度
        ("byBackPanelTemp", BYTE), # 背板温度，单位：摄氏度
        ("byRes1", BYTE),
        ("byLeftDecResource", BYTE * 32), # 各解码板剩余解码资源，以解D1分辨率资源为单位，byLeftDecResource[i],表示槽位号i解码板剩余资源，0xff表示无效（非解码板或没插板子）
        ("fNetworkFlow", DOUBLE), # 网络流量，单位：KB/s，归一化处理，保留小数点后两位
        ("byRes2", BYTE * 88),
    ]


LPNET_DVR_DEVICE_RUN_STATUS = POINTER(NET_DVR_DEVICE_RUN_STATUS)


#  91系列HD-SDI高清DVR 相机信息
class NET_DVR_ACCESS_CAMERA_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sCameraInfo", CHAR * 32), #  前端相机信息
        ("byInterfaceType", BYTE), #  前端接入接口类型，1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
        ("byRes1", BYTE * 3),
        ("dwChannel", DWORD),
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_ACCESS_CAMERA_INFO = POINTER(NET_DVR_ACCESS_CAMERA_INFO)


class NET_DVR_AUDIO_INPUT_PARAM(Structure):
    _fields_ = [
        ("byAudioInputType", BYTE), # 音频输入类型，0-mic in，1-line in
        ("byVolume", BYTE), # volume,[0-100]
        ("byEnableNoiseFilter", BYTE), # 是否开启声音过滤-关，-开
        ("byres", BYTE * 5),
    ]


LPNET_DVR_AUDIO_INPUT_PARAM = POINTER(NET_DVR_AUDIO_INPUT_PARAM)


class NET_DVR_CAMERA_DEHAZE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDehazeMode", BYTE), # 0-不启用，1-自动模式，2-开
        ("byLevel", BYTE), # 等级，0-100
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_CAMERA_DEHAZE_CFG = POINTER(NET_DVR_CAMERA_DEHAZE_CFG)


class NET_DVR_INPUT_SIGNAL_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwInputSignalNums", DWORD), # 设备输入信号源数量
        ("*pBuffer", BYTE), # 指向dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小的缓冲区
        ("byRes1", BYTE * 3),
        ("dwBufLen", DWORD), # 所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小）
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_INPUT_SIGNAL_LIST = POINTER(NET_DVR_INPUT_SIGNAL_LIST)


#  安全拔盘状态
PULL_DISK_SUCCESS = 1 #  安全拔盘成功
PULL_DISK_FAIL = 2 #  安全拔盘失败
PULL_DISK_PROCESSING = 3 #  正在停止阵列
PULL_DISK_NO_ARRAY = 4 #  阵列不存在
PULL_DISK_NOT_SUPPORT = 5 #  不支持安全拔盘
#  扫描阵列状态
SCAN_RAID_SUC = 1 #  扫描阵列成功
SCAN_RAID_FAIL = 2 #  扫描阵列失败
SCAN_RAID_PROCESSING = 3 #  正在扫描阵列
SCAN_RAID_NOT_SUPPORT = 4 #  不支持阵列扫描
#  设置前端相机类型状态
SET_CAMERA_TYPE_SUCCESS = 1 #  成功
SET_CAMERA_TYPE_FAIL = 2 #  失败
SET_CAMERA_TYPE_PROCESSING = 3 #  正在处理
# 9000 2.2
class NET_DVR_RECORD_TIME_SPAN_INQUIRY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byType", BYTE), # 0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_RECORD_TIME_SPAN_INQUIRY = POINTER(NET_DVR_RECORD_TIME_SPAN_INQUIRY)


class NET_DVR_RECORD_TIME_SPAN(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("strBeginTime", NET_DVR_TIME), # 开始时间
        ("strEndTime", NET_DVR_TIME), # 结束时间
        ("byType", BYTE), # 0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
        ("byRes", BYTE * 35), # 保留
    ]


LPNET_DVR_RECORD_TIME_SPAN = POINTER(NET_DVR_RECORD_TIME_SPAN)


class NET_DVR_DRAWFRAME_DISK_QUOTA_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byPicQuota", BYTE), # 图片百分比     [0%,  30%]
        ("byRecordQuota", BYTE), # 普通录像百分比 [20%, 40%]
        ("byDrawFrameRecordQuota", BYTE), # 抽帧录像百分比 [30%, 80%]
        ("byRes", BYTE * 61), # 保留字节
    ]


LPNET_DVR_DRAWFRAME_DISK_QUOTA_CFG = POINTER(NET_DVR_DRAWFRAME_DISK_QUOTA_CFG)


class NET_DVR_NAT_PORT(Structure):
    _fields_ = [
        ("wEnable", WORD), # 该端口是否使能映射
        ("wExtPort", WORD), # 映射的外部端口号
        ("byRes", BYTE * 12), # 保留
    ]


LPNET_DVR_NAT_PORT = POINTER(NET_DVR_NAT_PORT)


class NET_DVR_NAT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("wEnableUpnp", WORD), # UPNP功能是否启用
        ("wEnableNat", WORD), # UPNP端口映射（NAT）功能是否启用(保留，与wEnableUpnp保持一致)
        ("struIpAddr", NET_DVR_IPADDR), # NAT路由器LAN IP地址
        ("struHttpPort", NET_DVR_NAT_PORT), # web server http端口映射配置
        ("struCmdPort", NET_DVR_NAT_PORT), # 命令端口映射配置(8000)
        ("struRtspPort", NET_DVR_NAT_PORT), # rtsp端口映射配置
        ("byFriendName", BYTE * 64), # 服务名
        ("byNatType", BYTE), # UPNP端口映射类型，0-手动，1-自动
        ("byRes1", BYTE * 3), # 保留
        ("struHttpsPort", NET_DVR_NAT_PORT), # https端口映射配置
        ("struSDKOverTLSPort", NET_DVR_NAT_PORT), # SDKOverTLS端口映射配置
        ("struRtspsPort", NET_DVR_NAT_PORT), # Rtsps端口映射配置
        ("byres", BYTE * 44), # 保留
    ]


LPNET_DVR_NAT_CFG = POINTER(NET_DVR_NAT_CFG)


class NET_DVR_PLAYCOND(Structure):
    _fields_ = [
        ("dwChannel", DWORD),
        ("struStartTime", NET_DVR_TIME),
        ("struStopTime", NET_DVR_TIME),
        ("byDrawFrame", BYTE), # 0:不抽帧，1：抽帧
        ("byStreamType", BYTE), # 码流类型，0-主码流 1-子码流 2-码流三
        ("byStreamID", BYTE * STREAM_ID_LEN),
        ("byCourseFile", BYTE), # 课程文件0-否，1-是
        ("byDownload", BYTE), # 是否下载 0-否，1-是
        ("byOptimalStreamType", BYTE), # 是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
        ("byVODFileType", BYTE), #  下载录像文件，文件格式 0-PS码流格式，1-3GP格式
        ("byRes", BYTE * 26), # 保留
    ]


LPNET_DVR_PLAYCOND = POINTER(NET_DVR_PLAYCOND)


class NET_DVR_ATMFINDINFO(Structure):
    _fields_ = [
        ("byTransactionType", BYTE), # 交易类型 0-全部，1-查询， 2-取款， 3-存款， 4-修改密码，5-转账， 6-无卡查询 7-无卡存款， 8-吞钞 9-吞卡 10-自定义
        ("byRes", BYTE * 3), # 保留
        ("dwTransationAmount", DWORD), # 交易金额
    ]


LPNET_DVR_ATMFINDINFO = POINTER(NET_DVR_ATMFINDINFO)


class NET_DVR_SPECIAL_FINDINFO_UNION(Union):
    _fields_ = [
        ("byLenth", BYTE * 8),
        ("struATMFindInfo", NET_DVR_ATMFINDINFO), # ATM查询
    ]


LPNET_DVR_SPECIAL_FINDINFO_UNION = POINTER(NET_DVR_SPECIAL_FINDINFO_UNION)


class NET_DVR_FILECOND_V40(Structure):
    _fields_ = [
        ("lChannel", LONG),
        ("dwFileType", DWORD), # 不带卡号录象文件类型0xff-全部，0-定时录像，1-移动侦测，2-报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，
        # 7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件，15-越界侦测，16-区域入侵，17-声音异常，18-场景变更侦测，19-智能侦测（越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测），
        # 20-人脸侦测， 21-信号量，22-回传，23-回迁录像，24-遮挡，25-pos录像，26-进入区域侦测, 27-离开区域侦测,28-徘徊侦测,29-人员聚集侦测,30-快速运动侦测,31-停车侦测,32-物品遗留侦测,33-物品拿取侦测,
        # 34-火点侦测，35-防破坏检测，36-船只检测，37-测温预警,38-测温报警,39-打架斗殴报警，40-起身检测，41-瞌睡检测，42-温差报警，43-离线测温报警,44-防区报警，45-紧急求助,46-业务咨询,47-起身检测,48-折线攀高,49-如厕超时，50-奔跑检测，51-滞留检测，52-人脸抓拍, 53-非法摆摊, 54-目标识别,
        # 55-剧烈运动，56-离岗检测，57-起立，58-人数变化，59-违停, 60-逆行,61-压线,62-机占非,63-变道,64-掉头,65-行人检测,66-路障,67-抛洒物,68-浓雾检测,69-施工,70-拥堵,71-交通事故检测, 72-侧方停车，73-手动触发报警,74-交通违章，75-挖沙船检测报警 76-废气排放监测77-灰度报警
        #
        ("dwIsLocked", DWORD),
        ("dwUseCardNo", DWORD), # 是否带ATM信息进行查询：0-不带ATM信息，1-按交易卡号查询，2-按交易类型查询，3-按交易金额查询，4-按卡号、交易类型及交易金额的组合查询 5-按课程名称查找，此时卡号表示课程名称
        ("sCardNumber", BYTE * CARDNUM_LEN_OUT),
        ("struStartTime", NET_DVR_TIME),
        ("struStopTime", NET_DVR_TIME),
        ("byDrawFrame", BYTE), # 0:不抽帧，1：抽帧
        ("byFindType", BYTE), # 0:查询普通卷，1：查询存档卷
        ("byQuickSearch", BYTE), # 0:普通查询，1：快速（日历）查询
        ("bySpecialFindInfoType", BYTE), # 专有查询条件类型 0-无效， 1-带ATM查询条件
        ("dwVolumeNum", DWORD), # 存档卷号
        ("byWorkingDeviceGUID", BYTE * GUID_LEN), # 工作机GUID，通过获取N+1得到
        ("uSpecialFindInfo", NET_DVR_SPECIAL_FINDINFO_UNION), # 专有查询条件
        ("byStreamType", BYTE), # 0-同一个时间段只返回一种录像，优先级顺序为：主码流、子码流、三码流，1-子码流，2-三码流，3-主码流，254-双码流搜索(优先返回主码流录像，没有主码流录像时返回子码流录像)
        ("byAudioFile", BYTE), # 音频文件 0-非音频文件，1-音频文件
        ("byRes2", BYTE * 30), # 保留
    ]


LPNET_DVR_FILECOND_V40 = POINTER(NET_DVR_FILECOND_V40)


# 录像文件查找条件结构V50
class NET_DVR_FILECOND_V50(Structure):
    _fields_ = [
        ("struStreamID", NET_DVR_STREAM_INFO), # 流ID或通道号
        ("struStartTime", NET_DVR_TIME_SEARCH_COND), # 开始时间
        ("struStopTime", NET_DVR_TIME_SEARCH_COND), # 结束时间
        ("byFindType", BYTE), # 0-查询普通卷，1-查询存档卷 2-查询N+1录像文件
        ("byDrawFrame", BYTE), # 是否抽帧 0-不抽帧 1-抽帧
        ("byQuickSearch", BYTE), # 0-普通查询，1-快速（日历）查询
        ("byStreamType", BYTE), # 0-主码流，1-子码流，2-3码流，0xff-全部
        ("dwFileType", DWORD), #  文件类型
        ("dwVolumeNum", DWORD), # 存档卷号，byFindType为1时有效
        ("byIsLocked", BYTE), # 是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
        ("byNeedCard", BYTE), # 是否需要查询卡，0-不需要 1-需要
        ("byOnlyAudioFile", BYTE), # 音频文件 0-视频文件 1-音频文件
        ("bySpecialFindInfoType", BYTE), # 0-无效， 1-带ATM查询条件
        ("szCardNum", CHAR * 32), # 卡号，byNeedCard为1时有效
        ("szWorkingDeviceGUID", CHAR * 16), # 工作机GUID，通过获取N+1得到，byFindType为2时有效
        ("uSpecialFindInfo", NET_DVR_SPECIAL_FINDINFO_UNION), # 专有查询条件联合体
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_FILECOND_V50 = POINTER(NET_DVR_FILECOND_V50)


MAX_PRO_PATH = 256 # 最大协议路径长度
# B10能支持PSIA设备
# 循环上墙结构体（实时）
# 实时预览上墙结构体
class NET_DVR_MATRIX_TRUNKCFG(Structure):
    _fields_ = [
        ("dwGlobalIndex", DWORD), # 主键
        ("dwInterIndex", DWORD), # 本地全局编号
        ("sTrunkName", BYTE * NAME_LEN),
        ("byType", BYTE), # 设备类型1-bnc, 2-SP3, 3-V6
        ("byDir", BYTE), # 干线方向 1-输入2-输出
        ("byAbility", BYTE), # 干线能力，D1衡量
        ("bySubsys", BYTE), # 子系统ID
        ("byChan", BYTE), # 通道ID
        ("byRes", BYTE * 255), # 预留
    ]


LPNET_DVR_MATRIX_TRUNKCFG = POINTER(NET_DVR_MATRIX_TRUNKCFG)


class NET_DVR_DECSUBSYSTEMJIONSTATUS_V41(Structure):
    _fields_ = [
        ("byJoinStatus", BYTE), # 关联状态，0-没有关联，1-已经关联，通过其他字段判断被自己关联或被其他子系统关联，2-被占用，byDecodeAbility大于1时有效，3-被大屏主屏关联，4-被大屏子屏关联
        ("byJoinSubSystem", BYTE), #  所关联或占用的子系统槽位号
        ("byJoinDispNum", BYTE), #  所关联或占用的显示通道号
        ("byJoinSubWindowNum", BYTE), #  所关联或占用的子窗口号
        ("byDecodeAbility", BYTE), # 解码通道的当前解码能力，0-未关联，1-D1，2-720，3-1080
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_DECSUBSYSTEMJIONSTATUS_V41 = POINTER(NET_DVR_DECSUBSYSTEMJIONSTATUS_V41)


class NET_DVR_SINGLESUBSYSTEMJOININFO_V41(Structure):
    _fields_ = [
        # 子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）
        ("bySubSystemType", BYTE),
        ("byConnectStatus", BYTE), # 级联系统关联状态，1-连接正常，2-连接断开
        ("byMatrixNum", BYTE), # 级联视频综合平台号，子系统类型是3或4时可用
        ("bySubSystemNum", BYTE), # 级联子系统槽位号，子系统类型是3或4时可用
        ("struSubSystem", NET_DVR_DECSUBSYSTEMJIONSTATUS_V41 * MAX_DECODECHANNUM),
        ("byBindStatus", BYTE), # 绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
        ("bySlotNum", BYTE), # 槽位号，此参数只能获取
        ("byUsedTrunk", BYTE), # 是否被干线使用，0-未被使用，1-被使用
        ("byRes", BYTE * 65),
    ]


LPNET_DVR_SINGLESUBSYSTEMJOININFO_V41 = POINTER(NET_DVR_SINGLESUBSYSTEMJOININFO_V41)


class NET_DVR_ALLDECSUBSYSTEMJOININFO_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSingleSubSystemJoinInfo", NET_DVR_SINGLESUBSYSTEMJOININFO_V41 * MAX_SUBSYSTEM_NUM_V40),
        ("byRes", BYTE * 48),
    ]


LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41 = POINTER(NET_DVR_ALLDECSUBSYSTEMJOININFO_V41)


# # # # # 子系统配置# # # # # # /
MAX_ALARMHOSTKEYBOARD = 64 # 网络报警主机最大键盘数
class NET_DVR_PUBLIC_SUB_SYSTEM(Structure):
    _fields_ = [
        # 关联子系统号，按位表示，bit0表示该公共子系统关联子系统1.
        ("dwJointSubSystem", DWORD),
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_PUBLIC_SUB_SYSTEM = POINTER(NET_DVR_PUBLIC_SUB_SYSTEM)


class NET_DVR_NOAMAL_SUB_SYSTEM(Structure):
    _fields_ = [
        # 表示被哪些公共子系统关联，按位表示，bit0 表示，该子系统.被关联到公共子系统1
        ("dwBeJoinedSubSystem", DWORD),
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_NOAMAL_SUB_SYSTEM = POINTER(NET_DVR_NOAMAL_SUB_SYSTEM)


class NET_DVR_JOINT_SUB_SYSTEM(Union):
    _fields_ = [
        # byPublicAttributeEnable为0时使用该变量
        ("struNormalSubSystem", NET_DVR_NOAMAL_SUB_SYSTEM),
        # byPublicAttributeEnable为1时使用该变量
        ("struPublicSubSystem", NET_DVR_PUBLIC_SUB_SYSTEM),
        ("byRes", BYTE * 20),
    ]


LPNET_DVR_JOINT_SUB_SYSTEM = POINTER(NET_DVR_JOINT_SUB_SYSTEM)


MAX_SUBSYSTEM_ID_LEN = 16 # 子系统ID最大长度
# # # # # GPRS参数配置# # # # # # /
ACCOUNTNUM_LEN = 6
ACCOUNTNUM_LEN_32 = 32
ACCOUNTNUM_LEN_V40 = 9
APN_NAME_LEN = 32
APN_USERNAME_LEN = 24
APN_USERPASSWORD_LEN = 16
class NET_DVR_ALARMSUBSYSTEMPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wEnterDelay", WORD), # 进入延时,单位:秒, 范围：10-150 动环报警主机和自助行报警主机的延时时间在 NET_DVR_ALARMIN_PARAM 中的dwParam来设置延时时间
        # 具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
        ("wExitDelay", WORD), # 退出延时,单位:秒， 范围10-300
        ("byHostageReport", BYTE), # 挟持报告，0禁能 1使能
        ("bySubsystemEnable", BYTE), # 子系统使能
        ("byKeyToneOfArmOrDisarm", BYTE), #  成功发送布撤防报告是否键盘提示，0-键盘不提示 1-键盘输出提示音
        ("byKeyToneOfManualTestReport", BYTE), # 成功发送测试报告是否键盘提示，0-键盘不提示 1-键盘输出提示音
        ("wDelayTime", WORD), # 警号输出延时，当能力集中dwSupport1中的bit0位为1时，使用该参数设置警号输出时间。bit0为0时，使用NET_DVR_SIREN_PARAM中的wDelay参数设置警号输出时间
        ("byEnableAlarmInDelay", BYTE), # 0--不启用(使用子系统延时),1--启用(使用防区延时)，默认不启用
        ("byPublicAttributeEnable", BYTE), # 是否为公共子系统
        ("struJointSubSystem", NET_DVR_JOINT_SUB_SYSTEM),
        ("byKeyZoneArm", BYTE), # 是否支持钥匙防区对子系统进行布防操作
        ("byKeyZoneArmReport", BYTE), # 是否支持钥匙防区对子系统布防时发送布防报告
        ("byKeyZoneDisarm", BYTE), # 是否支持钥匙防区对子系统进行撤防操作
        ("byKeyZoneDisarmReport", BYTE), # 是否支持钥匙防区对子系统进行撤防操作时发送撤防报告
        ("bySubSystemID", BYTE * MAX_SUBSYSTEM_ID_LEN), # 子系统ID
        ("byKeyZoneArmReportEnable", BYTE), # 钥匙防区上传布防报告使能 0-禁能 1-使能
        ("byKeyZoneArmEnable", BYTE), # 钥匙防区使能， 0 -禁能 1-使能
        ("byOneKeySetupAlarmEnable", BYTE), # 一键布防使能
        ("bySingleZoneSetupAlarmEnable", BYTE), # 单防区布撤防使能
        ("byCenterType", BYTE), # 0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
        ("sCenterAccount", BYTE * ACCOUNTNUM_LEN), # 中心帐号
        ("sCenterAccountV40", BYTE * ACCOUNTNUM_LEN_32), # 中心账号V40,使用此字段时sCenterAccount无效
        ("byRes2", BYTE * 565), #  保留字节
    ]


LPNET_DVR_ALARMSUBSYSTEMPARAM = POINTER(NET_DVR_ALARMSUBSYSTEMPARAM)


class NET_DVR_REMIND_TIME(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用本次提醒 0-不启用，1-启用
        ("byHour", BYTE), # 0~24
        ("byMinute", BYTE), # 0~60
        ("bySecond", BYTE), # 0~60
    ]


LPNET_DVR_REMIND_TIME = POINTER(NET_DVR_REMIND_TIME)


# 子系统参数配置扩展
MAX_KEYBOARD_USER_NUM = 256
class NET_DVR_SUBSYSTEM_PARAM_EX(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布撤防时间
        ("byAlarmInAdvance", BYTE), #  布撤防提前提示时间0~45分
        ("byRes1", BYTE * 3),
        ("byJointAlarmIn", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 按位，表示子系统关联的报警输入通道号，0-不加入，1-加入
        ("byJointKeyboard", BYTE * MAX_ALARMHOSTKEYBOARD), # 按位，表示支持的键盘号，0-不加入，1-加入
        ("byJointOpetaterUser", BYTE * int(MAX_KEYBOARD_USER_NUM/8)), # 按位表示，bit0表示键盘操作用户1 ，0-不关联 1-关联
        ("struAlarmRemindTime", NET_DVR_REMIND_TIME * MAX_DAYS), # MAX_TIMESEGMENT_V30表示每天最多支持8个提醒
        ("byRes2", BYTE * 288), #  保留字节
    ]


LPNET_DVR_SUBSYSTEM_PARAM_EX = POINTER(NET_DVR_SUBSYSTEM_PARAM_EX)


class NET_DVR_ALARMHOST_PRINTER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPrinterEnable", BYTE), # 是否启用打印机
        ("byPrintTime", BYTE), # 是否打印时间
        ("byFaultDetect", BYTE), # 是否检测打印机故障
        ("byRes1", BYTE),
        ("dwAlarmInfo", DWORD), # 报警信息，按位表示。bit0-防区报警，bit1-防区报警恢复，bit2-紧急报警，bit-3挟持报警
        ("dwDeviceInfo", DWORD), # 设备信息，按位表示。bit0-交流电断电、bit1-交流电断电恢复，bit2-蓄电池欠压、bit3-蓄电池欠压恢复，bit4-电话线断线、bit5-电话线断线恢复，bit6-测试报告、bit7-防拆、bit8-防拆恢复、bit9-485设备掉线、bit10-485设备掉线恢复、bit11-无线网络异常、bit12-无线网络恢复正常、bit13-有线网络异常、bit14-有线网络恢复正常、bit15-扩展总线异常、bit17-扩展总线恢复正常、bit17-硬盘故障、bit18-硬盘故障恢复、bit19-键盘锁定
        ("dwOperateInfo", DWORD), # 操作信息，按位表示。bit0-布防、bit1-撤防、bit2-消警、bit3-旁路、bit4-旁路恢复、bit5-进入编程、bit6-退出编程、bit7-主机复位
        ("byRes2", BYTE * 256), #  保留字节
    ]


LPNET_DVR_ALARMHOST_PRINTER_CFG = POINTER(NET_DVR_ALARMHOST_PRINTER_CFG)


class NET_DVR_ALARMHOST_NETPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIP", NET_DVR_IPADDR),
        ("wPort", WORD),
        ("byAddressType", BYTE), # 0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
        ("byRes1", BYTE * 1),
        ("byDomainName", BYTE * MAX_DOMAIN_NAME), # 域名，GPRS参数配置、网络参数配置时该字段均有效
        ("byReportProtocol", BYTE), # 1-private 2-NAL2300, 3-Ehome
        ("byDevID", BYTE * ACCOUNTNUM_LEN_32), # 协议为NAL2300时有效
        ("byRes2", BYTE * 7), # GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
    ]


LPNET_DVR_ALARMHOST_NETPARAM = POINTER(NET_DVR_ALARMHOST_NETPARAM)


class NET_DVR_REGISTER_RS485CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("wDeviceProtocol", WORD), #  前端设备协议 通过获取协议列表获取
        ("byRes", BYTE * 2),
        ("dwBaudRate", DWORD), # 波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k
        ("byRes1", BYTE * 124), #  保留字节
    ]


LPNET_DVR_REGISTER_RS485CFG = POINTER(NET_DVR_REGISTER_RS485CFG)


class NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNetCenter", NET_DVR_ALARMHOST_NETPARAM * MAX_CENTERNUM), # 中心 GPRS网络相关参数的配置
        ("byAPNName", BYTE * APN_NAME_LEN),
        ("byAPNUserName", BYTE * APN_USERNAME_LEN),
        ("byAPNPassWord", BYTE * APN_USERPASSWORD_LEN),
        ("byReconnTime", BYTE), # 重连时间，连接失效后启用重连的时间，10秒为单位,取值范围1-30
        ("byOverTime", BYTE), # 超时时间，超过OverTime时间没有收到有效数据则重连，范围1-254，单位30秒
        ("byDetectLinkTime", BYTE), #     探测链路是否还保持，范围1-30，单位10s
        ("byRes1", BYTE),
        ("bySIMNum", BYTE * NAME_LEN), # SIM卡号（手机号）
        ("struSIMIP", NET_DVR_IPADDR), # 登陆网络后网络给分配的IP地址，只能获取
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG = POINTER(NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG)


# # # # # 网络参数配置# # # # # # /
class NET_DVR_ALARMHOST_NETCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNetCenter", NET_DVR_ALARMHOST_NETPARAM * MAX_CENTERNUM),
        ("byRes1", BYTE * 32),
    ]


LPNET_DVR_ALARMHOST_NETCFG = POINTER(NET_DVR_ALARMHOST_NETCFG)


# # # # # 积木上传方式# # # # # # /
MAX_REPORTCHAN_NUM = 4
MAX_CENTERGROUP_NUM = 16
class NET_DVR_ALARMHOST_REPORTCENTER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), # 是否启用
        ("byRes", BYTE * 3), # 保留1
        ("byChanAlarmMode", BYTE * MAX_REPORTCHAN_NUM), # 中心组报警通道， 1-T1、2-T2、 3-N1、 4-N2、5-G1、 6-G2
        ("byDealFailCenter", BYTE * MAX_CENTERGROUP_NUM), # 向指定中心组发送失败报告，用数组下标表示是哪个中心组，0-不选择、1-选择
        ("byDataType", BYTE), # 1-报警数据 2-非报警数据 3-所有数据
        ("byRes2", BYTE * 15), # 保留2
    ]


LPNET_DVR_ALARMHOST_REPORTCENTER_CFG = POINTER(NET_DVR_ALARMHOST_REPORTCENTER_CFG)


MAX_EVENT_NUM = 32 # 网络报警主机最大事件数
class NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), # 是否启用
        ("byDataType", BYTE), # 1-所有报警数据 2-所有非报警数据 3-所有数据，4-防区报警报告，5-非防区报警报告
        ("byRes", BYTE * 2), # 保留1
        ("byChanAlarmMode", BYTE * MAX_REPORTCHAN_NUM), # 中心组报警通道， 1-T1、2-T2、 3-N1、 4-N2、5-G1、 6-G2、7-N3、 8-N4(如果设备支持3G，G1，G2表示3G模块，如果不支持，表示GPRS模块，一款设备中3G模块和GPRS模块只会出现一种)
        ("byDealFailCenter", BYTE * MAX_CENTERGROUP_NUM), # 向指定中心组发送失败报告，用数组下标表示是哪个中心组，0-不选择、1-选择
        ("byZoneReport", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 防区报告类型，0-不上传，1-上传
        ("byNonZoneReport", BYTE * MAX_EVENT_NUM), # 非防区报警报告, 每一个元素表示一种事件类型，0-不上传，1-上传，byNonZoneReport[0]-软防区报告 byNonZoneReport[1]-系统状态报告 byNonZoneReport[2]-取消报告 byNonZoneReport[3]-测试报告 byNonZoneReport[4]-布防报告 byNonZoneReport[5]-撤防报告 byNonZoneReport[6]-挟持报告 byNonZoneReport[7]-报警恢复报告 byNonZoneReport[8]-旁路报告 byNonZoneReport[9]-旁路恢复报告。byNonZoneReport[10]-探测器连接状态报告（上线、离线）。byNonZoneReport[11]-探测器电量状态报告（电压正常、欠压）byNonZoneReport[12]-视频报警报告
        ("byAlarmNetCard", BYTE * MAX_REPORTCHAN_NUM), # 中心组报警网卡中心，0-主网卡中心1，1-主网卡中心2，2-扩展网卡中心1,3-扩展网卡中心2（报警通道为N1、N2、N3、N4时有效）
        ("byRes2", BYTE * 252), # 保留2
    ]


LPNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40 = POINTER(NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40)


# # # # # 防护舱状态上传# # # # # # /
class NET_DVR_ALARMHOST_SAFETYCABINSTATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnterButton", BYTE), # 进门按钮状态 0-不按下 1-按钮按下
        ("byExitButton", BYTE), # 出门按钮状态 0-不按下 1-按钮按下
        ("byDoorState", BYTE), # 门状态    0-门关闭 1-门打开
        ("byLockState", BYTE), # 锁状态 0-锁关    1-锁开
        ("byUrgencyButton", BYTE), # 紧急按钮状态    0-不按下 1-按钮按下
        ("byManState", BYTE), # 人状态     0-没人 1-有人
        ("byAbnormal", BYTE), # 异常状态  0-正常 1-异常(防护舱使用超时上传异常)
        ("byLightState", BYTE), # 灯光状态 0-关 ，1-开
        ("byFanState", BYTE), # 风扇状态 0-关，1-开
        ("byFollow", BYTE), # 尾随进入状态 0-无尾随，1-有尾随
        ("byFighting", BYTE), # 打斗状态 0-无打斗，1-有打斗
        ("byFaint", BYTE), # 晕倒状态 0-无晕倒，1-有人晕倒
        ("byManyPerson", BYTE), # 多人状态 0-无多人进舱，1-多人进舱
        ("byRes", BYTE * 59), # 保留
    ]


LPNET_DVR_ALARMHOST_SAFETYCABINSTATE = POINTER(NET_DVR_ALARMHOST_SAFETYCABINSTATE)


# # # # /警号输出口，警号状态上传# # # # # # /
class NET_DVR_ALARMHOST_ALARMOUTSTATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byName", BYTE * 32), # 报警输出口名称或警号名称
        ("byAlarmType", BYTE), # 1-报警输出口状态， 2-警号状态
        ("wChan", WORD), # 如果是报警输出口状态，该值的范围为0-511；如果是警号状态，范围1-8（防护舱只有1个警号输出）
        ("byAlarmStatus", BYTE), # 报警状态 0-无报警 1-有报警
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_ALARMHOST_ALARMOUTSTATUS = POINTER(NET_DVR_ALARMHOST_ALARMOUTSTATUS)


# # # # # 语音上传下载# # # # # # /
class NET_DVR_AUDIO_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAudioFormat", BYTE), # 音频格式，1-G711，2-G722
        ("byRes1", BYTE),
        ("wChannels", WORD), #  number of channels (i.e. mono, stereo...)
        ("dwSamplesPerSec", DWORD), # 采样率
        ("byRes2", BYTE * 20), # 保留
        ("dwAudioSize", DWORD), # 音频长度大小，压缩后的大小
    ]


LPNET_DVR_AUDIO_PARAM = POINTER(NET_DVR_AUDIO_PARAM)


# 预览V40接口
class NET_DVR_PREVIEWINFO(Structure):
    _fields_ = [
        ("lChannel", LONG), # 通道号
        ("dwStreamType", DWORD), #  码流类型，0-主码流，1-子码流，2-码流3，3-码流4, 4-码流5,5-码流6,7-码流7,8-码流8,9-码流9,10-码流10
        ("dwLinkMode", DWORD), #  0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP ,6- HRUDP（可靠传输） ,7-RTSP/HTTPS
        ("hPlayWnd", HWND), # 播放窗口的句柄,为NULL表示不播放图象
        ("bBlocked", DWORD), # 0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.
        ("bPassbackRecord", DWORD), # 0-不启用录像回传,1启用录像回传
        ("byPreviewMode", BYTE), # 预览模式，0-正常预览，1-延迟预览
        ("byStreamID", BYTE * STREAM_ID_LEN), # 流ID，lChannel为0xffffffff时启用此参数
        ("byProtoType", BYTE), # 应用层取流协议，0-私有协议，1-RTSP协议,2-SRTP码流加密（对应此结构体中dwLinkMode 字段，支持如下方式, 为1，表示udp传输方式，信令走TLS加密，码流走SRTP加密，为2，表示多播传输方式，信令走TLS加密，码流走SRTP加密）
        ("byRes1", BYTE),
        ("byVideoCodingType", BYTE), # 码流数据编解码类型 0-通用编码数据 1-热成像探测器产生的原始数据（温度数据的加密信息，通过去加密运算，将原始数据算出真实的温度值）
        ("dwDisplayBufNum", DWORD), # 播放库播放缓冲区最大缓冲帧数，范围1-50，置0时默认为1
        ("byNPQMode", BYTE), # NPQ是直连模式，还是过流媒体 0-直连 1-过流媒体
        ("byRecvMetaData", BYTE), # 是否接收metadata数据，设备是否支持该功能通过GET /ISAPI/System/capabilities 中DeviceCap.SysCap.isSupportMetadata是否存在且为true
        ("byRes", BYTE * 214),
    ]


LPNET_DVR_PREVIEWINFO = POINTER(NET_DVR_PREVIEWINFO)


# 中心智能设备取流
class NET_DVR_PREVIEWINFO_SPECIAL(Structure):
    _fields_ = [
        ("sURL", CHAR * 1024), # 取流URL，对应/ISAPI/SDT/Management/Region/ID返回的取流URL，部分设备返回的URL不合法，需要增加用户名密码节点，其中用户名和密码信息来自deviceUser和devicePassword节点
        # 示例：rtsp:admin:abcd12345@10.7.37.2:554/Streaming/Channels/101?transportmode=unicast
        ("dwLinkMode", DWORD), #  0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP
        ("hPlayWnd", HWND), # 播放窗口的句柄,为NULL表示不播放图象
        ("bBlocked", DWORD), # 0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.
        ("dwDisplayBufNum", DWORD), # 播放库播放缓冲区最大缓冲帧数，范围1-50，置0时默认为1
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PREVIEWINFO_SPECIAL = POINTER(NET_DVR_PREVIEWINFO_SPECIAL)


# 事件触发报警输出
class NET_DVR_TRIGGER_EVENT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwOverallEventTriggerAlarmoutOn", DWORD), # 全局事件触发报警输出开启，按位或，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常 ,bit5-硬盘故障, bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线 ，bit8- WIFI通信故障，bit9-RF信号干扰故障
        ("dwOverallEventTriggerAlarmoutOff", DWORD), # 全局事件触发报警输出开启，按位或，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常 ,bit5-硬盘故障, bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线 ，bit8- WIFI通信故障，bit9-RF信号干扰故障
        ("dwSubSystemEventTriggerAlarmoutOn", DWORD * MAX_ALARMHOST_SUBSYSTEM), # 子系统事件触发报警输出开启,dwSubSystemEvent[0]表示子系统1，dwSubSystemEvent[2]表示子系统2，具体的子系统个数从能力集获取（wSubSystem），每个子系统的事件按位表示，bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆,bit6-报警恢复,bit7-防区防拆,bit8-防区防拆恢复
        ("dwSubSystemEventTriggerAlarmoutOff", DWORD * MAX_ALARMHOST_SUBSYSTEM), # 子系统事件触发报警输出关闭,wSubSystemEvent[0]表示子系统1，dwSubSystemEvent[2]表示子系统2，具体的子系统个数从能力集获取（wSubSystem），每个子系统的事件按位表示，bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆,bit6-报警恢复,bit7-防区防拆,bit8-防区防拆恢复
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_TRIGGER_EVENT = POINTER(NET_DVR_TRIGGER_EVENT)


# 故障处理配置
class NET_DVR_ALARMHOST_FAULT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCheckFault", DWORD), # 是否检测故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，bit9- FPGA故障，bit10- 模拟量故障, bit11-防区扩展板异常，bit12-WIFI通信故障，bit13-RF信号干扰故障，具体支持的故障类型从能力集获取
        ("dwOverallFaultJointLED", DWORD), # 故障关联全局键盘指示灯输出 bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，具体支持的故障类型从能力集获取
        ("dwOverallFaultJointSound", DWORD), # 故障关联全局键盘声音输出 bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，具体支持的故障类型从能力集获取
        ("dwSubSystemFaultJointLED", DWORD * MAX_ALARMHOST_SUBSYSTEM), # 故障关联子系统键盘指示灯输出，dwSubSystemFaultJointLED[0]表示子系统1的关联信息。dwSubSystemFaultJointLED[0]的每一位表示一中故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常 dwSubSystemFaultJointLED[1]表示子系统2，以此类推
        ("dwSubSystemFaultJointSound", DWORD * MAX_ALARMHOST_SUBSYSTEM), # 故障关联子系统键盘声音输出（声音在键盘上输出）dwSubSystemFaultJointLED[0]表示子系统1的关联信息。dwSubSystemFaultJointSound [0]的每一位表示一中故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常 dwSubSystemFaultJointSound [1]表示子系统2，以此类推
        ("dwFaultJointFaultLight", DWORD), # 故障关联故障灯输出
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_ALARMHOST_FAULT_CFG = POINTER(NET_DVR_ALARMHOST_FAULT_CFG)


class NET_DVR_LIST_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIndex", BYTE), # 子系统号，0xff表示所有子系统
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_LIST_INFO = POINTER(NET_DVR_LIST_INFO)


CID_CODE_LEN = 4
DEV_SERIAL_LEN = 9
NET_DVR_DEFENCE_ALARM = 1
        # NET_DVR_VIDEO_ALARM,            视频报警
        # NET_DVR_VIRTUAL_DEFENCE_ALARM,    软防区报警
        # NET_DVR_HOSTAGE_ALARM,            挟持报警
        # NET_DVR_KNOCK_DOWN_ALARM,        防拆报警
        # NET_DVR_OPERATE_ALARM,            操作报告
        # NET_DVR_OHTER_ABNORMAL_ALARM    异常报告


CID_ENTER = 1000
CID_EXIT = 3000


CID_MEDICAL_ALARM = 100
CID_ALARM = 103
CID_FIRE_ALARM = 110
CID_ABDUCT_REPORT = 121
CID_SILENT_24 = 122
CID_AUDIO_24 = 123
CID_AUXILIARY_24 = 124
CID_SHOCK_24 = 125
CID_OVERTIME_ALARM = 126
CID_EMERGENCE_CALL_HELP = 129
CID_BURGLARY_ALARM = 130
CID_PERIMETER_ALARM = 131
CID_INNET_ALARM = 132
CID_ENTER_EXIT = 134
CID_DEVICE_OPEN = 137
CID_ZONE_BUS_BREAK = 141
CID_ZONE_BUS_SHORT = 142
CID_MOTION_ALARM = 148
CID_GAS_LEAKAGE = 151
CID_ZONE_EARLY_WARNING = 207
CID_AC_LOSS = 301
CID_LOW_BATT_VOL = 302
CID_DEV_RESET = 305
CID_MBUS_MODEL_FAULT = 333
CID_PRINTER_FAIL = 336
CID_LOW_EXPANDER_VOL = 338
CID_EXPANDER_OPEN = 341
CID_EXPANDER_AC_POWER_DOWN = 342
CID_WIRELESS_REPEATER_TAMPERED = 343
CID_WIRELESS_SIREN_TAMPERED = 344
CID_WIRELESS_SIREN_DISCONNECTED = 345
CID_LINE_LOSS = 354
CID_BUS_LOSS = 382
CID_DETECTOR_OPEN = 383
CID_ZONE_OPEN_CIRCUIT = 386
CID_ZONE_SHORT_CIRCUIT = 387
CID_GUARD = 401
CID_GUARD_AUTO = 403
CID_CANCEL_ARM = 406
CID_GUARD_IMME = 408
CID_KEY_ZONE_GUARD = 409
CID_GUARD_STAY = 441
CID_FORCED_ARM = 442
CID_AUTOCTRL_TRIG = 443
CID_ONETOUCH_AWAY_ARMING = 444
CID_ONETOUCH_STAY_ARMING = 445
CID_CARD_ARMING_OR_DISARMING = 446
CID_LATE_TO_DISARM = 452
CID_AUTOGUARD_FAIL = 455
CID_AOPEN_TRIG_FAIL = 460
CID_ACLOSE_TRIG_FAIL = 461
CID_AUTOUNGUARD_FAIL = 462
CID_BYPASS = 570
CID_GROUP_BYPASS = 574
CID_MANUAL_TEST_RPT = 601
CID_AUTO_TEST_RPT = 602
CID_PHONE_CONNET_TEST = 617
CID_ENTER_PROG = 627
CID_EXIT_PROG = 628
CID_FIELD_DETECTION = 759
CID_LINE_DETECTION = 773
CID_PIR_ALARM = 774
CID_SOUND_INTENSITY_RISE = 775
CID_SOUND_INTENSITY_DROP = 776
CID_AUDIO_INPUT_EXCEPTION = 777
CID_SOFT_INSTAND = 810
CID_SOFT_FIRE = 811
CID_SOFT_MOBS = 812
CID_KEYPAD_LOCKED = 862
CID_ABSENCE_ALARM = 863
CID_KEY_FAIL = 910
CID_TRIGGER_FAIL = 911
CID_GPK_FAIL = 912
CID_MODULE_FAIL = 913
CID_WIRELESS_DETECTOR_FAIL = 914
CID_WIRELESS_DETECTOR_BATTERY_LOW = 915
CID_EXPANDER_DISCONNECT = 916
CID_WIRELESS_REPEATER_DISCONNECT = 917
CID_RADAR_TRANS_FAULT = 918
CID_WIRELESS_SIREN_LOW_BATTERY = 919
CID_WRIE_LESS_NET = 920
CID_SIM_FAULT = 921
CID_WIFI_ABNORMAL = 922
CID_RF_ABNORMAL = 923
CID_DATE_TRAFFIC_OVERFLOW = 924
CID_IPADDR_CONFLICT = 930
CID_ETHERNET_BROKEN = 931
CID_GROUP_OUT_RP = 932
CID_GROUP_IN_RP = 933
CID_MOTION_DECTECT = 940
CID_MASK_ALARM = 941
CID_VI_LOST = 942
CID_VS_MISMATCH = 943
CID_VI_EXCEPTION = 944
CID_HD_FULL = 945
CID_HD_ERROR = 946
CID_PIC_SEND_FAILED = 947
CID_KEY_LOCKED = 948
CID_NETWORK_CAMERA_DISCONNECT = 949
CID_DUTY_CHECKING = 960
CID_POST_RESPONSE = 961
CID_ZONE_BUS_SEARCH = 970
CID_ZONE_BUS_REGIST = 971
CID_GUARD_DELAY_OP = 972
CID_GUARD_SINGLE = 973
CID_SINGLE_ZONE_CLEARED = 974
CID_ZONE_ASSOCIATED_DETECTOR = 975
CID_ZONE_CONSULTING = 976
CID_EXPANDER_DELETED = 977
CID_WIRELESS_REPEATER_DELETED = 978
CID_WIRELESS_SIREN_DELETED = 979


CID_TYPE_MEDICAL_ALARM = 1100
CID_TYPE_MEDICAL_ALARM_RESET = 3100
CID_TYPE_ALARM = 1103
CID_TYPE_ALARM_RESET = 3103
CID_TYPE_FIRE_ALARM = 1110
CID_TYPE_FIRE_ALARM_RESET = 3110
CID_TYPE_ABDUCT_REPORT = 1121
CID_TYPE_SILENT_24 = 1122
CID_TYPE_SILENT_24_RESET = 3122
CID_TYPE_AUDIO_24 = 1123
CID_TYPE_AUDIO_24_RESET = 3123
CID_TYPE_AUXILIARY_24 = 1124
CID_TYPE_AUXILIARY_24_RESET = 3124
CID_TYPE_SHOCK_24 = 1125
CID_TYPE_SHOCK_24_RESET = 3125
CID_TYPE_TIMEOUT = 1126
CID_TYPE_TIMEOUT_RESET = 3126
CID_TYPE_EMERGENCE_CALL_HELP = 1129
CID_TYPE_EMERGENCE_CALL_HELP_RESET = 3129
CID_TYPE_BURGLARY_ALARM = 1130
CID_TYPE_BURGLARY_ALARM_RESET = 3130
CID_TYPE_PERIMETER_ALARM = 1131
CID_TYPE_PERIMETER_ALARM_RESET = 3131
CID_TYPE_INNET_ALARM = 1132
CID_TYPE_INNET_ALARM_RESET = 3132
CID_TYPE_ENTER_EXIT = 1134
CID_TYPE_ENTER_EXIT_RESET = 3134
CID_TYPE_DEVICE_OPEN = 1137
CID_TYPE_DEVICE_OPEN_RESET = 3137
CID_TYPE_ZONE_BUS_BREAK = 1141
CID_TYPE_ZONE_BUS_BREAK_RESET = 3141
CID_TYPE_ZONE_BUS_SHORT = 1142
CID_TYPE_ZONE_BUS_SHORT_RESET = 3142
CID_TYPE_MOTION_ALARM = 1148
CID_TYPE_MOTION_ALARM_RESET = 3148
CID_TYPE_GAS_LEAKAGE_ALARM = 1151
CID_TYPE_GAS_LEAKAGE_ALARM_RESET = 3151
CID_TYPE_ZONE_EARLY_WARNING = 1207
CID_TYPE_ZONE_EARLY_WARNING_RESET = 3207
CID_TYPE_AC_LOSS = 1301
CID_TYPE_AC_LOSS_RESET = 3301
CID_TYPE_LOW_BATT_VOL = 1302
CID_TYPE_LOW_BATT_VOL_NORMAL = 3302
CID_TYPE_DEV_RESET = 1305
CID_TYPE_MBUS_MODEL_FAULT = 1333
CID_TYPE_MBUS_MODEL_RESET = 3333
CID_TYPE_PRINTER_OFF = 1336
CID_TYPE_PRINTER_ON = 3336
CID_TYPE_EXTEND_MODULE_VOL_LOW = 1338
CID_TYPE_EXTEND_MODULE_VOL_NORMAL = 3338
CID_TYPE_EXTEND_MODULE_REMOVE = 1341
CID_TYPE_EXTEND_MODULE_RECOVER = 3341
CID_TYPE_EXTEND_MODULE_AC_LOSS = 1342
CID_TYPE_EXTEND_MODULE_AC_LOSS_RESET = 3342
CID_TYPE_WIRELESS_REPEATER_TAMPER = 1343
CID_TYPE_WIRELESS_REPEATER_RESTORE = 3343
CID_TYPE_WIRELESS_SIREN_TAMPER = 1344
CID_TYPE_WIRELESS_SIREN_RESTORE = 3344
CID_TYPE_WIRELESS_SIREN_DISCONNECT = 1345
CID_TYPE_WIRELESS_SIREN_CONNECT = 3345
CID_TYPE_LINE_LOSS = 1354
CID_TYPE_LINE_LOSS_RESET = 3354
CID_TYPE_BUS_LOSS = 1382
CID_TYPE_BUS_LOSS_RESET = 3382
CID_TYPE_SENSOR_TAMPER = 1383
CID_TYPE_SENSOR_TAMPER_RESET = 3383
CID_TYPE_ZONE_OPEN_CIRCUIT_ALARM = 1386
CID_TYPE_ZONE_SHORT_CIRCUIT_ALARM = 1387
CID_TYPE_DISARM = 1401
CID_TYPE_ARM = 3401
CID_TYPE_DISARM_AUTO = 1403
CID_TYPE_ARM_AUTO = 3403
CID_TYPE_CANCEL_ARM = 1406
CID_TYPE_ARM_IMME = 3408
CID_TYPE_KEY_ZONE_ARM = 1409
CID_TYPE_KEY_ZONE_DISARM = 3409
CID_TYPE_GUARD_STAY = 3441
CID_TYPE_FORCED_ARM = 3442
CID_TYPE_AUTOCTRL_TRIG_ON = 1443
CID_TYPE_AUTOCTRL_TRIG_OFF = 3443
CID_TYPE_LATE_TO_DISARM = 1452
CID_TYPE_AUTOGUARD_FAIL = 1455
CID_TYPE_AOPEN_TRIG_FAIL = 1460
CID_TYPE_ACLOSE_TRIG_FAIL = 1461
CID_TYPE_AUTOUNGUARD_FAIL = 1462
CID_TYPE_BYPASS = 1570
CID_TYPE_BYPASS_RESET = 3570
CID_TYPE_GROUP_BYPASS = 1574
CID_TYPE_GROUP_BYPASS_RESET = 3574
CID_TYPE_MANUAL_TEST_RPT = 1601
CID_TYPE_AUTO_TEST_RPT = 1602
CID_TYPE_LINE_TEST = 1617
CID_TYPE_ENTER_PROG = 1627
CID_TYPE_EXIT_PROG = 1628
CID_TYPE_FIELD_DETECTION = 1759
CID_TYPE_FIELD_DETECTION_RESET = 3759
CID_TYPE_LINE_DETECTION = 1773
CID_TYPE_LINE_DETECTION_RESET = 3773
CID_TYPE_PIR_ALARM = 1774
CID_TYPE_PIR_ALARM_RESET = 3774
CID_TYPE_SOUND_INTENSITY_RISE = 1775
CID_TYPE_SOUND_INTENSITY_RISE_RESET = 3775
CID_TYPE_SOUND_INTENSITY_DROP = 1776
CID_TYPE_SOUND_INTENSITY_DROP_RESET = 3776
CID_TYPE_AUDIO_INPUT_EXCEPTION = 1777
CID_TYPE_AUDIO_INPUT_EXCEPTION_RESET = 3777
CID_TYPE_SOFT_INSTAND = 1810
CID_TYPE_SOFT_FIRE = 1811
CID_TYPE_SOFT_MOBS = 1812
CID_TYPE_KEYPAD_LOCK = 1862
CID_TYPE_KEYPAD_UNLOCK = 3862
CID_TYPE_ABSENCE_ALARM = 1863
CID_TYPE_KEY_FAIL = 1910
CID_TYPE_KEY_RESET = 3910
CID_TYPE_TRIGGER_FAIL = 1911
CID_TYPE_TRIGGER_RESET = 3911
CID_TYPE_GPK_FAIL = 1912
CID_TYPE_GPK_RESET = 3912
CID_TYPE_MODULE_FAIL = 1913
CID_TYPE_MODULE_RESET = 3913
CID_TYPE_WIRELESS_DETECTOR_FAIL = 1914
CID_TYPE_WIRELESS_DETECTOR_RESET = 3914
CID_TYPE_WIRELESS_DETECTOR_BATTERY_LOW = 1915
CID_TYPE_WIRELESS_DETECTOR_BATTERY_NORMAL = 3915
CID_TYPE_EXTEND_MODULE_LOSS = 1916
CID_TYPE_EXTEND_MODULE_LOSS_RESET = 3916
CID_TYPE_WIRELESS_REPEATER_DISCONNECT = 1917
CID_TYPE_WIRELESS_REPEATER_CONNECT = 3917
CID_TYPE_RADAR_TRANS_FAULT = 1918
CID_TYPE_RADAR_TRANS_RESET = 3918
CID_TYPE_WRIELESS_SIREN_LOW_BATTERY = 1919
CID_TYPE_NORMAL_WRIELESS_SIREN_BATTERY = 3919
CID_TYPE_WRIELESS_NET_FAULT = 1920
CID_TYPE_WRIELESS_NET_RESET = 3920
CID_TYPE_SIM_FAULT = 1921
CID_TYPE_SIM_RESET = 3921
CID_TYPE_WIFI_ABNORMAL = 1922
CID_TYPE_WIFI_NORMAL = 3922
CID_TYPE_RF_ABNORMAL = 1923
CID_TYPE_RF_NORMAL = 3923
CID_TYPE_DATE_TRAFFIC_OVERFLOW = 1924
CID_TYPE_IPADDR_CONFLICT = 1930
CID_TYPE_IPADDR_NORMAL = 3930
CID_TYPE_ETHERNET_BROKEN = 1931
CID_TYPE_ETHERNET_NORMAL = 3931
CID_TYPE_MOTION_DECTECT_START = 1940
CID_TYPE_MOTION_DECTECT_STOP = 3940
CID_TYPE_MASK_ALARM_START = 1941
CID_TYPE_MASK_ALARM_STOP = 3941
CID_TYPE_VI_LOST_START = 1942
CID_TYPE_VI_LOST_STOP = 3942
CID_TYPE_VS_MISMATCH = 1943
CID_TYPE_VS_MATCH = 3943
CID_TYPE_VI_EXCEPTION = 1944
CID_TYPE_VI_NORMAL = 3944
CID_TYPE_HD_FULL = 1945
CID_TYPE_HD_FREE = 3945
CID_TYPE_HD_ERROR = 1946
CID_TYPE_HD_RESET = 3946
CID_TYPE_PIC_SEND_FAILED = 1947
CID_TYPE_SENDING_EMAIL_FAILED = 1948
CID_TYPE_NETWORK_CAMERA_DISCONNECT = 1949
CID_TYPE_NETWORK_CAMERA_CONNECT = 3949
CID_TYPE_DUTY_CHECKING = 1960
CID_TYPE_POST_RESPONSE = 1961
CID_TYPE_ZONE_BUS_SEARCH = 1970
CID_TYPE_ZONE_BUS_REGIST = 1971
CID_TYPE_GUARD_SINGLE_ARM = 1973
CID_TYPE_GUARD_SINGLE_DISARM = 3973
CID_TYPE_SINGLE_ZONE_ALARM_CLEARED = 1974
CID_TYPE_ZONE_ASSOCIATED_DETECTOR_DEL = 1975
CID_TYPE_ZONE_ASSOCIATED_DETECTOR_ADD = 3975
CID_TYPE_ZONE_CONSULT = 1976
CID_TYPE_ZONE_CONSULT_STOP = 3976
CID_TYPE_EXTEND_MODULE_DEL = 1977
CID_TYPE_EXTEND_MODULE_ADD = 3977
CID_TYPE_WIRELESS_REPEATER_DEL = 1978
CID_TYPE_WIRELESS_REPEATER_ADD = 3978
CID_TYPE_WIRELESS_SIREN_DEL = 1979
CID_TYPE_WIRELESS_SIREN_ADD = 3979


class NET_DVR_CID_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sCIDCode", BYTE * CID_CODE_LEN), # CID事件号
        ("sCIDDescribe", BYTE * NAME_LEN), # CID事件名
        ("struTriggerTime", NET_DVR_TIME_EX), # 触发报警的时间点
        ("struUploadTime", NET_DVR_TIME_EX), # 上传报警的时间点
        ("sCenterAccount", BYTE * ACCOUNTNUM_LEN), # 中心帐号
        ("byReportType", BYTE), # 见定义NET_DVR_ALARMHOST_REPORT_TYPE
        ("byUserType", BYTE), # 用户类型，0-网络用户 1-键盘用户,2-手机用户,3-系统用户
        ("sUserName", BYTE * NAME_LEN), # 网络用户用户名
        ("wKeyUserNo", WORD), # 键盘用户号    0xFFFF表示无效
        ("byKeypadNo", BYTE), # 键盘号        0xFF表示无效
        ("bySubSysNo", BYTE), # 子系统号        0xFF表示无效
        ("wDefenceNo", WORD), # 防区号        0xFFFF表示无效
        ("byVideoChanNo", BYTE), # 视频通道号   0表示无效，表示设备自带的默认视频通道号
        ("byDiskNo", BYTE), # 硬盘号        0xFF表示无效
        ("wModuleAddr", WORD), # 模块地址        0xFFFF表示无效
        ("byCenterType", BYTE), # 0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
        ("byRelativeChannel", BYTE), # 外接的视频通道号，0表示无效，字节表示通道号
        ("sCenterAccountV40", BYTE * ACCOUNTNUM_LEN_32), # 中心账号V40,使用此字段时sCenterAccount无效
        ("byDevSerialNo", BYTE * DEV_SERIAL_LEN), # 产品序列号
        ("byRepeaterNo", BYTE), # 中继器号，为0无效
        ("wRemoteCtrllerUserNo", WORD), # 遥控器用户号，为0无效
        ("dwIOTChannelNo", DWORD), # IOT通道号
        ("standardCIDcode", BYTE), # 标准CID码
        ("byRes2", BYTE * 11),
    ]


LPNET_DVR_CID_ALARM = POINTER(NET_DVR_CID_ALARM)


class NET_DVR_ALARMHOST_MODULE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byModuleType", BYTE), # 1-防区，2-触发器 3-防区触发器
        ("byZoneType", BYTE), # 防区类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区，6-单防区触发器，0xff表示该参数无效
        ("byTriggerType", BYTE), # 触发器类型，1-本地触发器， 2-4路触发器，3-8路触发器，4-单防区触发器，0xff表示该参数无效
        ("byRes1", BYTE * 1),
        ("sModelInfo", CHAR * MODULE_INFO_LEN), # 模块信息
        ("sDeviceVersionInfo", CHAR * VERSION_INFO_LEN), #  版本信息
        ("byRes", BYTE * 188),
    ]


LPNET_DVR_ALARMHOST_MODULE_CFG = POINTER(NET_DVR_ALARMHOST_MODULE_CFG)


MAX_DECODE_CARD_SUPPORTDISPNUMS = 8 # 每个解码卡最多支持的显示通道数
MAX_SUPPORT_RES = 32
class NET_DVR_DECCARD_ABILITY_V41(Structure):
    _fields_ = [
        ("byCardType", BYTE), # 解码卡类型(0:MD,1:MD+,2:HD)
        ("byDecNums", BYTE), # 解码通道数
        ("byDispNums", BYTE), # 显示通道数
        ("byDecStartIdx", BYTE), # 首个解码通道在所有解码通道中的索引
        ("byDispStartIdx", BYTE), # 首个显示通道在所有显示通道中的索引
        ("byRes1", BYTE * 3),
        ("dwVgaSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持的分辨率
        ("dwHdmiSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持的分辨率
        ("dwDviSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持的分辨率
        ("dwYpbprSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持的分辨率
        ("byDispFormat", BYTE * MAX_DECODE_CARD_SUPPORTDISPNUMS), # 支持的输出模式(按HD_DISPLAY_FORMAT中的枚举)
        ("byWindowMode", BYTE * MAX_DECODE_CARD_SUPPORTDISPNUMS), # 支持的窗口模式(比如1,2,4,9,16))
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_DECCARD_ABILITY_V41 = POINTER(NET_DVR_DECCARD_ABILITY_V41)


MAX_DECODE_CARD_NUM = 6 # 最多高清解码卡数
class NET_DVR_DECODESVR_ABILITY_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byCardNums", BYTE), #  解码卡数
        ("byStartChan", BYTE), #  起始通道号
        ("byRes1", BYTE * 2),
        ("struDecCardAbility", NET_DVR_DECCARD_ABILITY_V41 * MAX_DECODE_CARD_NUM),
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_DECODESVR_ABILITY_V41 = POINTER(NET_DVR_DECODESVR_ABILITY_V41)


#  流录像状态
class NET_DVR_STREAM_RECORD_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRecord", BYTE), # (只读)录像类型, 0：不在录像，1：在录像 2-空闲
        # 3-无连接 4-无输入视频 5-未加载 6-存档中
        # 7-回传中 8-用户名或密码错 9-未验证
        # 10-存档中和录像中 11-录像回传中和录像中12-token认证失败
        # 13-当前条件不满足录像计划条件 14-通道接入异常（见通道状态） 15-硬盘满
        # 16-硬盘错 17-无硬盘
        ("byOffLineRecord", BYTE), # 断网录像功能 0-关闭 1-开启
        ("byRes1", BYTE * 2), # 保留字节
        ("dwRelatedHD", DWORD), # 关联磁盘
        ("byRes2", BYTE * 8), # 保留字节
    ]


LPNET_DVR_STREAM_RECORD_STATUS = POINTER(NET_DVR_STREAM_RECORD_STATUS)


CHAN_NO_LEN = 24
class NET_DVR_DIRECT_CONNECT_CHAN_INFO(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用
        ("byProType", BYTE), # 协议类型，0-私有协议(default), (需要从设备获取能力)
        ("byZeroChan", BYTE), # 是否是零通道,0-不是，1-是
        ("byPriority", BYTE), # 优先级
        ("sUserName", BYTE * NAME_LEN), # 用户名
        ("sPassword", BYTE * PASSWD_LEN), # 密码
        ("byDomain", BYTE * MAX_DOMAIN_NAME), # 设备域名
        ("struIP", NET_DVR_IPADDR), # IP地址
        ("wDVRPort", WORD), # 端口号
        ("byStreamType", BYTE), # 主码流:0 子码流：1
        ("byOnline", BYTE), # 只读，0-不在线 1-在线
        ("dwChannel", DWORD), # 通道号
        ("byTransProtocol", BYTE), # 协议类型，0-TCP，1-UDP，2-多播
        ("byLocalBackUp", BYTE), # 本地备份: 0-不启用CVR本地备份，1-启用CVR本地备份--即回放时的流一份在录像卷，一份在存档卷（本地备份）
        ("wDirectLastTime", WORD), # 导播持续时间
        ("byChanNo", BYTE * CHAN_NO_LEN), # 通道编号--用于VAG取流
    ]


LPNET_DVR_DIRECT_CONNECT_CHAN_INFO = POINTER(NET_DVR_DIRECT_CONNECT_CHAN_INFO)


class NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用
        ("byProType", BYTE), # 协议类型，0-私有协议(default), 1-松下协议，2-索尼, 3-大华 (需要从设备获取能力)
        ("byZeroChan", BYTE), # 是否是零通道,0-不是，1-是
        ("byRes1", BYTE), # 保留字段，置0
        ("sUserName", BYTE * NAME_LEN), # 用户名
        ("sPassword", BYTE * PASSWD_LEN), # 密码
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # 前端IP或者域名,需要设备 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
        ("wDVRPort", WORD), # 端口号
        ("byStreamType", BYTE), # 主码流:0 子码流：1
        ("byOnline", BYTE), # 只读，0-不在线 1-在线
        ("dwChannel", DWORD), # 通道号
        ("byTransProtocol", BYTE), # 传输协议类型，0-TCP，1-UDP 2-多播
        ("byLocalBackUp", BYTE), # 本地备份，0-不启用CVR本地备份，1-启用CVR本地备份--即录像时的流一份在录像卷，一份在存档卷（本地备份）
        ("byRes2", BYTE * 2), # 保留字段，置0
        ("byVAGChanNo", BYTE * MAX_VAG_CHANNO_LEN), # 协议类型为VAG时，对应的VAG通道编号
        ("byRes", BYTE * 340),
    ]


LPNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40 = POINTER(NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40)


class NET_DVR_PU_STREAM_URL_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byRes", BYTE * 3),
        ("byStreamMediaIP", BYTE * 64), # 流媒体IP
        ("wStreamMediaPort", WORD), # 流媒体端口
        ("byTransmitType", BYTE), # 流媒体传输协议 0- TCP  1- UDP
        ("byRes1", BYTE * 33),
        ("byDevIP", BYTE * 64), # 设备IP
        ("wDevPort", WORD), # 设备端口
        ("byChannel", BYTE), # 通道号
        ("byTransMode", BYTE), # 传输模式 0-主码流 1- 子码流
        ("byProType", BYTE),
        # 厂家类型 0-私有 1-大华 2-汉邦 3-郎驰 4-蓝色星际 NET_DVR_GetIPCProtoList接口获取
        # VQD流媒体下只支持 0，1方式；直连支持 0，1，2，3，4
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP,  1-UDP,  2-多播方式,  3-RTP
        ("byRes3", BYTE * 2),
        ("sUserName", BYTE * NAME_LEN), # 设备登陆用户名
        ("sPassWord", BYTE * PASSWD_LEN), #  设备登陆密码
        ("byRes2", BYTE * 28), # 预留
    ]


LPNET_DVR_PU_STREAM_URL_CFG = POINTER(NET_DVR_PU_STREAM_URL_CFG)


class NET_DVR_PU_STREAM_URL_CFG_V40(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byRes", BYTE * 3),
        ("byStreamMediaIP", BYTE * 64), # 流媒体IP
        ("wStreamMediaPort", WORD), # 流媒体端口
        ("byTransmitType", BYTE), # 流媒体传输协议 0- TCP  1- UDP
        ("byRes1", BYTE),
        ("byDevIP", BYTE * 64), # 设备IP
        ("wDevPort", WORD), # 设备端口
        ("byChannel", BYTE), # 通道号
        ("byTransMode", BYTE), # 传输模式 0-主码流 1- 子码流
        ("byProType", BYTE),
        # 厂家类型 0-海康 1-大华 2-汉邦 3-郎驰 4-蓝色星际 NET_DVR_GetIPCProtoList接口获取
        # VQD流媒体下只支持 0，1方式；直连支持 0，1，2，3，4
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP,  1-UDP  2-多播方式
        ("byRes3", BYTE * 2),
        ("sUserName", BYTE * NAME_LEN), # 设备登陆用户名
        ("sPassWord", BYTE * PASSWD_LEN), #  设备登陆密码
        ("byRes2", BYTE * 308), # 预留
    ]


LPNET_DVR_PU_STREAM_URL_CFG_V40 = POINTER(NET_DVR_PU_STREAM_URL_CFG_V40)


class NET_DVR_STREAM_URL_V40(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byStreamType", BYTE), # 主子码流
        ("byLocalBackUp", BYTE), # 是否本地备份
        ("byRes", BYTE),
        ("strURL", BYTE * URL_LEN_V40), # 流媒体URL，可以级联
        ("dwProtocalType", DWORD), # IPC协议类型值，可以通过获取IPC协议列表得到
        ("sUserName", BYTE * NAME_LEN), # 设备登陆用户名
        ("sPassWord", BYTE * PASSWD_LEN), #  设备登陆密码
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # 流来源IP或者域名,需要解析 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
        ("wIPPort", WORD), # 流来源对应的端口号
        ("wChanNo", WORD), # 流来源设备IP通道号
        ("byVAGChanNo", BYTE * MAX_VAG_CHANNO_LEN), # 流来源通道编号,用于VAG功能
        ("byRes1", BYTE * 88),
    ]


LPNET_DVR_STREAM_URL_V40 = POINTER(NET_DVR_STREAM_URL_V40)


class NET_DVR_STREAM_TYPE_UNION(Union):
    _fields_ = [
        ("struChanInfo", NET_DVR_DIRECT_CONNECT_CHAN_INFO), # IP通道信息  类型值为0
        ("struStreamUrl", NET_DVR_PU_STREAM_URL), # 通过流媒体到url取流，类型值为4
        ("struStreamUrlCfg", NET_DVR_PU_STREAM_URL_CFG), # 通过流媒体到指定监控设备上取流，类型值为6
    ]


LPNET_DVR_STREAM_TYPE_UNION = POINTER(NET_DVR_STREAM_TYPE_UNION)


class NET_DVR_STREAM_TYPE_V40_UNION(Union):
    _fields_ = [
        ("struChanInfo", NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40), # IP通道信息，类型值为0
        ("struPuStreamUrl", NET_DVR_PU_STREAM_URL), # 通过流媒体到url取流，类型值为4
        ("struStreamUrlCfg", NET_DVR_PU_STREAM_URL_CFG_V40), # 通过流媒体到组合url取流，类型值为6
        ("struRtspCfg", NET_DVR_RTSP_PROTOCAL_CFG), # 由标准RTSP接入取流 类型值7
        ("struStreamUrlV40", NET_DVR_STREAM_URL_V40), # 通过流媒体（支持级联方式）向流来源取流，类型值为8
    ]


LPNET_DVR_STREAM_TYPE_V40_UNION = POINTER(NET_DVR_STREAM_TYPE_V40_UNION)


class NET_DVR_STREAM_MODE_TYPE(Structure):
    _fields_ = [
        ("byGetStreamType", BYTE), # 取流方式，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流, 3.通过IPServer找到设备，再通过流媒体去设备的流 4-通过流媒体由URL去取流
        ("byRes", BYTE * 3), #  保留字节
        ("uGetStream", NET_DVR_STREAM_TYPE_UNION), #  不同取流方式结构体
    ]


LPNET_DVR_STREAM_MODE_TYPE = POINTER(NET_DVR_STREAM_MODE_TYPE)


#  流来源信息
class NET_DVR_STREAM_SRC_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamSrcInfo", NET_DVR_STREAM_MODE_TYPE),
    ]


LPNET_DVR_STREAM_SRC_INFO = POINTER(NET_DVR_STREAM_SRC_INFO)


class NET_DVR_STREAM_SRC_INFO_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byGetStreamType", BYTE), # 取流方式，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流, 3.通过IPServer找到设备，再通过流媒体去设备的流 4-通过流媒体由URL去取流 6-通过流媒体到指定监控设备上取流
        ("byRes1", BYTE * 3), #  保留字节
        ("uGetStream", NET_DVR_STREAM_TYPE_V40_UNION), #  不同取流方式结构体
        ("byMonitorName", BYTE * 128), # 监控点名称（支持中文，大小写字母，数字，下划线等非特殊字符，编码格式根据登录返回的byCharEncodeType字段判断，
        # 目前CVR中英文版本不一样，有不同选择，中文CVR要求监控点名称为gbk，英文版本CVR要求监控点名称为iso8859-1，如“海康A号楼_监控点1”）
        ("byRes", BYTE * 384), #  保留字节
    ]


LPNET_DVR_STREAM_SRC_INFO_V40 = POINTER(NET_DVR_STREAM_SRC_INFO_V40)


#  流录像信息
#  按流ID对时间段加锁
class NET_DVR_STREAM_TIME_LOCK(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("strBeginTime", NET_DVR_TIME), #  开始时间
        ("strEndTime", NET_DVR_TIME), #  结束时间
        ("struStreamInfo", NET_DVR_STREAM_INFO), #  流信息
        ("dwRecordType", DWORD), #  录像类型:  0xffffffff－全部，－定时录像，-移动侦测，－报警触发，-报警触发或移动侦测，-报警触发和移动侦测，-命令触发，-手动录像，-智能录像(同文件查找)
        ("dwLockDuration", DWORD), #  锁定持续时间,单位秒，0xffffffff表示永久锁定
        ("strUnlockTimePoint", NET_DVR_TIME_EX), #  加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效,0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45，+表示东区, byISO8601为1时有效
        ("byRes", BYTE * 1),
    ]


LPNET_DVR_STREAM_TIME_LOCK = POINTER(NET_DVR_STREAM_TIME_LOCK)


# 回放抽帧接口 开始抽帧命令 NET_DVR_START_DRAWFRAME，对应的控制结构体
class NET_DVR_VOD_DRAWFRAME_PARA(Structure):
    _fields_ = [
        ("struTime", NET_DVR_TIME_EX),
        #
        # dwDrawType只有设备支持选择性抽帧时，参数才有效果，抽帧方式有：
        # 0：只传I帧
        # 1：丢1/2 P帧（只有svc码流支持）
        # 2：丢3/4P帧 （只有svc码流支持）
        # 3：传1/2 I帧(只传I帧，且每2个I帧传一个。)
        # 4：传1/4 I振(只传I帧，且每4个I帧传一个。)
        # 5：传1/8 I帧(只传I帧，且每8个I帧传一个。)
        #
        ("dwDrawType", DWORD),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_VOD_DRAWFRAME_PARA = POINTER(NET_DVR_VOD_DRAWFRAME_PARA)


#  按ID+时间回放结构体
class NET_DVR_VOD_PARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIDInfo", NET_DVR_STREAM_INFO),
        ("struBeginTime", NET_DVR_TIME),
        ("struEndTime", NET_DVR_TIME),
        ("hWnd", HWND),
        ("byDrawFrame", BYTE), # 0:不抽帧，1：抽帧
        ("byVolumeType", BYTE), # 0-普通录像卷  1-存档卷
        ("byVolumeNum", BYTE), # 卷号，目前指存档卷号
        ("byStreamType", BYTE), # 码流类型 0-主码流， 1-子码流，2-码流三
        ("dwFileIndex", DWORD), # 存档卷上的录像文件索引，搜索存档卷录像时返回的值
        ("byAudioFile", BYTE), # 音频文件0-否，1-是
        ("byCourseFile", BYTE), # 课程文件0-否，1-是
        ("byDownload", BYTE), # 是否下载 0-否，1-是
        ("byOptimalStreamType", BYTE), # 是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
        ("byRes2", BYTE * 20),
    ]


LPNET_DVR_VOD_PARA = POINTER(NET_DVR_VOD_PARA)


class NET_DVR_VOD_PARA_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIDInfo", NET_DVR_STREAM_INFO),
        ("struBeginTime", NET_DVR_TIME_V50),
        ("struEndTime", NET_DVR_TIME_V50),
        ("hWnd", HWND),
        ("byDrawFrame", BYTE), # 0:不抽帧，1：抽帧
        ("byVolumeType", BYTE), # 0-普通录像卷  1-存档卷
        ("byVolumeNum", BYTE), # 卷号，目前指存档卷号
        ("byStreamType", BYTE), # 码流类型 0-主码流， 1-子码流，2-码流三
        ("dwFileIndex", DWORD), # 存档卷上的录像文件索引，搜索存档卷录像时返回的值
        ("byAudioFile", BYTE), # 回放音频文件，0-不回放音频文件，1-仅回放音频文件
        ("byCourseFile", BYTE), # 回放课程文件0-否，1-是
        ("byPlayMode", BYTE), # 播放方式0-正放，1-倒放
        ("byLinkMode", BYTE), # 连接方式0-TCP，1-AdaptiveUDP
        ("byDownload", BYTE), # 是否下载 0-否，1-是
        ("byOptimalStreamType", BYTE), # 是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
        ("byDisplayBufNum", BYTE), # 设置播放缓冲帧数，当为0时，默认为3帧，hWnd不为空时有效
        ("byNPQMode", BYTE), # NPQ是直连模式，还是过流媒体 0-直连 1-过流媒体
        ("sUserName", BYTE * NAME_LEN), # 二次认证用户名
        ("sPassword", BYTE * PASSWD_LEN), # 二次认证密码
        ("byRemoteFile", BYTE), # 回放远程文件0-否，1-是
        ("byRes2", BYTE * 203),
        ("pSavedFileName", CHARP), # 下载时，保存的录像文件路径，byDownload为1时有效，长度超过256将会被截断
    ]


LPNET_DVR_VOD_PARA_V50 = POINTER(NET_DVR_VOD_PARA_V50)


#  手动录像
class NET_DVR_MANUAL_RECORD_PARA(Structure):
    _fields_ = [
        ("struStreamInfo", NET_DVR_STREAM_INFO),
        ("lRecordType", DWORD),
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_MANUAL_RECORD_PARA = POINTER(NET_DVR_MANUAL_RECORD_PARA)


#  CABAC码流压缩性能选项，开启可提高20%，只有模拟通道可以用
class NET_DVR_STREAM_CABAC(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byCabacEnable", BYTE), # 码流压缩性能选项值0 不提升 1 提升
        ("byRes1", BYTE * 31), # 保留
    ]


LPNET_DVR_STREAM_CABAC = POINTER(NET_DVR_STREAM_CABAC)


MAX_IOSPEED_GROUP_NUM = 4 # IO测速组个数
MAX_IOOUT_NUM = 4 # 最大IO输出口个数
MAX_IOIN_NUM = 8 # 最大IO输入口个数
MAX_RELAY_NUM = 12 # 继电器控制设备最大数 2013-11-04
MAX_VEHICLE_TYPE_NUM = 8 # 车辆信息管控最大数2013-11-04
MAX_IOIN_NUMEX = 10 # 最大IO输入口个数(扩展)
MAX_ITC_LANE_NUM = 6 # 最大车道个数
MAX_LANEAREA_NUM = 2 # 单车道最大区域个数
ITC_MAX_POLYGON_POINT_NUM = 20 # 检测区域最多支持20个点的多边形
MAX_ITC_SERIALCHECK_NUM = 8 # 串口校验类型个数
MAX_LIGHT_NUM = 6 # 最大交通灯数
MAX_VIDEO_INTERVAL_NUM = 2 # 最大抓拍间隔数
MAX_VIDEO_DETECT_LIGHT_NUM = 12 # 视频检测的最大检测区域
MAX_CALIB_RECOG_NUM = 2 # 标定区域个数
MAX_RS485_NUM = 12 # 485口最大支持数
MAX_MOBILE_POLYGON_NUM = 3 # 移动布控支持最大牌识区域个数
MAX_MOBILE_DETECTLINE_NUM = 3 # 移动布控支持最大违规检测线个数
MAX_IOOUT_K_NUM = 8 # K系列最大IO输出口个数
# IO输出口参数（3.1版本（含）之后）
class NET_ITC_IOOUT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDefaultStatus", BYTE), # IO默认状态：0-低电平，1-高电平
        ("byIOOutStatus", BYTE), # IO起效时状态：0-低电平，1-高电平，2-脉冲
        ("byMode", BYTE), # 闪光灯工作方式,按位表示，0-表示工作，1-表示不工作，bit0-视频，bit1-卡口，bit2-违章
        ("byIOWorkMode", BYTE), # IO输出口工作模式：0-闪光灯，1-偏振镜,  2-常亮灯
        ("dwTimeDelay", DWORD), # IO有效持续时间，单位us
        ("wAheadTime", WORD), # 输出IO提前时间，单位us
        ("byFreqMulti", BYTE), # 倍频，数值范围[1,15]
        ("byDutyRate", BYTE), # 占空比，[0,40%]
        ("byDetectBrightness", BYTE), # 自动检测亮度使能闪光灯0-不检测；1-检测
        ("byBrightnessThreld", BYTE), # 使能闪光灯亮度阈值，范围[0,100],高于阈值闪
        ("byFlashLightEnable", BYTE), # 设置闪光灯时间使能:0-关1-开
        ("byStartHour", BYTE), # 开始时间-小时,取值范围0-23
        ("byStartMinute", BYTE), # 开始时间-分,取值范围0-59
        ("byEndHour", BYTE), # 结束时间-小时,取值范围0-23
        ("byEndMinute", BYTE), # 结束时间-分,取值范围0-59
        ("byAutoPlateBrightness", BYTE), #  车牌亮度自动使能闪光灯 0-不启用 1-启用
        ("byIncrBrightEnable", BYTE), # 是否启用增亮模式（常亮灯模式下）
        ("byIncrBrightPercent", BYTE), # 增量百分比，0~100%（启用增亮模式下生效）
        ("wIncrBrightTime", WORD), # 增亮时间,单位为毫秒（启用增亮模式下生效）
        ("byBrightness", BYTE), # 亮度值；0~100（常亮灯模式下）
        ("byEnvironBright", BYTE), # 环境照度值；0~100（闪光灯模式下生效，该参数只读）环境照度值代表着闪光灯所处环境的亮度值，客户可以拿该值作为参考，去配置相应的亮度阈值。
        ("wDelayCaptureTime", WORD), # 延时抓拍时间1~1000ms（启用增亮模式下生效）
    ]


LPNET_ITC_IOOUT_PARAM = POINTER(NET_ITC_IOOUT_PARAM)


ITC_POST_IOSPEED_TYPE = 0x1
ITC_POST_SINGLEIO_TYPE = 0x2
ITC_POST_RS485_TYPE = 0x4
ITC_POST_RS485_RADAR_TYPE = 0x8
ITC_POST_VIRTUALCOIL_TYPE = 0x10
ITC_POST_HVT_TYPE_V50 = 0x20
ITC_POST_MPR_TYPE = 0x40
ITC_POST_PRS_TYPE = 0x80
ITC_EPOLICE_IO_TRAFFICLIGHTS_TYPE = 0x100
ITC_EPOLICE_RS485_TYPE = 0x200
ITC_POST_HVT_TYPE = 0x400
ITC_PE_RS485_TYPE = 0x10000
ITC_VIDEO_EPOLICE_TYPE = 0x20000
ITC_VIA_VIRTUALCOIL_TYPE = 0x40000
ITC_POST_IMT_TYPE = 0x80000
IPC_POST_HVT_TYPE = 0x100000
ITC_POST_MOBILE_TYPE = 0x200000
ITC_REDLIGHT_PEDESTRIAN_TYPE = 0x400000
ITC_NOCOMITY_PEDESTRIAN_TYPE = 0x800000


# 能力集接口的输出参数，对应pOutBuf参数
class NET_ITC_TRIGGERMODE_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTriggerType", DWORD), # 触发类型，按位表示，定义ITC_TRIGGERMODE_ABILITY定义，根据输入的能力类型不同，此处返回的触发类型也不同
        ("byRes", BYTE * 16),
    ]


LPNET_ITC_TRIGGERMODE_ABILITY = POINTER(NET_ITC_TRIGGERMODE_ABILITY)


class NET_ITC_INTERVAL_PARAM(Structure):
    _fields_ = [
        ("byIntervalType", BYTE), # 间隔类型（默认按时间），0-时间起效,1-距离起效
        ("byRes1", BYTE * 3),
        ("wInterval", WORD * MAX_INTERVAL_NUM), # 连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
        ("byRes", BYTE * 8),
    ]


LPNET_ITC_INTERVAL_PARAM = POINTER(NET_ITC_INTERVAL_PARAM)


# 牌识参数
class NET_ITC_PLATE_RECOG_PARAM(Structure):
    _fields_ = [
        ("byDefaultCHN", BYTE * MAX_CHJC_NUM), # 设备运行省份的汉字简写
        ("byEnable", BYTE), # 是否启用该区域牌识，0-否，1-是
        ("dwRecogMode", DWORD),
        # 识别的类型，
        # bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别)
        # bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别
        # bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别
        # bit3-农用车识别：0-不采用农用车识别，1-农用车识别
        # bit4-模糊识别：0-不采用模糊识别，1-模糊识别
        # bit5-帧定位或场定位：0-帧定位，1-场定位
        # bit6-帧识别或场识别：0-帧识别，1-场识别
        # bit7-晚上或白天：0-白天，1-晚上
        # bit8-摩托车识别：0-不采用摩托车识别，1-摩托车识别
        # bit9-场景模式：0-电警/多帧，1-卡口
        # bit10-微小车牌：0-不启用，1-启用微小车牌识别(像素60～80)
        # bit11-安全带检测：0-不启用，1-启用安全带检测
        # bit12-民航车牌识别: 0-不启用，1-开启民航车牌识别
        # bit13-车牌过渡倾斜处理: 0-不启用，1-开启过渡倾斜处理（PRS）
        # bit14-超大车牌识别: 0-不启用，1-开启超大车牌识别（PRS）
        # bit15-遮阳板检测：0-不启用，1-启用遮阳板检测
        # bit16-黄标车检测：0-不启用，1-启用黄标车检测
        # bit17-危险品车辆检测：0-不启用，1-启用危险品车辆检测
        # bit18-使馆车牌识别：0-不启用，1-启用使馆车牌识别
        # bit19-车辆子品牌识别：0-不启用，1-启用车辆子品牌识别
        # bit20-打电话识别：0-不启用，1-启用
        # bit21-车窗悬挂物识别：0-不启用，1-启用
        #
        ("byVehicleLogoRecog", BYTE), # 车标识别 0-不启用，1-启用
        #
        # 0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，8-贵，9-琼，10-冀，11-豫，
        # 12-黑，13-鄂，14-湘，15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，22-鲁，
        # 23-晋，24-陕，25-沪，26-川，27-台，28-津，29-藏，30-港，31-新，32-云，33-浙，
        # 34-皖，0xff-全部
        #
        ("byProvince", BYTE), # 省份索引值
        ("byRegion", BYTE), #  区域索引值 0-保留，1-欧洲，2-俄语区域, 3-欧洲&俄罗斯(EU&CIS),4-中东(Middle East)
        ("byCountry", BYTE), # 国家索引，参照枚举COUNTRY_INDEX(不支持“COUNTRY_ALL = 0xff,ALL 全部”)
        ("wPlatePixelWidthMin", WORD), # 车牌像素识别宽度最小值（单位是像素）当前推荐范围[130,500]
        ("wPlatePixelWidthMax", WORD), # 车牌像素识别宽度最大值（单位是像素）当前推荐范围[130,500]
        ("byRes", BYTE * 24),
    ]


LPNET_ITC_PLATE_RECOG_PARAM = POINTER(NET_ITC_PLATE_RECOG_PARAM)


# 多边型结构体
class NET_ITC_POLYGON(Structure):
    _fields_ = [
        ("dwPointNum", DWORD), # 有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域
        ("struPos", NET_VCA_POINT * ITC_MAX_POLYGON_POINT_NUM), # 多边形边界点,最多20个
    ]


LPNET_ITC_POLYGON = POINTER(NET_ITC_POLYGON)


class uRegion(Union):
    _fields_ = [
        ("struRect", NET_VCA_RECT), # 矩形区域
        ("struPolygon", NET_ITC_POLYGON), # 多边形区域
    ]

class NET_ITC_PLATE_RECOG_REGION_PARAM(Structure):
    _fields_ = [
        ("byMode", BYTE), # 区域类型，0-矩形，1-多边形
        ("byRes1", BYTE * 3),
        ("uRegion", uRegion),
        ("byRes", BYTE * 16), # 保留
    ]


LPNET_ITC_PLATE_RECOG_REGION_PARAM = POINTER(NET_ITC_PLATE_RECOG_REGION_PARAM)


# 单组IO测速参数
class NET_ITC_SINGLE_IOSPEED_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("byTrigCoil1", BYTE), # 第一线圈关联IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
        ("byCoil1IOStatus", BYTE), # 第一线圈IO输入口状态，0-下降沿（默认），1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
        ("byTrigCoil2", BYTE), # 第二线圈关联IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
        ("byCoil2IOStatus", BYTE), # 第二线圈IO输入口状态，0-下降沿（默认），1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
        ("byRelatedDriveWay", BYTE), # 关联的车道号
        ("byTimeOut", BYTE), # 超时时间（默认10），单位s
        ("byRelatedIOOutEx", BYTE), # 第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
        ("dwDistance", DWORD), # 线圈距离（默认1000）,单位：厘米
        ("byCapSpeed", BYTE), # 起拍速度（默认30），单位km/h
        ("bySpeedLimit", BYTE), # 限速值（默认60），单位km/h
        ("bySpeedCapEn", BYTE), # 是否启用超速抓拍，0-否，1-是
        ("bySnapTimes1", BYTE), # 线圈1抓拍次数（默认不抓拍），0-不抓拍，非0-连拍次数，最大5次
        ("bySnapTimes2", BYTE), # 线圈2抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5次
        ("byBigCarSpeedLimit", BYTE), # 大车车速限制值
        ("byBigCarSignSpeed", BYTE), # 标志限速(大车)，单位km/h(3.7Ver)
        ("byIntervalType", BYTE), # 间隔类型（默认按时间），0-时间起效,1-距离起效
        ("wInterval1", WORD * MAX_INTERVAL_NUM), # 线圈1连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
        ("wInterval2", WORD * MAX_INTERVAL_NUM), # 线圈2连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
        ("byRelatedIOOut", BYTE * MAX_IOOUT_NUM), # 关联的IO输出口(可以同时关联多个)，数组0表示IO输出口1，数组1表示IO输出口2，以此类推，0-不关联，1-关联
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("byLaneType", BYTE), # 车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
        ("byCarSignSpeed", BYTE), # 标志限速，单位km/h(3.7Ver)
        ("byUseageType", BYTE), # 车道用途类型，详见ITC_LANE_USEAGE_TYPE
        ("struPlateRecog", NET_ITC_PLATE_RECOG_REGION_PARAM * MAX_LANEAREA_NUM), # 牌识参数(可用牌识区域1个，保留一个)
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byLowSpeedLimit", BYTE), # 小车限底速值，单位km/h
        ("byBigCarLowSpeedLimit", BYTE), # 大车限底速值，单位km/h
        ("byLowSpeedCapEn", BYTE), # 是否启用低速抓拍，0-否，1-是
        ("byEmergencyCapEn", BYTE), # 是否启用应急车道抓拍，0-否，1-是
        ("byRes", BYTE * 27),
    ]


LPNET_ITC_SINGLE_IOSPEED_PARAM = POINTER(NET_ITC_SINGLE_IOSPEED_PARAM)


# 卡口IO测速参数
class NET_ITC_POST_IOSPEED_PARAM(Structure):
    _fields_ = [
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struSingleIOSpeed", NET_ITC_SINGLE_IOSPEED_PARAM * MAX_IOSPEED_GROUP_NUM), # 单个IO测速组参数
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_POST_IOSPEED_PARAM = POINTER(NET_ITC_POST_IOSPEED_PARAM)


# 单IO参数
class NET_ITC_SINGLEIO_PARAM(Structure):
    _fields_ = [
        ("byDefaultStatus", BYTE), # IO触发默认状态：0-低电平，1-高电平
        ("byRelatedDriveWay", BYTE), # 关联的车道号
        ("bySnapTimes", BYTE), # 抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
        ("byRelatedIOOutEx", BYTE), # 第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
        ("struInterval", NET_ITC_INTERVAL_PARAM), # 抓拍间隔参数
        ("byRelatedIOOut", BYTE * MAX_IOOUT_NUM), # 关联的IO输出口，可以同时关联多个
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("byEnable", BYTE), # 单IO使能标志0-不启用，1-启用 (Remark:在能力返回支持 bySupport&0x20，表示是否支持单IO触发界面IO使能配置 时生效)
        ("byUseageType", BYTE), # 车道用途类型，详见ITC_LANE_USEAGE_TYPE
        ("byEmergencyCapEn", BYTE), # 是否启用应急车道抓拍，0-否，1-是
        ("struPlateRecog", NET_ITC_PLATE_RECOG_REGION_PARAM * MAX_LANEAREA_NUM), # 牌识参数
        ("byRes", BYTE * 24),
    ]


LPNET_ITC_SINGLEIO_PARAM = POINTER(NET_ITC_SINGLEIO_PARAM)


# 单IO触发参数
class NET_ITC_POST_SINGLEIO_PARAM(Structure):
    _fields_ = [
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struSingleIO", NET_ITC_SINGLEIO_PARAM * MAX_IOIN_NUMEX), # 单个IO触发参数
    ]


LPNET_ITC_POST_SINGLEIO_PARAM = POINTER(NET_ITC_POST_SINGLEIO_PARAM)


class NET_ITC_LANE_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该车道，0-不启用，1-启用
        ("byRelatedDriveWay", BYTE), # 关联的车道号
        ("wDistance", WORD), # 线圈距离，计算速度
        ("wTrigDelayTime", WORD), # 触发延迟时间（默认200），单位：毫秒
        ("byTrigDelayDistance", BYTE), # 触发延迟距离（默认0），单位：分米
        ("bySpeedCapEn", BYTE), # 是否启用超速抓拍，0-否，1-是
        ("bySignSpeed", BYTE), # 标志限速，单位km/h
        ("bySpeedLimit", BYTE), # 限速值，单位km/h
        ("bySnapTimes", BYTE), # 抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
        ("byOverlayDriveWay", BYTE), # OSD叠加的车道号
        ("struInterval", NET_ITC_INTERVAL_PARAM), # 抓拍间隔参数
        ("byRelatedIOOut", BYTE * MAX_IOOUT_NUM), # 关联的IO输出口，可以同时关联多个
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("byCartSignSpeed", BYTE), # 标志限速(大车)，单位km/h
        ("byCartSpeedLimit", BYTE), # 限速值（大车），单位km/h
        ("byRelatedIOOutEx", BYTE), # 第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
        ("struPlateRecog", NET_ITC_PLATE_RECOG_REGION_PARAM * MAX_LANEAREA_NUM), # 车道牌识参数
        ("byLaneType", BYTE), # 车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
        ("byUseageType", BYTE), # 车道用途类型，详见ITC_LANE_USEAGE_TYPE
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byLowSpeedLimit", BYTE), # 小车限底速值，单位km/h
        ("byBigCarLowSpeedLimit", BYTE), # 大车限底速值，单位km/h
        ("byLowSpeedCapEn", BYTE), # 是否启用低速抓拍，0-否，1-是
        ("byEmergencyCapEn", BYTE), # 是否启用应急车道抓拍，0-否，1-是
        ("byRes", BYTE * 9),
    ]


LPNET_ITC_LANE_PARAM = POINTER(NET_ITC_LANE_PARAM)


# 卡口RS485车检器触发参数
class NET_ITC_POST_RS485_PARAM(Structure):
    _fields_ = [
        ("byRelatedLaneNum", BYTE), # 关联的车道个数
        ("byTriggerSpareMode", BYTE), # 触发备用模式，0-默认，1-卡口虚拟线圈模式,2-卡口混合车道模式
        ("byFaultToleranceTime", BYTE), # 容错时间(单位:分钟)，用于检测车检器是否正常的最大时间
        ("byRes1", BYTE),
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struLane", NET_ITC_LANE_PARAM * MAX_ITC_LANE_NUM), # 关联的车道参数
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_POST_RS485_PARAM = POINTER(NET_ITC_POST_RS485_PARAM)


class NET_ITC_RADAR_PARAM(Structure):
    _fields_ = [
        ("byRadarType", BYTE), # 雷达类型，0-无雷达,1-安道雷雷达，2-奥利维亚，3-川速微波4,雷达接IO扩展盒(此参数在卡口虚拟线圈、混行卡口界面中使用，卡口RS485雷达不使用),0xff-其它类型
        ("byLevelAngle", BYTE), # 与水平线所成角度,默认为25°(0到90度)
        ("wRadarSensitivity", WORD), # 雷达灵敏度
        ("wRadarSpeedValidTime", WORD), # 雷达速度有效时间(0~2000] ,0表示不支持
        ("byRes1", BYTE * 2),
        ("fLineCorrectParam", DOUBLE), # 线性矫正参数[0.0~2.0]
        ("iConstCorrectParam", INT), # 常量矫正参数[-100~100]
        ("byRes2", BYTE * 8),
    ]


LPNET_ITC_RADAR_PARAM = POINTER(NET_ITC_RADAR_PARAM)


class NET_ITC_RS485_ACCESS_INFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("dwTriggerModeType", DWORD),
        ("byAssociateRS485No", BYTE), # 关联的RS485号 1～5 (唯一值)
        # BYTE  byModeType; 0～预留，1～雷达，2～车检器，3～信号灯检测器
        ("byRes", BYTE * 15),
    ]


LPNET_ITC_RS485_ACCESS_INFO_COND = POINTER(NET_ITC_RS485_ACCESS_INFO_COND)


class NET_ITC_RADAR_INFO_PARAM(Structure):
    _fields_ = [
        ("struRadarParam", NET_ITC_RADAR_PARAM), # 24
        ("byAssociateLaneNo", BYTE), # 关联的车道号1～99 (这个值可以在不同RS485口重复)
        ("byRes", BYTE * 103),
    ]


LPNET_ITC_RADAR_INFO_PARAM = POINTER(NET_ITC_RADAR_INFO_PARAM)


class NET_ITC_ACCESS_DEVINFO_PARAM_UNION(Union):
    _fields_ = [
        ("uLen", BYTE * 128),
        ("struRadarInfoParam", NET_ITC_RADAR_INFO_PARAM), # 雷达参数配置
    ]


LPNET_ITC_ACCESS_DEVINFO_PARAM_UNION = POINTER(NET_ITC_ACCESS_DEVINFO_PARAM_UNION)


class NET_ITC_RS485_ACCESS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byModeType", BYTE), # 0～预留，bit1～雷达，bit2～车检器，bit3～信号灯检测器
        ("byRes", BYTE * 3),
        ("uITCAccessDevinfoParam", NET_ITC_ACCESS_DEVINFO_PARAM_UNION), # 64
        ("byRes1", BYTE * 12),
    ]


LPNET_ITC_RS485_ACCESS_CFG = POINTER(NET_ITC_RS485_ACCESS_CFG)


# 2013-07-09 雷达关联车道扩展
class NET_ITC_RS485_ACCESS_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRadar", NET_ITC_RADAR_PARAM * MAX_ITC_LANE_NUM), # 多车道雷达信息
        # 根据能力集开发显示，不支持的默认为0，不显示  （有几个车道支持几个）
        ("byRes", BYTE * 20),
    ]


LPNET_ITC_RS485_ACCESS_INFO = POINTER(NET_ITC_RS485_ACCESS_INFO)


# 卡口RS485雷达触发参数
class NET_ITC_POST_RS485_RADAR_PARAM(Structure):
    _fields_ = [
        ("byRelatedLaneNum", BYTE), # 关联的车道个数
        ("byRes1", BYTE * 3),
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struLane", NET_ITC_LANE_PARAM * MAX_ITC_LANE_NUM), # 关联的车道参数
        ("struRadar", NET_ITC_RADAR_PARAM), # 雷达参数
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_POST_RS485_RADAR_PARAM = POINTER(NET_ITC_POST_RS485_RADAR_PARAM)


class NET_ITC_VTLANE_PARAM(Structure):
    _fields_ = [
        ("byRelatedDriveWay", BYTE), # 关联的车道号
        ("bySpeedCapEn", BYTE), # 是否启用超速抓拍，0-否，1-是
        ("bySignSpeed", BYTE), # 标志限速，单位km/h
        ("bySpeedLimit", BYTE), # 限速值，单位km/h
        ("bySnapTimes", BYTE), # 抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
        ("byBigCarSignSpeed", BYTE), # 大车标志限速，单位km/h
        ("byBigCarSpeedLimit", BYTE), # 大车限速值，单位km/h
        ("byRelatedIOOutEx", BYTE), # 第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
        ("struInterval", NET_ITC_INTERVAL_PARAM), # 抓拍间隔参数
        ("byRelatedIOOut", BYTE * MAX_IOOUT_NUM), # 关联的IO输出口，可以同时关联多个
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("byLowSpeedLimit", BYTE), # 限低速，单位km/h
        ("byBigCarLowSpeedLimit", BYTE), # 大车限低速，单位km/h
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("struPlateRecog", NET_ITC_PLATE_RECOG_REGION_PARAM * MAX_LANEAREA_NUM), # 车道牌识参数
        ("struLine", NET_VCA_LINE), # 车道线
    ]


LPNET_ITC_VTLANE_PARAM = POINTER(NET_ITC_VTLANE_PARAM)


class NET_ITC_VTCOIL_INFO(Structure):
    _fields_ = [
        ("struLaneRect", NET_VCA_RECT), # 虚拟线圈区域
        ("byTrigFlag", BYTE), # 触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发
        ("byTrigSensitive", BYTE), # 触发灵敏度，1-100
        ("byRelatedIOOut", BYTE * MAX_IOOUT_NUM), # 关联的IO输出口(可以同时关联多个)，数组0表示IO输出口1，数组1表示IO输出口2，以此类推，0-不关联，1-关联
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("byLaneType", BYTE), # 车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
        ("byEnableRadar", BYTE), # 是否启用雷达测速，0-否，1-是
        ("struLane", NET_ITC_VTLANE_PARAM), # 关联的车道参数
        # 车道用途类型，详见ITC_LANE_USEAGE_TYPE，使用1和8两种类型(3.7Ver)
        ("byUseageType", BYTE),
        # 车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT(3.7Ver)
        ("byCarDriveDirect", BYTE),
        ("byRes", BYTE * 30),
    ]


LPNET_ITC_VTCOIL_INFO = POINTER(NET_ITC_VTCOIL_INFO)


# 卡口虚拟线圈触发参数
class NET_ITC_POST_VTCOIL_PARAM(Structure):
    _fields_ = [
        ("byRelatedLaneNum", BYTE), # 关联的车道个数
        ("byIsDisplay", BYTE), # 视频中是否显示虚拟线圈，0-不显示，1-显示
        ("byLoopPos", BYTE), # 晚间触发线圈的偏向（默认10）
        ("byPolarLenType", BYTE), # 偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。
        ("byDayAuxLightMode", BYTE), # 白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明
        ("byVideoLaneNO", BYTE), # 视频参考亮度的参考车道号
        ("byVideoLowTh", BYTE), # 视频参考亮度低阈值初始化值（默认40）
        ("byVideoHighTh", BYTE), # 视频参考亮度高阈值初始化值（默认55）
        ("byRecordMode", BYTE), # 录像标志：0-不录像，1-录像
        ("bySnapMode", BYTE), # 抓拍模式：0-频闪模式；1-爆闪模式
        # 测速方式：0-不测速，0x1-雷达测速，0x2-视频测速
        ("bySpeedDetector", BYTE),
        ("byRes2", BYTE),
        ("wResolutionX", WORD), #  设备当前分辨率宽
        ("wResolutionY", WORD), #  设备当前分辨率高
        ("dwDayInitExp", DWORD), # 视频白天曝光时间的初始值2000
        ("dwDayMaxExp", DWORD), # 视频白天曝光时间的最大值20000
        ("dwNightExp", DWORD), # 晚间视频曝光时间的设置值3000
        ("dwSnapExp", DWORD), # 抓拍曝光时间
        ("byDayInitGain", BYTE), # 视频白天增益的初始值200
        ("byDayMaxGain", BYTE), # 视频白天增益的最大值400
        ("byNightGain", BYTE), # 晚间视频增益
        ("bySnapGain", BYTE), # 抓拍增益
        ("dwSceneMode", DWORD), # 场景模式， 详见SCENE_MODE
        ("struGeogLocation", NET_DVR_GEOGLOCATION), # 地址位置(默认浙江)
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struVtCoil", NET_ITC_VTCOIL_INFO * MAX_VL_NUM), # 虚拟线圈参数
        ("struRadar", NET_ITC_RADAR_PARAM), # 雷达参数
        ("struLine", NET_VCA_LINE), # 右车道线
        # 违规检测类型，按位表示，详见ITC_VIOLATION_DETECT_TYPE，0-不启用，1-启用(3.7Ver)
        ("dwVioDetectType", DWORD),
        ("byDebugMode", BYTE), # 调试模式，0-不启用，1-启用
        ("byRes", BYTE * 11),
    ]


LPNET_ITC_POST_VTCOIL_PARAM = POINTER(NET_ITC_POST_VTCOIL_PARAM)


# 单组IO红绿灯参数
class NET_ITC_SINGLE_IOTL_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("byLightIO", BYTE), # 红绿灯IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
        ("byTrafficLight", BYTE), # 红绿灯有效状态0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
        ("byTrigIO", BYTE), # 触发的IO号，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
        ("byTrigIOStatus", BYTE), # 触发IO口的状态（默认0），0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
        ("byRelatedDriveWay", BYTE), # 关联的车道号
        ("byRecordEnable", BYTE), # 闯红灯周期录像标志，0-不录像，1-录像
        ("byRecordType", BYTE), # 闯红灯录像类型，0-预录，1-延时录像
        ("byPreRecordTime", BYTE), # 闯红灯录像片段预录时间（默认0），单位：秒
        ("byRecordDelayTime", BYTE), # 闯红灯录像片段延时时间（默认0），单位：秒
        ("byRecordTimeOut", BYTE), # 闯红灯周期录像超时时间（秒）
        ("byRedSnapTimes", BYTE), # 红灯抓拍次数，0-不抓拍，非0-连拍次数，最大5次
        ("byGreenSnapTimes", BYTE), # 绿灯抓拍次数，0-不抓拍，非0-连拍次数，最大5次
        ("byRelatedIOOutEx", BYTE), # 第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
        ("byRes1", BYTE),
        ("byIntervalType", BYTE), # 间隔类型（默认按时间），0-时间起效,1-距离起效
        ("wRedInterval", WORD * MAX_INTERVAL_NUM), # 红灯连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
        ("wGreenInterval", WORD * MAX_INTERVAL_NUM), # 绿灯连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
        ("byRelatedIOOut", BYTE * MAX_IOOUT_NUM), # 关联的IO输出口，可以同时关联多个
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("byRes2", BYTE * 3),
        ("struPlateRecog", NET_ITC_PLATE_RECOG_REGION_PARAM * MAX_LANEAREA_NUM), # 牌识区域参数
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_SINGLE_IOTL_PARAM = POINTER(NET_ITC_SINGLE_IOTL_PARAM)


# 电警IO红绿灯参数
class NET_ITC_EPOLICE_IOTL_PARAM(Structure):
    _fields_ = [
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struSingleIOTL", NET_ITC_SINGLE_IOTL_PARAM * MAX_IOSPEED_GROUP_NUM), # 单组IO红绿灯参数
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_EPOLICE_IOTL_PARAM = POINTER(NET_ITC_EPOLICE_IOTL_PARAM)


ITC_PROTOCOL_UNKNOW = 0
ITC_SINGLE_COIL_PROTOCOL_MODE1 = 1
ITC_DOUBLE_COIL_PROTOCOL_MODE1 = 2
ITC_DOUBLE_COIL_PROTOCOL_MODE2 = 3
ITC_DOUBLE_COIL_PROTOCOL_MODE3 = 4
ITC_DOUBLE_COIL_PROTOCOL_MODE4 = 5
ITC_DOUBLE_COIL_PROTOCOL_MODE5 = 6
ITC_DOUBLE_COIL_PROTOCOL_MODE6 = 7
ITC_DOUBLE_COIL_PROTOCOL_MODE7 = 8
ITC_DOUBLE_COIL_PROTOCOL_MODE8 = 9
ITC_SINGLE_COIL_PROTOCOL_MODE2 = 10
ITC_OTHER_PROTOCOL = 0xff


# 正常过车逻辑抓拍类型
ITC_NORMAL_PASS_SERIAL_UNKNOW = 0
ITC_NORMAL_PASS_PROTOCOL_MODE1 = 1
ITC_NORMAL_PASS_PROTOCOL_MODE2 = 2
ITC_NORMAL_PASS_PROTOCOL_MODE3 = 3
ITC_NORMAL_PASS_PROTOCOL_MODE4 = 4
ITC_NORMAL_PASS_PROTOCOL_MODE5 = 5


# 逆行违规逻辑抓拍类型
ITC_INVERSE_SERIAL_UNKNOW = 0
ITC_INVERSE_PROTOCOL_MODE1 = 1
ITC_INVERSE_PROTOCOL_MODE2 = 2
ITC_INVERSE_PROTOCOL_MODE3 = 3


# 超速违规逻辑抓拍类型
ITC_SPEED_SERIAL_UNKNOW = 0
ITC_SPEED_PROTOCOL_MODE1 = 1
ITC_SPEED_PROTOCOL_MODE2 = 2
ITC_SPEED_PROTOCOL_MODE3 = 3


# 车检器参数
class NET_ITC_SERIAL_INFO(Structure):
    _fields_ = [
        ("bySerialProtocol", BYTE), # 车检器协议类型，详见ITC_SERIAL_PROTOCOL
        ("byIntervalType", BYTE), # 间隔类型（默认按时间），0-时间起效,1-距离起效
        ("wInterval", WORD), # 连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
        ("byNormalPassProtocol", BYTE), # 正常过车抓拍协议类型，详见ITC_NORMAL_PASS_SERIAL_PROTOCOL
        ("byInverseProtocol", BYTE), # 逆行抓拍协议类型，详见ITC_INVERSE_SERIAL_PROTOCOL
        ("bySpeedProtocol", BYTE), # 超速抓拍协议类型，详见ITC_SPEED_SERIAL_PROTOCOL
        ("byRes", BYTE * 9),
    ]


LPNET_ITC_SERIAL_INFO = POINTER(NET_ITC_SERIAL_INFO)


class NET_ITC_EPOLICE_LANE_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该车道，0-不启用，1-启用
        ("byRelatedDriveWay", BYTE), # 关联的车道号
        ("wDistance", WORD), # 线圈距离，单位厘米
        ("byRecordEnable", BYTE), # 闯红灯周期录像标志，0-不录像，1-录像
        ("byRecordType", BYTE), # 闯红灯录像类型，0-预录，1-延时录像
        ("byPreRecordTime", BYTE), # 闯红灯录像片段预录时间（默认0），单位：秒
        ("byRecordDelayTime", BYTE), # 闯红灯录像片段延时时间（默认0），单位：秒
        ("byRecordTimeOut", BYTE), # 闯红灯周期录像超时时间（秒）
        ("bySignSpeed", BYTE), # 标志限速(卡式电警模式有效)，单位km/h
        ("bySpeedLimit", BYTE), # 限速值(卡式电警模式有效)，单位km/h
        ("byOverlayDriveWay", BYTE), # OSD叠加的车道号
        ("struSerialInfo", NET_ITC_SERIAL_INFO), # 车检器参数
        ("byRelatedIOOut", BYTE * MAX_IOOUT_NUM), # 关联的IO输出口，可以同时关联多个
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("bySerialType", BYTE), # 车检器类型，0-私有车检器，1-私有OEM车检器，2-其他车检器
        ("byRelatedIOOutEx", BYTE), # 第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
        ("bySnapPicPreRecord", BYTE), # 抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
        ("struPlateRecog", NET_ITC_PLATE_RECOG_REGION_PARAM * MAX_LANEAREA_NUM), # 车道牌识参数
        ("byBigCarSignSpeed", BYTE), # 大车标志限速，单位km/h
        ("byBigCarSpeedLimit", BYTE), # 大车限速值，单位km/h
        ("byRedTrafficLightChan", BYTE), # 红灯通道号：1～16（红绿灯检测器）
        ("byYellowTrafficLightChan", BYTE), # 黄灯通道号：1～16（红绿灯检测器）
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byRes3", BYTE * 11),
    ]


LPNET_ITC_EPOLICE_LANE_PARAM = POINTER(NET_ITC_EPOLICE_LANE_PARAM)


# 电警/卡式电警RS485车检器触发参数
class NET_ITC_EPOLICE_RS485_PARAM(Structure):
    _fields_ = [
        ("byRelatedLaneNum", BYTE), # 关联的车道个数
        ("byTrafficLightSignalSrc", BYTE), # 交通灯信号来源 0～车检器 1～红绿灯检测器
        ("byRes1", BYTE * 2),
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struLane", NET_ITC_EPOLICE_LANE_PARAM * MAX_ITC_LANE_NUM), # 关联的车道参数
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_EPOLICE_RS485_PARAM = POINTER(NET_ITC_EPOLICE_RS485_PARAM)


# 车道属性参数结构
class NET_ITC_LANE_LOGIC_PARAM(Structure):
    _fields_ = [
        ("byUseageType", BYTE), # 车道用途类型，详见ITC_LANE_USEAGE_TYPE
        ("byDirectionType", BYTE), # 车道方向类型，详见ITC_LANE_DIRECTION_TYPE
        ("byCarDriveDirect", BYTE), # 车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT
        ("byRes", BYTE * 33), # 保留
    ]


LPNET_ITC_LANE_LOGIC_PARAM = POINTER(NET_ITC_LANE_LOGIC_PARAM)


# 视频电警线结构
class NET_ITC_LINE(Structure):
    _fields_ = [
        ("struLine", NET_VCA_LINE), # 线参数
        ("byLineType", BYTE), # 线类型，详见ITC_LINE_TYPE
        ("byRes", BYTE * 7),
    ]


LPNET_ITC_LINE = POINTER(NET_ITC_LINE)


class NET_ITC_SNAPMODE_PARAM(Structure):
    _fields_ = [
        ("byVehicleCapMode", BYTE), # 机动车抓拍模式，0-频闪模式；1-爆闪模式
        ("byNoVehicleCapMode", BYTE), # 非机动车抓拍模式，0-频闪模式；1-爆闪模式
        ("byPasserCapMode", BYTE), # 行人抓拍模式，0-频闪模式；1-爆闪模式
        ("byRes", BYTE * 29),
    ]


LPNET_ITC_SNAPMODE_PARAM = POINTER(NET_ITC_SNAPMODE_PARAM)


# size = 128
class NET_ITC_HVT_EC_PARAM(Structure):
    _fields_ = [
        ("dwCapShutter", DWORD), # 抓拍快门0~65535
        ("wCapGain", WORD), # 抓拍增益0～100
        ("byRes", BYTE * 2),
        ("dwDayTimeVideoShutter", DWORD), # 白天曝光时间最大值
        ("wDayTimeVideoGain", WORD), # 白天增益最大值
        ("wNightVideoGain", WORD), # 晚上增益最大值
        ("wNightVideoShutter", DWORD), # 晚上曝光时间最大值
        ("byRes1", BYTE * 108),
    ]


LPNET_ITC_HVT_EC_PARAM = POINTER(NET_ITC_HVT_EC_PARAM)


class NET_ITC_LANE_HVT_PARAM(Structure):
    _fields_ = [
        ("byLaneNO", BYTE), # 关联的车道号 1~255（用于叠加和上传）
        ("bySignSpeed", BYTE), # 标志限速，单位km/h 0～255  70
        ("bySpeedLimit", BYTE), # 限速值，单位km/h 0～255    80 实际起效
        ("byBigCarSignSpeed", BYTE), # 大车标志限速，单位km/h
        ("byBigCarSpeedLimit", BYTE), # 大车限速值，单位km/h
        ("bySpeedCapEn", BYTE), # 是否启用超速抓拍，0-否，1-是
        ("byCaptureCount", BYTE), # 抓拍张数1～5(正常)
        ("byRelatedIOOut", BYTE), # 关联的IO输出口(可以同时关联多个)，按位表示IO输出口，第0位表示IO输出口1，以此类推，0-不关联，1-关联
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("byEnableRadar", BYTE), # 是否启用雷达测速，0-否，1-是
        ("byChangeLaneEnable", BYTE), # 违章变道抓拍使能，0-关闭，1-开启
        ("byChangeLaneCapNo", BYTE), # 违章变道抓拍张数2-3
        ("dwCapTarget", DWORD), # 抓拍类型 bit0 表示机动车 bit1 表示非机动车 bit2 表示行人 0～表示不选择 1～表示选择
        ("struInterval", NET_ITC_INTERVAL_PARAM), # 抓拍间隔参数
        ("byRes3", BYTE * 24),
        ("struLane", NET_ITC_LANE_LOGIC_PARAM), # 车道属性，用byUseageType和byCarDriveDirect
        ("struLeftLaneLine", NET_ITC_LINE), # 左车道线，线类型为虚线、实线、单黄线和双黄线
        ("struRightLaneLine", NET_ITC_LINE), # 右车道线，线类型为虚线、实线、单黄线和双黄线
        ("struPlateRecog", NET_ITC_POLYGON), # 牌识区域参数
        ("struTraceArea", NET_ITC_POLYGON), # 视频触发焦点区域
        ("struForwardTrigLine", NET_VCA_LINE), # 正向触发线：一条线段，关心端点位置，目前只支持水平配置，接口按线段的两个端点保存。（一般配置为正向车辆的最佳触发位置）
        ("struBackwardTrigLine", NET_VCA_LINE), # 背向触发线：一条线段，关心端点位置，目前只支持水平配置，接口按线段的两个端点保存（一般配置为背向车辆的最佳触发位置）
        ("struLeftTrigLine", NET_VCA_LINE), # 左边触发线：一条线段，关心端点位置，目前只支持垂直配置，接口按线段的两个端点保存（一般配置为从左边进入车辆的最佳触发位置）
        ("struRightTrigLine", NET_VCA_LINE), # 右边触发线：一条线段，关心端点位置，目前只支持垂直配置，接口按线段的两个端点保存（一般配置为从右边进入车辆的最佳触发位置）
        ("byRes4", BYTE * 60),
    ]


LPNET_ITC_LANE_HVT_PARAM = POINTER(NET_ITC_LANE_HVT_PARAM)


class NET_ITC_POST_HVT_PARAM(Structure):
    _fields_ = [
        ("byLaneNum", BYTE), # 识别的车道个数，1-6
        ("bySceneMode", BYTE), # 0-未知1-城区道路；2-小区出入口
        ("byRoadExpBright", BYTE), # 路面期望亮度（视频曝光参数调整的依据之一。在无机动车时，依据此亮度期望值，调整视频曝光参数）
        ("byPlateExpBright", BYTE), # 车牌期望亮度（视频曝光参数调整的依据之一。在有机动车通过并识别到车牌时，依据此亮度期望值，对视频曝光参数调整）
        ("struDetectArea", NET_ITC_POLYGON), # 视频检测区域
        ("struCapMode", NET_ITC_SNAPMODE_PARAM), # 抓拍模式
        ("struEcParam", NET_ITC_HVT_EC_PARAM), # 曝光控制参数
        ("struLaneParam", NET_ITC_LANE_HVT_PARAM * MAX_ITC_LANE_NUM), # 单车道属性
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struGeogLocation", NET_DVR_GEOGLOCATION), # 地址位置（默认浙江）
        ("byRes", BYTE * 324),
    ]


LPNET_ITC_POST_HVT_PARAM = POINTER(NET_ITC_POST_HVT_PARAM)


# class NET_ITC_POST_MPR_PARAM(Structure):
#     _fields_ = [
#         ("byEnable", BYTE),
#         ("byLaneNum", BYTE),
#         ("bySourceType", BYTE), # 0-MPR触发（视频触发）,1-关联IO触发（地感线圈）,2-关联RS485的触发信号
#         ("byPicUploadType", BYTE), # 图片上传类型，0~全部上传，1-正向上传，2-背向上传
#         ("byRoadType", BYTE), # 模式选择 0-出入口，1-城市道路，2-自定义，3-报警输入，4-卡口, 5-治安监控(该模式下可以检测车辆比较混乱且没有车道线的场景)
#         ("byRes2", BYTE),
#         ("wCustomDelayTime", WORD), # 自定义抓拍延时时间（在byRoadType为 "自定义"的时候生效），范围在[0,15000]ms
#         ("byRes", BYTE * 56),
#         ("struLaneBoundaryLine", NET_ITC_LINE), # 车道边界线（最左边车道的左边界线）
#         ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数  40
#         ("struLaneParam", NET_ITC_LANE_MPR_PARAM * MAX_ITC_LANE_NUM),
#         ("szSceneName", CHAR * NAME_LEN), # 场景名称
#         ("struSnapLine", NET_VCA_LINE), # 抓拍线，在相机的架设方式为侧装，配置这个参数生效（即4.5中NET_DVR_CAMERA_SETUPCFG结构体中byErectMethod字段为1时 ）
#         ("byRes1", BYTE * 392),
#     ]
#
#
# LPNET_ITC_POST_MPR_PARAM = POINTER(NET_ITC_POST_MPR_PARAM)


# ************************MPR触发模式 end 2013-12-07***************
class NET_DVR_VIA_LANE_PARAM(Structure):
    _fields_ = [
        ("byLaneNO", BYTE), # 关联车道号
        ("byRes", BYTE * 63), # 保留
        ("struLogicParam", NET_ITC_LANE_LOGIC_PARAM), # 车道属性参数
        ("struLaneLine", NET_ITC_LINE), # 车道线
        ("struPlateRecog", NET_ITC_POLYGON), # 牌识区域
        ("byRes1", BYTE * 300), # 保留
    ]


LPNET_DVR_VIA_LANE_PARAM = POINTER(NET_DVR_VIA_LANE_PARAM)


class NET_DVR_VIA_VTCOIL_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能 0-不开启 1-开启
        ("byLaneNum", BYTE), # 车道数
        ("byRes", BYTE * 62), # 保留
        ("struLaneBoundaryLine", NET_ITC_LINE), # 车道边界线（最左边车道的左边界线）
        ("struLaneParam", NET_DVR_VIA_LANE_PARAM * MAX_ITC_LANE_NUM),
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("byRes1", BYTE * 624), # 保留
    ]


LPNET_DVR_VIA_VTCOIL_PARAM = POINTER(NET_DVR_VIA_VTCOIL_PARAM)


# 配置条件接口
class NET_DVR_TRIGGER_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD), # 通道号
        ("dwTriggerMode", DWORD), # 触发方式，参考 ITC_TRIGGERMODE_TYPE
        ("byDetSceneID", BYTE), # 检测场景号[1,4], IPC默认是0
        ("byRes", BYTE * 63), # 保留留
    ]


LPNET_DVR_TRIGGER_COND = POINTER(NET_DVR_TRIGGER_COND)


class NET_ITC_LANE_IMT_PARAM(Structure):
    _fields_ = [
        ("byLaneNO", BYTE), # 叠加车道号
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byRes", BYTE * 146),
        ("struLaneLine", NET_ITC_LINE), # 车道线
        ("byRes1", BYTE * 256),
    ]


LPNET_ITC_LANE_IMT_PARAM = POINTER(NET_ITC_LANE_IMT_PARAM)


class NET_ITC_POST_IMT_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byLaneNum", BYTE),
        ("bySnapMode", BYTE), # 抓拍类型；0~机动车，1~机非人
        ("byRes", BYTE * 61),
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struLaneBoundaryLine", NET_ITC_LINE), # 车道边界线（最右边车道的边界线）
        ("struLaneParam", NET_ITC_LANE_IMT_PARAM * MAX_ITC_LANE_NUM),
        ("byRes1", BYTE * 1584),
    ]


LPNET_ITC_POST_IMT_PARAM = POINTER(NET_ITC_POST_IMT_PARAM)


# class NET_ITC_POST_PRS_PARAM(Structure):
#     _fields_ = [
#         ("byEnable", BYTE),
#         ("byLaneNum", BYTE),
#         ("bySourceType", BYTE), # 0-视频检测,1-关联IO触发（地感线圈）,2-关联RS485的触发信号
#         ("bySnapMode", BYTE), # 0-全景图，1-全景图+特写
#         ("byCapMode", BYTE), # bySourceType为0视频检测时使用，0-频闪模式；1-爆闪模式
#         ("byNoPlatCarCap", BYTE), # 是否启用无车牌抓拍 0-不启用 1-启用
#         ("bySceneMode", BYTE), # 场景模式:0-普通出入口场景、1-收费站模式场景(车辆停留时间较长)、2-地下停车场出入口场景(白天黑夜均较暗)
#         ("byRes", BYTE * 57),
#         ("struLaneBoundaryLine", NET_ITC_LINE), # 车道边界线（最左边车道的左边界线）
#         ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数  40
#         ("struLaneParam", NET_ITC_LANE_PRS_PARAM * MAX_ITC_LANE_NUM),
#         ("byRes1", BYTE * 440),
#     ]
#
#
# LPNET_ITC_POST_PRS_PARAM = POINTER(NET_ITC_POST_PRS_PARAM)


class NET_IPC_LANE_HVT_PARAM(Structure):
    _fields_ = [
        ("byLaneNO", BYTE),
        ("byCarDriveDirect", BYTE), # 车辆行驶方向 ITC_LANE_CAR_DRIVE_DIRECT
        ("byRes", BYTE * 62),
        ("struLaneLine", NET_ITC_LINE), # 车道线
        ("struPlateRecog", NET_ITC_POLYGON), # 牌识区域
        ("byRes1", BYTE * 256),
    ]


LPNET_IPC_LANE_HVT_PARAM = POINTER(NET_IPC_LANE_HVT_PARAM)


class NET_ITC_PARKING_DETECTION(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("byRes", BYTE), # 保留字节
        ("wDuration", WORD), # 检测时间间隔，单位：s
        ("wAlarmIntervalTime", WORD), # 上传时间间隔，单位：s
        ("byRes1", BYTE * 58), # 保留字节
    ]


LPNET_ITC_PARKING_DETECTION = POINTER(NET_ITC_PARKING_DETECTION)


class NET_IPC_POST_HVT_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byLaneNum", BYTE),
        ("byEnhancedMode", BYTE), # 增强模式，0-不启用，1-启用
        ("byPicRecognition", BYTE), # 车辆报警图片二次识别，0-不启用，1-启用
        ("byRes", BYTE * 60),
        ("struLaneBoundaryLine", NET_ITC_LINE), # 车道边界线（最左边车道的左边界线）
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数  40
        ("struLaneParam", NET_IPC_LANE_HVT_PARAM * MAX_ITC_LANE_NUM),
        ("szSceneName", CHAR * NAME_LEN), # 场景名称
        ("struSnapLine", NET_VCA_LINE), # 抓拍线，抓在相机的架设方式为侧装，配置这个参数生效（即4.5中NET_DVR_CAMERA_SETUPCFG结构体中byErectMethod字段为1时 ）
        ("struParkingDetection", NET_ITC_PARKING_DETECTION), # 停车检测参数
        ("byRes1", BYTE * 328),
    ]


LPNET_IPC_POST_HVT_PARAM = POINTER(NET_IPC_POST_HVT_PARAM)


# 抓拍机4.0新增
class NET_ITC_LANE_HVT_PARAM_V50(Structure):
    _fields_ = [
        ("byLaneNO", BYTE), # 关联的车道号1～255(用于叠加和上传)
        ("byFlashMode", BYTE), # 闪光灯闪烁模式，0-同时闪，1-轮流闪
        ("bySignSpeed", BYTE), # 小车标志限高速，单位km/h
        ("bySpeedLimit", BYTE), # 小车限高速值，单位km/h
        ("bySignLowSpeed", BYTE), # 小车标志限底速，单位km/h
        ("byLowSpeedLimit", BYTE), # 小车限底速值，单位km/h
        ("byBigCarSignSpeed", BYTE), # 大车标志限高速，单位km/h（新交规）
        ("byBigCarSpeedLimit", BYTE), # 大车限高速值，单位km/h（新交规）
        ("byBigCarSignLowSpeed", BYTE), # 大车标志限底速，单位km/h
        ("byBigCarLowSpeedLimit", BYTE), # 大车限底速值，单位km/h
        ("bySnapTimes", BYTE), # 卡口抓拍张数，1~3
        ("byDriveLineSnapTime", BYTE), #  压线抓拍张数 1~3
        ("byHighSpeedSnapTime", BYTE), #  超高速抓拍张数1~3
        ("byLowSpeedSnapTime", BYTE), #  超低速抓拍张数1~3
        ("byBanSnapTime", BYTE), #  违反禁令抓拍张数  1~3
        ("byReverseSnapTime", BYTE), # 逆行抓拍张数  1~3
        ("byRelatedDriveWay", BYTE), # 关联车道号，用于匹配车检器
        ("byLaneType", BYTE), # 车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号byRelatedDriveWay对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byRes1", BYTE * 27),
        ("byChangeLaneEnable", BYTE), # 违章变道抓拍使能，0-关闭，1-开启
        ("byChangeLaneCapNo", BYTE), # 违章变道抓拍张数2-3
        # 目前仅使用第一个车道的，以后可能会扩展为多车道分别配置
        # 类型, 按位表示,0-不启用,1-启用参考 ITC_VIOLATION_DETECT_TYPE
        ("dwVioDetectType", DWORD),
        ("dwRelatedIOOut", DWORD), # 关联的IO输出口(可以同时关联多个)，按位表示IO输出口，第0位表示IO输出口1，以此类推，0-不关联，1-关联
        ("struTrigLine", NET_ITC_LINE), # 触发线，目前仅使用第一个车道的，以后可能会扩展为多车道分别配置
        ("struLineLeft", NET_ITC_LINE), # 左车道线
        ("struPlateRecog", NET_ITC_POLYGON), # 牌识区域
        ("struLane", NET_ITC_LANE_LOGIC_PARAM), # 车道属性，用byUseageType和byCarDriveDirect
        ("struInterval", NET_ITC_INTERVAL_PARAM), # 抓拍间隔参数（20byte）
        ("byRes2", BYTE * 280),
    ]


LPNET_ITC_LANE_HVT_PARAM_V50 = POINTER(NET_ITC_LANE_HVT_PARAM_V50)


class NET_ITC_POST_HVT_PARAM_V50(Structure):
    _fields_ = [
        ("byLaneNum", BYTE), # 识别的车道个数，1-6
        ("byCapType", BYTE), # 抓拍类型，0-机、非、人（默认），1-机动车
        ("byCapMode", BYTE), # 抓拍方式，0-视频抽帧，1-打断抓拍，2-混合模式，
        ("bySecneMode", BYTE), # 场景模式，0-城区道路（默认），1-小区出入口，2-高速公路
        ("bySpeedMode", BYTE), # 测速模式，0-无测速，1-雷达测速，2-视频测速
        ("byLineRuleEffect", BYTE), # 触发规则线有效性,每一位代表一条触发线,0-无效1-有效。bit0-左触发线bit1-右触发线bit2-视频检测区域
        ("byRes1", BYTE * 78),
        ("struLeftTrigLine", NET_ITC_LINE), # 左触发线(一条垂直线)
        ("struRigtTrigLine", NET_ITC_LINE), # 右触发线(一条垂直线)
        ("struLaneBoundaryLine", NET_ITC_LINE), # 车道边界线（最右边车道的右车道线）
        ("struDetectArea", NET_ITC_POLYGON), # 视频检测区域
        ("struGeogLocation", NET_DVR_GEOGLOCATION), # 地理位置（默认浙江省）计算时区
        ("struLaneParam", NET_ITC_LANE_HVT_PARAM_V50 * MAX_ITC_LANE_NUM), # 单车道属性
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("byRes2", BYTE * 260),
    ]


LPNET_ITC_POST_HVT_PARAM_V50 = POINTER(NET_ITC_POST_HVT_PARAM_V50)


# 车道参数
class NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM(Structure):
    _fields_ = [
        ("byRelatedDriveWay", BYTE), # 关联的车道号
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byPedestriansNum", BYTE), # 行人数量阈值：范围1-100，默认值1
        ("byVehicleSpeed", BYTE), # 车辆速度阈值：范围0-100，默认值0
        ("dwVehicleInterval", DWORD), # 跟车检测阈值：范围0-65536，默认值0
        ("byPedesDetRule", BYTE), # 行人检测规则；代表行人检测区域中行人行驶方向； 0~向左， 1~向右。
        ("byRes", BYTE * 3),
        ("struLaneLine", NET_ITC_LINE), # 车道线
        ("struStopLine", NET_ITC_LINE), # 停止线
        ("struPlateRecog", NET_ITC_POLYGON), # 牌识区域
        ("byRes1", BYTE * 280),
    ]


LPNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM = POINTER(NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM)

# 不礼让行人参数
class NET_ITC_NOCOMITY_PEDESTRIAN_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能
        ("byLaneNum", BYTE), #  关联车道总数：范围1-3，默认值3
        ("byRes", BYTE * 74),
        ("struLaneBoundaryLine", NET_ITC_LINE), # 车道右边界线
        ("struTriggerLine", NET_ITC_LINE), # 不礼让行人触发线
        ("struPedesDetRecog", NET_ITC_POLYGON), # 行人检测区域
        ("struLaneParam", NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM * MAX_ITC_LANE_NUM), # 车道参数
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("byRes1", BYTE * 400),
    ]


LPNET_ITC_NOCOMITY_PEDESTRIAN_PARAM = POINTER(NET_ITC_NOCOMITY_PEDESTRIAN_PARAM)

# 单个IO接入信号灯参数
class NET_ITC_SINGLE_IO_LIGHT_PARAM(Structure):
    _fields_ = [
        ("byLightType", BYTE), # 交通灯导向类型,0-左转灯,1-直行灯,2-右转灯
        ("byRelatedIO", BYTE), # 关联的IO口号
        ("byRedLightState", BYTE), # 红灯电平状态，0-高电平红灯，1-低电平红灯
        ("byRes", BYTE * 17),
    ]


LPNET_ITC_SINGLE_IO_LIGHT_PARAM = POINTER(NET_ITC_SINGLE_IO_LIGHT_PARAM)


# IO接入信号灯参数
class NET_ITC_IO_LIGHT_PARAM(Structure):
    _fields_ = [
        ("struIOLight", NET_ITC_SINGLE_IO_LIGHT_PARAM * MAX_LIGHT_NUM), # 单个IO接入信号灯参数
        ("byRes", BYTE * 8),
    ]


LPNET_ITC_IO_LIGHT_PARAM = POINTER(NET_ITC_IO_LIGHT_PARAM)


# 单个485接入信号灯参数
class NET_ITC_SINGLE_RS485_LIGHT_PARAM(Structure):
    _fields_ = [
        ("byLightType", BYTE), # 交通灯导向类型，0-左转灯，1-直行灯，2-右转灯
        ("byRelatedLightChan", BYTE), # 关联的红绿灯检测器通道号
        ("byInputLight", BYTE), # 接入的信号灯类型，0-接红灯，1-接绿灯
        ("byRelatedYLightChan", BYTE), # 关联的黄灯检测器通道号
        ("byRes", BYTE * 16),
    ]


LPNET_ITC_SINGLE_RS485_LIGHT_PARAM = POINTER(NET_ITC_SINGLE_RS485_LIGHT_PARAM)


# 485接入信号灯参数
class NET_ITC_RS485_LIGHT_PARAM(Structure):
    _fields_ = [
        ("struRS485Light", NET_ITC_SINGLE_RS485_LIGHT_PARAM * MAX_LIGHT_NUM), # 单个485接入信号灯参数
        ("byRes", BYTE * 8),
    ]


LPNET_ITC_RS485_LIGHT_PARAM = POINTER(NET_ITC_RS485_LIGHT_PARAM)


class NET_POS_PARAM(Structure):
    _fields_ = [
        ("wLeft", WORD),
        ("wTop", WORD),
        ("wRight", WORD),
        ("wBottom", WORD),
    ]


LPNET_POS_PARAM = POINTER(NET_POS_PARAM)


# 单组视频检测交通信号灯参数结构
class NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM(Structure):
    _fields_ = [
        ("byLightNum", BYTE), # 交通灯个数
        ("byStraightLight", BYTE), # 是否有直行标志灯，0-否 ，1-是
        ("byLeftLight", BYTE), # 是否有左转标志灯，0-否，1-是
        ("byRightLight", BYTE), # 是否有右转标志灯，0-否，1-是
        ("byRedLight", BYTE), # 是否有红灯，0-否，1-是
        ("byGreenLight", BYTE), # 是否有绿灯，0-否，1-是
        ("byYellowLight", BYTE), # 是否有黄灯，0-否，1-是
        ("byYellowLightTime", BYTE), # 取值范围（0～10s）（ITC3.7Ver）
        ("struLightRect", NET_POS_PARAM), # 交通灯区域
        ("byRes", BYTE * 24),
    ]


LPNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM = POINTER(NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM)


# 视频检测交通信号灯参数结构(最大可有12个区域检测，488字节)
class NET_ITC_VIDEO_DETECT_LIGHT_PARAM(Structure):
    _fields_ = [
        ("struTrafficLight", NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM * MAX_VIDEO_DETECT_LIGHT_NUM), # 单个视频检测信号灯参数
        ("byRes", BYTE * 8),
    ]


LPNET_ITC_VIDEO_DETECT_LIGHT_PARAM = POINTER(NET_ITC_VIDEO_DETECT_LIGHT_PARAM)


# 交通信号灯接入参数
class NET_ITC_LIGHT_ACCESSPARAM_UNION(Union):
    _fields_ = [
        ("uLen", DWORD * 122),
        ("struIOLight", NET_ITC_IO_LIGHT_PARAM), # IO接入信号灯参数
        ("struRS485Light", NET_ITC_RS485_LIGHT_PARAM), # 485接入信号灯参数
        ("struVideoDelectLight", NET_ITC_VIDEO_DETECT_LIGHT_PARAM), # 视频检测信号灯参数
    ]


LPNET_ITC_LIGHT_ACCESSPARAM_UNION = POINTER(NET_ITC_LIGHT_ACCESSPARAM_UNION)


# 交通信号灯参数结构
class NET_ITC_TRAFFIC_LIGHT_PARAM(Structure):
    _fields_ = [
        ("bySource", BYTE), # 交通信号灯接入源，0-IO接入，1-RS485接入
        ("byRes1", BYTE * 3),
        ("struLightAccess", NET_ITC_LIGHT_ACCESSPARAM_UNION), # 信号灯接入参数
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_TRAFFIC_LIGHT_PARAM = POINTER(NET_ITC_TRAFFIC_LIGHT_PARAM)


# 违规检测线参数结构
class NET_ITC_VIOLATION_DETECT_LINE(Structure):
    _fields_ = [
        ("struLaneLine", NET_ITC_LINE), # 车道线参数
        ("struStopLine", NET_ITC_LINE), # 停止线参数
        ("struRedLightLine", NET_ITC_LINE), # 闯红灯触发线参数
        ("struCancelLine", NET_ITC_LINE), # 直行触发位置取消线
        ("struWaitLine", NET_ITC_LINE), # 待行区停止线参数
        ("struRes", NET_ITC_LINE * 8),
    ]


LPNET_ITC_VIOLATION_DETECT_LINE = POINTER(NET_ITC_VIOLATION_DETECT_LINE)


# 行人闯红灯参数
class NET_ITC_REDLIGHT_PEDESTRIAN_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能
        ("bySnapNumTimes", BYTE), # 抓拍张数：1-3，默认3张
        ("byPedesDir", BYTE), # 行人方向：0~正向，1~背向，2~双向
        ("byDelayTime", BYTE), # 延时时间1-5s
        ("byStackTargetEnble", BYTE), # 叠加目标框（即抓拍第一张图片上框住闯红灯的行人），0~不叠加，1~叠加
        ("byCalibRecogCtrl", BYTE), # 标定区域控制；0~移除标定区域，1~添加标定区域
        ("byRes1", BYTE * 2),
        ("struTrafficLight", NET_ITC_TRAFFIC_LIGHT_PARAM), # 交通信号灯参数
        ("struStopLine", NET_ITC_LINE), # 停止线
        ("struCalibRecog", NET_ITC_POLYGON * MAX_CALIB_RECOG_NUM), # 标定区域
        ("byRes", BYTE * 440),
    ]


LPNET_ITC_REDLIGHT_PEDESTRIAN_PARAM = POINTER(NET_ITC_REDLIGHT_PEDESTRIAN_PARAM)

class NET_ITC_POST_MOBILE_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("bySceneMode", BYTE), # 场景模式 0-高速公路 1-城市道路
        # 抓拍类型
        # bit0-卡口,bit1-大车占道,bit2-压硬路肩
        #
        ("wExpressWayCapType", WORD), # 高速公路
        # 抓拍类型
        # bit0-卡口,bit1-机占非,bit2-占用专用车道
        #
        ("wUrbanRoadCapType", WORD), # 城市道路
        ("byCapNum", BYTE), # 抓拍张数 [2,3]
        ("byRecordEnable", BYTE), # 违章录像使能 0-关闭，1-开启
        ("dwPreRecordTime", DWORD), # 录像预录时间(s)
        ("dwOverRecordTime", DWORD), # 录像超时时间(s)
        ("struLane", NET_ITC_LANE_LOGIC_PARAM), # 车道属性
        ("struPolygon", NET_ITC_POLYGON * MAX_MOBILE_POLYGON_NUM), # 牌识区域参数
        ("struLine", NET_ITC_VIOLATION_DETECT_LINE * MAX_MOBILE_DETECTLINE_NUM), # 违规检测线
        ("struLaneBoundaryLine", NET_ITC_LINE), # 车道边界线（最右边车道的右车道线）
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struInterval", NET_ITC_INTERVAL_PARAM), # 抓拍间隔参数（20byte）
        ("byRes", BYTE * 256),
    ]


LPNET_ITC_POST_MOBILE_PARAM = POINTER(NET_ITC_POST_MOBILE_PARAM)


# class NET_ITC_TRIGGER_PARAM_UNION(Union):
#     _fields_ = [
#         ("uLen", DWORD * 1070), # 参数
#         ("struIOSpeed", NET_ITC_POST_IOSPEED_PARAM), # （卡口）IO测速参数
#         ("struSingleIO", NET_ITC_POST_SINGLEIO_PARAM), # （卡口）单IO参数
#         ("struPostRs485", NET_ITC_POST_RS485_PARAM), # （卡口）RS485车检器参数
#         ("struPostRadar", NET_ITC_POST_RS485_RADAR_PARAM), # （卡口）RS485雷达参数
#         ("struVtCoil", NET_ITC_POST_VTCOIL_PARAM), # （卡口）虚拟线圈参数
#         ("struHvt", NET_ITC_POST_HVT_PARAM), # （卡口）混行卡口参数
#         ("struIOTL", NET_ITC_EPOLICE_IOTL_PARAM), # （电警）IO红绿灯参数
#         ("struEpoliceRs485", NET_ITC_EPOLICE_RS485_PARAM), # （电警）RS485车检器触发参数
#         ("struPERs485", NET_ITC_EPOLICE_RS485_PARAM), # （卡式电警）RS485车检器触发参数
#         ("struPostMpr", NET_ITC_POST_MPR_PARAM), # 多帧检测触发（MPR）
#         ("struViaVtCoil", NET_DVR_VIA_VTCOIL_PARAM), # (VIA)视频检测参数
#         ("struPostImt", NET_ITC_POST_IMT_PARAM), # 智慧监控触发
#         ("struPostPrs", NET_ITC_POST_PRS_PARAM), # 视频检测触发
#         ("struIpcHvt", NET_IPC_POST_HVT_PARAM), # (IPC) 混行卡口参数
#         ("struHvtV50", NET_ITC_POST_HVT_PARAM_V50), # （卡口）混行卡口参数V50
#         ("struPostMobile", NET_ITC_POST_MOBILE_PARAM), #  移动交通触发模式
#         ("struNoComityPed", NET_ITC_NOCOMITY_PEDESTRIAN_PARAM), # 不礼让行人参数
#         ("struRedLightPed", NET_ITC_REDLIGHT_PEDESTRIAN_PARAM), # 行人闯红灯参数
#     ]
#
#
# LPNET_ITC_TRIGGER_PARAM_UNION = POINTER(NET_ITC_TRIGGER_PARAM_UNION)


# # 单个触发参数结构
# class NET_ITC_SINGLE_TRIGGERCFG(Structure):
#     _fields_ = [
#         ("byEnable", BYTE), # 是否启用该触发模式，0-否，1-是
#         ("byRes1", BYTE * 3),
#         ("dwTriggerType", DWORD), # 触发类型，详见ITC_TRIGGERMODE_TYPE
#         ("uTriggerParam", NET_ITC_TRIGGER_PARAM_UNION), # 触发参数
#         ("byRes", BYTE * 64),
#     ]
#
#
# LPNET_ITC_SINGLE_TRIGGERCFG = POINTER(NET_ITC_SINGLE_TRIGGERCFG)


# # 触发参数结构
# class NET_ITC_TRIGGERCFG(Structure):
#     _fields_ = [
#         ("dwSize", DWORD), # 结构长度
#         ("struTriggerParam", NET_ITC_SINGLE_TRIGGERCFG), # 单个触发参数
#         ("byRes", BYTE * 32),
#     ]
#
#
# LPNET_ITC_TRIGGERCFG = POINTER(NET_ITC_TRIGGERCFG)


# 违规检测类型宏定义
ITC_VIOLATION_POST = 0x01
ITC_VIOLATION_DRIVELINE = 0x02
ITC_VIOLATION_REVERSE = 0x04
ITC_VIOLATION_REDLIGHT = 0x08
ITC_VIOLATION_DIRECTION = 0x10
ITC_VIOLATION_INTERSECTION_CONGEST = 0x20
ITC_VIOLATION_NONDRIVEWAY = 0x40
ITC_VIOLATION_CHANGELANE = 0x80
ITC_VIOLATION_BAN = 0x100
ITC_VIOLATION_INTERSECTION_PARK = 0x200
ITC_VIOLATION_GREEN_PARK = 0x400
ITC_VIOLATION_HIGH_SPEED = 0x800
ITC_VIOLATION_LOW_SPEED = 0x1000
ITC_VIOLATION_EMERGENCY = 0x2000
ITC_VIOLATION_TURN_AROUND = 0x8000
ITC_VIOLATION_CONGESTION = 0x10000


# 违规检测参数结构
class NET_ITC_VIOLATION_DETECT_PARAM(Structure):
    _fields_ = [
        ("dwVioDetectType", DWORD), # 违规检测类型, 按位表示, 详见ITC_VIOLATION_DETECT_TYPE ,0-不启用,1-启用
        ("byDriveLineSnapTimes", BYTE), # 压车道线抓拍张数,2-3
        ("byReverseSnapTimes", BYTE), # 逆行抓拍,2-3
        ("wStayTime", WORD), # 机占非停留时间（该时间后抓拍），单位s
        ("byNonDriveSnapTimes", BYTE), # 机占非抓拍张数2-3
        ("byChangeLaneTimes", BYTE), # 违法变道抓拍张数 2-3
        ("bybanTimes", BYTE), # 违法禁令抓拍张数2-3
        ("byDriveLineSnapSen", BYTE), #  压线灵敏度(0~100)(3.7Ver)
        ("wSnapPosFixPixel", WORD), # 第2,3张抓拍位置最小偏移(违反信号灯时起效)（单位：像素） 命名需改进
        ("bySpeedTimes", BYTE), # 违法超速抓拍张数2-3(3.8Ver)
        ("byTurnAroundEnable", BYTE), # 违章掉头使能 0~关闭 1~开启
        ("byThirdPlateRecogTime", BYTE), # 第三张牌识时间 0~180s
        ("byPostSnapTimes", BYTE), # 卡口抓拍张数,1-2张
        ("byRes1", BYTE * 18),
        ("wStopLineDis", WORD), # 电警第2张违规图片与停止线的最短距离，[0,300]单位(像素)
        ("byRes", BYTE * 14),
    ]


LPNET_ITC_VIOLATION_DETECT_PARAM = POINTER(NET_ITC_VIOLATION_DETECT_PARAM)


# 关联车道方向类型定义
ITC_RELA_LANE_DIRECTION_UNKNOW = 0
ITC_RELA_LANE_EAST_WEST = 1
ITC_RELA_LANE_WEST_EAST = 2
ITC_RELA_LANE_SOUTH_NORTH = 3
ITC_RELA_LANE_NORTH_SOUTH = 4
ITC_RELA_LANE_EASTSOUTH_WESTNORTH = 5
ITC_RELA_LANE_WESTNORTH_EASTSOUTH = 6
ITC_RELA_LANE_EASTNORTH_WESTSOUTH = 7
ITC_RELA_LANE_WESTSOUTH_EASTNORTH = 8


# 车道用途类型定义
ITC_LANE_USEAGE_UNKNOW = 0
ITC_LANE_CARRIAGEWAY = 1
ITC_LANE_BUS = 2
ITC_LANE_FAST = 3
ITC_LANE_SLOW = 4
ITC_LANE_MOTOR = 5
ITC_LANE_NONMOTOR = 6
ITC_LANE_REVERSE_LANE = 7
ITC_LANE_BAN_TRUCKS = 8
ITC_LANE_MIX = 9
ITC_LANE_EMERGENCY = 10
ITC_LANE_BAN_LEFT = 11
ITC_LANE_BAN_RIGHT = 12


# 车道方向类型定义
ITC_LANE_DIRECTION_UNKNOW = 0
ITC_LANE_LEFT = 1
ITC_LANE_STRAIGHT = 2
ITC_LANE_LEFT_STRAIGHT = 3
ITC_LANE_RIGHT = 4
ITC_LANE_LEFT_RIGHT = 5
ITC_LANE_RIGHT_STRAIGHT = 6
ITC_LANE_LEFT_RIGHT_STRAIGHT = 7
ITC_LANE_LEFT_WAIT = 9
ITC_LANE_STRAIGHT_WAIT = 10
ITC_LANE_FORWARD = 11
ITC_LANE_BACKWARD = 12
ITC_LANE_BOTHWAY = 13
ITC_LANE_STRAIGHT_WAIT_RIGHT = 14


# 车辆行驶方向类型定义
ITC_LANE_DRIVE_UNKNOW = 0
ITC_LANE_DRIVE_UP_TO_DOWN = 1
ITC_LANE_DRIVE_DOWN_TO_UP = 2


# 线类型定义
ITC_LINT_UNKNOW = 0
ITC_LINE_WHITE = 1
ITC_LINE_STOP = 2
ITC_LINE_SINGLE_YELLOW = 3
ITC_LINE_DOUBLE_YELLOW = 4
ITC_LINE_GUARD_RAIL = 5
ITC_LINE_NO_CROSS = 6
ITC_LINE_DOTTED = 7


# 单个车道视频电警触发参数结构
class NET_ITC_LANE_VIDEO_EPOLICE_PARAM(Structure):
    _fields_ = [
        ("byLaneNO", BYTE), # 关联的车道号
        ("bySensitivity", BYTE), # 线圈灵敏度，[1,100]
        ("byEnableRadar", BYTE), # 启用雷达测试0-不启用，1-启用
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("struLane", NET_ITC_LANE_LOGIC_PARAM), # 车道参数
        ("struVioDetect", NET_ITC_VIOLATION_DETECT_PARAM), # 违规检测参数
        ("struLine", NET_ITC_VIOLATION_DETECT_LINE), # 违规检测线
        ("struPlateRecog", NET_ITC_POLYGON), # 牌识区域参数
        ("byRecordEnable", BYTE), # 闯红灯周期录像标志，0-不录像，1-录像
        ("byRecordType", BYTE), # 闯红灯录像类型，0-预录，1-延时录像
        ("byPreRecordTime", BYTE), # 闯红灯录像片段预录时间（默认0），单位：秒
        ("byRecordDelayTime", BYTE), # 闯红灯录像片段延时时间（默认0），单位：秒
        ("byRecordTimeOut", BYTE), # 闯红灯周期录像超时时间（秒）
        ("byCarSpeedLimit", BYTE), # 车速限制值，单位km/h
        ("byCarSignSpeed", BYTE), # 标志限速，单位km/h
        ("bySnapPicPreRecord", BYTE), # 抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
        ("struInterval", NET_ITC_INTERVAL_PARAM), # 抓拍间隔参数（20byte）
        ("byRes", BYTE * 36),
    ]


LPNET_ITC_LANE_VIDEO_EPOLICE_PARAM = POINTER(NET_ITC_LANE_VIDEO_EPOLICE_PARAM)


# 视频电警触发参数结构
class NET_ITC_VIDEO_EPOLICE_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("byLaneNum", BYTE), # 识别的车道个数
        ("byLogicJudge", BYTE), # 闯红灯违规判断逻辑，设置值为：0-按方向，1-按车道
        ("byRes1", BYTE),
        ("struPlateRecog", NET_ITC_PLATE_RECOG_PARAM), # 牌识参数
        ("struTrafficLight", NET_ITC_TRAFFIC_LIGHT_PARAM), # 交通信号灯参数
        ("struLaneParam", NET_ITC_LANE_VIDEO_EPOLICE_PARAM * MAX_ITC_LANE_NUM), # 单车道参数
        ("struLaneBoundaryLine", NET_ITC_LINE), # 车道边界线（最右边车道的边界线）
        ("struLeftLine", NET_ITC_LINE), # 左转弯分界线
        ("struRightLine", NET_ITC_LINE), # 右转弯分界线
        ("struTopZebraLine", NET_ITC_LINE), # 上部斑马线
        ("struBotZebraLine", NET_ITC_LINE), # 下部斑马线
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_VIDEO_EPOLICE_PARAM = POINTER(NET_ITC_VIDEO_EPOLICE_PARAM)


class NET_ITC_VIDEO_TRIGGER_PARAM_UNION(Union):
    _fields_ = [
        ("uLen", DWORD * 1150),
        ("struVideoEP", NET_ITC_VIDEO_EPOLICE_PARAM), # 视频电警参数
    ]


LPNET_ITC_VIDEO_TRIGGER_PARAM_UNION = POINTER(NET_ITC_VIDEO_TRIGGER_PARAM_UNION)


class NET_ITC_VIDEO_TRIGGER_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMode", DWORD), # 触发模式，详见ITC_TRIGGERMODE_TYPE
        ("uVideoTrigger", NET_ITC_VIDEO_TRIGGER_PARAM_UNION), # 触发模式参数
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_VIDEO_TRIGGER_PARAM = POINTER(NET_ITC_VIDEO_TRIGGER_PARAM)


class NET_DVR_STATUS_DETECTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byEnableTrigIODetect", BYTE), # 开启触发IO状态检测，1-是，0-否
        ("byEnableFlashOutDetect", BYTE), # 开启同步输出状态检测，1-是，0-否
        ("byEnableRS485Detect", BYTE), # 开启RS485接收状态检测，1-是，0-否
        ("byEnableTrafficLightDetect", BYTE), # 开启交通灯状态检测，1-是，0-否
        ("byRes", BYTE * 28),
    ]


LPNET_DVR_STATUS_DETECTCFG = POINTER(NET_DVR_STATUS_DETECTCFG)


ITC_STATUS_DETECT_NULL = 0
        # ITC_STATUS_DETECT_TRIGGERIO,    触发IO
        # ITC_STATUS_DETECT_FLASHOUT,     同步输出
        # ITC_STATUS_DETECT_RS485, RS485
        # ITC_STATUS_DETECT_TRIGGERTYPE, 触发类型（保留）
        # ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR,  交通灯（区分颜色）
        # ITC_STATUS_DETECT_TRAFFICLIGHT_TURN  交通灯（区分转向）


class NET_ITC_TRIGGERIO_INFO(Structure):
    _fields_ = [
        ("byTriggerIOIndex", BYTE * MAX_IOIN_NUM), # 触发IO号
        ("byRes", BYTE * 40),
    ]


LPNET_ITC_TRIGGERIO_INFO = POINTER(NET_ITC_TRIGGERIO_INFO)


class NET_ITC_FLASHOUT_INFO(Structure):
    _fields_ = [
        ("byFlashOutIndex", BYTE * MAX_IOOUT_K_NUM), # 同步输出号
        ("byRes", BYTE * 40),
    ]


LPNET_ITC_FLASHOUT_INFO = POINTER(NET_ITC_FLASHOUT_INFO)


class NET_ITC_SERIAL_CHECKINFO(Structure):
    _fields_ = [
        ("bySerialIndex", BYTE * MAX_ITC_SERIALCHECK_NUM), # 485串口校验结果，0-无效,1-有效, bySerialIndex[0]表示正确的头, bySerialIndex[1]表示正确的尾
        ("byRes", BYTE * 40),
    ]


LPNET_ITC_SERIAL_CHECKINFO = POINTER(NET_ITC_SERIAL_CHECKINFO)


class NET_ITC_TRIGGERTYPE_INFO(Structure):
    _fields_ = [
        ("byTrigTypeIndex", BYTE), # 触发类型值
        ("byRes", BYTE * 47),
    ]


LPNET_ITC_TRIGGERTYPE_INFO = POINTER(NET_ITC_TRIGGERTYPE_INFO)


# 视频电警
class NET_ITC_TRAFFIC_LIGHT_COLOR(Structure):
    _fields_ = [
        ("byLeftLight", BYTE), # 左转灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
        ("byRightLight", BYTE), # 右转灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
        ("byStraightLight", BYTE), # 直行灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
        ("byRes", BYTE * 45),
    ]


LPNET_ITC_TRAFFIC_LIGHT_COLOR = POINTER(NET_ITC_TRAFFIC_LIGHT_COLOR)


# 非视频电警
class NET_ITC_TRAFFIC_LIGHT_TURN(Structure):
    _fields_ = [
        ("byLightType", BYTE * MAX_ITC_LANE_NUM), #  0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
        ("byRes", BYTE * 42),
    ]


LPNET_ITC_TRAFFIC_LIGHT_TURN = POINTER(NET_ITC_TRAFFIC_LIGHT_TURN)


class NET_ITC_STATUS_UNION(Union):
    _fields_ = [
        ("uLen", BYTE * 48), # 参数
        ("struTrigIO", NET_ITC_TRIGGERIO_INFO), # 触发IO口号
        ("struFlashOut", NET_ITC_FLASHOUT_INFO), # 同步输出
        ("struSerial", NET_ITC_SERIAL_CHECKINFO), # 串口
        ("struTrigType", NET_ITC_TRIGGERTYPE_INFO), # 触发类型（保留）
        ("struTrafficLightColor", NET_ITC_TRAFFIC_LIGHT_COLOR), # 交通灯（区分颜色）对应类型ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR
        ("struTrafficLightTurn", NET_ITC_TRAFFIC_LIGHT_TURN), # 交通灯（区分转向）对应类型ITC_STATUS_DETECT_TRAFFICLIGHT_TURN
    ]


LPNET_ITC_STATUS_UNION = POINTER(NET_ITC_STATUS_UNION)


class NET_ITC_STATUS_DETECT_RESULT(Structure):
    _fields_ = [
        ("dwStatusType", DWORD), # 状态检测类型，详见ITC_STATUS_DETECT_TYPE
        ("uStatusParam", NET_ITC_STATUS_UNION), # 状态检测结果
        ("dwHoldTime", DWORD), # 灯亮持续时间（保留），单位：ms
        ("byRes", BYTE * 32),
    ]


LPNET_ITC_STATUS_DETECT_RESULT = POINTER(NET_ITC_STATUS_DETECT_RESULT)


class NET_DVR_SETUPALARM_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLevel", BYTE), # 布防优先级，0-一等级（高），1-二等级（中），2-三等级（低）
        ("byAlarmInfoType", BYTE), # 上传报警信息类型（抓拍机支持），0-老报警信息（NET_DVR_PLATE_RESULT），1-新报警信息(NET_ITS_PLATE_RESULT)2012-9-28
        ("byRetAlarmTypeV40", BYTE), # 0--返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO, 1--设备支持NET_DVR_ALARMINFO_V40则返回NET_DVR_ALARMINFO_V40，不支持则返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO
        ("byRetDevInfoVersion", BYTE), # CVR上传报警信息回调结构体版本号 0-COMM_ALARM_DEVICE， 1-COMM_ALARM_DEVICE_V40
        ("byRetVQDAlarmType", BYTE), # VQD报警上传类型，0-上传报报警NET_DVR_VQD_DIAGNOSE_INFO，1-上传报警NET_DVR_VQD_ALARM
        # 1-表示人脸侦测报警扩展(INTER_FACE_DETECTION),0-表示原先支持结构(INTER_FACESNAP_RESULT)
        ("byFaceAlarmDetection", BYTE),
        # Bit0- 表示二级布防是否上传图片: 0-上传，1-不上传
        # Bit1- 表示开启数据上传确认机制；0-不开启，1-开启
        # Bit6- 表示雷达检测报警(eventType:radarDetection)是否开启实时上传；0-不开启，1-开启（用于web插件实时显示雷达目标轨迹）
        ("bySupport", BYTE),
        # 断网续传类型
        # bit0-车牌检测（IPC） （0-不续传，1-续传）
        # bit1-客流统计（IPC）  （0-不续传，1-续传）
        # bit2-热度图统计（IPC） （0-不续传，1-续传）
        # bit3-人脸抓拍（IPC） （0-不续传，1-续传）
        # bit4-人脸对比（IPC） （0-不续传，1-续传）
        ("byBrokenNetHttp", BYTE),
        ("wTaskNo", WORD), # 任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应 同时 下发任务结构 NET_DVR_VEHICLE_RECOG_COND中的字段dwTaskNo对应)
        ("byDeployType", BYTE), # 布防类型：0-客户端布防，1-实时布防
        ("bySubScription", BYTE), # 订阅，按位表示，未开启订阅不上报  占位
        # Bit7-移动侦测人车分类是否传图；0-不传图(V30上报)，1-传图(V40上报)
        ("byRes1", BYTE * 2),
        ("byAlarmTypeURL", BYTE), # bit0-表示人脸抓拍报警上传（INTER_FACESNAP_RESULT）；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断,同时设备需要支持URL的相关服务，当前是”云存储“）
        # bit1-表示EVENT_JSON中图片数据长传类型；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断）
        # bit2 - 人脸比对(报警类型为COMM_SNAP_MATCH_ALARM)中图片数据上传类型：0 - 二进制传输，1 - URL传输
        # bit3 - 行为分析(报警类型为COMM_ALARM_RULE)中图片数据上传类型：0 - 二进制传输，1 - URL传输，本字段设备是否支持，对应软硬件能力集中<isSupportBehaviorUploadByCloudStorageURL>节点是否返回且为true
        ("byCustomCtrl", BYTE), # Bit0- 表示支持副驾驶人脸子图上传: 0-不上传,1-上传
    ]


LPNET_DVR_SETUPALARM_PARAM = POINTER(NET_DVR_SETUPALARM_PARAM)


class NET_DVR_SETUPALARM_PARAM_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLevel", BYTE), # 布防优先级，0-一等级（高），1-二等级（中），2-三等级（低）
        ("byAlarmInfoType", BYTE), # 上传报警信息类型（抓拍机支持），0-老报警信息（NET_DVR_PLATE_RESULT），1-新报警信息(NET_ITS_PLATE_RESULT)2012-9-28
        ("byRetAlarmTypeV40", BYTE), # 0--返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO, 1--设备支持NET_DVR_ALARMINFO_V40则返回NET_DVR_ALARMINFO_V40，不支持则返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO
        ("byRetDevInfoVersion", BYTE), # CVR上传报警信息回调结构体版本号 0-COMM_ALARM_DEVICE， 1-COMM_ALARM_DEVICE_V40
        ("byRetVQDAlarmType", BYTE), # VQD报警上传类型，0-上传报报警NET_DVR_VQD_DIAGNOSE_INFO，1-上传报警NET_DVR_VQD_ALARM
        # 1-表示人脸侦测报警扩展(INTER_FACE_DETECTION),0-表示原先支持结构(INTER_FACESNAP_RESULT)
        ("byFaceAlarmDetection", BYTE),
        # Bit0- 表示二级布防是否上传图片: 0-上传，1-不上传
        # Bit1- 表示开启数据上传确认机制；0-不开启，1-开启
        # Bit6- 表示雷达检测报警(eventType:radarDetection)是否开启实时上传；0-不开启，1-开启（用于web插件实时显示雷达目标轨迹）
        ("bySupport", BYTE),
        # 断网续传类型
        # bit0-车牌检测（IPC） （0-不续传，1-续传）
        # bit1-客流统计（IPC）  （0-不续传，1-续传）
        # bit2-热度图统计（IPC） （0-不续传，1-续传）
        # bit3-人脸抓拍（IPC） （0-不续传，1-续传）
        # bit4-人脸对比（IPC） （0-不续传，1-续传）
        # bit5-JSON报警透传（IPC） （0-不续传，1-续传）
        # bit6-热度图按人员停留时间统计数据上传事件（0-不续传，1-续传）
        # bit7-热度图按人数统计数据上传事件的确认机制（0-不续传，1-续传）
        ("byBrokenNetHttp", BYTE),
        ("wTaskNo", WORD), # 任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应 同时 下发任务结构 NET_DVR_VEHICLE_RECOG_COND中的字段dwTaskNo对应)
        ("byDeployType", BYTE), # 布防类型：0-客户端布防，1-实时布防
        ("bySubScription", BYTE), # 订阅，按位表示，未开启订阅不上报  占位
        # Bit7-移动侦测人车分类是否传图；0-不传图(V30上报)，1-传图(V40上报)
        ("byRes1", BYTE * 2),
        ("byAlarmTypeURL", BYTE), # bit0-表示人脸抓拍报警上传（INTER_FACESNAP_RESULT）；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断,同时设备需要支持URL的相关服务，当前是”云存储“）
        # bit1-表示EVENT_JSON中图片数据长传类型；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断）
        # bit2 - 人脸比对(报警类型为COMM_SNAP_MATCH_ALARM)中图片数据上传类型：0 - 二进制传输，1 - URL传输
        # bit3 - 行为分析(报警类型为COMM_ALARM_RULE)中图片数据上传类型：0 - 二进制传输，1 - URL传输，本字段设备是否支持，对应软硬件能力集中<isSupportBehaviorUploadByCloudStorageURL>节点是否返回且为true
        ("byCustomCtrl", BYTE), # Bit0- 表示支持副驾驶人脸子图上传: 0-不上传,1-上传
        ("byRes4", BYTE * 128),
    ]


LPNET_DVR_SETUPALARM_PARAM_V50 = POINTER(NET_DVR_SETUPALARM_PARAM_V50)


class NET_ITC_VIDEO_TRIGGER_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("dwTriggerMode", DWORD), # 视频触发模式类型，详见ITC_TRIGGERMODE_TYPE
        ("byRes", BYTE * 16),
    ]


LPNET_ITC_VIDEO_TRIGGER_COND = POINTER(NET_ITC_VIDEO_TRIGGER_COND)


# 条件结构
class NET_ITC_FTP_TYPE_COND(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号
        ("byWorkMode", BYTE), #  0-FTP1(主FTP)，1-FTP2(备FTP)
        ("byRes", BYTE * 7),
    ]


LPNET_ITC_FTP_TYPE_COND = POINTER(NET_ITC_FTP_TYPE_COND)

class NET_DVR_LATITUDE_PARAM(Structure):
    _fields_ = [
        ("byDegree", BYTE), # 度[0,179]
        ("byMinute", BYTE), # 分[0,59]
        ("bySec", BYTE), # 秒[0,59]
        ("byRes", BYTE),
    ]


LPNET_DVR_LATITUDE_PARAM = POINTER(NET_DVR_LATITUDE_PARAM)


class NET_DVR_LONGITUDE_PARAM(Structure):
    _fields_ = [
        ("byDegree", BYTE), # 度[0,179]
        ("byMinute", BYTE), # 分[0,59]
        ("bySec", BYTE), # 秒[0,59]
        ("byRes", BYTE),
    ]


LPNET_DVR_LONGITUDE_PARAM = POINTER(NET_DVR_LONGITUDE_PARAM)


class NET_DVR_GPS_DATACFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byGpsDataMode", BYTE), # GPS数据获取 0-自动，1-手动
        ("byLongitudeType", BYTE), # 经度 0-东经，1-西经
        ("byLatitudeType", BYTE), # 纬度 0-南纬，1-北纬
        ("byRes", BYTE),
        ("struLatitude", NET_DVR_LATITUDE_PARAM), # 纬度
        ("struLongitude", NET_DVR_LONGITUDE_PARAM), # 经度
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_GPS_DATACFG = POINTER(NET_DVR_GPS_DATACFG)


DATABASE_NULL = 0
        # DATABASE_SNAP,    抓拍数据库
        # DATABASE_FACE    人脸数据库


class NET_VCA_DATABASE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDataBaseID", DWORD), # 数据库ID（设备生成，添加时无效，修改和删除时有效）
        ("dwDataBaseType", DWORD), # 数据库类型，见VCA_DATABASE_TYPE
        ("byDataBaseName", BYTE * NAME_LEN), # 数据库名称
        ("byAttribute", BYTE * 64), # 数据库属性
        ("byRes", BYTE * 20),
    ]


LPNET_VCA_DATABASE_PARAM = POINTER(NET_VCA_DATABASE_PARAM)


class NET_VCA_FIND_DATABASE_COND(Structure):
    _fields_ = [
        ("dwDataBaseType", DWORD), # 数据库类型，详见VCA_DATABASE_TYPE
        ("byRes", BYTE * 12), # 保留
    ]


LPNET_VCA_FIND_DATABASE_COND = POINTER(NET_VCA_FIND_DATABASE_COND)


class NET_VCA_DELETE_DATABASE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDataBaseType", DWORD), # 数据库类型，见VCA_DATABASE_TYPE
        ("dwDataBaseID", DWORD), # 数据库ID
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_VCA_DELETE_DATABASE_COND = POINTER(NET_VCA_DELETE_DATABASE_COND)


class NET_VCA_INQUIRE_SNAPDB_COND(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号
        ("struStartTime", NET_DVR_TIME), # 开始时间
        ("struStopTime", NET_DVR_TIME), # 结束时间
        ("bySex", BYTE), # 性别：0-不启用，1-男，2-女
        ("byRes1", BYTE * 3), # 保留
        ("byStartBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 起始出生年月，如：201106
        ("byEndBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 截止出生年月，如201106
        ("byAttribute1", BYTE * NAME_LEN), # 属性1
        ("byAttribute2", BYTE * NAME_LEN), # 属性2
        ("byRes", BYTE * 12), # 保留
    ]


LPNET_VCA_INQUIRE_SNAPDB_COND = POINTER(NET_VCA_INQUIRE_SNAPDB_COND)


class NET_VCA_INQUIRE_SNAPRECORD_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwDataBaseID", DWORD), # 数据库ID
        ("dwRecordID", DWORD), # 记录ID
        ("struSnapTime", NET_DVR_TIME), # 抓拍时间
        ("bySex", BYTE), # 性别：0-不启用，1-男，2-女
        ("byRes1", BYTE * 3), # 保留
        ("byStartBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 起始出生年月，如：201106
        ("byEndBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 截止出生年月，如201106
        ("byAttribute1", BYTE * NAME_LEN), # 属性1
        ("byAttribute2", BYTE * NAME_LEN), # 属性2
        ("dwFacePicID", DWORD), # 人脸图ID
        ("dwFacePicLen", DWORD), # 人脸图数据长度
        ("byRes", BYTE * 80), # 保留
        ("*pFacePic", BYTE), # 人脸图数据
    ]


LPNET_VCA_INQUIRE_SNAPRECORD_RESULT = POINTER(NET_VCA_INQUIRE_SNAPRECORD_RESULT)


class NET_VCA_DELETE_SNAPRECORD_COND_UNION(Union):
    _fields_ = [
        ("struAttribute", NET_VCA_INQUIRE_SNAPDB_COND), # 人员信息（批量删除）
        ("dwRecordID", DWORD), # 记录ID（单条删除）
    ]


LPNET_VCA_DELETE_SNAPRECORD_COND_UNION = POINTER(NET_VCA_DELETE_SNAPRECORD_COND_UNION)


DELETE_RECORD_SINGLE = 0
        # DELETE_RECORD_BATCH    批量删除


class NET_VCA_DELETE_SNAPRECORD_COND(Structure):
    _fields_ = [
        ("dwDeleteType", DWORD), # 删除记录类型, VCA_DELETE_RECORD_TYPE
        ("uDeleteCond", NET_VCA_DELETE_SNAPRECORD_COND_UNION), # 删除参数
        ("byRes", BYTE * 40), # 保留
    ]


LPNET_VCA_DELETE_SNAPRECORD_COND = POINTER(NET_VCA_DELETE_SNAPRECORD_COND)


VCA_NORMAL_SEARCH_DATABASE = 0x00000000
VCA_ADVANCE_SEARCH_DATABASE = 0x00000001


class NET_VCA_ADVANCE_SEARCH_DATABASE_COND(Structure):
    _fields_ = [
        ("dwDataBaseType", DWORD), # 数据库类型，详见VCA_DATABASE_TYPE
        ("dwDataBaseID", DWORD), # 数据库ID
        ("dwFacePicID", DWORD), # 人脸图片ID
        ("byRes", BYTE * 36),
    ]


LPNET_VCA_ADVANCE_SEARCH_DATABASE_COND = POINTER(NET_VCA_ADVANCE_SEARCH_DATABASE_COND)


class NET_VCA_SEARCH_DATABASE_COND_UNION(Union):
    _fields_ = [
        ("uLen", DWORD * 25),
        ("struNormalFind", NET_VCA_REGISTER_PIC), # 普通检索
        ("struAdvanceFind", NET_VCA_ADVANCE_SEARCH_DATABASE_COND), # 高级检索
    ]


LPNET_VCA_SEARCH_DATABASE_COND_UNION = POINTER(NET_VCA_SEARCH_DATABASE_COND_UNION)


class NET_VCA_SEARCH_DATABASE_PARAM(Structure):
    _fields_ = [
        ("dwSearchType", DWORD), # 检索类型，详见VCA_SEARCH_DATABASE_TYPE
        ("uSearchCond", NET_VCA_SEARCH_DATABASE_COND_UNION), # 检索参数
        ("byRes", BYTE * 16),
    ]


LPNET_VCA_SEARCH_DATABASE_PARAM = POINTER(NET_VCA_SEARCH_DATABASE_PARAM)


class NET_VCA_SEARCH_SNAPDB_COND(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道
        ("dwDataBaseID", DWORD), # 数据库ID
        ("struStartTime", NET_DVR_TIME), # 开始时间
        ("struStopTime", NET_DVR_TIME), # 结束时间
        ("bySex", BYTE), # 性别：0-不启用，1-男，2-女
        ("byRes1", BYTE * 3), # 保留
        ("byStartBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 起始出生年月，如：201106
        ("byEndBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 截止出生年月，如201106
        ("byAttribute1", BYTE * NAME_LEN), # 属性1
        ("byAttribute2", BYTE * NAME_LEN), # 属性2
        ("struSearchParam", NET_VCA_SEARCH_DATABASE_PARAM), # 检索参数
        ("dwMaxSearchNum", DWORD), # 最大检索条数
        ("wThreshold", WORD), # 阈值，0-100
        ("byRes", BYTE * 78), # 保留
    ]


LPNET_VCA_SEARCH_SNAPDB_COND = POINTER(NET_VCA_SEARCH_SNAPDB_COND)


class NET_VCA_SEARCH_SNAPRECORD_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwDataBaseID", DWORD), # 数据库ID
        ("dwRecordID", DWORD), # 记录ID
        ("struSnapTime", NET_DVR_TIME), # 抓拍时间
        ("bySex", BYTE), # 性别：0-不启用，1-男，2-女
        ("byRes1", BYTE * 3), # 保留
        ("byStartBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 起始出生年月，如：201106
        ("byEndBirthDate", BYTE * MAX_HUMAN_BIRTHDATE_LEN), # 截止出生年月，如201106
        ("byAttribute1", BYTE * NAME_LEN), # 属性1
        ("byAttribute2", BYTE * NAME_LEN), # 属性2
        ("fSimilarity", DOUBLE), # 相似度，[0.001,1]
        ("dwFacePicID", DWORD), # 人脸图ID
        ("dwFacePicLen", DWORD), # 人脸图数据长度
        ("byRes", BYTE * 80), # 保留
        ("*pFacePic", BYTE), # 人脸图数据
    ]


LPNET_VCA_SEARCH_SNAPRECORD_RESULT = POINTER(NET_VCA_SEARCH_SNAPRECORD_RESULT)


class NET_VCA_DATARECORD_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwRecordID", DWORD), # 记录ID，添加时无效，修改时有效
        ("struAttribute", NET_VCA_HUMAN_ATTRIBUTE), # 人员信息
        ("struRegisterPic", NET_VCA_REGISTER_PIC), # 人员图片信息
        ("byRemark1", BYTE * NAME_LEN), # 备注信息1
        ("byRemark2", BYTE * 64), # 备注信息2
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_VCA_DATARECORD_INFO = POINTER(NET_VCA_DATARECORD_INFO)


class NET_VCA_FAST_DATARECORD_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struAttribute", NET_VCA_HUMAN_ATTRIBUTE), # 人员信息
        ("byRemark1", BYTE * NAME_LEN), # 备注信息1
        ("byRemark2", BYTE * 64), # 备注信息2
        ("dwImageLen", DWORD), # 图像数据长度
        ("byRes", BYTE * 80), # 保留
        ("*pImage", BYTE), # 图像数据
    ]


LPNET_VCA_FAST_DATARECORD_INFO = POINTER(NET_VCA_FAST_DATARECORD_INFO)


class NET_VCA_INQUIRE_DATARECORD_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwDataBaseID", DWORD), # 数据库ID
        ("dwRecordID", DWORD), # 记录ID
        ("struAttribute", NET_VCA_HUMAN_ATTRIBUTE), # 人员信息
        ("byRemark1", BYTE * NAME_LEN), # 备注信息1
        ("byRemark2", BYTE * 64), # 备注信息2
        ("dwFacePicID", DWORD), # 人脸图ID
        ("dwFacePicLen", DWORD), # 人脸图数据长度
        ("byRes", BYTE * 80), # 保留
        ("*pFacePic", BYTE), # 人脸图数据
    ]


LPNET_VCA_INQUIRE_DATARECORD_RESULT = POINTER(NET_VCA_INQUIRE_DATARECORD_RESULT)


class NET_VCA_SEARCH_DATARECORD_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwDataBaseID", DWORD), # 数据库ID
        ("dwRecordID", DWORD), # 记录ID
        ("struAttribute", NET_VCA_HUMAN_ATTRIBUTE), # 人员信息
        ("byRemark1", BYTE * NAME_LEN), # 备注信息1
        ("byRemark2", BYTE * 64), # 备注信息2
        ("fSimilarity", DOUBLE), # 相似度，[0.001,1]
        ("dwFacePicID", DWORD), # 人脸图ID
        ("dwFacePicLen", DWORD), # 人脸图数据长度
        ("byRes", BYTE * 80), # 保留
        ("*pFacePic", BYTE), # 人脸图数据
    ]


LPNET_VCA_SEARCH_DATARECORD_RESULT = POINTER(NET_VCA_SEARCH_DATARECORD_RESULT)


class NET_VCA_DATARECORD_COND(Structure):
    _fields_ = [
        ("dwDataBaseID", DWORD), # 数据库ID
        ("struAttribute", NET_VCA_HUMANATTRIBUTE_COND), # 人员信息
        ("byRes", BYTE * 80), # 保留
    ]


LPNET_VCA_DATARECORD_COND = POINTER(NET_VCA_DATARECORD_COND)


class NET_VCA_DELETE_RECORD_COND_UNION(Union):
    _fields_ = [
        ("struAttribute", NET_VCA_HUMANATTRIBUTE_COND), # 人员信息（批量删除）
        ("dwRecordID", DWORD), # 记录ID（单条删除）
    ]


LPNET_VCA_DELETE_RECORD_COND_UNION = POINTER(NET_VCA_DELETE_RECORD_COND_UNION)


class NET_VCA_DELETE_RECORD_COND(Structure):
    _fields_ = [
        ("dwDeleteType", DWORD), # 删除记录类型 VCA_DELETE_RECORD_TYPE
        ("uDeleteCond", NET_VCA_DELETE_RECORD_COND_UNION), # 删除参数
        ("byRes", BYTE * 40), # 保留
    ]


LPNET_VCA_DELETE_RECORD_COND = POINTER(NET_VCA_DELETE_RECORD_COND)


class NET_VCA_SEARCH_FACEDB_COND(Structure):
    _fields_ = [
        ("dwDataBaseID", DWORD), # 数据库ID
        ("struAttribute", NET_VCA_HUMANATTRIBUTE_COND), # 人员信息
        ("struSearchParam", NET_VCA_SEARCH_DATABASE_PARAM), # 检索参数
        ("dwMaxSearchNum", DWORD), # 最大检索条数
        ("wThreshold", WORD), # 阈值，0-100
        ("byRes", BYTE * 78), # 保留
    ]


LPNET_VCA_SEARCH_FACEDB_COND = POINTER(NET_VCA_SEARCH_FACEDB_COND)


class NET_VCA_FIND_MATCHPIC_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDataBaseType", DWORD), # 数据库类型，见VCA_DATABASE_TYPE
        ("dwDataBaseID", DWORD), # 数据库ID
        ("dwRecordID", DWORD), # 记录ID
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_VCA_FIND_MATCHPIC_COND = POINTER(NET_VCA_FIND_MATCHPIC_COND)


class NET_VCA_FIND_MATCHPIC_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDataBaseType", DWORD), # 数据库类型，见VCA_DATABASE_TYPE
        ("dwDataBaseID", DWORD), # 数据库ID
        ("dwRecordID", DWORD), # 记录ID
        ("dwPicLen", DWORD), # 图片长度
        ("byRes", BYTE * 64), # 保留
        ("*pPicBuffer", BYTE), # 图片数据指针
    ]


LPNET_VCA_FIND_MATCHPIC_RESULT = POINTER(NET_VCA_FIND_MATCHPIC_RESULT)


class NET_DVR_REMOTECONTROL_ALARM_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("wDealyTime", WORD), # 延迟时间，单位s
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_REMOTECONTROL_ALARM_PARAM = POINTER(NET_DVR_REMOTECONTROL_ALARM_PARAM)


class NET_DVR_REMOTECONTROL_STUDY_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_REMOTECONTROL_STUDY_PARAM = POINTER(NET_DVR_REMOTECONTROL_STUDY_PARAM)


class NET_DVR_WIRELESS_ALARM_STUDY_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byIndex", BYTE), # 无线报警序号，1-8
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_WIRELESS_ALARM_STUDY_PARAM = POINTER(NET_DVR_WIRELESS_ALARM_STUDY_PARAM)


MAX_AUX_ALARM_NUM = 8 # 最大辅助报警个数
MAX_WIRELESS_ALARM_NUM = 8 # 最大无线报警个数
IPC_AUXALARM_UNKNOW = 0
IPC_AUXALARM_PIR = 1
IPC_AUXALARM_WIRELESS = 2
IPC_AUXALARM_CALLHELP = 3


class NET_IPC_AUDIO_LIMIT_ALARM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("byRes1", BYTE * 3),
        ("dwDecibelLimit", DWORD), # 分贝告警阀值
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V30), # 异常处理方式
        ("byRes2", BYTE * 24),
    ]


LPNET_IPC_AUDIO_LIMIT_ALARM_CFG = POINTER(NET_IPC_AUDIO_LIMIT_ALARM_CFG)


class NET_IPC_BUTTON_DOWN_ALARM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("byRes1", BYTE * 3),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V30), # 异常处理方式
        ("byRes2", BYTE * 24),
    ]


LPNET_IPC_BUTTON_DOWN_ALARM_CFG = POINTER(NET_IPC_BUTTON_DOWN_ALARM_CFG)


class NET_IPC_PIR_ALARMCFG(Structure):
    _fields_ = [
        ("byAlarmName", BYTE * NAME_LEN), #  报警名称
        ("byAlarmHandle", BYTE), #  是否处理 0-不处理 1-处理
        ("byRes1", BYTE * 3),
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("byRes", BYTE * 64),
    ]


LPNET_IPC_PIR_ALARMCFG = POINTER(NET_IPC_PIR_ALARMCFG)


class NET_IPC_PIR_ALARMCFG_EX(Structure):
    _fields_ = [
        ("byAlarmName", BYTE * NAME_LEN), #  报警名称
        ("byAlarmHandle", BYTE), #  是否处理 0-不处理 1-处理
        ("byRes1", BYTE * 3),
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS),
        ("byRes", BYTE * 1464),
    ]


LPNET_IPC_PIR_ALARMCFG_EX = POINTER(NET_IPC_PIR_ALARMCFG_EX)


# 呼救报警
class NET_IPC_CALLHELP_ALARMCFG(Structure):
    _fields_ = [
        ("byAlarmHandle", BYTE), #  是否处理 0-不处理 1-处理
        ("byRes1", BYTE * 3),
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("byRes", BYTE * 64),
    ]


LPNET_IPC_CALLHELP_ALARMCFG = POINTER(NET_IPC_CALLHELP_ALARMCFG)


class NET_IPC_SINGLE_WIRELESS_ALARMCFG(Structure):
    _fields_ = [
        ("byAlarmName", BYTE * NAME_LEN), #  报警名称
        ("byAlarmHandle", BYTE), #  是否处理 0-不处理 1-处理
        ("byID", BYTE), # 无线报警ID，1-8
        ("byRes1", BYTE * 2),
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V30), #  处理方式
        ("byRelRecordChan", BYTE * MAX_CHANNUM_V30), # 报警触发的录象通道,为1表示触发该通道
        ("byRes", BYTE * 32),
    ]


LPNET_IPC_SINGLE_WIRELESS_ALARMCFG = POINTER(NET_IPC_SINGLE_WIRELESS_ALARMCFG)


class NET_IPC_WIRELESS_ALARMCFG(Structure):
    _fields_ = [
        ("struWirelessAlarm", NET_IPC_SINGLE_WIRELESS_ALARMCFG * MAX_WIRELESS_ALARM_NUM), # 单个无线报警参数
        ("byRes", BYTE * 32),
    ]


LPNET_IPC_WIRELESS_ALARMCFG = POINTER(NET_IPC_WIRELESS_ALARMCFG)


class NET_IPC_AUX_ALARMCFG_UNION(Union):
    _fields_ = [
        ("uLen", DWORD * 472),
        ("struPIRAlarm", NET_IPC_PIR_ALARMCFG_EX), # PIR报警参数
        ("struWirelessAlarm", NET_IPC_WIRELESS_ALARMCFG), # 无线报警参数
        ("struCallHelpAlarm", NET_IPC_CALLHELP_ALARMCFG), # 呼救报警参数
    ]


LPNET_IPC_AUX_ALARMCFG_UNION = POINTER(NET_IPC_AUX_ALARMCFG_UNION)


class NET_IPC_SINGLE_AUX_ALARMCFG(Structure):
    _fields_ = [
        ("byAlarmType", BYTE), # 报警器类型，详见IPC_AUX_ALARM_TYPE
        ("byRes1", BYTE * 3),
        ("uAlarm", NET_IPC_AUX_ALARMCFG_UNION), # 报警参数
        ("byRes", BYTE * 16),
    ]


LPNET_IPC_SINGLE_AUX_ALARMCFG = POINTER(NET_IPC_SINGLE_AUX_ALARMCFG)


class NET_IPC_AUX_ALARMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAlarm", NET_IPC_SINGLE_AUX_ALARMCFG * MAX_AUX_ALARM_NUM), # 报警参数
        ("byRes", BYTE * 64),
    ]


LPNET_IPC_AUX_ALARMCFG = POINTER(NET_IPC_AUX_ALARMCFG)


class NET_IPC_AUXALARM_UPLOAD_UNION(Union):
    _fields_ = [
        ("uLen", DWORD * 66),
        ("struPIRAlarm", NET_IPC_PIR_ALARMCFG), # PIR报警参数
        ("struWirelessAlarm", NET_IPC_SINGLE_WIRELESS_ALARMCFG), # 无线报警参数
        ("struCallHelpAlarm", NET_IPC_CALLHELP_ALARMCFG), # 呼救报警参数
    ]


LPNET_IPC_AUXALARM_UPLOAD_UNION = POINTER(NET_IPC_AUXALARM_UPLOAD_UNION)


class NET_IPC_AUXALARM_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byAlarmType", BYTE), # 报警器类型，详见IPC_AUX_ALARM_TYPE
        ("byRes1", BYTE * 3),
        ("struAuxAlarm", NET_IPC_AUXALARM_UPLOAD_UNION), # 报警结果参数
        ("byDeviceID", BYTE * NAME_LEN), # 设备的ID串
        ("byRes", BYTE * 32),
    ]


LPNET_IPC_AUXALARM_RESULT = POINTER(NET_IPC_AUXALARM_RESULT)


class NET_DVR_PREVIEW_DISPLAYCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byCorrectMode", BYTE), # 校正模式，0-软件校正，1-芯片校正
        ("byMountType", BYTE), # 安装类型，0-吸顶，1-桌面，2-墙面
        #
        # 0-模式1：鱼眼+全景+3PTZ (与原有非实时模式一致)；
        # 1-模式2：鱼眼+4PTZ(与原有实时模式一致)；
        # 2-模式3：鱼眼(主)+鱼眼(子)+3PTZ；
        # 3-模式4：全景展开(主码流+子码流)；
        # 4-模式5：4PTZ；
        # 5-模式6：鱼眼；
        # 6-模式7: 经纬度全景展开模式；
        # 7-模式8: 4PTZ融合模式；
        #
        ("byRealTimeOutput", BYTE), # 实时输出，0 -不启用，1- 启用
        ("byRes", BYTE * 61),
    ]


LPNET_DVR_PREVIEW_DISPLAYCFG = POINTER(NET_DVR_PREVIEW_DISPLAYCFG)


class NET_DVR_REMOTECONTROL_PTZ_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("dwPTZCommand", DWORD), # PTZ控制命令
        ("struVcaPoint", NET_VCA_POINT), # 预览界面点坐标
        ("dwSpeed", DWORD), # 控制的速度，取值范围[0,7]
        ("dwStop", DWORD), # 停止动作或开始动作：0-开始；1-停止
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_REMOTECONTROL_PTZ_PARAM = POINTER(NET_DVR_REMOTECONTROL_PTZ_PARAM)


class NET_DVR_PRESET_POINT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("dwPTZPresetCmd", DWORD), # 预置点控制命令
        ("struVcaPoint", NET_VCA_POINT), # 预览界面点坐标
        ("dwPresetIndex", DWORD), # 预置点的序号（从1开始），最多支持255个预置点
        ("wZoomCoordinate", WORD), # /<预置点窗口Zoom值
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_PRESET_POINT_PARAM = POINTER(NET_DVR_PRESET_POINT_PARAM)


class NET_DVR_PTZ_CRUISE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("dwPTZCruiseCmd", DWORD), # 巡航控制命令
        ("struVcaPoint", NET_VCA_POINT), # 预览界面点坐标
        ("wCruiseRoute", WORD), # 巡航路径，最多支持32条路径（序号从1开始）
        ("wCruisePoint", WORD), # 巡航点，最多支持32个点（序号从1开始）
        ("wInput", WORD), # 不同巡航命令时的值不同，预置点(最大255)、时间(最大255)、速度(最大40)
        ("wZoomCoordinate", WORD), # /<预置点窗口Zoom值
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_PTZ_CRUISE_PARAM = POINTER(NET_DVR_PTZ_CRUISE_PARAM)


class NET_DVR_WPS_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableWps", BYTE), # 启用WPS，0-否，1-是
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_WPS_PARAM = POINTER(NET_DVR_WPS_PARAM)


class NET_DVR_PIN_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPIN", BYTE * 8), # PIN码
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_PIN_PARAM = POINTER(NET_DVR_PIN_PARAM)


class NET_DVR_WPS_CONNECT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byConnectType", BYTE), # WPS连接方式，0-PBC,1-AP PIN
        ("byRes1", BYTE * 3),
        ("byPIN", BYTE * 8), # PIN码(WPS连接方式为AP PIN时有效)
        ("byEssid", BYTE * IW_ESSID_MAX_SIZE), # essid(WPS连接方式为AP PIN时有效)
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_WPS_CONNECT_PARAM = POINTER(NET_DVR_WPS_CONNECT_PARAM)


class NET_DVR_DECODER_JOINT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byJointed", BYTE), #   0 没有关联 1 已经关联
        ("byRes1", BYTE * 3), #  保留字节
        ("struIP", NET_DVR_IPADDR), #  被关联解码器的IP地址
        ("wPort", WORD), #  被关联解码器的端口号
        ("wChannel", WORD), #  被关联解码器的解码通道号
        ("sDeviceName", BYTE * NAME_LEN), # 被关联解码器的设备名称
        ("sChanName", BYTE * NAME_LEN), # 被关联解码器的解码通道名称
        ("byRes2", BYTE * 32), #  保留字节
    ]


LPNET_DVR_DECODER_JOINT_PARAM = POINTER(NET_DVR_DECODER_JOINT_PARAM)


class NET_DVR_PIC_VIEW_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struCuIp", NET_DVR_IPADDR), # CU端IP地址
        ("wPort", WORD), # CU端口
        ("bySourceIndex", BYTE), # 信号源通道号
        ("byRes", BYTE * 29),
    ]


LPNET_DVR_PIC_VIEW_PARAM = POINTER(NET_DVR_PIC_VIEW_PARAM)


DVCS_DEVICEID_LEN = 16
# 2012-03-13图片回显注册消息回调
class NET_DVR_PICVIEW_CALLBACKPARAM(Structure):
    _fields_ = [
        ("dwUserID", DWORD),
        ("sDeviceID", BYTE * DVCS_DEVICEID_LEN),
        ("nPicViewHandle", LONG), # 回显句柄
        ("wSignalIndex", WORD), # 信号源索引
        ("wHeadLen", WORD), # 文件头长度 私有的码流文件头都是40
        ("byHeadBuf", BYTE * 100), # 文件头
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_PICVIEW_CALLBACKPARAM = POINTER(NET_DVR_PICVIEW_CALLBACKPARAM)


DEVICEID_LEN = 32
class NET_DVR_DEVICEID_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDeviceIndex", DWORD), # 设备序号
        ("byWallNo", BYTE), # 墙号，从1开始
        ("byRes1", BYTE * 27),
        ("dwChan", DWORD), # 通道号
        ("dwInputSignalIndex", DWORD), # 信号源索引，集中式大屏控制器使用
        ("byRes2", BYTE * 60),
    ]


LPNET_DVR_DEVICEID_INFO = POINTER(NET_DVR_DEVICEID_INFO)


class NET_DVR_SINGLE_NETPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byUseDhcp", BYTE), # 是否启用DHCP 0xff-无效 0-不启用 1-启用
        ("byRes1", BYTE * 3),
        ("struDevIP", NET_DVR_IPADDR), #  设备IP地址
        ("struSubnetMask", NET_DVR_IPADDR), #  设备子网掩码
        ("struGateway", NET_DVR_IPADDR), #  设备网关
        ("wDevPort", WORD), #  设备端口号
        ("byMACAddr", BYTE * MACADDR_LEN), #  MAC 地址(只能获取)
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_SINGLE_NETPARAM = POINTER(NET_DVR_SINGLE_NETPARAM)


class NET_DVR_CHAN_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), # 0-无效 1-有效
        ("byRes1", BYTE * 3),
        ("sChanName", BYTE * NAME_LEN), # 通道名称
        ("struVideoColor", NET_DVR_COLOR), # 信号源颜色
        ("wResolutionX", WORD), # 当前分辨率---宽
        ("wResolutionY", WORD), # 当前分辨率---高
        ("byRes2", BYTE * 40),
    ]


LPNET_DVR_CHAN_INFO = POINTER(NET_DVR_CHAN_INFO)


# 编码子设备信息
class NET_DVR_CODEDEV_INFO(Structure):
    _fields_ = [
        ("struChanInfo", NET_DVR_CHAN_INFO * MAX_CHANNUM), # 设备通道信息
    ]


LPNET_DVR_CODEDEV_INFO = POINTER(NET_DVR_CODEDEV_INFO)


# 解码子设备信息
class NET_DVR_DECODEDEV_INFO(Structure):
    _fields_ = [
        ("byRes", BYTE * 1408),
    ]


LPNET_DVR_DECODEDEV_INFO = POINTER(NET_DVR_DECODEDEV_INFO)


# 网络信号源信息
class NET_DVR_NETSIGNAL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDevName", BYTE * NAME_LEN), # 网络信号源名称
        ("struPuStream", NET_DVR_PU_STREAM_CFG),
        ("byValid", BYTE), # 是否有效，0-无效，删除时设为0  1-有效，添加和修改时设为1/
        ("byRes1", BYTE * 3), # 保留
        ("sGroupName", BYTE * NAME_LEN), # 网络信号源所在组的组名，网络信号源根据这个组名来分类
        ("wResolutionX", WORD), # 当前分辨率---宽
        ("wResolutionY", WORD), # 当前分辨率---高
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_NETSIGNAL_INFO = POINTER(NET_DVR_NETSIGNAL_INFO)


class NET_DVR_NETSIGNALDEV_INFO(Structure):
    _fields_ = [
        ("struDevInfo", NET_DVR_NETSIGNAL_INFO),
        ("byRes1", BYTE * 816),
    ]


LPNET_DVR_NETSIGNALDEV_INFO = POINTER(NET_DVR_NETSIGNALDEV_INFO)


class NET_DVR_DIFFDEV_INFO(Union):
    _fields_ = [
        ("struCodeDevInfo", NET_DVR_CODEDEV_INFO), # 编码设备信息
        ("struDecodeDevInfo", NET_DVR_DECODEDEV_INFO), # 解码设备信息
        ("struNetSignalInfo", NET_DVR_NETSIGNALDEV_INFO), # 网络信号源信息
    ]


LPNET_DVR_DIFFDEV_INFO = POINTER(NET_DVR_DIFFDEV_INFO)


# 注册设备信息
NET_DVR_BNC_PROC = 1
        # NET_DVR_RGB_PROC,                        RGB处理器
        # NET_DVR_STP_PROC,                        转码处理器
        # NET_DVR_DISP_PROC,                       显示处理器
        # NET_DVR_NETSIGNAL,                      网络信号源
        # NET_DVR_SDI_PROC,                       SDI处理器
        # NET_DVR_BIW_PROC,                       8路BNC处理器
        # NET_DVR_DON_PROC,                       显示处理器
        # NET_DVR_TVI_PROC,                       TVI处理器
        # NET_DVR_DI2_PROC,                       2路DVI输入处理器
        # NET_DVR_DO2_PROC,                       2路DVI输出设备
        # NET_DVR_UHDI_PROC,                      DP/HDMI 1路4K超高清输入设备
        # NET_DVR_YI2_PROC,                        两路YPbPr输入板
        # NET_DVR_HI2_PROC,                         HDMI输入节点(2路)
        # NET_DVR_VI2_PROC,                         VGA输入节点(2路)
        # NET_DVR_SI2_PROC,                         SDI输入节点(2路)
        # NET_DVR_HO2_PROC,                         HDMI输出节点(2路)
        # NET_DVR_S24G_PROC,                         C20N专用千兆交换机(24路)
        # NET_DVR_S24X_PROC                         C20N专用万兆交换机(24路)


class NET_DVR_SINGLE_DEV_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSoftVersion", DWORD), # 设备软件版本号(只能获取) 最高8位为主版本号，次高8位为次版本号，低16位为修复版本号
        ("dwSoftwareBuildDate", DWORD), # 版本编译日期Build, 0xYYYYMMDD
        ("byUseInSys", BYTE), # 是否在系统中使用
        ("byDevStatus", BYTE), # 设备当前状态，0-下线，1-上线(只能获取)
        ("byDeviceType", BYTE), # 设备类型(只能获取)  见DEVICE_TYPE
        ("byRes1", BYTE * 17),
        ("sDevName", BYTE * NAME_LEN), # 设备名称
        ("struEtherNet", NET_DVR_SINGLE_NETPARAM * MAX_ETHERNET), # 设备网络参数
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 设备序列号
        ("struSubDevInfo", NET_DVR_DIFFDEV_INFO), # 设备信息
        ("dwDeviceIndex", DWORD), # 设备序号，相对于C20N或Y10等设备的全局编号
        ("dwSubBoardNo", DWORD), # 分布式设备所属的子板编号，相对于C20N或Y10等设备的全局编号，从1开始，为0时该字段无效，子板编号默认为1
        ("bySubSysNo", BYTE), # 分布式设备所属的子板上的子系统编号，相对于子板全局，从1开始，为0时该字段无效，子系统号默认为1
        ("byRes3", BYTE * 3),
        ("wStartAudioTalkChanNo", WORD), # 分布式设备上语音对讲的起始通道号
        ("wAudioTalkChanNum", WORD), # 分布式设备上语音对讲通道号的数量
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_SINGLE_DEV_INFO = POINTER(NET_DVR_SINGLE_DEV_INFO)


class NET_DVR_DEVLIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDevNums", DWORD), # 设备返回的分布式子设备数量
        ("*pBuffer", BYTE),
        ("byRes1", BYTE * 3),
        ("dwBufLen", DWORD), # 所分配指针长度，输入参数
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_DEVLIST = POINTER(NET_DVR_DEVLIST)


class NET_DVR_DEV_BASE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否在系统中使用
        ("byDeviceType", BYTE), # 设备类型(只能获取)
        ("byRes1", BYTE * 2),
        ("sDevName", BYTE * NAME_LEN), # 设备名称
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_DEV_BASE_INFO = POINTER(NET_DVR_DEV_BASE_INFO)


# 网络配置信息
class NET_DVR_NETPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struEtherNet", NET_DVR_SINGLE_NETPARAM * MAX_ETHERNET), # 以太网口
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_NETPARAM = POINTER(NET_DVR_NETPARAM)


#  绑定屏幕和设备关系(16个字节)
class NET_DVR_DISP_SCREEN(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wScreenID", WORD), #  屏幕ID号, ID号从1开始
        ("byWallNo", BYTE), #  电视墙号
        ("byRes1", BYTE), #  保留1
        ("dwDeviceIndex", DWORD), #  输出设备序号
        ("byRes2", BYTE * 16), #  保留2
    ]


LPNET_DVR_DISP_SCREEN = POINTER(NET_DVR_DISP_SCREEN)


#  屏幕控制
class NET_DVR_TEXTSHOW(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byShowText", BYTE), # 是否显示文字，1-显示文字，0-不显示文字
        ("byRes", BYTE * 35),
    ]


LPNET_DVR_TEXTSHOW = POINTER(NET_DVR_TEXTSHOW)


class NET_DVR_SCREENLIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWallNo", BYTE), # 电视墙号，从1开始
        ("byRes", BYTE * 11),
        ("dwScreenNums", DWORD), # 设备返回的映射显示屏数量
        ("*pBuffer", BYTE),
        ("dwBufLen", DWORD), # 所分配指针长度，输入参数
    ]


LPNET_DVR_SCREENLIST = POINTER(NET_DVR_SCREENLIST)


class NET_DVR_OPERATE_DEVICE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSubCommand", DWORD), # 设置设备的命令，1-设备开始升级，2-停止升级
        ("dwDeviceIndex", DWORD), # 设备序号
        ("byRes", BYTE * 44),
    ]


LPNET_DVR_OPERATE_DEVICE = POINTER(NET_DVR_OPERATE_DEVICE)


# 设备升级
class NET_DVR_UPGRADE_STATE(Structure):
    _fields_ = [
        ("dwProgress", DWORD), #  0-100
        ("byState", BYTE), # 升级进度：1-升级完成 2-正在升级 3-升级失败
        ("byRes2", BYTE * 31),
    ]


LPNET_DVR_UPGRADE_STATE = POINTER(NET_DVR_UPGRADE_STATE)

class NET_DVR_START_PIC_VIEW_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSignalIndex", DWORD), # 信号源序号，该参数用于大屏控制器，其他设备该值设为0
        ("dwDeviceIndex", DWORD), # 设备序号
        ("byRes1", BYTE * 12),
        ("byChanIndex", BYTE), # 通道号
        ("byRes2", BYTE * 3),
        # 视频综合平台回显参数
        ("dwScreenNum", DWORD), # 大屏序号：从零开始
        ("dwLayer", DWORD), # 图层号：从零开始
        ("dwResolution", DWORD), # 回显分辨率,1-QCIF,2-CIF,3-D1
        ("byFrame", BYTE), # 帧率，单位：帧/秒
        ("bySupportStreamView", BYTE), # 客户端是否支持码流回显，0-不支持，1-支持
        ("byRes3", BYTE * 14),
    ]


LPNET_DVR_START_PIC_VIEW_INFO = POINTER(NET_DVR_START_PIC_VIEW_INFO)


class NET_DVR_DVCS_STATE_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAlarmType", BYTE), #  报警类型,1-设备上线，2-设备离线 3-服务器上线 4-服务器离线 5-管理员登陆 6-预案开始,7-预案结束，8-分辨率变化，9-图像切割失败，10-设备资源不足，11-温度异常  12-窗口大小与信号源分辨率不符合
        ("byDeviceType", BYTE), #  设备类型 见定义NET_DVCS_DEVICE_TYPE
        ("byWallNo", BYTE), #  墙号，从1开始， 0表示无效
        ("byDeviceChanIndex", BYTE), #  设备通道号，0表示无效，其他值表示通道号
        ("dwDeviceIndex", DWORD), #  设备序号， 0表示无效
        ("wResolutionX", WORD), #  分辨率-宽  0表示无效
        ("wResolutionY", WORD), #  分辨率-高  0表示无效
        ("wTemperature", WORD), #  设备温度 单位：摄氏度, 0表示无效
        ("byRes", BYTE * 86),
    ]


LPNET_DVR_DVCS_STATE_ALARM = POINTER(NET_DVR_DVCS_STATE_ALARM)


class NET_DVR_PIC_ADJUST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySubCommand", BYTE), # 见宏定义DECODEPIC_LEFTADJUST等
        ("byScale", BYTE), # 调整的量值
        ("byPictureProportion", BYTE), # 图像缩放比例 0-无效 1-4:3, 2-16:9
        ("byRes", BYTE * 29),
    ]


LPNET_DVR_PIC_ADJUST = POINTER(NET_DVR_PIC_ADJUST)


class NET_DVR_PICTURE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byControlCommand", BYTE), # 切换命令，1-显示，2-隐藏，3-全部删除（针对GIF图片    ）
        ("byUseType", BYTE), # 图片类型，1-OSD 2-底图，3-GIF
        ("byWallNo", BYTE), # 电视墙墙号，从1开始
        ("byPictureNo", BYTE), # 图片序号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PICTURE_PARAM = POINTER(NET_DVR_PICTURE_PARAM)


#  76SP设备POE通道添加方式配置
class NET_DVR_POE_CHANNEL_ADD_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byAddMode", BYTE), # 添加方式 0: 即插即用 1: 手动添加
        ("byRes1", BYTE * 127), # 保留
    ]


LPNET_DVR_POE_CHANNEL_ADD_MODE = POINTER(NET_DVR_POE_CHANNEL_ADD_MODE)


MAX_ESATA_NUM = 16
MAX_MINISAS_NUM = 96
class NET_DVR_ESATA_MINISAS_USAGE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byESATAUsage", BYTE * MAX_ESATA_NUM), #  数组索引表示第几个eSATA，0：默认备份 1：默认录像
        ("byMiniSASUsage", BYTE * MAX_MINISAS_NUM), #  数组索引表示第几个miniSAS，0：默认备份 1：默认录像
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_ESATA_MINISAS_USAGE = POINTER(NET_DVR_ESATA_MINISAS_USAGE)


MAX_DISK_NUM = 128
class NET_DVR_BACKUP_LOG_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDiskDesc", BYTE * DESC_LEN_32), # 备份磁盘描述
        ("byHardDisk", BYTE * MAX_DISK_NUM), # 需备份的硬盘号，备份几个取前几个
        ("byBackupHardDiskNum", BYTE), # 需备份的硬盘个数
        ("byContinue", BYTE), # 是否继续备份，0-不继续，1-继续
        ("byAllLogBackUp", BYTE), # 是否全部备份，0-按磁盘号备份，1-备份所有日志，当为1时，需备份的磁盘号和硬盘个数无效
        ("byRes", BYTE * 29),
    ]


LPNET_DVR_BACKUP_LOG_PARAM = POINTER(NET_DVR_BACKUP_LOG_PARAM)


class NET_DVR_DIGITAL_CHANNEL_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDigitalAudioChanTalkState", BYTE * MAX_CHANNUM_V30), # 表示数字语音通道的对讲状态 0-未使用，1-使用中, 0xff无效
        ("byDigitalChanState", BYTE * MAX_CHANNUM_V30), # 数字通道的连接状态 byDigitalChanErrState[0]
        # 表示第一个数字通道，具体值表示状态码，祥见NET_SDK_DIGITAL_CHANNEL_STATUS，以此类推，0表示无效
        ("byDigitalAudioChanTalkStateEx", BYTE * MAX_CHANNUM_V30*3), # 表示数字语音通道的对讲状态，从第MAX_CHANNUM_V30+1 到第MAX_CHANNUM_V30*4个， 0-未使用，1-使用中, 0xff无效
        ("byDigitalChanStateEx", BYTE * MAX_CHANNUM_V30*3), # 数字通道的连接状态 byDigitalChanErrStateEx[0]表示第从第MAX_CHANNUM_V30+1个个数字通道，具体值表示状态码，祥见NET_SDK_DIGITAL_CHANNEL_STATUS，以此类推，0表示无效
        ("byAnalogChanState", BYTE * MAX_ANALOG_CHANNUM), # 表示模拟通道是否启用,0-禁用,1-启用
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DIGITAL_CHANNEL_STATE = POINTER(NET_DVR_DIGITAL_CHANNEL_STATE)


# 数字通道状态
# ************************************ITS***************************
VERSION_LEN = 32 # 版本长度
MAX_OVERLAP_ITEM_NUM = 50 # 最大字符叠加种数
ITS_MAX_DEVICE_NUM = 32 # 最大设备个数
# 终端基本信息
class NET_ITS_BASEINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMainVer", BYTE * VERSION_LEN), #  算法主流程版本
        ("byMprVer", BYTE * VERSION_LEN), #  多帧识别库版本
        ("byBvtVer", BYTE * VERSION_LEN), #  背向视频库版本
        ("byLptVer", BYTE * VERSION_LEN), #  视频跟踪库版本
        ("byTvdVer", BYTE * VERSION_LEN), #  违章检测库版本
        ("byTldVer", BYTE * VERSION_LEN), #  信号灯检测库版本
        ("byRes", BYTE * 252), #  预留字段
    ]


LPNET_ITS_BASEINFO = POINTER(NET_ITS_BASEINFO)


# 图片合成参数
class NET_ITS_IMGMERGE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIsMerge", BYTE), # 是否需要合成（0：不合成；1：合成）
        ("byCloseupProportion", BYTE), # 特写图比例 1-原始分辨率大小，2-宽高为原始分辨率两倍，以此类推(1～8)
        ("byRes1", BYTE * 2),
        ("dwOneMergeType", DWORD), # 抓拍单张图合成方式（可能会截取特写图）
        # **********************************************************************
        # 201 两张图片上下排列合成,合成后图片宽为单张图的1倍,高为2倍
        # 202 两张图片左右排列合成,合成后图片宽为单张图的2倍,高为1倍
        # 203 上下合成，特写在最上边.
        # 204 上下合成，特写在最下边.
        # 205 左右合成，特写在最右边。
        # 206 左右合成，特写在最左边
        # 207 品字合成，特写图在上边
        # 208 倒品字合成，特写图在下边
        # 209 唱字形，左边1张为特写
        # 210 反唱字形，右边1张为特写
        # 301 三张图片上下排列合成,合成后图片宽为单张图的1倍,高为3倍
        # 302 三张图片左右排列合成,合成后图片宽为单张图的3倍,高为1倍
        # 303 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
        # 特写在右下 合成后图片宽为单张图的2倍,高为2倍
        # 304 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
        # 特写在右下 合成后图片宽为单张图的1倍,高为1倍
        # 305 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
        # 特写在左上 合成后图片宽为单张图的2倍,高为2倍
        # 306 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
        # 特写在左上 压缩图片分辨率,合成后图片宽为单张图的1倍,高为1倍
        # 307 三张图片"品"字型排列合成
        # 308 三张图片倒"品"字型排列合成
        # 309 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
        # 特写在左下 合成后图片宽为单张图的2倍,高为2倍
        # 310 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
        # 特写在左下 合成后图片宽为单张图的1倍,高为1倍
        # 311 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
        # 特写在右上 合成后图片宽为单张图的2倍,高为2倍
        # 312 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
        # 特写在右上 压缩图片分辨率,合成后图片宽为单张图的1倍,高为1倍
        #
        # 313 从三张图片中取一幅车牌特写区域，组成四张图片；
        # 四张图片横"一"字型合成，
        # 顺序为：特写图、场景图、场景图、场景图
        # 314 从三张图片中取一幅车牌特写区域，组成四张图片；
        # 四张图片横"一"字型合成，
        # 顺序为：场景图、特写图、场景图、场景图
        # 315 从三张图片中取一幅车牌特写区域，组成四张图片；
        # 四张图片横"一"字型合成，
        # 顺序为：场景图、场景图、特写图、场景图
        # 316 从三张图片中取一幅车牌特写区域，组成四张图片；
        # 四张图片横"一"字型合成，
        # 顺序为：场景图、场景图、场景图、特写图
        # 317 从三张图片中取一幅车牌特写区域，组成四张图片；
        # 四张图片竖"1"字型合成，
        # 顺序为：特写图、场景图、场景图、场景图
        # 318 从三张图片中取一幅车牌特写区域，组成四张图片；
        # 四张图片竖"1"字型合成，
        # 顺序为：场景图、特写图、场景图、场景图
        # 319 从三张图片中取一幅车牌特写区域，组成四张图片；
        # 四张图片竖"1"字型合成，
        # 顺序为：场景图、场景图、特写图、场景图
        # 320 从三张图片中取一幅车牌特写区域，组成四张图片；
        # 四张图片竖"1"字型合成，
        # 顺序为：场景图、场景图、场景图、特写图
        # **********************************************************************
        ("dwTwoMergeType", DWORD), # 抓拍两张图合成方式
        ("dwThreeMergeType", DWORD), # 抓拍三张图合成方式
        ("dwJpegQuality", DWORD), # 压缩质量（0~100）
        ("dwCloseupIndex", DWORD), # 特写图抓拍第几张
        ("dwMerageMaxSize", DWORD), # 合成图片大小的上限,300-10240(单位KB)
        ("wCloseupDeviation", WORD), #  特写图偏移量(50~图片高度)，单位:像素
        ("byRes", BYTE * 30),
    ]


LPNET_ITS_IMGMERGE_CFG = POINTER(NET_ITS_IMGMERGE_CFG)


# 交通数据主机
class NET_ITS_TRAFFIC_DATA_HOST(Structure):
    _fields_ = [
        ("struHostAddr", NET_DVR_IPADDR), #  远程主机IP
        ("wHostPort", WORD), #  远程主机Port
        ("byRes1", BYTE * 2),
        ("dwDataType", DWORD), #  上传远程主机的数据类型（定义见下），按位表示
        ("bySuspendUpload", BYTE), #  是否暂停数据上传：0-正常上传；1-暂停上传
        ("byUploadStrategy", BYTE), #  上传策略：0-最新数据优先上传；1-按照通行时间上传
        ("wUploadInterval", WORD), #  上传间隔时间（ms，1~2000），该参数只对历史数据有效
        ("dwUploadTimeOut", DWORD), # 上传超时时间
        ("byRes", BYTE * 24),
    ]


LPNET_ITS_TRAFFIC_DATA_HOST = POINTER(NET_ITS_TRAFFIC_DATA_HOST)


# 数据上传参数
class NET_ITS_UPLOAD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRemoteDataHost1", NET_ITS_TRAFFIC_DATA_HOST), # 接收交通数据主机1
        ("struRemoteDataHost2", NET_ITS_TRAFFIC_DATA_HOST), # 接收交通数据主机2
    ]


LPNET_ITS_UPLOAD_CFG = POINTER(NET_ITS_UPLOAD_CFG)


class NET_DVR_SYSTEM_TIME(Structure):
    _fields_ = [
        ("wYear", WORD), # 年
        ("wMonth", WORD), # 月
        ("wDay", WORD), # 日
        ("wHour", WORD), # 时
        ("wMinute", WORD), # 分
        ("wSecond", WORD), # 秒
        ("wMilliSec", WORD), # 毫秒
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_SYSTEM_TIME = POINTER(NET_DVR_SYSTEM_TIME)


# 交通数据主机状态信息
class NET_ITS_TRAFFIC_DATA_INFO(Structure):
    _fields_ = [
        ("dwDataQuantity", DWORD), # 数据总量
        ("dwDataRsendQuantity", DWORD), # 未发送数量（需要上传交通数据主机的）
        ("struStartTime", NET_DVR_SYSTEM_TIME), # 未发送数据的最早时间
        ("struEndTime", NET_DVR_SYSTEM_TIME), # 未发送数据的最晚时间
        ("struDataHost", NET_DVR_IPADDR), # 接收交通数据主机
    ]


LPNET_ITS_TRAFFIC_DATA_INFO = POINTER(NET_ITS_TRAFFIC_DATA_INFO)


# 终端工作状态
class NET_ITS_WORKSTATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDevName", BYTE * NAME_LEN), #  设备名称
        ("dwRunTime", DWORD), #  系统运行时间，单位s
        ("struTrafficDataInfo", NET_ITS_TRAFFIC_DATA_INFO * 2), # 支持两台主机（数据上传配置的主机）
        ("dwMemoryUsage", DWORD), #  内存占用率（如果内存占用率为30%，此处填30）
        ("dwCpuUsage", DWORD), #  cpu占用率（如果cpu占用率为30%，此处填30）
        ("dwDevTemperature", DWORD), #  本机温度
        ("dwDeviceStatic", DWORD), #  设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
        ("struHardDiskStatic", NET_DVR_DISKSTATE * MAX_DISKNUM_V30), # 硬盘状态
        ("struChanStatic", NET_DVR_CHANNELSTATE_V30 * MAX_CHANNUM_V30), # 通道的状态
        ("byAlarmInStatic", BYTE * MAX_ALARMIN_V30), # 报警输入口的状态,0-没有报警,1-有报警
        ("byAlarmOutStatic", BYTE * MAX_ALARMOUT_V30), # 报警输出端口的状态,0-没有输出,1-有报警输出
        ("dwLocalDisplay", DWORD), # 本地显示状态,0-正常,1-不正常
        ("byAudioInChanStatus", BYTE * 8), # 表示语音通道的状态 0-未使用，1-使用中，数组0表示第1个语音通道
        ("byRes", BYTE * 36), # 保留
    ]


LPNET_ITS_WORKSTATE = POINTER(NET_ITS_WORKSTATE)


# 出入口交通配置获取参数
class NET_ITS_ECT_WORKSTATE_COMMAND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_ITS_ECT_WORKSTATE_COMMAND = POINTER(NET_ITS_ECT_WORKSTATE_COMMAND)


class NET_ITS_ECTWORKSTATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDevName", BYTE * NAME_LEN), #  设备名称
        ("dwRunTime", DWORD), #  系统运行时间，单位s
        ("struTrafficDataInfo", NET_ITS_TRAFFIC_DATA_INFO * 2), # 支持两台主机（数据上传配置的主机）
        ("dwMemoryUsage", DWORD), #  内存占用率（如果内存占用率为30%，此处填30）
        ("dwCpuUsage", DWORD), #  cpu占用率（如果cpu占用率为30%，此处填30）
        ("dwDevTemperature", DWORD), #  本机温度
        ("dwDeviceStatic", DWORD), #  设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
        ("struHardDiskStatic", NET_DVR_DISKSTATE * MAX_DISKNUM_V30), # 硬盘状态
        ("byAlarmInStatic", BYTE * MAX_ALARMIN_V30), # 报警输入口的状态,0-没有报警,1-有报警
        ("byAlarmOutStatic", BYTE * MAX_ALARMOUT_V30), # 报警输出端口的状态,0-没有输出,1-有报警输出
        ("dwLocalDisplay", DWORD), # 本地显示状态,0-正常,1-不正常
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_ITS_ECTWORKSTATE = POINTER(NET_ITS_ECTWORKSTATE)


#  图片信息（后续会加入码流）
class NET_ITS_PICTURE_INFO(Structure):
    _fields_ = [
        ("dwDataLen", DWORD), # 媒体数据长度
        # 0:车牌图;1:车辆图;2:合成图; 3:特写图;4:二直图;5:码流;6:人脸子图(主驾驶);7:人脸子图(副驾驶)成图;8-非机动车;9-行人;10-称重原始裸数据;11-目标图;12-主驾驶室图 ;13-副驾驶室图;14-人脸图抠小图
        # 15 - 自定义图片(用户自己上传进行违法检测的图片)
        ("byType", BYTE),
        # 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
        ("byDataType", BYTE),
        ("byCloseUpType", BYTE), # 特写图类型，0-保留,1-非机动车,2-行人
        ("byPicRecogMode", BYTE), # 图片背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ；
        ("dwRedLightTime", DWORD), # 经过的红灯时间  （s）
        ("byAbsTime", BYTE * 32), # 绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
        ("struPlateRect", NET_VCA_RECT), # 车牌位置,当byType为8-非机动车9-行人时，表示人体坐标
        ("struPlateRecgRect", NET_VCA_RECT), # 牌识区域坐标，当图片类型为12-主驾驶室图13-副驾驶室图是，该坐标为驾驶员坐标
        ("*pBuffer", BYTE), # 数据指针
        ("dwUTCTime", DWORD), # UTC时间定义
        ("byCompatibleAblity", BYTE), # 兼容能力字段 0表示无效，1表示有效 bit0-表示dwUTCTime字段有效
        ("byTimeDiffFlag", BYTE), # 时差字段是否有效  0-时差无效， 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
        ("byRes2", BYTE * 4), # 保留
    ]


LPNET_ITS_PICTURE_INFO = POINTER(NET_ITS_PICTURE_INFO)


class NET_ITS_ILLEGAL_INFO(Structure):
    _fields_ = [
        ("byIllegalInfo", BYTE * MAX_ILLEGAL_LEN), #  违章类型信息（字符格式）
        ("byRes", BYTE * 256),
    ]


LPNET_ITS_ILLEGAL_INFO = POINTER(NET_ITS_ILLEGAL_INFO)


#  检测结果
class NET_ITS_PLATE_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwMatchNo", DWORD), # 匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
        ("byGroupNum", BYTE), # 图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
        ("byPicNo", BYTE), # 连拍的图片序号（接收到图片组数量后，表示接收完成接收超时不足图片组数量时，根据需要保留或删除）
        ("bySecondCam", BYTE), # 是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
        ("byFeaturePicNo", BYTE), # 闯红灯电警，取第几张图作为特写图,0xff-表示不取
        ("byDriveChan", BYTE), # 触发车道号
        ("byVehicleType", BYTE), # 车辆类型，参考VTR_RESULT
        ("byDetSceneID", BYTE), # 检测场景号[1,4], IPC默认是0
        # 车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
        # 该节点已不再使用,使用下面的byYellowLabelCar和byDangerousVehicles判断是否黄标车和危险品车
        ("byVehicleAttribute", BYTE),
        ("wIllegalType", WORD), # 违章类型采用国标定义
        ("byIllegalSubType", BYTE * 8), # 违章子类型
        ("byPostPicNo", BYTE), # 违章时取第几张图片作为卡口图,0xff-表示不取
        # 通道号(有效，报警通道号和所在设备上传报警通道号一致，在后端和所接入的 通道号一致)
        ("byChanIndex", BYTE),
        ("wSpeedLimit", WORD), # 限速上限（超速时有效）
        ("byChanIndexEx", BYTE), # byChanIndexEx*256+byChanIndex表示真实通道号。
        # 车辆方位布控标志,0~为普通车牌识别报警,
        # 1~为车辆位置布控触发报警(即通过PUT /ISAPI/Traffic/channels/<ID>/vehiclePositionControl?format=json触发)。
        # 2~为车辆智能布控触发报警(包含多预置点及GPS车辆布控)(即通过PUT /ISAPI/Traffic/channels/<ID>/vehicleMonitor/<taskID>/startTask触发,
        # 但在unarmedVehicleDetectionEnable（非目标车辆检测使能）为true时，只上报车辆检测报警，无车辆智能布控报警，因此该字段取值为0，而不是2)。
        # 3~为手动车辆布控触发报警(/ISAPI/Traffic/channels/<ID>/manualVehicleMonitor?format=json)
        # 4~为日常布控(复用车辆检测配置)可通过车辆检测能力中区分是否支持日常车辆布控,
        # (即通过/ISAPI/Traffic/channels/<ID>/vehicleDetect/capabilities中isSupportDailyVehicleMonitor判断,日常车辆布控时,设备不仅会上报ANPR报警还会实时上报vehicleMonitor车辆布控报警)
        # 若不返回该字段则代表为普通车辆检测
        #
        ("byVehiclePositionControl", BYTE),
        ("struPlateInfo", NET_DVR_PLATE_INFO), # 车牌信息结构
        ("struVehicleInfo", NET_DVR_VEHICLE_INFO), # 车辆信息
        ("byMonitoringSiteID", BYTE * 48), # 监测点编号
        ("byDeviceID", BYTE * 48), # 设备编号
        ("byDir", BYTE), # 监测方向，1-上行（反向），2-下行(正向)，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
        ("byDetectType", BYTE), # 检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byCarDirectionType", BYTE), # 车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
        # 当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
        ("dwCustomIllegalType", DWORD), # 违章类型定义(用户自定义)
        # 为0~数字格式时，为老的违章类型，wIllegalType、dwCustomIllegalType参数生效，赋值国标违法代码。
        # 为1~字符格式时，pIllegalInfoBuf参数生效。老的违章类型，wIllegalType、dwCustomIllegalType参数依然赋值国标违法代码
        ("pIllegalInfoBuf", CHARP), # 违法代码字符信息结构体指针；指向NET_ITS_ILLEGAL_INFO
        ("byIllegalFromatType", BYTE), # 违章信息格式类型； 0~数字格式， 1~字符格式
        ("byPendant", BYTE), #  0-表示未知,1-车窗有悬挂物，2-车窗无悬挂物
        ("byDataAnalysis", BYTE), # 0-数据未分析, 1-数据已分析
        ("byYellowLabelCar", BYTE), # 0-表示未知, 1-非黄标车,2-黄标车
        ("byDangerousVehicles", BYTE), # 0-表示未知, 1-非危险品车,2-危险品车
        # 以下字段包含Pilot字符均为主驾驶，含Copilot字符均为副驾驶
        ("byPilotSafebelt", BYTE), # 0-表示未知,1-系安全带,2-不系安全带
        ("byCopilotSafebelt", BYTE), # 0-表示未知,1-系安全带,2-不系安全带
        ("byPilotSunVisor", BYTE), # 0-表示未知,1-不打开遮阳板,2-打开遮阳板
        ("byCopilotSunVisor", BYTE), # 0-表示未知, 1-不打开遮阳板,2-打开遮阳板
        ("byPilotCall", BYTE), #  0-表示未知, 1-不打电话,2-打电话
        # 0-开闸，1-未开闸 (专用于历史数据中相机根据黑白名单匹配后，是否开闸成功的标志)；当byAlarmDataType为0-实时数据时 0-未开闸 1-开闸
        ("byBarrierGateCtrlType", BYTE),
        ("byAlarmDataType", BYTE), # 0-实时数据，1-历史数据
        ("struSnapFirstPicTime", NET_DVR_TIME_V30), # 端点时间(ms)（抓拍第一张图片的时间）
        ("dwIllegalTime", DWORD), # 违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
        ("dwPicNum", DWORD), # 图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
        ("struPicInfo", NET_ITS_PICTURE_INFO * 6), # 图片信息,单张回调，最多6张图，由序号区分
    ]


LPNET_ITS_PLATE_RESULT = POINTER(NET_ITS_PLATE_RESULT)


# 出入口车辆抓拍数据上传
class NET_ITS_GATE_VEHICLE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwMatchNo", DWORD), # 匹配序号,由(车辆序号,数据类型,车道号)组成匹配码 默认0
        ("byGroupNum", BYTE), # 图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）默认 1 抓拍类型下图片数据 控制后续接收延时操作
        ("byPicNo", BYTE), # 连拍的图片组上传图片序号（接收到图片组数量后，表示接收完成。
        # 接收超时不足图片组数量时，根据需要保留或删除）
        ("bySecondCam", BYTE), # 是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）标示前后相机抓拍图片
        ("byRes", BYTE), # 标记为预留
        ("wLaneid", WORD), # 车道号1～32（索引车道号，可以跳跃）
        ("byCamLaneId", BYTE), # 对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
        ("byRes1", BYTE), # 保留
        ("byAlarmReason", BYTE * MAX_ALARMREASON_LEN), # 自定义报警类型 默认为中文
        ("wBackList", WORD), # 标记为是否报警数据 0 表示为正常过车数据 1 表示黑名单
        ("wSpeedLimit", WORD), # 限速上限（超速时有效）km/h
        ("dwChanIndex", DWORD), # 通道号
        ("struPlateInfo", NET_DVR_PLATE_INFO), # 车牌信息结构
        ("struVehicleInfo", NET_DVR_VEHICLE_INFO), # 车辆信息  含速度
        ("byMonitoringSiteID", BYTE * MAX_ID_LEN), # 监测点编号
        ("byDeviceID", BYTE * MAX_ID_LEN), # 设备编号
        ("byDir", BYTE), # 监测方向，0-其它 1 入场，2 出场
        ("byDetectType", BYTE), # 检测方式, 0-其他 1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
        ("byRes2", BYTE * 2),
        ("byCardNo", BYTE * MAX_ID_LEN), #  卡号
        ("dwPicNum", DWORD), # 图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
        ("struPicInfo", NET_ITS_PICTURE_INFO * 4), # 图片信息,单张回调，最多4张图，由序号区分
        # 2013-11-19 出入口车辆抓拍数据上传（监听方式）新增参数
        ("bySwipeTime", BYTE * MAX_TIME_LEN), # 增加刷卡时间  时间格式为yyyymmddhh24missfff
        ("byRes3", BYTE * 224),
    ]


LPNET_ITS_GATE_VEHICLE = POINTER(NET_ITS_GATE_VEHICLE)


# 出入口人脸识别
class NET_ITS_GATE_FACE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("byGroupNum", BYTE), # 图片组数量（一个行人相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
        ("byPicNo", BYTE), # 连拍的图片序号（接收到图片组数量后，表示接收完成。
        # 接收超时不足图片组数量时，根据需要保留或删除）
        ("byFeaturePicNo", BYTE), # 连抓时取第几张图作为特写图,0xff-表示不取
        ("byRes", BYTE), # 保留
        ("wLaneid", WORD), # 车道号1～32（索引车道号，可以跳跃）
        ("byCamLaneId", BYTE), # 对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
        ("byDir", BYTE), # 监测方向，0-其他 1 入场， 2 出场
        ("dwChanIndex", DWORD), # 通道号
        ("byMonitoringSiteID", BYTE * MAX_ID_LEN), # 监测点编号
        ("byDeviceID", BYTE * MAX_ID_LEN), # 设备编号
        ("struFaceInfo", NET_VCA_FACESNAP_RESULT), # 人脸抓拍数据
        ("byRes2", BYTE * 256), # 预留
    ]


LPNET_ITS_GATE_FACE = POINTER(NET_ITS_GATE_FACE)


# 停车场数据上传
# 交通取证报警
class NET_DVR_TFS_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("dwIllegalType", DWORD), # 违章类型，采用国标定义，当dwIllegalType值为0xffffffff时使用byIllegalCode
        ("dwIllegalDuration", DWORD), # 违法持续时间（单位：秒） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
        ("byMonitoringSiteID", BYTE * MONITORSITE_ID_LEN), # 监测点编号（路口编号、内部编号）
        ("byDeviceID", BYTE * DEVICE_ID_LEN), # 设备编号
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("struSceneInfo", NET_DVR_SCENE_INFO), # 场景信息
        ("struBeginRecTime", NET_DVR_TIME_EX), # 录像开始时间
        ("struEndRecTime", NET_DVR_TIME_EX), # 录像结束时间
        ("struAIDInfo", NET_DVR_AID_INFO), # 交通事件信息
        ("struPlateInfo", NET_DVR_PLATE_INFO), # 车牌信息
        ("struVehicleInfo", NET_DVR_VEHICLE_INFO), # 车辆信息
        ("dwPicNum", DWORD), # 图片数量
        ("struPicInfo", NET_ITS_PICTURE_INFO * 8), # 图片信息，最多8张
        ("bySpecificVehicleType", BYTE), # 具体车辆种类  参考识别结果类型VTR_RESULT
        ("byLaneNo", BYTE), # 关联车道号
        ("byRes1", BYTE * 2), # 保留
        ("struTime", NET_DVR_TIME_V30), # 手动跟踪定位，当前时间。
        ("dwSerialNo", DWORD), # 序号；
        ("byVehicleAttribute", BYTE), # 车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
        ("byPilotSafebelt", BYTE), # 0-表示未知,1-系安全带,2-不系安全带
        ("byCopilotSafebelt", BYTE), # 0-表示未知,1-系安全带,2-不系安全带
        ("byPilotSunVisor", BYTE), # 0-表示未知,1-不打开遮阳板,2-打开遮阳板
        ("byCopilotSunVisor", BYTE), # 0-表示未知, 1-不打开遮阳板,2-打开遮阳板
        ("byPilotCall", BYTE), #  0-表示未知, 1-不打电话,2-打电话
        ("byRes2", BYTE * 2), # 保留
        ("byIllegalCode", BYTE * ILLEGAL_LEN), # 违法代码扩展，当dwIllegalType值为0xffffffff；使用这个值
        ("wCountry", WORD), #  国家索引值,参照枚举COUNTRY_INDEX
        ("byRegion", BYTE), # 区域索引值,0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS) , 4-中东（Middle East），0xff-所有
        ("byCrossLine", BYTE), # 是否压线停车（侧方停车），0-表示未知，1-不压线，2-压线
        ("byParkingSerialNO", BYTE * SERIAL_NO_LEN), # 泊车位编号
        ("byCrossSpaces", BYTE), # 是否跨泊车位停车（侧方停车），0-表示未知，1-未跨泊车位停车，2-跨泊车位停车
        ("byAngledParking", BYTE), # 是否倾斜停车（侧方停车）, 0-表示未知，1-未倾斜停车，2-倾斜停车
        ("byAlarmValidity", BYTE), # 报警置信度，可以输出驶入驶出的置信度，范围0-100；置信度越高，事件真实性越高
        ("byDoorsStatus", BYTE), # 车门状态 0-车门关闭 1-车门开启
        ("dwXmlLen", DWORD), # XML报警信息长度
        # #if (defined(OS_WINDOWS64) || defined(OS_POSIX64))win64及linux64下指针为8字节
        ("pXmlBuf", CHARP), #  XML报警信息指针,其XML对应到EventNotificationAlert XML Block
        # #else
        ("pXmlBuf", CHARP), #  XML报警信息指针,其XML对应到EventNotificationAlert XML Block
        ("byRes3", BYTE * 4),
        # #endif
        ("byVehicleHeadTailStatus", BYTE), # 车头车尾状态 0-保留 1-车头 2-车尾
        ("byRes", BYTE * 31), # 保留
    ]


LPNET_DVR_TFS_ALARM = POINTER(NET_DVR_TFS_ALARM)


class NET_DVR_SOFTWARE_SERVICE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byThirdStreamEnabled", BYTE), # 是否开启三码流配置：0-否，1-是
        ("bySubStreamEnabled", BYTE), # 是否开启子码流配置：0-否，1-是
        ("byRes", BYTE * 254),
    ]


LPNET_DVR_SOFTWARE_SERVICE_CFG = POINTER(NET_DVR_SOFTWARE_SERVICE_CFG)


# IPC通道参数配置
class NET_ITS_IPC_CHAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCameraType", BYTE), # 相机种类，0-监控用相机；1-线圈触发相机；2-视频分析用相机,3-一体机
        ("byRes1", BYTE * 3), # 保留
        ("byMonitoringSiteID", BYTE * 48), # 监测点编号
        ("byDeviceID", BYTE * 48), # 设备编号
        ("byDirectionNo", BYTE), # 监测方向编号,0-无,1-上行,2-下行,3-双向,4-由东向西,5-由南向北,6-由西向东,7-由北向南,8-其他
        ("byMonitorInfo", BYTE * 48), # 监测点信息描述
        ("byRes2", BYTE * 15), # 保留
    ]


LPNET_ITS_IPC_CHAN_CFG = POINTER(NET_ITS_IPC_CHAN_CFG)


# 单个设备信息
class NET_ITS_SINGLE_DEVICE_INFO(Structure):
    _fields_ = [
        ("dwDeviceType", DWORD), # 设备类型：0-终端，1-相机，2-补光灯，3-车检器，4-线圈1，5-线圈2，6-线圈3，7-红绿灯检测器，8-机柜，
        # 9-雷达，10-道闸，11-出入口控制机(票箱)，12-LED显示屏，13-远距离读卡器，14-近距离读卡器，15-红外扫描枪，
        # 16-票据打印机，17-节点管理器(诱导服务器相关) , 18-机柜检测仪
        ("dwDirID", DWORD), # 方向编号
        ("dwLaneID", DWORD), # 车道编号
        ("dwDeviceState", DWORD), # 设备状态  0正常 非0 异常（参考设备异常代码表）
        ("byDeviceName", BYTE * 32), # 设备名称
        ("byDeviceID", BYTE * 48), # 设备编号，一般用序列号，车检器用地址
        ("struTriggerTime", NET_DVR_TIME_V30), # 触发时间
        ("byRelateChan", BYTE), # 关联通道号（传感器是1~8  AC端子1~4  AC插座1~2）
        ("byRes", BYTE * 3),
    ]


LPNET_ITS_SINGLE_DEVICE_INFO = POINTER(NET_ITS_SINGLE_DEVICE_INFO)


# 路口信息
class NET_ITS_ROADINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号,0xffffffff表示终端，其它表示对应的相机
        ("byTriggerMode", BYTE), #   0:线圈触发  1:视频触发
        ("byRes1", BYTE * 3),
        ("dwDeviceNum", DWORD), # 实际设备个数
        ("byMonitoringSiteID", BYTE * 48), # 监测点编号
        ("byRoadInfo", BYTE * 48), # 监测点信息
        ("struSingleDevice", NET_ITS_SINGLE_DEVICE_INFO * ITS_MAX_DEVICE_NUM),
        ("byRes", BYTE * 16),
    ]


LPNET_ITS_ROADINFO = POINTER(NET_ITS_ROADINFO)


# 单个车道路况信息
class NET_ITS_TRAFFIC_DRIVE_CHAN(Structure):
    _fields_ = [
        ("byDriveChan", BYTE), # 车道号
        ("byRes1", BYTE * 3), #  预留
        ("wCarFlux", WORD), # 汽车流量数
        ("wPasserbyFlux", WORD), # 行人流量数
        ("wShayFlux", WORD), # 二轮车流量数
        ("fAverOccpancy", DOUBLE), # 平均车道占有率百分比
        ("wAverSpeed", WORD), # 平均车速(km/h)
        ("wAverCarDis", WORD), # 平均车距(单位待定)
        ("byRes2", BYTE * 16), #  预留
    ]


LPNET_ITS_TRAFFIC_DRIVE_CHAN = POINTER(NET_ITS_TRAFFIC_DRIVE_CHAN)


class NET_ITS_TRAFFIC_COLLECT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byMonitoringSiteID", BYTE * 48), # 监测点编号
        ("byDeviceID", BYTE * 48), # 设备编号
        ("byLaneNum", BYTE), # 车道总数
        ("byDir", BYTE), # 监测方向
        ("byDetectType", BYTE), # 检测方式1-地感线圈、2-视频触发、3、多帧识别、4雷达触发
        ("byRes1", BYTE), # 预留
        ("dwChannel", DWORD), # 通道号
        ("struStartTime", NET_DVR_SYSTEM_TIME), # 统计开始时间
        ("dwSamplePeriod", DWORD), # 统计时间,单位秒
        ("struDriveChan", NET_ITS_TRAFFIC_DRIVE_CHAN * 6), # 交通流量数据,每个相机支持6个车道
        ("byRes2", BYTE * 24), # 预留
    ]


LPNET_ITS_TRAFFIC_COLLECT = POINTER(NET_ITS_TRAFFIC_COLLECT)


class NET_ITS_OVERLAPCFG_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("dwConfigMode", DWORD), # 配置模式，0-终端，1-前端(直连前端或终端接前端)
        ("byPicModeType", BYTE), # 0-表示小图(独立图)，1-表示大图(合成图)
        #
        # 0表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
        # 1 表示关联 抓拍 HVT 模式（混卡IPC使用）
        #
        ("byRelateType", BYTE),
        ("byRes", BYTE * 14),
    ]


LPNET_ITS_OVERLAPCFG_COND = POINTER(NET_ITS_OVERLAPCFG_COND)


OVERLAP_ITEM_NULL = 0
        # OVERLAP_ITEM_SITE,                1-地点
        # OVERLAP_ITEM_ROADNUM,             2-路口编号
        # OVERLAP_ITEM_INSTRUMENTNUM,       3-设备编号
        # OVERLAP_ITEM_DIRECTION,           4-方向编号
        # OVERLAP_ITEM_DIRECTIONDESC,       5-方向
        # OVERLAP_ITEM_LANENUM,             6-车道号
        # OVERLAP_ITEM_LANEDES,             7-车道
        # OVERLAP_ITEM_CAPTIME,             8-抓拍时间(不带毫秒)
        # OVERLAP_ITEM_CAPTIME_MILLSECOND,  9-抓拍时间(带毫秒)
        # OVERLAP_ITEM_PLATENUM,            10-车牌号
        # OVERLAP_ITEM_CARCOLOR,            11-车身颜色
        # OVERLAP_ITEM_CARTYPE,             12-车辆类型
        # OVERLAP_ITEM_CARBRAND,            13-车辆品牌
        # OVERLAP_ITEM_CARSPEED,            14-车辆速度
        # OVERLAP_ITEM_SPEEDLIMIT,          15-限速标志
        # OVERLAP_ITEM_CARLENGTH,           16-车辆长度1~99m
        # OVERLAP_ITEM_ILLEGALNUM,          17-违法代码(违法代码叠加应该没用的，应该直接叠加违法信息，比如正常、低速、超速、逆行、闯红灯、占道、压黄线等)
        # OVERLAP_ITEM_MONITOR_INFO,      18-监测点信息
        # OVERLAP_ITEM_ILLEGALDES,          19-违法行为
        # OVERLAP_ITEM_OVERSPEED_PERCENT,    20-超速比
        # OVERLAP_ITEM_RED_STARTTIME,           21-红灯开始时间
        # OVERLAP_ITEM_RED_STOPTIME,        22-红灯结束时间
        # OVERLAP_ITEM_RED_DURATION,        23-红灯已亮时间
        # OVERLAP_ITEM_SECUNITY_CODE,        24-防伪码
        # OVERLAP_ITEM_CAP_CODE,        25-抓拍编号
        # OVERLAP_ITEM_SEATBELT,      26-安全带
        # OVERLAP_ITEM_MONITOR_ID,    27-监测点编号
        # OVERLAP_ITEM_SUN_VISOR,     28-遮阳板
        # OVERLAP_ITEM_LANE_DIRECTION,  29-车道行驶方向
        # OVERLAP_ITEM_LICENSE_PLATE_COLOR,   30-车牌颜色
        # OVERLAP_ITEM_SCENE_NUMBER,  31-场景编号
        # OVERLAP_ITEM_SCENE_NAME,   32-场景名称
        # OVERLAP_ITEM_YELLOW_SIGN_CAR,  33-黄标车
        # OVERLAP_ITEM_DANGEROUS_CAR,    34-危险品车
        # OVERLAP_ITEM_CAR_SUBBRAND,  35-车辆子品牌
        # OVERLAP_ITEM_CAR_DIRECTION,  36-车辆方向
        # OVERLAP_ITEM_PENDANT,  37-车窗悬挂物
        # OVERLAP_ITEM_CALL,  38-打电话
        # OVERLAP_ITEM_CAR_VALIDITY,  39-置信度
        # OVERLAP_ITEM_CAR_COUNTRY,       40-国家
        # OVERLAP_ITEM_CAR_PLATE_TYPE,    41-车牌类型，参考车牌类型枚举
        # OVERLAP_ITEM_CAR_PLATE_SIZE,		42-车牌尺寸
        # OVERLAP_ITEM_CAR_PLATE_COLOR,		43-车牌颜色
        # OVERLAP_ITEM_CAR_PLATE_CATEGORY,		44-车牌附加信息
        # OVERLAP_ITEM_ACCIDENT,  45-交通事故
        # OVERLAP_ITEM_SMOKING,  46-吸烟
        # OVERLAP_ITEM_HELMET, 47-戴头盔
        # OVERLAP_ITEM_MANNED, 48-载人
        # OVERLAP_ITEM_HUMAN, 49-人体属性
        # OVERLAP_ITEM_PLAYMOBILEPHONE, 50-玩手机
        #


# 字符叠加每一条信息结构体
class NET_ITS_OVERLAP_SINGLE_ITEM_PARAM(Structure):
    _fields_ = [
        ("byRes1", BYTE * 2), #  保留
        ("byItemType", BYTE), # 类型，详见OVERLAP_ITEM_TYPE
        ("byChangeLineNum", BYTE), # 叠加项后的换行数[0-10](默认0)
        ("bySpaceNum", BYTE), # 叠加项后的空格数[0-255](默认0)
        ("byRes2", BYTE * 2),
        ("byEnablePos", BYTE), # 是否启用坐标显示
        ("wStartPosTop", WORD), # 起始上坐标,只对图片内部叠加有效[0~2448](默认0)
        ("wStartPosLeft", WORD), # 起始左坐标,只对图片内部叠加有效[0~2448](默认0)
        ("byRes", BYTE * 8),
    ]


LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM = POINTER(NET_ITS_OVERLAP_SINGLE_ITEM_PARAM)


class NET_ITS_OVERLAP_ITEM_PARAM(Structure):
    _fields_ = [
        ("struSingleItem", NET_ITS_OVERLAP_SINGLE_ITEM_PARAM * MAX_OVERLAP_ITEM_NUM), # 单条字符参数
        ("dwLinePercent", DWORD), # 叠加行百分比(0-100),(默认100)
        ("dwItemsStlye", DWORD), # 叠加方式：0-横排,1-竖排(默认横排)
        ("wStartPosTop", WORD), # 起始上坐标,只对图片内部叠加有效[0~2448](默认0)
        ("wStartPosLeft", WORD), # 起始左坐标,只对图片内部叠加有效[0~2448](默认0)
        ("wCharStyle", WORD), # 字体类型,0-宋体1-魏体(默认)
        ("wCharSize", WORD), # 字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认),8x128(Ver3.7)
        ("wCharInterval", WORD), # 字符间距，[0～16]，可设单位：像素(默认)
        ("byRes1", BYTE * 2),
        ("dwForeClorRGB", DWORD), # 前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
        ("dwBackClorRGB", DWORD), # 背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
        ("byColorAdapt", BYTE), # 颜色是否自适应0-否1-是
        # (Ver3.7 新增)
        # 参数补零使能 0-补零, 1-不补零（详细注释）速度,限速值 不足3位补0
        ("byParamFillZeroEnble", BYTE),
        ("byPlateLeftCornerEnable", BYTE), #  车牌小图叠加左上角使能 0-不叠加, 1-叠加
        ("byRes2", BYTE),
        ("wStartSPicPosTop", WORD), # 起始上坐标,只对图片内部叠加有效[0~2448](默认0)
        ("wStartSPicPosLeft", WORD), # 起始左坐标,只对图片内部叠加有效[0~2448](默认0)
        # OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
        ("byOsdLocate", BYTE),
        ("byRes", BYTE * 23),
    ]


LPNET_ITS_OVERLAP_ITEM_PARAM = POINTER(NET_ITS_OVERLAP_ITEM_PARAM)


# 叠加项具体信息
class NET_ITS_OVERLAP_INFO_PARAM(Structure):
    _fields_ = [
        ("bySite", BYTE * 128), # 地点描述
        ("byRoadNum", BYTE * 32), # 路口编号
        ("byInstrumentNum", BYTE * 32), # 设备编号
        ("byDirection", BYTE * 32), # 方向编号
        ("byDirectionDesc", BYTE * 32), # 方向描述
        ("byLaneDes", BYTE * 32), # 车道描述
        ("byRes1", BYTE * 32), # 保留
        ("byMonitoringSite1", BYTE * 44), # 监测点1信息
        ("byMonitoringSite2", BYTE * 32), # 监测点2信息
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_ITS_OVERLAP_INFO_PARAM = POINTER(NET_ITS_OVERLAP_INFO_PARAM)


class NET_ITS_OVERLAP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("byRes1", BYTE * 3),
        ("struOverLapItem", NET_ITS_OVERLAP_ITEM_PARAM), # 字符串参数
        ("struOverLapInfo", NET_ITS_OVERLAP_INFO_PARAM), # 字符串内容信息
        ("byRes", BYTE * 32),
    ]


LPNET_ITS_OVERLAP_CFG = POINTER(NET_ITS_OVERLAP_CFG)


# 字符叠加每一条信息结构体
class NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50(Structure):
    _fields_ = [
        ("byRes1", BYTE * 2), #  保留
        ("byItemType", BYTE), # 类型，详见OVERLAP_ITEM_TYPE
        ("byChangeLineNum", BYTE), # 叠加项后的换行数[0-10](默认0)
        ("bySpaceNum", BYTE), # 叠加项后的空格数[0-255](默认0)
        ("byRes2", BYTE * 2),
        ("byEnablePos", BYTE), # 是否启用坐标显示
        ("wStartPosTop", WORD), # 起始上坐标,只对图片内部叠加有效[0~2448](默认0)
        ("wStartPosLeft", WORD), # 起始左坐标,只对图片内部叠加有效[0~2448](默认0)
        # 自定义类型；与byItemType参数对应。可将byItemType参数类型自定义名称。若自定义内容为空，便默认以byItemType参数中的类型命名。
        ("byItemTypeCustom", BYTE * 32),
        ("byRes", BYTE * 8),
    ]


LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 = POINTER(NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50)


class NET_ITS_OVERLAP_ITEM_PARAM_V50(Structure):
    _fields_ = [
        ("struSingleItem", NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 * MAX_OVERLAP_ITEM_NUM), # 单条字符参数
        ("dwLinePercent", DWORD), # 叠加行百分比(0-100),(默认100)
        ("dwItemsStlye", DWORD), # 叠加方式：0-横排,1-竖排(默认横排)
        ("wStartPosTop", WORD), # 起始上坐标,只对图片内部叠加有效[0~2448](默认0)
        ("wStartPosLeft", WORD), # 起始左坐标,只对图片内部叠加有效[0~2448](默认0)
        ("wCharStyle", WORD), # 字体类型,0-宋体1-魏体(默认)
        ("wCharSize", WORD), # 字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认),8x128(Ver3.7)
        ("wCharInterval", WORD), # 字符间距，[0～16]，可设单位：像素(默认)
        ("byRes1", BYTE * 2),
        ("dwForeClorRGB", DWORD), # 前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
        ("dwBackClorRGB", DWORD), # 背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
        ("byColorAdapt", BYTE), # 颜色是否自适应0-否1-是
        # (Ver3.7 新增)
        # 参数补零使能 0-补零, 1-不补零（详细注释）速度,限速值 不足3位补0
        ("byParamFillZeroEnble", BYTE),
        ("byPlateLeftCornerEnable", BYTE), #  车牌小图叠加左上角使能 0-不叠加, 1-叠加
        ("byRes2", BYTE),
        ("wStartSPicPosTop", WORD), # 起始上坐标,只对图片内部叠加有效[0~2448](默认0)
        ("wStartSPicPosLeft", WORD), # 起始左坐标,只对图片内部叠加有效[0~2448](默认0)
        # OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
        ("byOsdLocate", BYTE),
        ("byRes", BYTE * 63),
    ]


LPNET_ITS_OVERLAP_ITEM_PARAM_V50 = POINTER(NET_ITS_OVERLAP_ITEM_PARAM_V50)


class NET_ITS_OVERLAP_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("byRes1", BYTE * 3),
        ("struOverLapItemV50", NET_ITS_OVERLAP_ITEM_PARAM_V50), # 字符串参数
        ("struOverLapInfo", NET_ITS_OVERLAP_INFO_PARAM), # 字符串内容信息
        ("byRes", BYTE * 120),
    ]


LPNET_ITS_OVERLAP_CFG_V50 = POINTER(NET_ITS_OVERLAP_CFG_V50)


MAX_PTZCRUISE_POINT_NUM = 32 # 最大支持32个巡航点
# 预置点信息
class NET_DVR_PRESET_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPresetNum", DWORD), # 预置点个数
        ("dwGroupNum", DWORD), # 组数
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_PRESET_INFO = POINTER(NET_DVR_PRESET_INFO)


# 输入参数
class NET_DVR_PRESET_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("dwGroupNO", DWORD), # 组号
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_PRESET_COND = POINTER(NET_DVR_PRESET_COND)


# 输出参数
class NET_DVR_PRESETCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPresetIndex", DWORD), # 预置点序号
        ("struVcaPoint", NET_VCA_POINT), # 预置点坐标
        ("wZoomCoordinate", WORD), # /<预置点窗口Zoom值
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_PRESETCFG = POINTER(NET_DVR_PRESETCFG)


# 获取巡航路径的数目
class NET_DVR_PTZCRUISE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPtzCruiseNum", DWORD), # 路径个数
        ("dwGroupNum", DWORD), # 组数
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_PTZCRUISE_INFO = POINTER(NET_DVR_PTZCRUISE_INFO)


# 输入参数：
class NET_DVR_PTZCRUISE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("dwGroupNO", DWORD), # 组号
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_PTZCRUISE_COND = POINTER(NET_DVR_PTZCRUISE_COND)


# 输出参数
class NET_DVR_PTZCRUISE_POINTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPresetIndex", DWORD), # 预置点序号
        ("struVcaPoint", NET_VCA_POINT), # 预置点坐标
        ("byDwell", BYTE), # 停留时间
        ("bySpeed", BYTE), # 速度
        ("wZoomCoordinate", WORD), # /<预置点窗口Zoom值
        ("byRes", BYTE * 28),
    ]


LPNET_DVR_PTZCRUISE_POINTCFG = POINTER(NET_DVR_PTZCRUISE_POINTCFG)


class NET_DVR_PTZCRUISECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCruiseRoute", DWORD), # 巡航路径序号
        ("struCruisePoint", NET_DVR_PTZCRUISE_POINTCFG * MAX_PTZCRUISE_POINT_NUM), # 最大支持32个巡航点
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_PTZCRUISECFG = POINTER(NET_DVR_PTZCRUISECFG)


# 跟踪模式结构
class NET_DVR_MOTION_TRACK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableTrack", BYTE), # 启用跟踪，0-否，1-是
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_MOTION_TRACK_CFG = POINTER(NET_DVR_MOTION_TRACK_CFG)


# 一天的定时计划
class NET_DVR_DAY_SCHEDULE(Structure):
    _fields_ = [
        ("byWorkMode", BYTE), # 0-全天开，1-全天关，2-定时
        ("byRes1", BYTE * 3),
        ("struTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 时间段
        ("byRes2", BYTE * 8), # 保留
    ]


LPNET_DVR_DAY_SCHEDULE = POINTER(NET_DVR_DAY_SCHEDULE)


# 定时智能跟踪参数结构
class NET_DVR_SCHEDULE_AUTO_TRACK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byEnableTrack", BYTE), # 启用跟踪：0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("struSchedule", NET_DVR_DAY_SCHEDULE * MAX_DAYS), # 定时智能跟踪时间段，不在这8个时间段内的时间，默认定时智能跟踪关闭
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_SCHEDULE_AUTO_TRACK_CFG = POINTER(NET_DVR_SCHEDULE_AUTO_TRACK_CFG)


class NET_DVR_I_FRAME(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("sStreamID", BYTE * STREAM_ID_LEN), # 流ID
        ("dwChan", DWORD), # 被控通道号
        ("byStreamType", BYTE), # 0-主码流，1-子码流，2-码流3，3-码流4，4-码流5
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_I_FRAME = POINTER(NET_DVR_I_FRAME)


class NET_DVR_REBOOT_TIME(Structure):
    _fields_ = [
        ("byDate", BYTE), # 星期几，1-7代表星期一到星期日
        ("byHour", BYTE), # 时
        ("byMinute", BYTE), # 分
        ("byRes1", BYTE),
        ("byRebootMode", BYTE), # 0-按周重启，1-按月重启（此参数只能获取，不能设置）
        ("byDisabled", BYTE), #  0-启用 1-禁用
        ("byRes", BYTE * 10), # 保留
    ]


LPNET_DVR_REBOOT_TIME = POINTER(NET_DVR_REBOOT_TIME)


class NET_DVR_AUTO_REBOOT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRebootTime", NET_DVR_REBOOT_TIME),
    ]


LPNET_DVR_AUTO_REBOOT_CFG = POINTER(NET_DVR_AUTO_REBOOT_CFG)


NET_DVR_GPS_FINDING = 0 # 正在查找
NET_DVR_GPS_RECV = 1 # 接收数据
NET_DVR_GPS_OVER = 2 # 查找结束
NET_DVR_GPS_EXCEPTION = 3 # 接收异常
class NET_DVR_MENU_OUTPUT_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMenuOutputMode", BYTE), # 非同源设备：0-Auto 1-主CVBS 2-HDMI 3-VGA 同源设备：0-Auto 1-主CVBS 2-HDMI/VGA
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_MENU_OUTPUT_MODE = POINTER(NET_DVR_MENU_OUTPUT_MODE)


class NET_DVR_MB_IPADDR(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), # IP地址
        ("wPort", WORD), # 端口号
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_MB_IPADDR = POINTER(NET_DVR_MB_IPADDR)


class NET_DVR_MB_WVSPARA(Structure):
    _fields_ = [
        ("struWVSAddr", NET_DVR_MB_IPADDR),
        ("byPuid", BYTE * NAME_LEN), # 设备id
        ("byPassword", BYTE * PASSWD_LEN), # 密码
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_MB_WVSPARA = POINTER(NET_DVR_MB_WVSPARA)


class NET_DVR_MB_EHOMEPARA(Structure):
    _fields_ = [
        ("struEHomeAddr", NET_DVR_MB_IPADDR),
        ("byPuid", BYTE * NAME_LEN), # 设备id
    ]


LPNET_DVR_MB_EHOMEPARA = POINTER(NET_DVR_MB_EHOMEPARA)


class NET_DVR_MB_PLATFORMPARA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byNetEnvironment", BYTE), # 网络环境,0-wireless,1-3G,2-wLan,3-lan
        ("byCurPlatForm", BYTE), # < 当前平台0 - WVS, 1 - E家, 2 - 推模式
        ("byRes1", BYTE * 2),
        ("struWVSPara", NET_DVR_MB_WVSPARA), # 车载平台(平台登入)
        ("struMbEHpara", NET_DVR_MB_EHOMEPARA), # E家平台车载平台不设置设备登入密码
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_MB_PLATFORMPARA = POINTER(NET_DVR_MB_PLATFORMPARA)


class NET_DVR_MB_GPS_STATUS(Structure):
    _fields_ = [
        ("byGPSModule", BYTE), # gps模块, 0: 不存在, 1: 正常
        ("byPositionStatus", BYTE), # gps定位状态, 0: 定位失败, 1: 定位成功
        ("bySignalStrength", BYTE), # 信号强度, 0: 弱, 1: 正常, 2: 强
        ("byres", BYTE * 5),
    ]


LPNET_DVR_MB_GPS_STATUS = POINTER(NET_DVR_MB_GPS_STATUS)


class NET_DVR_MB_GSENSOR_STATUS(Structure):
    _fields_ = [
        ("byGsensorModule", BYTE), # g-sensor模块, 0: not exist, 1: 内置, 2: 外置
        ("byCurAccX", BYTE * 10), # 当前X轴加速度
        ("byCurAccY", BYTE * 10), # 当前Y轴加速度
        ("byCurAccZ", BYTE * 10), # 当前Z轴加速度
        ("byRefAccX", BYTE * 10), #  X轴加速度标定值
        ("byRefAccY", BYTE * 10), #  Y轴加速度标定值
        ("byRefAccZ", BYTE * 10), #  Z轴加速度标定值
        ("byres", BYTE * 3),
    ]


LPNET_DVR_MB_GSENSOR_STATUS = POINTER(NET_DVR_MB_GSENSOR_STATUS)


IP_ADDR_LEN = 16
IW_ESSID_MAX_SIZE = 32
class NET_DVR_MB_WIFI_STATUS(Structure):
    _fields_ = [
        ("byEnableWiFi", BYTE), #  无线, 0 关, 1 开
        ("byWiFiConnectStatus", BYTE), #  WIFI状态, 0: 连接失败, 1: 连接成功 2: 无模块
        ("bySignalStrength", BYTE), #  信号强度, 0 弱, 1 正常, 2 强
        ("byIPaddress", BYTE * IP_ADDR_LEN), # WIFI 设备 ip
        ("byEssid", BYTE * IW_ESSID_MAX_SIZE), # 无线接入点essid
        ("byres", BYTE * 5),
    ]


LPNET_DVR_MB_WIFI_STATUS = POINTER(NET_DVR_MB_WIFI_STATUS)


class NET_DVR_MB_PLATFORM_STATUS(Structure):
    _fields_ = [
        ("byCurPlat", BYTE), # 当前平台, 0: wvs, 1: ivms, 2: 推模式(net_3g_sdk)
        ("byLoginStatus", BYTE), # login 状态, 0: login failed, 1: login success
        ("byExceptionInfo", BYTE), # 异常信息
        #
        # WVS :exception info:
        # 0: 连接服务器失败
        # 1: 注册中
        # 2: 用户名密码错误
        # 3: 注册超时
        # 4: 心跳超时
        # 5: 注册成功
        # iVMS :exception info:
        # 0未注册
        # 1注册中
        # 2注册连接出错
        # 3注册超时
        # 4长时间没有心跳，连接中断
        # 5重新注册
        # 6 CMS中注册设备数量已经超过限定的台数
        # 7 CMS中注册通道数量已经超过限定通道数
        # 8设备在WEB管理中心中没有配置
        # 9CMS和WEB管理中心通信失败
        # 10登录未知错误
        # 11注册成功
        # 推模式 :exception info:
        # 0未注册
        # 1: 注册中
        # 2: 重复注册
        # 3: 注册连接失败
        # 4: 服务器IP变化
        # 5: 注册成功
        # 6: 用户注销
        # 7: 心跳超时
        #
        ("byres", BYTE * 5),
    ]


LPNET_DVR_MB_PLATFORM_STATUS = POINTER(NET_DVR_MB_PLATFORM_STATUS)


NET_DVR_GPS_STATUS = 0
NET_DVR_GSENSOR_STATUS = 1
NET_DVR_WIFI_STATUS = 2
NET_DVR_PLATFORM_STATUS = 3
# GPS点信息结构
class NET_DVR_GPS_INFO(Structure):
    _fields_ = [
        # 经纬度为S*100
        ("byDirection", BYTE * 2), # direction[0]0or1(东经/西经), direction[1]:0or1(北纬/南纬)
        ("bySvs", BYTE), #  satellite vehicles(初值0)：有效定位星数
        ("byLocateMode", BYTE), #  定位模式(初值0)：仅NMEA0183 3.00版本输出，0=自主定位，1=差分，2=估算，3=数据无效
        ("wHDOP", WORD), #  水平精度因子，度量GPS精确度，0.5-99.9，6以内定位精度高，20以上需丢弃，这里存储的是乘以10以后的整数
        ("wHeight", WORD), #  高度
        ("dwLatitude", DWORD), # 纬度latitude = 实际度*3600*100+实际分*60*100+实际秒*100
        ("dwLongitude", DWORD), # 经度longitude =实际度*3600*100+实际分*60*100+实际秒*100
        ("dwVehicleSpeed", DWORD), #  mobile speed =实际速度*100000 实际单位kph
        ("dwVehicleDirection", DWORD), #  mobile direction= 实际方向*100，实际数值是方向角，正北为0度，顺时针
        ("byRes", BYTE * 8), #  保留
    ]


LPNET_DVR_GPS_INFO = POINTER(NET_DVR_GPS_INFO)


# GPS状态上传
# GPS关联时间
class NET_DVR_GPS_DATA(Structure):
    _fields_ = [
        ("struGPSInfo", NET_DVR_GPS_INFO), # GPS坐标点
        ("struTime", NET_DVR_TIME), # GPS坐标对应的时间点，UTC时间
        ("byRes", BYTE * 12), #  保留
    ]


LPNET_DVR_GPS_DATA = POINTER(NET_DVR_GPS_DATA)


NET_SDK_MAX_CARD_LEN = 32 # 最大卡号长度
# 标签信息上传
class NET_DVR_SDKLOCAL_CFG(Structure):
    _fields_ = [
        ("byEnableAbilityParse", BYTE), # 使用能力集解析库,0-不使用,1-使用,默认不使用
        ("byVoiceComMode", BYTE), # 对讲模式，0-使用对讲库（默认），1-使用windows api模式
        ("byLoginWithSimXml", BYTE), # 登录时使用模拟能力,0-不使用,1-使用,默认不使用
        ("byCompatibleType", BYTE),
        ("byRes", BYTE * 380),
        ("byProtectKey", BYTE * 128), # 默认设置为0
    ]


LPNET_DVR_SDKLOCAL_CFG = POINTER(NET_DVR_SDKLOCAL_CFG)


class NET_DVR_LOCAL_ABILITY_PARSE_CFG(Structure):
    _fields_ = [
        ("byEnableAbilityParse", BYTE), # 使用能力集解析库,0-不使用,1-使用,默认不使用
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_LOCAL_ABILITY_PARSE_CFG = POINTER(NET_DVR_LOCAL_ABILITY_PARSE_CFG)


class NET_DVR_LOCAL_TALK_MODE_CFG(Structure):
    _fields_ = [
        ("byTalkMode", BYTE), # 对讲模式，0-使用对讲库（默认），1-使用windows api模式
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_LOCAL_TALK_MODE_CFG = POINTER(NET_DVR_LOCAL_TALK_MODE_CFG)


class NET_DVR_LOCAL_PROTECT_KEY_CFG(Structure):
    _fields_ = [
        ("byProtectKey", BYTE * 128), # 默认设置为0
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_LOCAL_PROTECT_KEY_CFG = POINTER(NET_DVR_LOCAL_PROTECT_KEY_CFG)


class NET_DVR_SIMXML_LOGIN(Structure):
    _fields_ = [
        ("byLoginWithSimXml", BYTE), # 登录时使用模拟能力校正结构体能力字段,0-不使用,1-使用
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_SIMXML_LOGIN = POINTER(NET_DVR_SIMXML_LOGIN)


# 报警回调配置参数
NET_SDK_LOCAL_CFG_TYPE_TCP_PORT_BIND = 0
        # NET_SDK_LOCAL_CFG_TYPE_UDP_PORT_BIND,            本地UDP端口绑定配置，对应结构体NET_DVR_LOCAL_UDP_PORT_BIND_CFG
        # NET_SDK_LOCAL_CFG_TYPE_MEM_POOL,                内存池本地配置，对应结构体NET_DVR_LOCAL_MEM_POOL_CFG
        # NET_SDK_LOCAL_CFG_TYPE_MODULE_RECV_TIMEOUT,        按模块配置超时时间，对应结构体NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
        # NET_SDK_LOCAL_CFG_TYPE_ABILITY_PARSE,            是否使用能力集解析库，对应结构体NET_DVR_LOCAL_ABILITY_PARSE_CFG
        # NET_SDK_LOCAL_CFG_TYPE_TALK_MODE,                对讲模式，对应结构体NET_DVR_LOCAL_TALK_MODE_CFG
        # NET_SDK_LOCAL_CFG_TYPE_PROTECT_KEY,                密钥设置，对应结构体NET_DVR_LOCAL_PROTECT_KEY_CFG
        # NET_SDK_LOCAL_CFG_TYPE_CFG_VERSION,             用于测试版本头的设备端兼容情NET_DVR_LOCAL_MEM_POOL_CFG况, 只有在设置参数时才起作用。
        # NET_SDK_LOCAL_CFG_TYPE_RTSP_PARAMS,                rtsp参数配置，对于结构体NET_DVR_RTSP_PARAMS_CFG
        # NET_SDK_LOCAL_CFG_TYPE_SIMXML_LOGIN,            在登录时使用模拟能力补充support字段, 对应结构NET_DVR_SIMXML_LOGIN
        # NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV,                心跳交互间隔时间
        # NET_SDK_LOCAL_CFG_TYPE_SECURITY,                  SDK本次安全配置，
        # NET_SDK_LOCAL_CFG_TYPE_EZVIZLIB_PATH,            配置萤石云通信库地址，
        # NET_SDK_LOCAL_CFG_TYPE_CHAR_ENCODE,               13.配置字符编码相关处理回调
        # NET_SDK_LOCAL_CFG_TYPE_PROXYS,                     设置获取代
        # NET_DVR_LOCAL_CFG_TYPE_LOG,                       日志参数配置  NET_DVR_LOCAL_LOG_CFG
        # NET_DVR_LOCAL_CFG_TYPE_STREAM_CALLBACK,           码流回调参数配置 NET_DVR_LOCAL_STREAM_CALLBACK_CFG
        # NET_DVR_LOCAL_CFG_TYPE_GENERAL,                   通用参数配置 NET_DVR_LOCAL_GENERAL_CFG
        # NET_DVR_LOCAL_CFG_TYPE_PTZ,                       PTZ是否接收设备返回配置
        # NET_DVR_LOCAL_CFG_MESSAGE_CALLBACK_V51,           报警V51回调相关本地配置,对应结构体为NET_DVR_MESSAGE_CALLBACK_PARAM_V51 。(仅对NET_DVR_SetDVRMessageCallBack_V51以上版本有效)
        # NET_SDK_LOCAL_CFG_CERTIFICATION,                  配置和证书相关的参数，对应结构体结构体NET_DVR_LOCAL_CERTIFICATION
        # NET_SDK_LOCAL_CFG_PORT_MULTIPLEX,                 端口复用，对应结构体NET_DVR_LOCAL_PORT_MULTI_CFG
        # NET_SDK_LOCAL_CFG_ASYNC,                 异步配置，对应结构体NET_DVR_LOCAL_ASYNC_CFG


NET_SDK_EXCEPTION_CALLBACK_BY_POOL = 0
NET_SDK_EXCEPTION_CALLBACK_DIRECTLY = 1


class NET_DVR_LOCAL_GENERAL_CFG(Structure):
    _fields_ = [
        ("byExceptionCbDirectly", BYTE), # 0-通过线程池异常回调，1-直接异常回调给上层
        ("byNotSplitRecordFile", BYTE), # 回放和预览中保存到本地录像文件不切片 0-默认切片，1-不切片
        ("byResumeUpgradeEnable", BYTE), # 断网续传升级使能，0-关闭（默认），1-开启
        ("byAlarmJsonPictureSeparate", BYTE), # 控制JSON透传报警数据和图片是否分离，0-不分离，1-分离（分离后走COMM_ISAPI_ALARM回调返回）
        ("byRes", BYTE * 4), # 保留
        ("i64FileSize", UINT64), # 单位：Byte
        ("dwResumeUpgradeTimeout", DWORD), # 断网续传重连超时时间，单位毫秒
        ("byAlarmReconnectMode", BYTE), # 0-独立线程重连（默认） 1-线程池重连
        ("byStdXmlBufferSize", BYTE), # 设置ISAPI透传接收缓冲区大小，1-1M 其他-默认
        ("byMultiplexing", BYTE), # 0-普通链接（非TLS链接）关闭多路复用，1-普通链接（非TLS链接）开启多路复用
        ("byRes1", BYTE * 233), # 预留
    ]


LPNET_DVR_LOCAL_GENERAL_CFG = POINTER(NET_DVR_LOCAL_GENERAL_CFG)


class NET_DVR_LOCAL_ASYNC_CFG(Structure):
    _fields_ = [
        ("bEnable", BOOL), # 异步配置使能，true-开启
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_LOCAL_ASYNC_CFG = POINTER(NET_DVR_LOCAL_ASYNC_CFG)


class NET_DVR_LOCAL_STREAM_CALLBACK_CFG(Structure):
    _fields_ = [
        ("byPlayBackEndFlag", BYTE), # 0-不回调回放结束标记，1-回调回放结束标记
        ("byRes", BYTE * 255), # 保留
    ]


LPNET_DVR_LOCAL_STREAM_CALLBACK_CFG = POINTER(NET_DVR_LOCAL_STREAM_CALLBACK_CFG)


class NET_DVR_LOCAL_LOG_CFG(Structure):
    _fields_ = [
        ("wSDKLogNum", WORD), # sdk在覆盖模式下，日志生成的个数 0为默认值（10个）
        ("byRes", BYTE * 254), # 保留
    ]


LPNET_DVR_LOCAL_LOG_CFG = POINTER(NET_DVR_LOCAL_LOG_CFG)


CHAR_ENCODE_CONVERT = WINFUNCTYPE(INT, CHARP, DWORD, DWORD, CHARP, DWORD, DWORD)
class NET_DVR_LOCAL_BYTE_ENCODE_CONVERT(Structure):
    _fields_ = [
        ("fnCharConvertCallBack", CHAR_ENCODE_CONVERT),
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_LOCAL_BYTE_ENCODE_CONVERT = POINTER(NET_DVR_LOCAL_BYTE_ENCODE_CONVERT)


class NET_DVR_LOCAL_SECURITY(Structure):
    _fields_ = [
        ("bySecurityLevel", BYTE), # 私有协议通信模式， 0-兼容模式（默认），允许所有的SDK登录协议通过，1-安全模式（MD5）, 允许RSA和MD5登录，开启校验2-安全模式（RSA）RSA登录，开启校验
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_LOCAL_SECURITY = POINTER(NET_DVR_LOCAL_SECURITY)


class NET_DVR_LOCAL_CHECK_DEV(Structure):
    _fields_ = [
        ("dwCheckOnlineTimeout", DWORD), # 巡检时间间隔，单位ms  最小值为30s，最大值120s。为0时，表示用默认值(120s)
        ("dwCheckOnlineNetFailMax", DWORD), # 由于网络原因失败的最大累加次数；超过该值SDK才回调用户异常，为0时，表示使用默认值1
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_LOCAL_CHECK_DEV = POINTER(NET_DVR_LOCAL_CHECK_DEV)


class NET_DVR_LOCAL_PTZ_CFG(Structure):
    _fields_ = [
        ("byWithoutRecv", BYTE), # 0-接收设备返回，1-不接收设备返回
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_LOCAL_PTZ_CFG = POINTER(NET_DVR_LOCAL_PTZ_CFG)


class NET_DVR_LOCAL_CFG_VERSION(Structure):
    _fields_ = [
        ("byVersion", BYTE), # 版本信息
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_LOCAL_CFG_VERSION = POINTER(NET_DVR_LOCAL_CFG_VERSION)


class NET_DVR_LOCAL_TCP_PORT_BIND_CFG(Structure):
    _fields_ = [
        ("wLocalBindTcpMinPort", WORD), # 本地绑定Tcp最小端口
        ("wLocalBindTcpMaxPort", WORD), # 本地绑定Tcp最大端口
        ("byRes", BYTE * 60), # 保留
    ]


LPNET_DVR_LOCAL_TCP_PORT_BIND_CFG = POINTER(NET_DVR_LOCAL_TCP_PORT_BIND_CFG)


class NET_DVR_LOCAL_UDP_PORT_BIND_CFG(Structure):
    _fields_ = [
        ("wLocalBindUdpMinPort", WORD), # 本地绑定Udp最小端口
        ("wLocalBindUdpMaxPort", WORD), # 本地绑定Udp最大端口
        ("byRes", BYTE * 60), # 保留
    ]


LPNET_DVR_LOCAL_UDP_PORT_BIND_CFG = POINTER(NET_DVR_LOCAL_UDP_PORT_BIND_CFG)


class NET_DVR_LOCAL_MEM_POOL_CFG(Structure):
    _fields_ = [
        ("dwAlarmMaxBlockNum", DWORD), # 报警模块内存池最多向系统申请的内存块（block）个数，每个block为64MB, 超过这个上限则不向系统申请，0表示无上限
        ("dwAlarmReleaseInterval", DWORD), # 报警模块空闲内存释放的间隔，单位秒，为0表示不释放
        ("dwObjectReleaseInterval", DWORD), # 对象申请模块空闲内存释放的间隔，单位秒，为0表示不释放
        ("byRes", BYTE * 508), # 保留
    ]


LPNET_DVR_LOCAL_MEM_POOL_CFG = POINTER(NET_DVR_LOCAL_MEM_POOL_CFG)


class NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG(Structure):
    _fields_ = [
        ("dwPreviewTime", DWORD), # 预览模块超时时间
        ("dwAlarmTime", DWORD), # 报警模块超时时间
        ("dwVodTime", DWORD), # 回放模块超时时间
        ("dwElse", DWORD), # 其他模块
        ("byRes", BYTE * 512), # 保留
    ]


LPNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG = POINTER(NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG)


MAX_CERTIFICATE_ISSUER_LEN = 64 # 证书颁发者长度
MAX_CERTIFICATE_VALIDITY_LEN = 128 # 证书有效时间长度
MAX_CERTIFICATE_SUBJECT_LEN = 64 # 证书持有者长度
class NET_DVR_CETTIFICATE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szIssuer", CHAR * MAX_CERTIFICATE_ISSUER_LEN), # 证书颁发者
        ("szSubject", CHAR * MAX_CERTIFICATE_SUBJECT_LEN), # 证书持有者
        ("struStartTime", NET_DVR_TIME),
        ("struEndTime", NET_DVR_TIME),
        ("byRes1", BYTE * 1024),
    ]


LPNET_DVR_CETTIFICATE_INFO = POINTER(NET_DVR_CETTIFICATE_INFO)

fnCertVerifyResultCallBack = WINFUNCTYPE(BOOL, DWORD, LPNET_DVR_CETTIFICATE_INFO, CHARP)
class NET_DVR_LOCAL_CERTIFICATION(Structure):
    _fields_ = [
        ("szLoadPath", CHAR * MAX_FILE_PATH_LEN),
        ("fnCB", fnCertVerifyResultCallBack),
        ("pUserData", VOIDP),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_LOCAL_CERTIFICATION = POINTER(NET_DVR_LOCAL_CERTIFICATION)


class NET_DVR_LOCAL_PORT_MULTI_CFG(Structure):
    _fields_ = [
        ("bEnable", BOOL), # 端口复用使能，true-开启
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_LOCAL_PORT_MULTI_CFG = POINTER(NET_DVR_LOCAL_PORT_MULTI_CFG)


class NET_DVR_RTSP_PARAMS_CFG(Structure):
    _fields_ = [
        ("dwMaxBuffRoomNum", DWORD), # rtp over udp排序开辟的最大缓冲区个数，0为无效，使用默认值20
        # 一个缓冲区开辟内存为10K多一点，缓冲区个数越多，处理乱序的能力则越强，流畅性越好，延时也越大
        ("byUseSort", BYTE), # 是否开启rtp over udp排序， 0-不开启  1-开启
        ("byRes", BYTE * 123),
    ]


LPNET_DVR_RTSP_PARAMS_CFG = POINTER(NET_DVR_RTSP_PARAMS_CFG)


class NET_DVR_OPTICAL_CHANNEL_BIND(Structure):
    _fields_ = [
        ("wChannelIndex", WORD), # 光口号(0-7)
        ("wSubChannel", WORD), # 光口子通道号，取值范围从能力集获取
        ("byBind", BYTE), # 0-不绑定或清除绑定，1-绑定
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_OPTICAL_CHANNEL_BIND = POINTER(NET_DVR_OPTICAL_CHANNEL_BIND)


class NET_DVR_OPTICAL_CHANNEL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struBindVideo", NET_DVR_OPTICAL_CHANNEL_BIND), # 视频绑定
        ("struBindAudio", NET_DVR_OPTICAL_CHANNEL_BIND), # 音频绑定
        ("byRes", BYTE * 16), # 保留
    ]


LPNET_DVR_OPTICAL_CHANNEL_CFG = POINTER(NET_DVR_OPTICAL_CHANNEL_CFG)


class NET_DVR_OPTICAL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySlotNum", BYTE), # 编码子系统槽位号
        ("byChannel", BYTE), # 编码通道号
        ("byRes", BYTE * 18),
    ]


LPNET_DVR_OPTICAL_INFO = POINTER(NET_DVR_OPTICAL_INFO)


# 音频切换
class NET_DVR_AUDIO_SURCHAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byStatus", BYTE), # 音频是否开启，1-开，0-关
        ("byRes1", BYTE * 3),
        # 以下参数当byStatus == 1时有效
        ("dwSubWinNum", DWORD), # 关联的子窗口号
        ("dwSurChanNum", DWORD), # 监控通道号
        ("struIpaddr", NET_DVR_IPADDR), # 监控通道地址
        ("wPort", WORD), # 监控通道端口
        ("byRes2", BYTE * 14),
    ]


LPNET_DVR_AUDIO_SURCHAN_CFG = POINTER(NET_DVR_AUDIO_SURCHAN_CFG)


# 端口聚合
MAX_ETHERNET_PORT_NUM = 8 # 每条链路最大端口数
class NET_DVR_ETHERNET_CHANNEL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byConverge", BYTE * MAX_ETHERNET_PORT_NUM),
        # byConverge[i] = j表示将第i个端口加入到第j条链路，j的取值为1-8,j=0表示移除
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_ETHERNET_CHANNEL_INFO = POINTER(NET_DVR_ETHERNET_CHANNEL_INFO)


# 畅显
class NET_DVR_SPARTAN_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySpartanStatus", BYTE), # 0-畅显关，1-畅显开
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_SPARTAN_INFO = POINTER(NET_DVR_SPARTAN_INFO)


class NET_DVR_IPADDR_FILTERCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 启用IP地址过滤，0-否，1-是
        ("byFilterType", BYTE), # 过滤类型，0-禁用，1-允许
        ("byRes", BYTE * 18),
        ("byIPAddr", BYTE * 1024), # IP地址信息，格式192.168.1.2192.168.1.3
    ]


LPNET_DVR_IPADDR_FILTERCFG = POINTER(NET_DVR_IPADDR_FILTERCFG)


class NET_DVR_LOGO_OVERLAYCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用，0-否，1-是
        ("byRes1", BYTE * 3),
        ("dwCoordinateX", DWORD), # 图片显示区域X坐标
        ("dwCoordinateY", DWORD), # 图片显示区域Y坐标
        ("wPicWidth", WORD), # 图片宽
        ("wPicHeight", WORD), # 图片高
        ("byLogoName", BYTE * 16), # Logo名称
    ]


LPNET_DVR_LOGO_OVERLAYCFG = POINTER(NET_DVR_LOGO_OVERLAYCFG)


class NET_DVR_INVALID_DISK_PARAM(Structure):
    _fields_ = [
        ("struStructHead", NET_DVR_STRUCTHEAD),
        ("dwDiskNo", DWORD), #  磁盘号
        ("byDelAll", BYTE), #  0-删除dwDiskNo  1-删除全部无效磁盘
        ("byres", BYTE * 31),
    ]


LPNET_DVR_INVALID_DISK_PARAM = POINTER(NET_DVR_INVALID_DISK_PARAM)


class NET_DVR_MOUNT_DISK_PARAM(Structure):
    _fields_ = [
        ("struStructHead", NET_DVR_STRUCTHEAD),
        ("dwDiskNo", DWORD), #  磁盘号
        ("byres", BYTE * 32),
    ]


LPNET_DVR_MOUNT_DISK_PARAM = POINTER(NET_DVR_MOUNT_DISK_PARAM)


#  长连接回调类型
#  回调类型为NET_SDK_CALLBACK_TYPE_STATUS时的状态值
# 一键配置通用状态
NET_SDK_OKC_STATUS_SUCCESS = 1000 # 一键配置成功
NET_SDK_OKC_STATUS_FAILED = 1002 # 一键配置失败
# 一键配置CVR状态
NET_SDK_OKC_STATUS_START_CONFIG = 1003 # 开始配置
NET_SDK_OKC_CHECK_HD = 1004 # 检测磁盘
NET_SDK_OKC_INIT_HD = 1005 # 初始化磁盘
NET_SDK_OKC_CREATE_RAID_OR_SINGLE_DISK = 1006 # 创建阵列或者单盘模式
NET_SDK_OKC_INIT_CVR_SERVICE = 1007 # 初始化CVR服务
NET_SDK_OKC_CREATE_RECORD_VOLUME = 1008 # 创建录像卷
# 以下为一键配置失败的状态码——part1
NET_SDK_OKC_ERR_LOAD_CONF_FAILED = 1009 # 加载配置文件失败
NET_SDK_OKC_ERR_NOT_SUPPORT_RAID_LEVLE = 1010 # 不支持此种类型的raid
NET_SDK_OKC_ERR_CONFIGURATION_CONFLICT = 1011 # 系统已经存在raid或存储池
NET_SDK_OKC_ERR_GET_DISK_INFO_FAILED = 1012 # 获取磁盘信息失败
NET_SDK_OKC_ERR_CHECK_DISK_FAILED = 1013 # 检测磁盘失败
NET_SDK_OKC_ERR_INIT_DISK_FAILED = 1014 # 初始化磁盘失败
NET_SDK_OKC_ERR_DISK_CAPACITY_SMALL = 1015 # 磁盘总容量不足
NET_SDK_OKC_ERR_BOTH_SV_NS = 1016 # 同时存在SV盘和NS盘
NET_SDK_OKC_ERR_CREATE_RAID_FAILED = 1017 # 创建raid失败
NET_SDK_OKC_ERR_GET_RAID_FAILED = 1018 # 获取raid失败
NET_SDK_OKC_ERR_CREATE_SPARE_FAILED = 1019 # 创建热备盘失败
NET_SDK_OKC_ERR_CREATE_STORAGE_POOL_FAILED = 1020 # 创建存储池失败
NET_SDK_OKC_ERR_GET_POOL_INFO_FAILED = 1021 # 获取存储池信息失败
NET_SDK_OKC_ERR_CREATE_LUN_FAILED = 1022 # 创建lun卷失败
NET_SDK_OKC_ERR_GET_LUN_INFO_FAILED = 1023 # 获取lun信息失败
NET_SDK_OKC_ERR_CREATE_BACKUP_FAILED = 1024 # 创建预留卷失败
NET_SDK_OKC_ERR_GET_BACKUP_FAILED = 1025 # 获取预留卷失败
NET_SDK_OKC_ERR_CREATE_PRIVATE_LUN_FAILED = 1026 # 创建私有卷失败
NET_SDK_OKC_ERR_CREATE_RV_FAILED = 1027 # 创建录像卷失败
NET_SDK_OKC_ERR_CREATE_ARCH_RV_FAILED = 1028 # 创建存档卷失败
NET_SDK_OKC_ERR_START_CVR_SERVICE_FAILED = 1029 # 开启CVR服务失败
# 一键配置SAN状态
NET_SDK_OKC_CREATING_ARRAY = 1030 # 创建阵列阶段
NET_SDK_OKC_CREATING_STORAGE_POOL = 1031 # 创建存储池阶段
NET_SDK_OKC_CREATING_LUN_VOL = 1032 # 创建逻辑卷阶段
NET_SDK_OKC_CREATING_ISCSI = 1033 # 创建ISCSI阶段
NET_SDK_OKC_ERR_HOT_SPARE_CONFICT = 1034 # 已存在热备盘
NET_SDK_OKC_ERR_STORAGE_POOL_CONFICT = 1035 # 已存在存储池
NET_SDK_OKC_ERR_RAID_CONFLICT = 1036 # 系统已经存在阵列
NET_SDK_OKC_ERR_OPEN_ISCSI_FAILED = 1037 # 开启ISCSI失败
NET_SDK_OKC_ERR_DEVICE_NOSUPPORT_SAN = 1038 # 设备不支持san
# 以下为一键配置失败的状态码——part2
NET_SDK_OKC_ERR_SAPRE_NUM_EXCEED = 1101 # 热备盘个数过多
NET_SDK_OKC_ERR_CREATE_PIC_VOLUME_FAILED = 1102 # 创建图片卷失败
#  用户调用SendwithRecv接口时，接口返回的状态
# 导入配置文件错误码
NET_SDK_IPC_CFG_FILE_NO_ERR = 0
NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_INVALID = 1
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_DUPLICATE,          通道ID重复
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_INVALID,               通道IP或域名非法
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_DUPLICATE,            通道IP或域名重复
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_CONFLICT_WITH_LOCAL,  通道IP与本地IP冲突
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_PROTOCOL_INVALID,          协议错误
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_PORT_INVALID,              管理端口错误
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_DEVICE_CHANNEL_ERR,    设备通道号错误
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_USER_NAME_ERR,        用户名含非法字符
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_PASSWD_ERR,              密码含非法字符
        # NET_SDK_IPC_CFG_FILE_ERR_CODE_TRANSPORT_PROTOCOL_INVALID 传输协议错误


# IPC升级错误码
MAX_CODE_CARD_SUPPORTDISPNUMS = 8 # 每个编码卡最多支持的显示通道数
MAX_SUPPORT_RES = 32
DS4004HC_BOARD = 2
DS4008HC_BOARD = 3
DS4016HC_BOARD = 4
DS4001HF_BOARD = 5
DS4004HF_BOARD = 6
DS4002MD_BOARD = 7
DS4004MD_BOARD = 8
DS4016HCS_BOARD = 9
DS4004HC_PLUS_BOARD = 13
DS4008HC_PLUS_BOARD = 14
DS4016HC_PLUS_BOARD = 15
DS4008HF_BOARD = 16
DS4008MD_BOARD = 17
DS4008HS_BOARD = 18
DS4016HS_BOARD = 19
        #
DS4108HCV_BOARD = 20
DS4116HCV_BOARD = 21
DS5016HC_BOARD = 22
        #
DS4208HFV_BOARD = 23
DS4216HC_BOARD = 24
DS4216HFV_BOARD = 25
        #
DS5008HF_BOARD = 26
DS5116HF_BOARD = 27
        #
DS5216HC_BOARD = 28
DS5208HF_BOARD = 29
DS5216HF_BOARD = 30
        #
DS4101HD_BOARD = 31
DS4102HD_BOARD = 32
DS4104HD_BOARD = 33
        #
DS4002MD_PLUS_BOARD = 34
DS4004MD_PLUS_BOARD = 35
        #
DS4204HFV_BOARD = 36
DS4308HCV_BOARD = 37
DS4308HFV_BOARD = 38
DS4316HCV_BOARD = 39
DS4316HFV_BOARD = 40
DS4304HD_BOARD = 41
DS4304HFH_BOARD = 42
DS4304HFV_BOARD = 43
DS4302HFH_BOARD = 44
DS5316HF_BOARD = 45
DS4308HW_BOARD = 46
DS4316HW_BOARD = 47
DS4308MD_BOARD = 48
UNKNOWN_BOARD_TYPE = 0xffffffff


class NET_DVR_CODECARD_ABILITY(Structure):
    _fields_ = [
        ("byCardType", BYTE), # 编码卡类型(按BOARD_TYPE中的枚举)
        ("byCodeNums", BYTE), # 编码通道数
        ("byDispNums", BYTE), # 显示通道数
        ("byCodeStartIdx", BYTE), # 首个编码通道在所有编码通道中的索引
        ("byDispStartIdx", BYTE), # 首个显示通道在所有显示通道中的索引
        ("byRes1", BYTE * 3),
        ("dwVgaSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持的分辨率
        ("dwHdmiSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持的分辨率
        ("dwDviSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持的分辨率
        ("dwYpbprSupportResolution", DWORD * MAX_SUPPORT_RES), # 支持的分辨率
        ("byDispFormat", BYTE * MAX_CODE_CARD_SUPPORTDISPNUMS), # 支持的输出模式(按HD_DISPLAY_FORMAT中的枚举)
        ("byWindowMode", BYTE * MAX_CODE_CARD_SUPPORTDISPNUMS), # 支持的窗口模式(比如1,2,4,9,16))
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_CODECARD_ABILITY = POINTER(NET_DVR_CODECARD_ABILITY)


MAX_CODE_CARD_NUM = 8 # 最多高清编码卡数
class NET_DVR_CODESVR_ABILITY(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byCardNums", BYTE), #  编码卡数
        ("byStartChan", BYTE), #  起始通道号
        ("byRes1", BYTE * 2),
        ("struCodeCardAbility", NET_DVR_CODECARD_ABILITY * MAX_CODE_CARD_NUM),
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_CODESVR_ABILITY = POINTER(NET_DVR_CODESVR_ABILITY)


class NET_DVR_CODER_SERVER_OUTPUT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDispChanType", BYTE), # 显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI 此参数只能获取
        ("byVedioFormat", BYTE), # 1:NTSC,2:PAL，0-NULL
        ("byRes1", BYTE * 2),
        ("dwResolution", DWORD), # 分辨率
        ("dwWindowMode", DWORD), # 画面模式，支持模式从能力集获取
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_CODER_SERVER_OUTPUT_CFG = POINTER(NET_DVR_CODER_SERVER_OUTPUT_CFG)


class NET_DVR_DISPLAY_START_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDisplayChan", DWORD), # 显示通道号
        ("dwCodeChan", DWORD), # 编码通道号
        ("dwWinNum", DWORD), # 窗口号，从1起
        ("byEnableAudio", BYTE), # 开启音频，0-关，1-开
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_DISPLAY_START_INFO = POINTER(NET_DVR_DISPLAY_START_INFO)


class NET_DVR_CODER_WINDOW_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDisplayChan", DWORD), # 显示通道号
        ("dwWinNum", DWORD), # 窗口号，从1开始
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_CODER_WINDOW_INFO = POINTER(NET_DVR_CODER_WINDOW_INFO)


class NET_DVR_WINDOW_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwCodeChan", DWORD), # 编码通道号
        ("byDisplay", BYTE), # 是否输出，0-否，1-是
        ("byAudio", BYTE), # 音频是否开启,0-否，1-是
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_WINDOW_STATUS = POINTER(NET_DVR_WINDOW_STATUS)


class NET_DVR_RECORD_LOCK_PERCENTAGE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byPercentage", BYTE), # 百分比，取值范围[0,100]
        ("byRes", BYTE * 31), # 保留
    ]


LPNET_DVR_RECORD_LOCK_PERCENTAGE = POINTER(NET_DVR_RECORD_LOCK_PERCENTAGE)


class NET_DVR_UPDATE_RECORD_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struStreasmInfo", NET_DVR_STREAM_INFO), # 流ID
        ("dwBeginTime", DWORD), # 录像总的开始时间
        ("dwEndTime", DWORD), # 录像总的结束时间
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_DVR_UPDATE_RECORD_INFO = POINTER(NET_DVR_UPDATE_RECORD_INFO)


class NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA(Structure):
    _fields_ = [
        ("struStreamInfo", NET_DVR_STREAM_INFO),
        ("dwCmdType", DWORD), # 外部触发类型
        ("dwRecordTimeLen", DWORD), # 录像持续时间，单位：秒
        ("byEventID", BYTE * MAX_EVENTID_LEN), # 事件ID，作为附加信息
        ("dwLockDuration", DWORD), # 锁定持续时间，单位：秒，0xffffffff- 永久锁定，0- 不锁
        ("byBackUp", BYTE), # 是否存档，0-不存档，1-存档
        ("byPreRecord", BYTE), # 是否预录，0-不预录，1-预录
        ("byRes", BYTE * 122),
    ]


LPNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA = POINTER(NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA)


class NET_DVR_LOCK_FILE_BY_NAME_PARA(Structure):
    _fields_ = [
        ("byFileName", BYTE * NAME_LEN), #  录像文件名，老协议只传32个文件名
        ("dwLockDuration", DWORD), #  锁定持续时间,单位秒，0xffffffff表示永久锁定
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_LOCK_FILE_BY_NAME_PARA = POINTER(NET_DVR_LOCK_FILE_BY_NAME_PARA)


class NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamInfo", NET_DVR_STREAM_INFO),
        ("dwStreamType", DWORD), # 码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……（自定义码流类型需通过GET /ISAPI/Streaming/channels/<ID>/customStream获取当前通道已经添加的所有自定义码流ID。自定义码流为6~10，其索引值就是6~10）
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND = POINTER(NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND)


class NET_DVR_MULTI_STREAM_COMPRESSIONCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwStreamType", DWORD), # 码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
        ("struStreamPara", NET_DVR_COMPRESSION_INFO_V30), # 码流压缩参数
        ("dwResolution", DWORD), # 当分辨率索引小于255时和byResolution保持一致，大于255时以该字段返回索引值判断。
        ("byRes", BYTE * 76),
    ]


LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG = POINTER(NET_DVR_MULTI_STREAM_COMPRESSIONCFG)


class NET_DVR_RECORD_PACK(Structure):
    _fields_ = [
        ("struStruceHead", NET_DVR_STRUCTHEAD),
        ("dwPackageInterval", DWORD), #  打包时间间隔 ，时间单位：分钟
        ("byRes", BYTE * 32), #  保留
    ]


LPNET_DVR_RECORD_PACK = POINTER(NET_DVR_RECORD_PACK)


NET_DVR_FIND_NAS_DIRECTORY = 6161 # 查找NAS目录
NET_DVR_NAS_FINDING = 0 # 正在查找
NET_DVR_NAS_RECV = 1 # 接收数据
NET_DVR_NAS_OVER = 2 # 查找结束
NET_DVR_NAS_EXCEPTION = 3 # 接收异常
class NET_DVR_NET_DISK_SERACH_PARAM(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), #  IP地址
        ("wPort", WORD), #  IP端口
        ("byRes", BYTE * 10), #  保留字节
    ]


LPNET_DVR_NET_DISK_SERACH_PARAM = POINTER(NET_DVR_NET_DISK_SERACH_PARAM)


class NET_DVR_NET_DISK_SERACH_RET(Structure):
    _fields_ = [
        ("byDirectory", BYTE * 128), #  返回的文件目录
        ("byRes", BYTE * 20),
    ]


LPNET_DVR_NET_DISK_SERACH_RET = POINTER(NET_DVR_NET_DISK_SERACH_RET)


class NET_DVR_WD1_CFG(Structure):
    _fields_ = [
        ("struStruceHead", NET_DVR_STRUCTHEAD),
        ("byWD1Enable", BYTE), # WD1使能开关 0 关闭 1 开启
        ("byRes", BYTE * 31), # 保留
    ]


LPNET_DVR_WD1_CFG = POINTER(NET_DVR_WD1_CFG)

class NET_DVR_FTP_TYPE(Structure):
    _fields_ = [
        ("byType", BYTE), #  0-主服务器，1-备服务器
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_FTP_TYPE = POINTER(NET_DVR_FTP_TYPE)


NET_SDK_ACCESS_KEY_LEN = 64 # 访问密码长度
NET_SDK_SECRET_KEY_LEN = 64 # 加密密码长度
class NET_DVR_GOP_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("lChannel", LONG), # 通道号
        ("struStartTime", NET_DVR_TIME_EX), # 开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 结束时间
        ("byRes", BYTE * 256), #  保留字节
    ]


LPNET_DVR_GOP_INFO = POINTER(NET_DVR_GOP_INFO)


class NET_DVR_GOP_INFO_RET(Structure):
    _fields_ = [
        ("struGopTime", NET_DVR_TIME_V30), # Gop信息时间点
        ("dwDuration", DWORD), # 信息持续时间
        ("dwDataSize", DWORD), # 指针pBuf大小
        ("byRes", BYTE * 128),
        ("pBuf", CHARP), # Gop信息块
    ]


LPNET_DVR_GOP_INFO_RET = POINTER(NET_DVR_GOP_INFO_RET)


class NET_DVR_GOP_INFO_PASSBACK(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struTime", NET_DVR_TIME_V30), # 开始时间,当数据类型为智能元数据时，表示的开始时间，当为缩略图时，表示的是图片时间
        ("dwDuration", DWORD), # 信息持续时间，仅当数据类型为智能元数据时有效
        ("dwMetaDataSize", DWORD), # 数据源的大小
        ("dwPicDataSize", DWORD), # 图片数据大小
        ("pMetaDataBuffer", CHARP), # 智能元数据缓冲区
        ("pPicDataBuf", CHARP), # 图片缓冲区
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_GOP_INFO_PASSBACK = POINTER(NET_DVR_GOP_INFO_PASSBACK)


class NET_DVR_SINGLEWALLPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE),
        ("byRes1", BYTE * 3),
        ("dwWallNum", DWORD), # 电视墙输出号
        # 坐标须为基准坐标的整数倍（128×128），宽度和高度值不用设置，即为基准值
        ("struRectCfg", NET_DVR_RECTCFG),
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_SINGLEWALLPARAM = POINTER(NET_DVR_SINGLEWALLPARAM)


# 窗口信息
class NET_DVR_WALLWINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE),
        ("byRes1", BYTE * 7),
        ("dwWinNum", DWORD), # 窗口号
        ("dwLayerIndex", DWORD), # 窗口相对应的图层号
        ("struWinPosition", NET_DVR_RECTCFG), # 目的窗口(相对显示墙)
        ("dwDeviceIndex", DWORD), # 分布式大屏控制器设备序号
        ("wInputIndex", WORD), # 输入信号源
        ("byRes2", BYTE * 14),
    ]


LPNET_DVR_WALLWINCFG = POINTER(NET_DVR_WALLWINCFG)


class NET_DVR_WALL_INDEX(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWallNo", BYTE), # 电视墙序号，从1开始
        ("bySceneNo", BYTE), # 场景序号
        ("byRes1", BYTE * 2),
        ("dwDeviceID", DWORD), # 分布式子设备ID
        ("dwWindowNo", DWORD), # 窗口序号/信号源序号
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_WALL_INDEX = POINTER(NET_DVR_WALL_INDEX)


class NET_DVR_WALLWINPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byTransparency", BYTE), # 使能透明度，0-关，非0-开
        ("byWinMode", BYTE), # 窗口分屏模式，能力集获取
        ("byEnableSpartan", BYTE), # 畅显使能，0-关，1-开
        ("byDecResource", BYTE), # 为窗口分配的解码资源，1-D1,2-720P,3-1080P
        ("byWndShowMode", BYTE), # 窗口显示模式，0-此字段不用，1-子窗口模式，2-子窗口全屏模式
        ("byEnabledFeature", BYTE), # 是否启用场景特写，0-不启用，!0-启用
        ("byFeatureMode", BYTE), # 特写模式，启用场景特写时有效，0-无效，1-“1+5”模式
        ("byRes1", BYTE),
        ("dwAmplifyingSubWndNo", DWORD), # 全屏子窗口号（1字节墙号+1字节子窗口号+2字节窗口号）
        # 当byWndShowMode为2时有效，表示当前全屏显示的子窗口
        ("byWndTopKeep", BYTE), # 窗口置顶保持，0-不保持，1-保持
        ("byWndOpenKeep", BYTE), # 窗口打开保持，0-不保持，1-保持
        ("byRes", BYTE * 22),
    ]


LPNET_DVR_WALLWINPARAM = POINTER(NET_DVR_WALLWINPARAM)


class NET_DVR_WALLSCENECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sSceneName", BYTE * NAME_LEN), # 场景名称
        ("byEnable", BYTE), # 场景是否有效，0-无效，1-有效
        ("bySceneIndex", BYTE), # 场景号，只能获取。获取所有场景时使用该参数
        ("byRes", BYTE),
    ]


LPNET_DVR_WALLSCENECFG = POINTER(NET_DVR_WALLSCENECFG)


class NET_DVR_WALLWIN_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwWinNum", DWORD), # 窗口号
        ("dwSubWinNum", DWORD), # 子窗口号
        ("dwWallNo", DWORD), # 墙号
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_WALLWIN_INFO = POINTER(NET_DVR_WALLWIN_INFO)


class NET_DVR_WALL_WIN_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDecodeStatus", BYTE), # 当前解码状态:0:未启动,1 :已启动
        ("byStreamType", BYTE), # 码流类型
        ("byPacketType", BYTE), # 打包方式
        ("byFpsDecV", BYTE), # 视频解码帧率
        ("byFpsDecA", BYTE), # 音频解码帧率
        ("byRes1", BYTE * 7),
        ("dwDecodedV", DWORD), # 解码的视频帧
        ("dwDecodedA", DWORD), # 解码的音频帧
        ("wImgW", WORD), # 当前码流源的图像大小
        ("wImgH", WORD),
        ("byStreamMode", BYTE), # 码流源(此参数对视频综合平台有效)：1-网络，2-综合平台内部编码子系统，3-屏幕服务器，0xff-无效
        ("byRes2", BYTE * 31),
    ]


LPNET_DVR_WALL_WIN_STATUS = POINTER(NET_DVR_WALL_WIN_STATUS)


class NET_DVR_WININDEX_INFO(Structure):
    _fields_ = [
        ("dwWinIndex", DWORD), # 窗口号
        ("dwSubWinIndex", DWORD), # 子窗口号
        ("byType", BYTE), # 资源类型，1-解码，2-回显
        ("byWallNo", BYTE), # 墙号
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_WININDEX_INFO = POINTER(NET_DVR_WININDEX_INFO)


class NET_DVR_ASSOCIATEDDEV_CHAN_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sAddress", BYTE * MAX_DOMAIN_NAME), # ip地址，或是域名
        ("wDVRPort", WORD), #  端口号
        ("wChannel", WORD), #  通道号
        ("sUserName", BYTE * NAME_LEN), #  监控主机登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), #  监控主机密码
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_ASSOCIATEDDEV_CHAN_INFO = POINTER(NET_DVR_ASSOCIATEDDEV_CHAN_INFO)


class NET_DVR_WALLOUTPUTPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwResolution", DWORD), # 分辨率
        ("struRes", NET_DVR_VIDEOEFFECT),
        ("byVideoFormat", BYTE), # 视频制式，见VIDEO_STANDARD
        ("byDisplayMode", BYTE), # 输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，0xff-无效
        ("byBackgroundColor", BYTE), # 背景色，0-无效，不支持背景色，1-红，2-绿，3-蓝，4-黄，5-紫，6-青，7-黑，8-白，0xff-自定义
        ("byUseEDIDResolution", BYTE), # 是否使用EDID分辨率，0-不使用，1-使用
        ("wLEDWidth", WORD), # LED屏输出分辨率宽
        ("wLEDHeight", WORD), # LED屏输出分辨率高
        ("struBackColor", NET_DVR_RGB_COLOR), # 背景色，byBackgroundColor为0xff时有效
        ("byLinkStatus", BYTE), # 输出口连接状态，0-无效,1-接入显示器,2-未接入显示器
        ("byRes2", BYTE * 51),
    ]


LPNET_DVR_WALLOUTPUTPARAM = POINTER(NET_DVR_WALLOUTPUTPARAM)


MAX_UNITEDMATRIX_NUM = 8 # 级联中最多视频综合平台数量
class NET_DVR_SUBMATRIXSYSTEMINFO(Structure):
    _fields_ = [
        # 平台号，0表示无此平台
        ("dwSequence", DWORD),
        ("sAddress", BYTE * MAX_DOMAIN_NAME), # ip地址，或是域名
        ("wSubMatrixPort", WORD), # 子系统端口号
        ("byRes1", BYTE * 6),
        ("sUserName", BYTE * NAME_LEN), # 用户名
        ("sPassword", BYTE * PASSWD_LEN), # 密码
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_SUBMATRIXSYSTEMINFO = POINTER(NET_DVR_SUBMATRIXSYSTEMINFO)


class NET_DVR_UNITEDMATRIXSYSTEMINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 视频综合平台信息
        ("struMatrixInfo", NET_DVR_SUBMATRIXSYSTEMINFO * MAX_UNITEDMATRIX_NUM),
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_UNITEDMATRIXSYSTEMINFO = POINTER(NET_DVR_UNITEDMATRIXSYSTEMINFO)


class NET_DVR_SUBSTREAM_SWITCH_CFG(Structure):
    _fields_ = [
        ("byAutoSwitchEnable", BYTE), # 子码流自动切换，0 - 不启用，1 - 启用
        ("byRes1", BYTE * 3),
        ("wSubWndWidth", WORD), # 子窗口宽度设定值，byAutoSwitchEnable为1时有效
        ("wSubWndHeight", WORD), # 子窗口高度设定值，byAutoSwitchEnable为1时有效
    ]


LPNET_DVR_SUBSTREAM_SWITCH_CFG = POINTER(NET_DVR_SUBSTREAM_SWITCH_CFG)


class NET_DVR_WALL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byTransparency", BYTE), # 透明度,0-100,0为不透明
        ("byWinStaticMode", BYTE), # 窗口解码停止显示模式，1-清屏(之前的清屏后是黑色)，2-显示最后一帧图像
        ("byStreamFailedMode", BYTE), # 取流失败显示模式，1-“无网络视频信号”，2-显示最后一帧图像，3-连接异常，4-清屏
        ("byEnabledOverlayLogo", BYTE), # 解码能力不足时是否叠加LOGO以提示用户，0-不叠加，!0-叠加
        ("struSubStreamSwitch", NET_DVR_SUBSTREAM_SWITCH_CFG), # 子码流切换
        ("byLEDShowMode", BYTE), # LED窗口显示模式，0-普通模式，1-平铺模式
        ("byLowLatencyMode", BYTE), # 低延时模式，0-普通模式，1-低延时模式
        ("byRes", BYTE * 50),
    ]


LPNET_DVR_WALL_CFG = POINTER(NET_DVR_WALL_CFG)

class NET_DVR_LOW_LIGHT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLowLightLimt", BYTE), #  低照度电子快门: 0-关，1-开
        ("byLowLightLimtLevel", BYTE),
        # 球机0-关，1-慢快门*2，2-慢快门*3，3-慢快门*4，4-慢快门*6，5-慢快门*8，6-慢快门*12，7-慢快门*16，
        # 8-慢快门*24，9-慢快门*32，10-慢快门*48，11-慢快门*64，12-慢快门*96，13-慢快门*128，14-慢快门*256，
        # 15-慢快门*512, 16-慢快门*1.25, 17-慢快门*1.5
        ("byRes", BYTE * 66),
    ]


LPNET_DVR_LOW_LIGHT_CFG = POINTER(NET_DVR_LOW_LIGHT_CFG)


class NET_DVR_FOCUSMODE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFocusMode", BYTE), #  聚焦模式，0-自动，1-手动，2-半自动
        ("byAutoFocusMode", BYTE), #  自动聚焦模式，0-关，1-模式A，2-模式B，3-模式AB，4-模式C 自动聚焦模式，需要在聚焦模式为自动时才显示
        ("wMinFocusDistance", WORD), #  最小聚焦距离，单位CM,  0-自动，0xffff-无穷远
        ("byZoomSpeedLevel", BYTE), #  变倍速度，为实际取值，1-3
        ("byFocusSpeedLevel", BYTE), #  聚焦速度，为实际取值，1-3
        ("byOpticalZoom", BYTE), #  光学变倍，0-255
        ("byDigtitalZoom", BYTE), #  数字变倍，0-255
        ("fOpticalZoomLevel", DOUBLE), #  光学变倍(倍率值) [1,32], 最小间隔0.5 ，内部设备交互的时候*1000
        ("dwFocusPos", DWORD), #  dwFocusPos 是focus值（聚焦值），范围为[0x1000,0xC000]，这个值是sony坐标值，使用这个值是为了对外统一，保证不同的镜头对外focus值都转换在这个范围内 (手动聚焦模式下下应用)
        ("byFocusDefinitionDisplay", BYTE), #  聚焦清晰度显示，0~不显示，1~显示, 开启会在码流上显示当前镜头目标的清晰度值，用于帮助客户调焦使相机抓拍能够达到最清晰的效果，该清晰度越大代表着越清晰，清晰度范围为：0~100.0000
        ("byFocusSensitivity", BYTE), # 聚焦灵敏度，范围[0,2]，聚焦模式为自动、半自动时生效
        ("byRes1", BYTE * 2),
        ("dwRelativeFocusPos", DWORD), # 相对focus值，其低16位表示聚焦值，0~4000；高16位代表当前聚焦值获取时的温度值
        ("byRes", BYTE * 48),
    ]


LPNET_DVR_FOCUSMODE_CFG = POINTER(NET_DVR_FOCUSMODE_CFG)


class NET_DVR_INFRARE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIrControlMode", BYTE), #  红外球机配置-控制模式：0-自动，1-手动
        ("byIrBrightness", BYTE), #  红外球机配置-红外亮度：0-100
        ("byIrSensitivity", BYTE), #  红外球机配置-红外灯灵敏度：0-100
        ("byIrTrigMode", BYTE), #  触发模式 0-机芯触发，1-光敏触发 自动模式下生效
        ("byIrBrightnessLimit", BYTE), #  亮度限制 如果此值为80，表示的意义是当前红外灯的亮度为原先根据自动策略计算出的亮度值×80% 自动模式下生效
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_INFRARE_CFG = POINTER(NET_DVR_INFRARE_CFG)


class NET_DVR_AEMODECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("iIrisSet", INT), #  光圈，为实际取值*100的值，0-关
        ("iGainSet", INT), #  快球增益，曝光补偿，为实际取值*100的值，有可能是负值
        ("iGainLimit", INT), #  增益限制，曝光补偿，为实际取值*100的值，有可能是负值
        ("iExposureCompensate", INT), #  曝光补偿，为实际取值*100的值，比如1050代表10.5dB, -750代表-7.5dB
        ("byExposureModeSet", BYTE), #  球机的曝光模式,0-手动模式，1-自动曝光，2-光圈优先，3-快门优先，4-增益优先
        ("byShutterSet", BYTE), #  快门，0-关，1-自动x1，2-自动x2，3-自动x4，4-自动x8，5-自动x16，6-自动x32，7-自动x64，8-自动x128，9-1/1，10-1/2，
        # 11-1/3，12-1/4，13-1/6，14-1/8，15-1/12，16-1/15，17-1/25，18-1/30，19-1/50，20-1/60，21-1/75，
        # 22-1/90，23-1/100，24-1/120，25-1/125，26-1/150，27-1/180，28-1/200，29-1/215，30-1/250，31-1/300，
        # 32-1/350，33-1/425，34-1/500，35-1/600，36-1/725，37-1/1000，38-1/1250，39-1500,40-1/1750，41-1/2000，
        # 42-1/2500，43-3000,44-1/3500，45-1/4000，46-1/6000，47-1/10000，48-1/30000，49-1/100000,50-1/175，
        # 51-1/195，52-1/225，53-1/230
        ("byImageStabilizeLevel", BYTE), #  防抖动等级: 0-3
        ("byCameraIrCorrect", BYTE), #  红外校正: 0-自动，1-开，2,关
        ("byHighSensitivity", BYTE), #  高灵敏度设置: 0-关，1-开
        ("byInitializeLens", BYTE), #  初始化镜头: 0-关，1-开
        ("byChromaSuppress", BYTE), #  色彩抑制 :0-255
        ("byMaxShutterSet", BYTE), # 最大快门值索引值与byShutterSet相同(在自动曝光、光圈优先模式下生效)
        ("byMinShutterSet", BYTE), # 最小快门值索引值与byShutterSet相同(在自动曝光、光圈优先模式下生效)
        ("byMaxIrisSet", BYTE), # 最大光圈限制值(自动曝光、快门优先模式) [0,100]
        ("byMinIrisSet", BYTE), # 最小光圈限制值(自动曝光、快门优先模式) [0,100]
        ("byExposureLevel", BYTE), # 曝光等级（曝光模式为自动、光圈优先、快门优先情况有效），等级1-5 默认4，兼容老版本SDK配置新设备时，保留字节为0的情况，所以这个字节为0时，也默认为曝光等级为1
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_AEMODECFG = POINTER(NET_DVR_AEMODECFG)


class NET_DVR_FLASH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("dwInNumbers", DWORD), # 进入人数
        ("dwOutNumbers", DWORD), # 离开人数
        ("dwStartTime", DWORD), # 开始时间秒数
        ("dwEndTime", DWORD), # 结束时间秒数
        ("dwEhomeFlag", DWORD),
        ("dwAlarmFlag", DWORD),
        ("byRes", BYTE * 1024),
    ]


LPNET_DVR_FLASH_CFG = POINTER(NET_DVR_FLASH_CFG)


class NET_DVR_EXTERNAL_MATRIX_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), #  有效时为设置，无效时为删除
        ("byRes1", BYTE * 3),
        ("sMatrixName", BYTE * NAME_LEN), #  矩阵的名称
        ("dwMatrixID", DWORD), #  矩阵的ID号，只能获取
        ("wMatrixInputChanNum", WORD), #  矩阵的输入通道数目
        ("wMatrixOutputChanNum", WORD), #  矩阵的输出通道数目
        ("wMatrixOutputChanRef", WORD * MAX_CAM_COUNT), #  设备输入和矩阵输出的绑定关系，数组下标表示控制器设备输入通道号，元素的值表示矩阵的输出通道号，
        # 元素值大于0 表示绑定矩阵输出通道，元素值为0时表示不绑定，屏幕服务器为屏幕索引号和矩阵输出的绑定关系
        ("byMatrixChanType", BYTE), #  矩阵的通道类型1-BNC、2-VGA、3-RGB、4-DVI
        ("byMatrixProtocol", BYTE), #  矩阵所用协议1、ZT1.0、2.ZT2.0、3.Extron、4.Creator
        ("byMatrixType", BYTE), # 1-模拟矩阵，2-数字矩阵
        ("byRes2", BYTE),
        ("struMatrixUnion", NET_MATRIX_UNION),
        ("byRes3", BYTE * 128),
    ]


LPNET_DVR_EXTERNAL_MATRIX_CFG = POINTER(NET_DVR_EXTERNAL_MATRIX_CFG)


class NET_DVR_EXTERNAL_MATRIX_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), #  有效时为设置，无效时为删除
        ("byRes1", BYTE * 3),
        ("sMatrixName", BYTE * NAME_LEN), #  矩阵的名称
        ("dwMatrixID", DWORD), #  矩阵的ID号，只能获取
        ("wMatrixInputChanNum", WORD), #  矩阵的输入通道数目
        ("wMatrixOutputChanNum", WORD), #  矩阵的输出通道数目
        ("wMatrixOutputChanRef", WORD * MAX_CAM_COUNT_V50), #  设备输入和矩阵输出的绑定关系，数组下标表示控制器设备输入通道号，元素的值表示矩阵的输出通道号，
        # 元素值大于0 表示绑定矩阵输出通道，元素值为0时表示不绑定，屏幕服务器为屏幕索引号和矩阵输出的绑定关系
        ("byMatrixChanType", BYTE), #  矩阵的通道类型1-BNC、2-VGA、3-RGB、4-DVI
        ("byMatrixProtocol", BYTE), #  矩阵所用协议1、ZT1.0、2.ZT2.0、3.Extron、4.Creator
        ("byMatrixType", BYTE), # 1-模拟矩阵，2-数字矩阵
        ("byRes2", BYTE),
        ("struMatrixUnion", NET_MATRIX_UNION),
        ("byRes3", BYTE * 128),
    ]


LPNET_DVR_EXTERNAL_MATRIX_CFG_V50 = POINTER(NET_DVR_EXTERNAL_MATRIX_CFG_V50)


MAX_INPUTNUMS = 1024
MAX_OUTPUTNUMS = 256
class NET_DVR_ASSOCIATE_INPUT_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byRes1", BYTE * 3),
        ("dwDeviceIndex", DWORD), # 分布式大屏控制器设备序号
        ("wInputIndex", WORD), # 输入信号源
        ("byRes2", BYTE * 18),
    ]


LPNET_DVR_ASSOCIATE_INPUT_PARAM = POINTER(NET_DVR_ASSOCIATE_INPUT_PARAM)


class NET_DVR_ASSOCIATE_OUTPUT_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byWallNo", BYTE), # 墙号，从1开始
        ("byRes1", BYTE * 2),
        ("dwOutputIndex", DWORD), # 输出显示屏的序号
        ("byRes2", BYTE * 20),
    ]


LPNET_DVR_ASSOCIATE_OUTPUT_PARAM = POINTER(NET_DVR_ASSOCIATE_OUTPUT_PARAM)


class NET_DVR_VCS_USER_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sUserName", BYTE * NAME_LEN), #  用户名，最大16字节
        ("sPassWord", BYTE * PASSWD_LEN), #  密码
        ("struUserIP", NET_DVR_IPADDR), #  用户IP地址(为0时表示允许任何地址)
        ("byMacAddr", BYTE * MACADDR_LEN), #  物理地址
        ("byPriority", BYTE), #  优先级，1-管理员，2-操作员 ，管理员具有任何权限，操作员没有"管理用户"的权限
        ("byRes1", BYTE),
        ("dwRight", DWORD), # 远程操作权限，按位表示，0-不支持，1-支持，各32位代表的权限类型
        # bit0-获取设置基本参数
        # bit1-显示屏管理
        # bit2-窗口管理
        # bit3-信号源管理
        # bit4-布局管理
        # bit5-预案管理
        # bit6-底图管理
        # bit7-OSD管理
        # bit8-回显权限
        # bit9-报警布防
        # bit10-远程升级
        # bit11-恢复默认设置
        # bit12-导入导出配置配置文件
        # bit13-日志查询
        # bit14-远程重启
        # bit15-屏幕区域管理
        ("struInputParam", NET_DVR_ASSOCIATE_INPUT_PARAM * MAX_INPUTNUMS),
        ("struOutputParam", NET_DVR_ASSOCIATE_OUTPUT_PARAM * MAX_OUTPUTNUMS),
        ("struManageRegion", NET_DVR_RECTCFG_EX), # 屏幕管理区域
        ("byWallNo", BYTE), # 开启屏幕管理区域的墙号，对只支持单墙的设备，此字段无效
        ("byRes2", BYTE * 3),
        ("sLoginPassword", BYTE * PASSWD_LEN), #  登陆密码
        ("byRes", BYTE * 88),
    ]


LPNET_DVR_VCS_USER_INFO = POINTER(NET_DVR_VCS_USER_INFO)


class NET_DVR_STREAM_MEDIA_SERVER_CFG_V41(Structure):
    _fields_ = [
        ("byValid", BYTE), # 是否启用，0-否，1-是
        ("byRes1", BYTE * 3),
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # IP或者域名
        ("wDevPort", WORD), # 流媒体服务器端口
        ("byTransmitType", BYTE), # 传输协议类型 0-TCP，1-UDP
        ("byRes2", BYTE * 69),
    ]


LPNET_DVR_STREAM_MEDIA_SERVER_CFG_V41 = POINTER(NET_DVR_STREAM_MEDIA_SERVER_CFG_V41)


# 设备通道信息
class NET_DVR_DEV_CHAN_INFO_V41(Structure):
    _fields_ = [
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # 设备域名
        ("wDVRPort", WORD), # 端口号
        ("byChannel", BYTE), # 通道号
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP，1-UDP
        ("byTransMode", BYTE), # 传输码流模式 0－主码流 1－子码流
        ("byFactoryType", BYTE), # 前端设备厂家类型,通过接口获取
        ("byDeviceType", BYTE), # 设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
        ("byDispChan", BYTE), # 显示通道号,智能配置使用
        ("bySubDispChan", BYTE), # 显示通道子通道号，智能配置时使用
        ("byResolution", BYTE), #  1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
        ("byUseZeroChan", BYTE), # 是否使用零通道，0-否，1-是
        ("byRes", BYTE),
        ("sUserName", BYTE * NAME_LEN), # 监控主机登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), # 监控主机密码
    ]


LPNET_DVR_DEV_CHAN_INFO_V41 = POINTER(NET_DVR_DEV_CHAN_INFO_V41)


class NET_DVR_DEV_CHAN_INFO_EX(Structure):
    _fields_ = [
        ("byChanType", BYTE), # 通道类型，0-普通通道,1-零通道,2-流ID，3-本地输入源，4-虚拟屏服务器通道，5-拼接通道，6-屏幕服务器，7-分布式网络源，8-多相机融合通道，9-网络输入源
        ("byStreamId", BYTE * STREAM_ID_LEN), # 流ID，当byChanType=2、9时，该字段用于指定流或者网络ipc的ID号
        ("byRes1", BYTE * 3),
        ("dwChannel", DWORD), # 通道号，通道类型为普通通道，零通道，本地输入源，虚拟屏服务器通道，拼接通道，屏幕服务器，分布式网络源时填此字段
        ("byRes2", BYTE * 24),
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # 设备域名
        ("wDVRPort", WORD), # 端口号
        ("byChannel", BYTE), # 通道号,dwChannel不为0时此字段无效
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP，1-UDP
        ("byTransMode", BYTE), # 传输码流模式 0－主码流 1－子码流
        ("byFactoryType", BYTE), # 前端设备厂家类型,通过接口获取
        ("byDeviceType", BYTE), # 设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
        ("byDispChan", BYTE), # 显示通道号,智能配置使用
        ("bySubDispChan", BYTE), # 显示通道子通道号，智能配置时使用
        ("byResolution", BYTE), #  1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
        ("byRes", BYTE * 2),
        ("sUserName", BYTE * NAME_LEN), # 监控主机登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), # 监控主机密码
    ]


LPNET_DVR_DEV_CHAN_INFO_EX = POINTER(NET_DVR_DEV_CHAN_INFO_EX)


class NET_DVR_STREAM_MEDIA_SERVER(Structure):
    _fields_ = [
        ("byValid", BYTE), # 是否启用，0-否，1-是
        ("byRes1", BYTE * 3),
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # IP或者域名
        ("wDevPort", WORD), # 流媒体服务器端口
        ("byTransmitType", BYTE), # 传输协议类型 0-TCP，1-UDP
        ("byRes2", BYTE * 5),
    ]


LPNET_DVR_STREAM_MEDIA_SERVER = POINTER(NET_DVR_STREAM_MEDIA_SERVER)


class NET_DVR_DEV_DDNS_INFO(Structure):
    _fields_ = [
        ("byDevAddress", BYTE * MAX_DOMAIN_NAME), # 域名(IPServer或hiDDNS时可填序列号或者别名)
        ("byTransProtocol", BYTE), # 传输协议类型0-TCP，1-UDP, 2-MCAST
        ("byTransMode", BYTE), # 传输码流模式 0－主码流 1－子码流
        ("byDdnsType", BYTE), # 域名服务器类型，0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，3- NO-IP, 4- hiDDNS
        ("byRes1", BYTE),
        ("byDdnsAddress", BYTE * MAX_DOMAIN_NAME), # DDNS服务器地址
        ("wDdnsPort", WORD), # DDNS服务器端口号
        ("byChanType", BYTE), # 0-普通通道,1-零通道,2-流ID
        ("byFactoryType", BYTE), # 前端设备厂家类型,通过接口获取
        ("dwChannel", DWORD), # 通道号
        ("byStreamId", BYTE * STREAM_ID_LEN), # 流ID
        ("sUserName", BYTE * NAME_LEN), # 监控主机登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), # 监控主机密码
        ("wDevPort", WORD), # 前端设备通信端口
        ("byRes2", BYTE * 2),
    ]


LPNET_DVR_DEV_DDNS_INFO = POINTER(NET_DVR_DEV_DDNS_INFO)


class NET_DVR_DEC_STREAM_DEV_EX(Structure):
    _fields_ = [
        ("struStreamMediaSvrCfg", NET_DVR_STREAM_MEDIA_SERVER),
        ("struDevChanInfo", NET_DVR_DEV_CHAN_INFO_EX),
    ]


LPNET_DVR_DEC_STREAM_DEV_EX = POINTER(NET_DVR_DEC_STREAM_DEV_EX)


# DDNS方式取流
class NET_DVR_DEC_DDNS_DEV(Structure):
    _fields_ = [
        ("struDdnsInfo", NET_DVR_DEV_DDNS_INFO),
        ("struMediaServer", NET_DVR_STREAM_MEDIA_SERVER),
    ]


LPNET_DVR_DEC_DDNS_DEV = POINTER(NET_DVR_DEC_DDNS_DEV)


class NET_DVR_DEC_STREAM_MODE(Union):
    _fields_ = [
        ("struDecStreamDev", NET_DVR_DEC_STREAM_DEV_EX),
        ("struUrlInfo", NET_DVR_PU_STREAM_URL),
        ("struDdnsDecInfo", NET_DVR_DEC_DDNS_DEV),
        ("byRes", BYTE * 300),
    ]


LPNET_DVR_DEC_STREAM_MODE = POINTER(NET_DVR_DEC_STREAM_MODE)


class NET_DVR_PU_STREAM_CFG_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byStreamMode", BYTE), # 取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流
        ("byStreamEncrypt", BYTE), # 是否进行码流加密处理,0-不支持,1-支持
        ("byRes1", BYTE * 2),
        ("uDecStreamMode", NET_DVR_DEC_STREAM_MODE), # 取流信息
        ("dwDecDelayTime", DWORD), # 解码延时时间，单位：毫秒
        ("sStreamPassword", BYTE * STREAM_PASSWD_LEN), # 码流加密密码,需敏感信息加密
        ("byRes2", BYTE * 48),
    ]


LPNET_DVR_PU_STREAM_CFG_V41 = POINTER(NET_DVR_PU_STREAM_CFG_V41)


class NET_DVR_MATRIX_CHAN_INFO_V41(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用，0-否，1-是
        ("byStreamMode", BYTE), # 取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流
        ("byRes", BYTE * 2),
        ("uDecStreamMode", NET_DVR_DEC_STREAM_MODE), # 取流信息
    ]


LPNET_DVR_MATRIX_CHAN_INFO_V41 = POINTER(NET_DVR_MATRIX_CHAN_INFO_V41)


class NET_DVR_MATRIX_LOOP_DECINFO_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPoolTime", DWORD), # 轮巡间隔
        ("struchanConInfo", NET_DVR_MATRIX_CHAN_INFO_V41 * MAX_CYCLE_CHAN_V30),
        ("byStreamEncrypt", BYTE), # 是否进行码流加密处理,0-不支持,1-支持
        ("byRes", BYTE * 3),
        ("sStreamPassword", BYTE * STREAM_PASSWD_LEN), # 码流加密密码,需敏感信息加密
    ]


LPNET_DVR_MATRIX_LOOP_DECINFO_V41 = POINTER(NET_DVR_MATRIX_LOOP_DECINFO_V41)


class NET_DVR_MATRIX_DEC_CHAN_INFO_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byStreamMode", BYTE), # 取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流
        ("byRes1", BYTE * 3),
        ("uDecStreamMode", NET_DVR_DEC_STREAM_MODE), # 取流信息
        ("dwPlayMode", DWORD), #  0-动态解码 1－循环解码 2－按时间回放 3－按文件回放
        ("StartTime", NET_DVR_TIME), #  按时间回放开始时间
        ("StopTime", NET_DVR_TIME), #  按时间回放停止时间
        ("sFileName", BYTE * 128), #  按文件回放文件名
        ("dwGetStreamMode", DWORD), # 取流模式:1-主动，2-被动
        ("struPassiveMode", NET_DVR_MATRIX_PASSIVEMODE),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41 = POINTER(NET_DVR_MATRIX_DEC_CHAN_INFO_V41)


class NET_DVR_IP_ADDRESS(Structure):
    _fields_ = [
        ("byDevAddress", BYTE * MAX_DOMAIN_NAME), # 设备IP地址
        ("wDevPort", WORD), # 设备端口
        ("byres", BYTE * 134),
    ]


LPNET_DVR_IP_ADDRESS = POINTER(NET_DVR_IP_ADDRESS)


class NET_DVR_DDNS_ADDRESS(Structure):
    _fields_ = [
        ("byDevAddress", BYTE * MAX_DOMAIN_NAME), # DDNS域名
        ("byDevDdns", BYTE * MAX_DOMAIN_NAME), # 设备地址
        ("byDdnsType", BYTE), # 域名服务器类型，0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，3- NO-IP, 4- hiDDNS
        ("byRes1", BYTE * 3),
        ("wDevPort", WORD), # 设备端口
        ("wDdnsPort", WORD), # 域名服务器端口
        ("byres", BYTE * 64),
    ]


LPNET_DVR_DDNS_ADDRESS = POINTER(NET_DVR_DDNS_ADDRESS)


class NET_DVR_PLAY_BACK_BY_TIME(Structure):
    _fields_ = [
        ("StartTime", NET_DVR_TIME),
        ("StopTime", NET_DVR_TIME),
    ]


LPNET_DVR_PLAY_BACK_BY_TIME = POINTER(NET_DVR_PLAY_BACK_BY_TIME)


class NET_DVR_DISPLAY_EFFECT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struColor", NET_DVR_COLOR), # 显示相关参数/
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DISPLAY_EFFECT_CFG = POINTER(NET_DVR_DISPLAY_EFFECT_CFG)


# 获取干线状态
class NET_DVR_TRUNK_USE_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTrunkID", DWORD), # 干线ID
        ("wReserveUserID", WORD), # 预留的用户ID： 1~256 ，0表示释放预留
        ("byStatus", BYTE), # 1-空闲，2-占用，3-复用
        ("byRes1", BYTE),
        ("byUserId", BYTE * 256), # 数组下标表示用户ID号，数组元素的值表示是否使用干线。如：byUserID[0] 的值为1，表示用户ID为0的用户正在使用，byUserID[0] 的值为0表示用户ID为0的用户没有使用这条干线
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_TRUNK_USE_STATE = POINTER(NET_DVR_TRUNK_USE_STATE)


# PTZ控制参数
class NET_DVR_PTZ_CTRL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCtrlDelayTime", DWORD), # PTZ控制持续时间，指PTZ控制后在dwCtrlDelayTime时间内，其他同级别或低级别用户对其操作无效。单位：秒
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PTZ_CTRL_INFO = POINTER(NET_DVR_PTZ_CTRL_INFO)


# 显示路径
MAX_MATRIX_CASCADE = 32
class NET_DVR_MATRIX_ROUTE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCamNo", DWORD),
        ("dwMonNo", DWORD),
        ("dwSubWin", DWORD),
        ("dwUserId", DWORD),
        ("dwTrunkId", DWORD * MAX_MATRIX_CASCADE), # trunkId成员对应级联级数从1到32，从CAM端开始，trunkId[0]表示第一级级联，trunkId[1]表示第二级级联, trunkId[i] = 0 表示无干线
        ("byRes", BYTE * 64), #  预留
    ]


LPNET_DVR_MATRIX_ROUTE_INFO = POINTER(NET_DVR_MATRIX_ROUTE_INFO)


# 获取PTZ状态
class NET_DVR_PTZ_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwUserID", DWORD), # 1~256，0 表示无用户
        ("dwStatus", DWORD), #  PTZ控制状态0-停止、1-运行
        ("dwRestTime", DWORD), # 剩余时间
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PTZ_STATUS = POINTER(NET_DVR_PTZ_STATUS)


class NET_DVR_SAFETYCABIN_WORK_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWorkMode", BYTE), # 工作模式，0-无人门常开，1-无人门常锁
        ("byFaintToUnlock", BYTE), # 晕倒报警一定时间后外部可以开锁：0-否，1-是
        ("byOvertimeToUnlock", BYTE), # 使用超时后外部按钮是否可以开锁：0-否，1-是
        ("byRes", BYTE * 13),
    ]


LPNET_DVR_SAFETYCABIN_WORK_MODE = POINTER(NET_DVR_SAFETYCABIN_WORK_MODE)


class NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySensorType", BYTE), # 传感器类型，0-红外对射型，1-幕帘传感器
        ("bySensitivity", BYTE), # 传感器敏感度，范围：0-100%
        ("byDevUseTimeout", BYTE), # 防护舱使用超时时间，单位：分,范围：5-30，默认超时15min,超时后通过布防通道上传报警
        ("byRes1", BYTE),
        ("wCurtainDelayTime", WORD), # 幕帘传感器探测延时时间，单位：秒，范围：0-10
        ("wCurtainResponseTime", WORD), # 幕帘人状态变化控制器响应时间，单位：秒，范围：0-300
        ("wFaintToEmergencyTime", WORD), # 晕倒告警生效时间，单位：秒，范围：10-300
        ("byFollowDetectorSensitivity", BYTE), # 尾随检测灵敏度，范围：0-100%
        ("byManyPersonSensitivity", BYTE), # 多人检测灵敏度，范围：0-100%
        ("byRes2", BYTE * 28), # 保留
    ]


LPNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG = POINTER(NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG)


class NET_DVR_ETHERNET_IPV6_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMACAddr", BYTE * MACADDR_LEN), # 网卡的物理地址
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_ETHERNET_IPV6_COND = POINTER(NET_DVR_ETHERNET_IPV6_COND)


class NET_DVR_ETHERNET_IPV6_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byState", BYTE), # IPv6状态，0-路由分配，1-自动设置
        ("byRes1", BYTE * 3),
        ("byIPv6", BYTE * MAX_IPV6_LEN), # IPv6地址
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_ETHERNET_IPV6_CFG = POINTER(NET_DVR_ETHERNET_IPV6_CFG)


class NET_DVR_DAYTIME(Structure):
    _fields_ = [
        ("byHour", BYTE), # 0~24
        ("byMinute", BYTE), # 0~60
        ("bySecond", BYTE), # 0~60
        ("byRes", BYTE),
        ("wMilliSecond", WORD), # 0~1000
        ("byRes1", BYTE * 2),
    ]


LPNET_DVR_DAYTIME = POINTER(NET_DVR_DAYTIME)


class NET_DVR_SCHEDULE_DAYTIME(Structure):
    _fields_ = [
        ("struStartTime", NET_DVR_DAYTIME), # 开始时间
        ("struStopTime", NET_DVR_DAYTIME), # 结束时间
    ]


LPNET_DVR_SCHEDULE_DAYTIME = POINTER(NET_DVR_SCHEDULE_DAYTIME)


class NET_DVR_DNMODE(Structure):
    _fields_ = [
        ("byObjectSize", BYTE), # 占比参数(0~100)
        ("byMotionSensitive", BYTE), # 移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_DNMODE = POINTER(NET_DVR_DNMODE)


class NET_DVR_MOTION_MULTI_AREAPARAM(Structure):
    _fields_ = [
        ("byAreaNo", BYTE), # 区域编号(IPC- 1~8)
        ("byRes", BYTE * 3),
        ("struRect", NET_VCA_RECT), # 单个区域的坐标信息(矩形) size = 16
        ("struDayNightDisable", NET_DVR_DNMODE), # 关闭模式
        ("struDayModeParam", NET_DVR_DNMODE), # 白天模式
        ("struNightModeParam", NET_DVR_DNMODE), # 夜晚模式
        ("byRes1", BYTE * 8),
    ]


LPNET_DVR_MOTION_MULTI_AREAPARAM = POINTER(NET_DVR_MOTION_MULTI_AREAPARAM)


class NET_DVR_MOTION_MULTI_AREA(Structure):
    _fields_ = [
        ("byDayNightCtrl", BYTE), # 日夜控制 0~关闭,1~自动切换,2~定时切换(默认关闭)
        ("byAllMotionSensitive", BYTE), # 移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭，全部区域的灵敏度范围
        ("byRes", BYTE * 2),
        ("struScheduleTime", NET_DVR_SCHEDULE_DAYTIME), # 切换时间  16
        ("struMotionMultiAreaParam", NET_DVR_MOTION_MULTI_AREAPARAM * MAX_MULTI_AREA_NUM), # 最大支持24个区域
        ("byRes1", BYTE * 60),
    ]


LPNET_DVR_MOTION_MULTI_AREA = POINTER(NET_DVR_MOTION_MULTI_AREA)


class NET_DVR_MOTION_SINGLE_AREA(Structure):
    _fields_ = [
        ("byMotionScope", BYTE * 64), # 侦测区域,0-96位,表示64行,共有96*64个小宏块,目前有效的是22*18,为1表示是移动侦测区域,0-表示不是
        ("byMotionSensitive", BYTE), # 移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_MOTION_SINGLE_AREA = POINTER(NET_DVR_MOTION_SINGLE_AREA)


class NET_DVR_MOTION_MODE_PARAM(Structure):
    _fields_ = [
        ("struMotionSingleArea", NET_DVR_MOTION_SINGLE_AREA), # 普通模式下的单区域设
        ("struMotionMultiArea", NET_DVR_MOTION_MULTI_AREA), # 专家模式下的多区域设置
    ]


LPNET_DVR_MOTION_MODE_PARAM = POINTER(NET_DVR_MOTION_MODE_PARAM)


class NET_DVR_MOTION_V40(Structure):
    _fields_ = [
        ("struMotionMode", NET_DVR_MOTION_MODE_PARAM), # (5.1.0新增)
        ("byEnableHandleMotion", BYTE), #  是否处理移动侦测 0－否 1－是
        ("byEnableDisplay", BYTE), # 启用移动侦测高亮显示，0-否，1-是
        ("byConfigurationMode", BYTE), # 0~普通,1~专家(5.1.0新增)
        ("byKeyingEnable", BYTE), # 启用键控移动侦测 0-不启用，1-启用
        # 异常处理方式
        ("dwHandleType", DWORD), # 异常处理,异常处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: 触发JPRG抓图并上传Email
        # 0x20: 无线声光报警器联动
        # 0x40: 联动电子地图(目前只有PCNVR支持)
        # 0x200: 抓图并上传FTP
        # 0x1000: 抓图上传到云
        ("dwMaxRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数（只读）最大支持数量
        ("dwRelAlarmOut", DWORD * MAX_ALARMOUT_V40), # 实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        # 触发的录像通道
        ("dwMaxRecordChanNum", DWORD), # 设备支持的最大关联录像通道数-只读
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V40), #  实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwRelRecordChan -1有效，如果中间遇到0xffffffff,则后续无效
        ("byDiscardFalseAlarm", BYTE), # 启用去误报 0-无效，1-不启用，2-启用
        ("byRes", BYTE * 127), # 保留字节
    ]


LPNET_DVR_MOTION_V40 = POINTER(NET_DVR_MOTION_V40)


class NET_DVR_HIDEALARM_V40(Structure):
    _fields_ = [
        ("dwEnableHideAlarm", DWORD), #  是否启动遮挡报警，0-否，1-低灵敏度，2-中灵敏度，3-高灵敏度
        ("wHideAlarmAreaTopLeftX", WORD), #  遮挡区域的x坐标
        ("wHideAlarmAreaTopLeftY", WORD), #  遮挡区域的y坐标
        ("wHideAlarmAreaWidth", WORD), #  遮挡区域的宽
        ("wHideAlarmAreaHeight", WORD), # 遮挡区域的高
        # 信号丢失触发报警输出
        ("dwHandleType", DWORD), # 异常处理,异常处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: 触发JPRG抓图并上传Email
        # 0x20: 无线声光报警器联动
        # 0x40: 联动电子地图(目前只有PCNVR支持)
        # 0x200: 抓图并上传FTP
        # 0x1000:抓图上传到云
        ("dwMaxRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数（只读）最大支持数量
        ("dwRelAlarmOut", DWORD * MAX_ALARMOUT_V40), # 触发报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_HIDEALARM_V40 = POINTER(NET_DVR_HIDEALARM_V40)


class NET_DVR_VILOST_V40(Structure):
    _fields_ = [
        ("dwEnableVILostAlarm", DWORD), #  是否启动信号丢失报警 ,0-否,1-是
        # 信号丢失触发报警输出
        ("dwHandleType", DWORD), # 异常处理,异常处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: 触发JPRG抓图并上传Email
        # 0x20: 无线声光报警器联动
        # 0x40: 联动电子地图(目前只有PCNVR支持)
        # 0x200: 抓图并上传FTP
        # 0x1000:抓图上传到云
        ("dwMaxRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数（只读）最大支持数量
        ("dwRelAlarmOut", DWORD * MAX_ALARMOUT_V40), # 触发报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("byVILostAlarmThreshold", BYTE), # 信号丢失报警阈值，当值低于阈值，认为信号丢失，取值0-99
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_VILOST_V40 = POINTER(NET_DVR_VILOST_V40)


class NET_DVR_VICOLOR(Structure):
    _fields_ = [
        ("struColor", NET_DVR_COLOR * MAX_TIMESEGMENT_V30), # 图象参数(第一个有效，其他三个保留)
        ("struHandleTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 处理时间段(保留)
    ]


LPNET_DVR_VICOLOR = POINTER(NET_DVR_VICOLOR)


class NET_DVR_PICCFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sChanName", BYTE * NAME_LEN),
        ("dwVideoFormat", DWORD), #  只读 视频制式 1-NTSC 2-PAL
        ("struViColor", NET_DVR_VICOLOR), #     图像参数按时间段设置
        # 显示通道名
        ("dwShowChanName", DWORD), #  预览的图象上是否显示通道名称,0-不显示,1-显示
        ("wShowNameTopLeftX", WORD), #  通道名称显示位置的x坐标
        ("wShowNameTopLeftY", WORD), #  通道名称显示位置的y坐标
        # 隐私遮挡
        ("dwEnableHide", DWORD), #  是否启动遮挡 ,0-否,1-是
        ("struShelter", NET_DVR_SHELTER * MAX_SHELTERNUM),
        # OSD
        ("dwShowOsd", DWORD), #  预览的图象上是否显示OSD,0-不显示,1-显示
        ("wOSDTopLeftX", WORD), #  OSD的x坐标
        ("wOSDTopLeftY", WORD), #  OSD的y坐标
        ("byOSDType", BYTE), #  OSD类型(主要是年月日格式)
        # 0: XXXX-XX-XX 年月日
        # 1: XX-XX-XXXX 月日年
        # 2: XXXX年XX月XX日
        # 3: XX月XX日XXXX年
        # 4: XX-XX-XXXX 日月年
        # 5: XX日XX月XXXX年
        # 6: xx/xx/xxxx(月/日/年)
        # 7: xxxx/xx/xx(年/月/日)
        # 8: xx/xx/xxxx(日/月/年)
        ("byDispWeek", BYTE), #  是否显示星期
        ("byOSDAttrib", BYTE), #  OSD属性:透明，闪烁
        # 0: 不显示OSD
        # 1: 透明，闪烁
        # 2: 透明，不闪烁
        # 3: 不透明，闪烁
        # 4: 不透明，不闪烁
        ("byHourOSDType", BYTE), #  OSD小时制:0-24小时制,1-12小时制
        ("byFontSize", BYTE), # 16*16(中)/8*16(英)，1-32*32(中)/16*32(英)，2-64*64(中)/32*64(英)  3-48*48(中)/24*48(英) 4-24*24(中)/12*24(英) 5-96*96(中)/48*96(英) 6-128*128(中)/64*128(英) 7-80*80(中)/40*80(英) 8-112*112(中)/56*112(英) 0xff-自适应(adaptive)
        ("byOSDColorType", BYTE), # 0-默认（黑白）；1-自定义
        # 当对齐方式选择国标模式时，可以分别对右下角、左下角两个区域做字符叠加。
        # 右下角区域：
        # 共支持6行字符叠加，可以通过NET_DVR_SET_SHOWSTRING_V30/ NET_DVR_GET_SHOWSTRING_V30字符叠加接口，对应NET_DVR_SHOWSTRINGINFO结构体数组中的第0至第5个下标的值。叠加字符的方式为从下到上的方式。
        # 左下角区域：
        # 共支持2行字符叠加，可以通过NET_DVR_SET_SHOWSTRING_V3/ NET_DVR_GET_SHOWSTRING_V30字符叠加接口，对应NET_DVR_SHOWSTRINGINFO结构体数组中的第6和第7个下标的值。叠加字符的方式为从下到上的方式。
        #
        ("byAlignment", BYTE), # 对齐方式 0-自适应，1-右对齐, 2-左对齐，3-国标模式，4-全部右对齐(包含叠加字符、时间以及标题等所有OSD字符)，5-全部左对齐(包含叠加字符、时间以及标题等所有OSD字符)
        ("byOSDMilliSecondEnable", BYTE), # 视频叠加时间支持毫秒；0~不叠加, 1-叠加
        ("struVILost", NET_DVR_VILOST_V40), # 视频信号丢失报警（支持组）
        ("struAULost", NET_DVR_VILOST_V40), # 音频信号丢失报警（支持组）
        ("struMotion", NET_DVR_MOTION_V40), # 移动侦测报警（支持组）
        ("struHideAlarm", NET_DVR_HIDEALARM_V40), # 遮挡报警（支持组）
        ("struOsdColor", NET_DVR_RGB_COLOR), # OSD颜色
        ("dwBoundary", DWORD), # 边界值，左对齐，右对齐以及国标模式的边界值，0-表示默认值，单位：像素在国标模式下，单位修改为字符个数（范围是，0,1,2）
        ("struOsdBkColor", NET_DVR_RGB_COLOR), # 自定义OSD背景色
        ("byOSDBkColorMode", BYTE), # OSD背景色模式，0-默认，1-自定义OSD背景色
        ("byUpDownBoundary", BYTE), # 上下最小边界值选项，单位为字符个数（范围是，0,1,2）,国标模式下无效。byAlignment=3该字段无效，通过dwBoundary进行边界配置，.byAlignment不等于3的情况下， byUpDownBoundary/byLeftRightBoundary配置成功后，dwBoundary值将不生效
        ("byLeftRightBoundary", BYTE), # 左右最小边界值选项，单位为字符个数（范围是，0,1,2）, 国标模式下无效。byAlignment=3该字段无效，通过dwBoundary进行边界配置，.byAlignment不等于3的情况下， byUpDownBoundary/byLeftRightBoundary配置成功后，dwBoundary值将不生效
        ("byAngleEnabled", BYTE), # OSD是否叠加俯仰角信息,0~不叠加, 1-叠加
        ("wTiltAngleTopLeftX", WORD), #  俯仰角信息显示位置的x坐标
        ("wTiltAngleTopLeftY", WORD), #  俯仰角信息显示位置的y坐标
        ("byRes", BYTE * 108),
    ]


LPNET_DVR_PICCFG_V40 = POINTER(NET_DVR_PICCFG_V40)


class NET_DVR_DEVSERVER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIrLampServer", BYTE), # 红外灯设置 0～禁用，1～启用
        ("bytelnetServer", BYTE), # telnet设置 0～禁用，1～启用
        ("byABFServer", BYTE), # ABF设置 0～启用，1～禁用
        ("byEnableLEDStatus", BYTE), # 状态指示灯控制 0～禁用，1～启用
        ("byEnableAutoDefog", BYTE), # 自动除雾控制 0～启用，1～禁用
        ("byEnableSupplementLight", BYTE), # 补光灯控制0-启用，1-禁用
        ("byEnableDeicing", BYTE), # 除冰功能 0-关闭，1-开启
        ("byEnableVisibleMovementPower", BYTE), #  可见光机芯电源开关 0-关闭，1-开启
        ("byEnableThermalMovementPower", BYTE), #  热成像机芯电源开关 0-关闭，1-开启
        ("byEnablePtzPower", BYTE), #  云台电源开关 0-关闭，1-开启
        ("byPowerSavingControl", BYTE), #  低功耗策略 0-保留 1-休眠模式 2-低功耗模式 低功耗模式下 可见光机芯电源、热成像机芯电源、云台电源控制生效
        ("byCaptureWithSupplimentLightEnabled", BYTE), # 启用抓拍补光使能 0-关闭，1-开启
        ("byRes", BYTE * 244),
    ]


LPNET_DVR_DEVSERVER_CFG = POINTER(NET_DVR_DEVSERVER_CFG)


class NET_DVR_GBT28181_ACCESS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 28181协议使能 0-关闭 1-开启
        ("byTransProtocol", BYTE), # 传输协议:0-UDP、1-TCP、默认0-UDP
        ("wLocalSipPort", WORD), # 1024-65535(IPC设备端)
        ("szServerID", CHAR * MAX_SERVERID_LEN), # 服务器ID：64字节字符串，仅限数字
        ("szServerDomain", CHAR * MAX_SIPSERVER_ADDRESS_LEN), #  服务器域
        ("szSipServerAddress", CHAR * MAX_SIPSERVER_ADDRESS_LEN), #  SIP服务器地址支持域名和IP地址
        ("wServerSipPort", WORD), # 服务器SIP端口：1024-65535
        ("byProtocolVersion", BYTE), # 协议版本 0-GB/T28181-2011(仅支持UDP),1-GB/T28181-2015(支持TCP,UDP),2-GB/T28181-2016
        ("byTCPConnectMod", BYTE), # TCP连接模式，使用TCP传输协议时有效，0-无效，1-主动模式，2-被动模式
        ("szSipUserName", CHAR * MAX_SERVERNAME_LEN), # SIP用户名称：64字节字符串(第三方SIP终端请求IPC服务时使用)
        ("szSipAuthenticateID", CHAR * MAX_AUTHENTICATEID_LEN), # SIP用户认证ID：64字节字符串
        ("szSipAuthenticatePasswd", CHAR * MAX_AUTHENTICATEPASSWD_LEN), # SIP用户认证密码：32字节字符串(IPC设备注册到SIP服务器时使用)
        ("dwRegisterValid", DWORD), # 注册有效期：单位秒，默认3600；
        ("byHeartbeatInterval", BYTE), # 心跳间隔：单位秒，默认10秒；
        ("byMaxHeartbeatTimeOut", BYTE), # 最大心跳超时次数：默认3次；
        ("byStreamType", BYTE), #  取流类型0～主码流，1～子码流，2～3码流
        ("byDeviceStatus", BYTE), # 设备是否在线状态，0-保留，1-在线，2-离线
        ("dwRegisterInterval", DWORD), # 注册间隔:注册失败后再次注册的时间间隔,范围60-600s，默认60s
        ("dwAutoAllocChannelID", DWORD), # 是否自动分配通道ID,按位表示，0为手动配置，1为自动分配，bit1-自动分配编码通道ID,bit2-自动分配报警输入通道,bit3-自动分配解码通道ID
        ("szDeviceDomain", CHAR * MAX_SIPSERVER_ADDRESS_LEN), #  设备域
        ("byRes4", BYTE * 116),
    ]


LPNET_DVR_GBT28181_ACCESS_CFG = POINTER(NET_DVR_GBT28181_ACCESS_CFG)


# GBT28181协议的设备编码通道配置
class NET_DVR_GBT28181_CHANINFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szVideoChannelNumID", CHAR * MAX_COMPRESSIONID_LEN), # 设备视频通道编码ID：64字节字符串，仅限数字
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_GBT28181_CHANINFO_CFG = POINTER(NET_DVR_GBT28181_CHANINFO_CFG)


# GBT28181协议的报警输入通道配置 条件结构
class NET_DVR_ALARMIN_INFO(Structure):
    _fields_ = [
        ("struStreamInfo", NET_DVR_STREAM_INFO),
        ("dwAlarmInChannel", DWORD), # 报警输入通道号
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_DVR_ALARMIN_INFO = POINTER(NET_DVR_ALARMIN_INFO)


# GBT28181协议的报警输入通道配置 配置结构
class NET_DVR_GBT28181_ALARMINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szAlarmInNumID", CHAR * MAX_COMPRESSIONID_LEN), # 设备报警输入编码ID（每一路报警输入不同）：20字节字符串，仅限数字
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_GBT28181_ALARMINCFG = POINTER(NET_DVR_GBT28181_ALARMINCFG)


class NET_DVR_CAMERA_SETUPCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wSetupHeight", WORD), # 架设高度[0,20]，单位：米
        ("byLensType", BYTE), # 镜头焦距类型，0-未知,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
        ("bySetupHeightUnit", BYTE), #  架设高度单位0～M,1~CM
        ("dwSceneDis", DWORD), # 图像下边缘位置与相机之间的水平距离，单位：厘米
        ("fPitchAngle", float), # 相机俯仰角度[-180°, 180°],
        ("fInclineAngle", float), # 相机倾斜角度[-180°,180°]
        ("fRotateAngle", float), # 相机旋转角度[-180°,180°]
        ("wVideoDetCoefficient", WORD), # 视频测试系数[0,300](3.6新增)
        ("byErectMethod", BYTE), # 架设方式0-正装，1-侧装(3.6新增)
        ("byCameraViewAngle", BYTE), # 摄像机安装视野角度(0-垂直，1-倾斜，默认0-垂直)
        ("dwHorizontalDistance", DWORD), # 摄像机与出入口水平距离：范围1-1000，默认30，单位cm，注意摄像机角度为倾斜时该项有效
        ("byDetailLensType", BYTE), # 范围1-100，默认28，单位0.1mm
        ("byRes", BYTE * 3),
        ("fHorFieldAngle", float), # 相机水平视场角角度[0°, 360°]（抓拍机）
        ("fVerFieldAngle", float), # 相机垂直视场角角度[0°, 360°]（抓拍机）,鹰眼范围-90°-90°
        ("fLableSetupHeight", float), # 标签到架设相机的高度[0,100]，单位：米
        ("fMaxViewRadius", float), # 最大可视半径,0~10000.00米，默认5000米.
        ("byRes1", BYTE * 16),
    ]


LPNET_DVR_CAMERA_SETUPCFG = POINTER(NET_DVR_CAMERA_SETUPCFG)


# 起止日期段参数结构体
class NET_DVR_SCHEDDATE(Structure):
    _fields_ = [
        ("byStartMonth", BYTE), # 起始（月）
        ("byStartDay", BYTE), # 起始（日）
        ("byStopMonth", BYTE), # 结束（月）
        ("byStopDay", BYTE), # 结束（日）
    ]


LPNET_DVR_SCHEDDATE = POINTER(NET_DVR_SCHEDDATE)


# 时控输出参数
class NET_DVR_OUTPUT_SCHEDULE(Structure):
    _fields_ = [
        ("struTime", NET_DVR_SCHEDTIME), # 时间段
        ("byState", BYTE), # 0–关闭, 1–开启
        ("byRes", BYTE * 11), # 保留
    ]


LPNET_DVR_OUTPUT_SCHEDULE = POINTER(NET_DVR_OUTPUT_SCHEDULE)


# 单条时控输出规则参数
class NET_DVR_ONE_OUTPUT_SCHEDULE_RULE(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用规则,0-否,1-是
        ("byRes1", BYTE * 3), # 保留
        ("struDate", NET_DVR_SCHEDDATE), # 日期区段
        ("struOutputSchedule", NET_DVR_OUTPUT_SCHEDULE * MAX_TIMESEGMENT_V30), # 最多支持8个时间段的时控输出
        ("byRes2", BYTE * 16), # 保留
    ]


LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE = POINTER(NET_DVR_ONE_OUTPUT_SCHEDULE_RULE)


# 时控输出规则参数
class NET_DVR_OUTPUT_SCHEDULE_RULECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struOutputRule", NET_DVR_ONE_OUTPUT_SCHEDULE_RULE * MAX_RULE_NUM), # 最多支持8个日期区段的规则配置
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_OUTPUT_SCHEDULE_RULECFG = POINTER(NET_DVR_OUTPUT_SCHEDULE_RULECFG)


# 交通统计报警参数
class NET_DVR_TPS_ALARMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用交通统计报警上传
        ("byRes1", BYTE * 3),
        ("dwInterval", DWORD), # 统计间隔时间（单位：分钟）
        ("byRes", BYTE * 248),
    ]


LPNET_DVR_TPS_ALARMCFG = POINTER(NET_DVR_TPS_ALARMCFG)


class NET_DVR_DOWNLOAD_ALARM_RECORD_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wAlarmRecordID", WORD), # 报警录像ID(用于查询录像，仅当byResultType为2时有效)
        ("byRes", BYTE * 130),
    ]


LPNET_DVR_DOWNLOAD_ALARM_RECORD_COND = POINTER(NET_DVR_DOWNLOAD_ALARM_RECORD_COND)


class NET_DVR_CABINET_AlARM_PARAMCFG(Structure):
    _fields_ = [
        ("sCabinetName", CHAR * NAME_LEN),
        ("byAssociateIO", BYTE), # 1-4，0xff， 其中1-4表示具体的IO通道号，0xff表示不启用
        ("byCabinetState", BYTE), # 0~低电平,1~高电平
        ("byAlarmIntervalTime", BYTE), # 取值范围1-60，单位：秒
        ("byRes1", BYTE * 25),
    ]


LPNET_DVR_CABINET_AlARM_PARAMCFG = POINTER(NET_DVR_CABINET_AlARM_PARAMCFG)


class NET_DVR_CABINET_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 0~不启用，1～启用
        ("byRes", BYTE * 3),
        ("struCabinetCfg", NET_DVR_CABINET_AlARM_PARAMCFG * MAX_CABINET_COUNT),
        ("byRes1", BYTE * 84),
    ]


LPNET_DVR_CABINET_CFG = POINTER(NET_DVR_CABINET_CFG)


class NET_ITS_GATE_LANE_CFG(Structure):
    _fields_ = [
        ("byGateSiteID", BYTE * MAX_ID_LEN), # 出入口编号
        ("byGateInfo", BYTE * MAX_ID_LEN), # 出入口信息描述
        ("byLaneName", BYTE * NAME_LEN), # 车道名称
        ("byValid", BYTE), # 是否启用 0 表示未启用，1表示启用
        ("byCamLaneId", BYTE), # 对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
        ("wLaneid", WORD), # 车道号1～32（索引车道号，可以跳跃 逻辑车道）
        ("byRelativeIoNum", BYTE), # 逻辑车道号关联的输出口编号
        ("byDirection", BYTE), # 方向编号  0 -其他 1 入场  2 出场 3 双向
        ("byLprMode", BYTE), # 牌识放行配置0 全部进1 除黑名单进2 白名单进
        ("byCardMode", BYTE), # 卡片放行配置0 全部进1 除黑名单进2 白名单进
        ("byGateLaneMode", BYTE), # 出入口放行配置模式 0-全部进 1-只有牌识匹配放行2 只有刷卡匹配放行 3-牌识或卡片有一个匹配则放行 4-牌识且卡片同时匹配则放行 5-全不进
        # 2013-11-19 新增参数
        ("byCharge", BYTE), # 是否收费 0-不收费，1-收费
        ("byChargeMode", BYTE), # 收费类型 0-车牌收费，1-卡号收费
        ("byRes1", BYTE),
        ("byLedRelativeIndex", BYTE * MAX_INDEX_LED), # LED 索引 (1~255) 紧凑排列，0表示无效，不解析后面的数据
        ("byGateRelativeIndex", BYTE), # 出入口控制机相对索引
        ("byFarRrRelativeIndex", BYTE), #  远距离读卡器相对索引
        ("byRes", BYTE * 82), # 预留
    ]


LPNET_ITS_GATE_LANE_CFG = POINTER(NET_ITS_GATE_LANE_CFG)


class NET_ITS_IPC_CHAN_LANE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIpcType", BYTE), # 0-无，1-车牌抓拍，2-人脸抓拍，3-监控相机
        ("byRes", BYTE * 135),
        ("struGateLane", NET_ITS_GATE_LANE_CFG * 4), # 车道配置结构体
    ]


LPNET_ITS_IPC_CHAN_LANE_CFG = POINTER(NET_ITS_IPC_CHAN_LANE_CFG)


# 设备远程控制
class NET_ITS_REMOTE_COMMAND(Structure):
    _fields_ = [
        ("wLaneid", WORD), # 车道号1～32（索引车道号，可以跳跃）
        ("byCamLaneId", BYTE), # 对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
        ("byRes", BYTE), # 预留
        ("dwCode", DWORD), # 命令码 0x0 开闸 0x1 关闸，其它待扩展
        ("byRes1", BYTE * 128),
    ]


LPNET_ITS_REMOTE_COMMAND = POINTER(NET_ITS_REMOTE_COMMAND)


class NET_ITS_REMOTE_CONTROL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRemoteCommand", NET_ITS_REMOTE_COMMAND), # 远程命令结构
    ]


LPNET_ITS_REMOTE_CONTROL = POINTER(NET_ITS_REMOTE_CONTROL)


# 长连接获取通道状态
class NET_ITS_ECT_CHANNELSTATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRecordStatic", BYTE), # 通道是否在录像,0-不录像,1-录像
        ("bySignalStatic", BYTE), # 连接的信号状态,0-正常,1-信号丢失
        ("byHardwareStatic", BYTE), # 通道硬件状态,0-正常,1-异常,例如DSP死掉
        ("byChannelArmState", BYTE), # 接入IPC的布防状态
        ("dwChannel", DWORD), # 通道号
        ("dwBitRate", DWORD), # 实际码率
        ("dwLinkNum", DWORD), # 客户端连接的个数
        ("struClientIP", NET_DVR_IPADDR * MAX_LINK), # 客户端的IP地址
        ("dwIPLinkNum", DWORD), # 如果该通道为IP接入，那么表示IP接入当前的连接数
        ("byExceedMaxLink", BYTE), #  是否超出了128路连接数 0 - 未超出, 1-超出
        ("byRes", BYTE * 139), #  保留字节
    ]


LPNET_ITS_ECT_CHANNELSTATE = POINTER(NET_ITS_ECT_CHANNELSTATE)


# 外接灯
class NET_DVR_PARK_EXTERNAL_SUBINFO(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 0 ～ 不开启 1 ～ 开启
        ("byFlicker", BYTE), # 0 ～ 不闪烁 1 ～ 闪烁
        ("byIOState", BYTE), # 0 ～ 低电平 1 ～ 高电平 (外置灯起效)
        ("byLampColor", BYTE), #  0- 灭 1-红   2-绿  3-黄  4-蓝 5-品红  6-青  7-白色 (内置灯起效)
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_PARK_EXTERNAL_SUBINFO = POINTER(NET_DVR_PARK_EXTERNAL_SUBINFO)


class NET_DVR_PARK_INLAY_SUBINFO(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 0～不开启 1 ～开启
        ("byFlicker", BYTE), # 0～不闪烁 1 ～闪烁
        ("byLampColor", BYTE), # 0-灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (内置灯起效)
        ("byRes", BYTE * 21),
    ]


LPNET_DVR_PARK_INLAY_SUBINFO = POINTER(NET_DVR_PARK_INLAY_SUBINFO)


class NET_DVR_PARKINFO(Structure):
    _fields_ = [
        ("struNormalParkIOState", NET_DVR_PARK_EXTERNAL_SUBINFO), # 有车io电平状态
        ("struNormalNoParkIOState", NET_DVR_PARK_EXTERNAL_SUBINFO), # 无车io电平状态
        ("struSpecialParkIOState", NET_DVR_PARK_EXTERNAL_SUBINFO), # 特殊车位有车io电平状态
        ("struSpecialNoParkIOState", NET_DVR_PARK_EXTERNAL_SUBINFO), # 特殊车位无车io电平状态
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_PARKINFO = POINTER(NET_DVR_PARKINFO)


class NET_DVR_EXTERNAL_LAMP_CTRL_MODE(Structure):
    _fields_ = [
        ("struParkInfo", NET_DVR_PARKINFO * MAX_PARKING_NUM), # 外接灯的情况下车位信息，一个通道最大4个车位 (从左到右车位 数组0～3)
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_EXTERNAL_LAMP_CTRL_MODE = POINTER(NET_DVR_EXTERNAL_LAMP_CTRL_MODE)


class NET_DVR_INLAY_LAMP_CTRL_MODE(Structure):
    _fields_ = [
        ("struLampStateCtrl", NET_DVR_PARK_INLAY_SUBINFO * MAX_PARKING_STATUS),
        ("byRes", BYTE * 96),
    ]


LPNET_DVR_INLAY_LAMP_CTRL_MODE = POINTER(NET_DVR_INLAY_LAMP_CTRL_MODE)


class NET_DVR_LAMP_INFO(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 0～不开启 1 ～开启
        ("byFlicker", BYTE), # 0~不闪烁 1 ～闪烁(车位指示灯闪烁)
        ("byLampColor", BYTE), # 0- 灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (车位指示灯颜色)
        ("byRes", BYTE * 5),
    ]


LPNET_DVR_LAMP_INFO = POINTER(NET_DVR_LAMP_INFO)


# 内置外置灯模式
class NET_DVR_PARKLAMP_CTRL_MODE(Structure):
    _fields_ = [
        # 车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
        ("struLampInfo", NET_DVR_LAMP_INFO * MAX_PARKING_STATUS),
        # 关联车位灯（0-内置灯, 1-外置灯1, 2-外置灯2, 3-外置灯3）
        ("byLampType", BYTE),
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_PARKLAMP_CTRL_MODE = POINTER(NET_DVR_PARKLAMP_CTRL_MODE)


class NET_DVR_LAMP_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 0～不开启 1 ～开启
        ("byFlicker", BYTE), # 0~不闪烁 1 ～闪烁
        ("byLampColor", BYTE), # 0- 灭 1-红   2-绿  3-黄  4-蓝 5-品红  6-青  7-白色
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_LAMP_PARAM = POINTER(NET_DVR_LAMP_PARAM)


# 内置外置灯模式
class NET_DVR_EXTERNAL_PARKLAMP(Structure):
    _fields_ = [
        # 车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
        ("struLampParam", NET_DVR_LAMP_PARAM * MAX_PARKING_STATUS),
        # 关联车位灯（0-内置灯, 1-外置灯1, 2-外置灯2, 3-外置灯3）
        ("byLampType", BYTE),
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_EXTERNAL_PARKLAMP = POINTER(NET_DVR_EXTERNAL_PARKLAMP)


# 内置灯加外置灯模式下 内置灯控制结构子信息
class NET_DVR_BUILTIN_PARKLAMP(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 0～不开启 1 ～开启
        ("byFlicker", BYTE), # 0~不闪烁 1 ～闪烁
        ("byLampColor", BYTE), # 0- 灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (内置灯起效)
        ("byRes", BYTE * 5),
    ]


LPNET_DVR_BUILTIN_PARKLAMP = POINTER(NET_DVR_BUILTIN_PARKLAMP)


#  混合控制模式结构
class NET_DVR_MIXLAMP_CTRL_MODE(Structure):
    _fields_ = [
        ("struExternalParkLamp", NET_DVR_EXTERNAL_PARKLAMP * MAX_PARKING_NUM), # 外置灯 按照车位号进行区分，一个通道最大4个车位 (从左到右车位 数组0～3)
        ("struBuiltInParkLamp", NET_DVR_BUILTIN_PARKLAMP * MAX_PARKING_STATUS), # 内置灯 按照车位状态区分，车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
    ]


LPNET_DVR_MIXLAMP_CTRL_MODE = POINTER(NET_DVR_MIXLAMP_CTRL_MODE)


#  单控外接灯控制模式结构
class NET_DVR_SINGLELAMP_CTRL_MODE(Structure):
    _fields_ = [
        ("struExternLampStateCtrl", NET_DVR_PARK_EXTERNAL_SUBINFO * MAX_PARKING_STATUS), # 外置灯 按照车位号进行区分，一个通道最大4个车位 (从左到右车位 数组0～3)
        ("byLampType", BYTE), #  1-外置灯1，2-外置灯2，3-外置灯3
        ("byRes", BYTE * 23),
    ]


LPNET_DVR_SINGLELAMP_CTRL_MODE = POINTER(NET_DVR_SINGLELAMP_CTRL_MODE)


class NET_DVR_LAMP_CTRL_MODE_UNION(Union):
    _fields_ = [
        ("uLen", BYTE * 288),
        ("struInlayLampCtrlMode", NET_DVR_INLAY_LAMP_CTRL_MODE), # 内置灯控制模式结构
        ("struExternalLampCtrlMode", NET_DVR_EXTERNAL_LAMP_CTRL_MODE), # 外接灯控制模式结构
        ("struParkLampCtrlMode", NET_DVR_PARKLAMP_CTRL_MODE * MAX_PARKING_NUM), # 内置外置灯模式，一个通道最大4个车位 (从左到右车位 数组0～3)  当模式为内外置灯的时候生效
        # 车位检测相机内外置灯，混合控制模式（区分与上面内外置灯模式，该模式下内置灯不作为外置灯使用（内置外置灯模式下，内置灯作为外置灯使用））；
        # 混合控制模式下，内置灯显示当前监测车位状态中，优先级最高的车位状态(压线>特殊车位>有无车状态)关联灯的状态
        ("struMixLampCtrlMode", NET_DVR_MIXLAMP_CTRL_MODE),
        # 单外置灯模式是不区分车位信息，显示当前车位状态中，等级最好的状态（压线>特殊车位>有无车状态）
        ("struSingleExternalLampCtrlMode", NET_DVR_SINGLELAMP_CTRL_MODE),
    ]


LPNET_DVR_LAMP_CTRL_MODE_UNION = POINTER(NET_DVR_LAMP_CTRL_MODE_UNION)


class NET_DVR_LAMP_CTRL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLampCtrlMode", BYTE), # 控灯模式：1代表内置灯,2代表外接灯,3代表内外置灯,4代表混合灯模式（内置灯只做高优先级指示灯),5-代表单外置灯模式
        ("byCtrlChannelIndex", BYTE), # 交替控制通道号(33~48)
        ("byRes", BYTE * 2),
        ("uLampCtrlMode", NET_DVR_LAMP_CTRL_MODE_UNION), # 灯控制模式联合体
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_LAMP_CTRL_INFO = POINTER(NET_DVR_LAMP_CTRL_INFO)


# 车位属性配置（默认都是normal）
class NET_DVR_PARKSPACE_INFO(Structure):
    _fields_ = [
        ("byParkSpaceAttribute", BYTE), # 0~普通车位 1～特殊车位
        ("byRes", BYTE * 23),
    ]


LPNET_DVR_PARKSPACE_INFO = POINTER(NET_DVR_PARKSPACE_INFO)


class NET_DVR_PARKSPACE_ATTRIBUTE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struParkSpaceInfo", NET_DVR_PARKSPACE_INFO * MAX_PARKING_NUM), # 一个通道最大4个车位 (从左到右车位 数组0～3)
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PARKSPACE_ATTRIBUTE = POINTER(NET_DVR_PARKSPACE_ATTRIBUTE)


# 指示灯外控
class NET_DVR_LAMP_STATE(Structure):
    _fields_ = [
        ("byFlicker", BYTE), # 0~不闪烁 1 ～闪烁
        ("byParkingIndex", BYTE), # 车位号1～3
        ("byRes1", BYTE * 2),
        ("dwIONo", DWORD), # 1~IO12~IO24~IO3
        ("byRes2", BYTE * 8),
    ]


LPNET_DVR_LAMP_STATE = POINTER(NET_DVR_LAMP_STATE)


class NET_DVR_LAMP_EXTERNAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 外控使能 0～不启用 1～启用
        ("byRes1", BYTE * 3),
        ("struLampStateCtrl", NET_DVR_LAMP_STATE), # 指示灯外控
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_LAMP_EXTERNAL_CFG = POINTER(NET_DVR_LAMP_EXTERNAL_CFG)


# 车位强制抓图 一个通道最多四车位
class NET_DVR_COMPEL_CAPTURE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byParkIndex", BYTE), # 车位序号从左到右 （0-表示当前有几个车位，就上传几张图片）1,2,3,4
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_COMPEL_CAPTURE = POINTER(NET_DVR_COMPEL_CAPTURE)


# 外控报警结构
class NET_DVR_EXTERNAL_CONTROL_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannelNo", DWORD),
        ("struLampStateCtrl", NET_DVR_LAMP_STATE), # 指示灯外控状态
        ("struExternalBeginTime", NET_DVR_TIME), # 外控开始时间
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_EXTERNAL_CONTROL_ALARM = POINTER(NET_DVR_EXTERNAL_CONTROL_ALARM)


#  设备类型
DEVICES_TYPE_RES1 = 0
DEVICES_TYPE_FAR_SCR = 1
DEVICES_TYPE_ENTRANCE_CONTROL = 2
DEVICES_TYPE_WJ_LED_DEV = 3
DEVICES_TYPE_NJ_LED_DEV = 4
DEVICES_TYPE_VEH_DETECT_DEV = 5
DEVICES_TYPE_DZ_DEV = 6
DEVICES_TYPE_PX_SCR_DEV = 7
DEVICES_TYPE_KJ_SCR_DEV = 8
DEVICES_TYPE_FKJ_DEV = 9
DEVICES_TYPE_SKJ_DEV = 10
DEVICES_TYPE_HDD_DEV = 11
DEVICES_TYPE_DZ_LOCK = 12
DEVICES_TYPE_PAPER_PRINTER = 13
DEVICES_TYPE_PAPER_SCANNERS = 14
DEVICES_TYPE_IPC_ALARM = 15

#  设备状态
# 通用设备状态码 0~19
DEVICES_STATUS_NORMAL = 0
DEVICES_STATUS_ABNORMAL = 1

# 发卡机设备状态码 20~39
DEVICES_STATUS_TOO_LESS_CARD = 20
DEVICES_STATUS_NO_CARD = 21
DEVICES_STATUS_SENDCARD_ERROR = 22
DEVICES_STATUS_CARD_BLOCKED = 23
DEVICES_STATUS_CARD_FULL = 24


# 道闸设备状态码 40~60
DEVICES_STATUS_OPENING = 40
DEVICES_STATUS_CLOSING = 41
DEVICES_STATUS_OPENED = 42
DEVICES_STATUS_CLOSED = 43
DEVICES_STATUS_NOSIGNAL = 44
DEVICES_STATUS_LOCK = 45

# 纸票打印机状态 61~90
PP_STATUS_OFFLINE = 61
PP_STATUS_PRINT_HEADER_UP = 62
PP_STATUS_FEED_BUTTON_FEEDING = 63
PP_STATUS_ONLINE_WAITING = 64
PP_STATUS_FEED_BUTTON_ENABLE = 65
PP_STATUS_JAMR_PAPER_ERROR = 66
PP_STATUS_CUT_PAPER_ERROR = 67
PP_STATUS_AUTO_FEED_ERROR = 68
PP_STATUS_EXIT_RECOVERY_ERROR = 69
PP_STATUS_EXIT_AUTO_RECOVERY_ERROR = 70
PP_STATUS_PULL_PAPER_ERROR = 71
PP_STATUS_LESS_PAPER  = 72
PP_STATUS_NO_PAPER = 73
PP_STATUS_PRINT_FAIL = 74
PP_STATUS_PRINTING = 75

class NET_DVR_ALARMWIRELESSINFO(Structure):
    _fields_ = [
        ("byDeviceID", BYTE * NAME_LEN), # 设备ID
        ("fDataTraffic", float), #  已用流量,单位：MB,小数点后两位
        ("bySignalIntensity", BYTE), #  信号强度，0~100
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_ALARMWIRELESSINFO = POINTER(NET_DVR_ALARMWIRELESSINFO)


class NET_DVR_VOLTAGE(Structure):
    _fields_ = [
        ("iPhaseAVol", int), # A相电压
        ("iPhaseBVol", int), # B相电压
        ("iPhaseCVol", int), # C相电压
        ("iAveragePhaseVol", int), # 相电压平均值
    ]


LPNET_DVR_VOLTAGE = POINTER(NET_DVR_VOLTAGE)


# 电流
class NET_DVR_CURRENT(Structure):
    _fields_ = [
        ("iPhaseACurrent", int), # A相电流
        ("iPhaseBCurrent", int), # B相电流
        ("iPhaseCCurrent", int), # C相电流
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_CURRENT = POINTER(NET_DVR_CURRENT)


# 功率
class NET_DVR_POWER(Structure):
    _fields_ = [
        ("iPhaseAPower", int), # A相功率
        ("iPhaseBPower", int), # B相功率
        ("iPhaseCPower", int), # C相功率
        ("iSysTotalPower", int), # 系统总功率
    ]


LPNET_DVR_POWER = POINTER(NET_DVR_POWER)


# 功率因数
class NET_DVR_POWER_FACTOR(Structure):
    _fields_ = [
        ("iPhaseAPowerFactor", int), # A相功率因数
        ("iPhaseBPowerFactor", int), # B相功率因数
        ("iPhaseCPowerFactor", int), # C相功率因数
        ("iTotalPowerFactor", int), # 总功率因数
    ]


LPNET_DVR_POWER_FACTOR = POINTER(NET_DVR_POWER_FACTOR)


# 频率
class NET_DVR_FREQUENCY(Structure):
    _fields_ = [
        ("iPhaseAFrequency", int), # A相频率
        ("iPhaseBFrequency", int), # B相频率
        ("iPhaseCFrequency", int), # C相频率
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_FREQUENCY = POINTER(NET_DVR_FREQUENCY)


# 负载率
class NET_DVR_LOAD_FACTOR(Structure):
    _fields_ = [
        ("iPhaseALoadFactor", int), # A相负载率
        ("iPhaseBLoadFactor", int), # B相负载率
        ("iPhaseCLoadFactor", int), # C相负载率
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_LOAD_FACTOR = POINTER(NET_DVR_LOAD_FACTOR)


# UPS状态
class NET_DVR_ALARMHOST_UPS_STATE(Structure):
    _fields_ = [
        ("struInputVoltage", NET_DVR_VOLTAGE), # 输入电压
        ("struBypassVoltage", NET_DVR_VOLTAGE), # 旁路电压
        ("struOutputVoltage", NET_DVR_VOLTAGE), # 输出电压
        ("iRectifierVol", int), # 整流器电压
        ("iInverterVol", int), # 逆变器电压
        #
        ("struInputCurrent", NET_DVR_CURRENT), # 输入电流
        ("struBypassCurrent", NET_DVR_CURRENT), # 旁路电流
        ("struOutputCurrent", NET_DVR_CURRENT), # 输出电流
        ("iInverterCurrent", int), # 逆变器电流
        #
        ("struInputFrequency", NET_DVR_FREQUENCY), # 输入频率
        ("struBypassFrequency", NET_DVR_FREQUENCY), # 旁路频率
        ("struOutputFrequency", NET_DVR_FREQUENCY), # 输出频率
        ("iInverterFre", int), # 逆变器频率
        #
        ("struInputPower", NET_DVR_POWER), # 输入功率
        ("struBypassPower", NET_DVR_POWER), # 旁路功率
        ("struOutputPower", NET_DVR_POWER), # 输出功率
        ("struComplexPower", NET_DVR_POWER), # 复功率
        #
        ("iNormalPower", int), # 标称功率
        ("iPowerFacter", int), # 功率因数
        #
        ("struBatteryLoadFactor", NET_DVR_LOAD_FACTOR), # 电池负载率
        ("iBatteryEstimated", int), # 电池备份时间(min)
        ("iBatteryTemperature", int), # 电池温度
        ("iBatteryVoltage", int), # 电池电压
        #
        #
        ("byRectifierState", BYTE), # 整流器运行状态1正常 2异常
        ("byInverterState", BYTE), # 逆变器运行状态1正常 2异常
        ("byChargeState", BYTE), # 充电器运行状态1正常 2异常
        ("byBatteryState", BYTE), # 电池运行状态1正常 2异常
        ("byAutoBypassState", BYTE), # 自动旁路状态1正常 2异常
        ("byRes2", BYTE * 247),
    ]


LPNET_DVR_ALARMHOST_UPS_STATE = POINTER(NET_DVR_ALARMHOST_UPS_STATE)


# 开关电源状态
class NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE(Structure):
    _fields_ = [
        ("struACVoltage", NET_DVR_VOLTAGE), # 交流电压
        ("iDCConvertVoltage", int), # DC转换器电压
        ("struACCurrent", NET_DVR_CURRENT), # 交流电流
        ("iTotalCurrent", int), # 负载总电流
        ("iBattery1Temperature", int), # 电池1温度
        ("iBattery2Temperature", int), # 电池2温度
        ("iBattery1Current", int), # 电池1电流
        ("iBattery2Current", int), # 电池2电流
        ("iBattery3Current", int), # 电池3电流
        ("iBattery4Current", int), # 电池4电流
        ("iBatteryTestVoltage", int), # 电池测试电压
        ("iRectifierOutputVoltage", int), # 整流模块输出电压
        ("iRectifierOutputCurrent", int), # 整流模块输出电流
        ("iDCOutputVoltage", int), # 直流输出电压
        ("byRes", BYTE * 432),
    ]


LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE = POINTER(NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE)


*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE;
# 气体探测器状态
class NET_DVR_ALARMHOST_GAS_DETECTOR_STATE(Structure):
    _fields_ = [
        ("iSF6", int), # SF6，单位ppm
        ("iFlow", int), # 流量，ml/min
        ("iTemperature", int), # 温度，单位摄氏度
        ("iO2", int), # 氧气，单位%
        ("iHumidity", int), # 湿度，单位%
        ("byRes", BYTE * 492),
    ]


LPNET_DVR_ALARMHOST_GAS_DETECTOR_STATE = POINTER(NET_DVR_ALARMHOST_GAS_DETECTOR_STATE)


*LPNET_DVR_ALARMHOST_GAS_DETECTOR_STATE;
# 温湿度传感器状态
class NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE(Structure):
    _fields_ = [
        ("iTemperature", int), # 温度，单位摄氏度
        ("iHumidity", int), # 湿度，单位%
        ("byRes", BYTE * 504),
    ]


LPNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE = POINTER(NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE)


# 空调状态
class NET_DVR_ALARMHOST_AIRCONDITION_STATE(Structure):
    _fields_ = [
        ("iTemperature", int), # 温度，单位摄氏度
        ("iHumidity", int), # 湿度，单位%
        ("byRunState", BYTE), # 运行状态 1-正常，2-停机
        ("byRes", BYTE * 503),
    ]


LPNET_DVR_ALARMHOST_AIRCONDITION_STATE = POINTER(NET_DVR_ALARMHOST_AIRCONDITION_STATE)


# 电量表状态
class NET_DVR_ALARMHOST_ELECTRICITY_STATE(Structure):
    _fields_ = [
        ("iDCVoltage", int), # 直流电压
        ("iDCCurrent", int), # 直流电流
        ("struPhaseVoltage", NET_DVR_VOLTAGE), # 相电压
        ("struLineVoltage", NET_DVR_LINE_VOLTAGE), # 线电压
        ("struCurrent", NET_DVR_CURRENT * 4), # 电流，struCurrent[0]表示第1路, 以此类推
        ("iAverageCurrent", int), # 平均电流
        ("iNeutralCurrent", int), # 中线电流
        ("struActivePower", NET_DVR_POWER * 4), # 有功功率 struActivePower[0]表示第一路有功功率，以此类推
        ("struReactivePower", NET_DVR_POWER * 4), # 无功功率 struReactivePower[0]表示第一路无功功率，以此类推
        ("struApparentPower", NET_DVR_POWER * 4), # 视在功率 struApprentPower[0]表示第一路视在功率，以此类推
        ("struPowerFactor", NET_DVR_POWER_FACTOR * 4), # 功率因数，struPowerFactor[0]表示第一路功率因数，以此类推
        ("struFrequency", NET_DVR_FREQUENCY), # 频率
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ALARMHOST_ELECTRICITY_STATE = POINTER(NET_DVR_ALARMHOST_ELECTRICITY_STATE)


# 变电器温显表状态
class NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE(Structure):
    _fields_ = [
        ("iPhaseATemperature", int), # A相温度
        ("iPhaseBTemperature", int), # B相温度
        ("iPhaseCTemperature", int), # C相温度
        ("iPhaseDTemperature", int), # D相温度
        ("byRes", BYTE * 496),
    ]


LPNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE = POINTER(NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE)


# 水位传感器
class NET_DVR_ALARMHOST_WATERLEVEL_SENSOR(Structure):
    _fields_ = [
        ("iWaterLevel", LONG), # 水位
        ("byRes", BYTE * 508),
    ]


LPNET_DVR_ALARMHOST_WATERLEVEL_SENSOR = POINTER(NET_DVR_ALARMHOST_WATERLEVEL_SENSOR)


# 扬尘噪声传感器
class NET_DVR_ALARMHOST_DUSTNOISE_SENSOR(Structure):
    _fields_ = [
        ("iDust", LONG), # 扬尘
        ("iNoise", LONG), # 噪声
        ("iPM25", LONG), # PM2.5
        ("byRes", BYTE * 500),
    ]


LPNET_DVR_ALARMHOST_DUSTNOISE_SENSOR = POINTER(NET_DVR_ALARMHOST_DUSTNOISE_SENSOR)


# 环境采集仪
class NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER(Structure):
    _fields_ = [
        ("iAmmoniaNitrogen", LONG), # 氨氮
        ("iCOD", LONG), # COD
        ("iPH", LONG), # PH
        ("iOxygen", LONG), # 氧气
        ("iSulfurDioxide", LONG), # 二氧化硫
        ("iSoot", LONG), # 烟尘
        ("iFluoride", LONG), # 氟化物
        ("iPollutedWater", LONG), # 污水
        ("iTotalPhosphorus", LONG), # 总磷
        ("iExhaust", LONG), # 废气
        ("iNitrogenOxides", LONG), # 氮氧化物
        ("iFlueGasTemperature", LONG), # 烟气温度
        ("iFlueGasPressure", LONG), # 烟气压力
        ("iDustThickness", LONG), # 粉尘浓度
        ("iAirCleanLevel", LONG), # 空气洁净度等级
        ("iPm10Thickness", LONG), # PM10浓度
        ("byRes", BYTE * 448),
    ]


LPNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER = POINTER(NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER)


# 风速传感器状态
class NET_DVR_WIND_SPEED_STATE(Structure):
    _fields_ = [
        ("iWindSpeed", int), # 风速
        ("byRes", BYTE * 508),
    ]


LPNET_DVR_WIND_SPEED_STATE = POINTER(NET_DVR_WIND_SPEED_STATE)


# 通用扩展输出模块状态（48路，每位表示1路，0表示关，1表示开）
class NET_DVR_GENERATE_OUTPUT_STATE(Structure):
    _fields_ = [
        ("byOutPutState1", BYTE), # output1-8
        ("byOutPutState2", BYTE), # output9-16
        ("byOutPutState3", BYTE), # output17-24
        ("byOutPutState4", BYTE), # output25-32
        ("byOutPutState5", BYTE), # output33-40
        ("byOutPutState6", BYTE), # output41-48
        ("Res", BYTE * 506),
    ]


LPNET_DVR_GENERATE_OUTPUT_STATE = POINTER(NET_DVR_GENERATE_OUTPUT_STATE)


# 浸水传感器状态
class NET_DVR_SOAK_STATE(Structure):
    _fields_ = [
        ("iWaterLogVal", int), #  泄露位置，100倍
        ("iLeakResist1", int), # 第一路漏水电阻
        ("iTotolResist1", int), # 第一路总电阻
        ("iLeakResist2", int), # 第二路漏水电阻
        ("iTotolResist2", int), # 第二路总电阻
        ("byWaterLogAlarm", BYTE), #  泄漏报警1：正常，2：告警
        ("byLeakAlarm1", BYTE), # 第一路漏水告警1：正常，2：告警
        ("byFaultAlarm1", BYTE), # 第一路故障告警1：正常，2：告警
        ("byLeakAlarm2", BYTE), # 第二路漏水告警1：正常，2：告警
        ("byFaultAlarm2", BYTE), # 第二路故障告警1：正常，2：告警
        ("byRes", BYTE * 487),
    ]


LPNET_DVR_SOAK_STATE = POINTER(NET_DVR_SOAK_STATE)


# 太阳能控制器状态
class NET_DVR_SOLAR_POWER_STATE(Structure):
    _fields_ = [
        ("iChangerVolInput", int), # 充电设备输入电压
        ("iChangerCurInput", int), # 充电设备输入电流
        ("iChangerPwInput", int), # 充电设备输入功率
        ("iChangerVolOutput", int), # 充电设备输出电压
        ("iChangerCurOutput", int), # 充电设备输出电流
        ("iChangerPwOutput", int), # 充电设备输出功率
        ("iDischangerVolOutput", int), # 放电设备输出电压
        ("iDischangerCurOutput", int), # 放电设备输出电流
        ("iDischangerPwOutput", int), # 放电设备输出功率
        ("iDevTemperatrue", int), # 设备内温度
        ("byBatteryVolState", BYTE), # 蓄电池电压状态1：正常，2：异常
        ("byBatteryTmpState", BYTE), # 蓄电池温度状态1：正常，2：异常
        ("byChangerVolInputState", BYTE), # 充电设备输入电压状态1：正常，2：异常
        ("byChangerRunState", BYTE), # 充电设备运行状态1：正常，2：待机
        ("byChangerChgState", BYTE), # 充电设备充电状态1：正常，2：异常
        ("byBatteryVolFlt", BYTE), # 蓄电池电压故障1：正常，2：告警
        ("byBatteryTmpFlt", BYTE), # 蓄电池温度异常1：正常，2：告警
        ("byBatteryResistanceFlt", BYTE), # 蓄电池内阻异常1：正常，2：告警
        ("byVolRcgFlt", BYTE), # 额定电压识别错误1：正常，2：告警
        ("byChangerVolInputFlt", BYTE), # 充电设备输入电压异常1：正常，2：告警
        ("byChangerMosShort", BYTE), # 充电MOS管短路1：正常，2：告警
        ("byChangerAntiOrMosShort", BYTE), # 充电或防反MOS管短路1：正常，2：告警
        ("byChangerAntiShort", BYTE), # 防反MOS管短路1：正常，2：告警
        ("byInputOverCur", BYTE), # 输入过流1：正常，2：告警
        ("byLoadOverCur", BYTE), # 负载过流1：正常，2：告警
        ("byLoadShort", BYTE), # 负载短路1：正常，2：告警
        ("byLoadMosShort", BYTE), # 负载MOS管短路1：正常，2：告警
        ("byChangerFlt", BYTE), # 充电设备故障1：正常，2：告警
        ("byRes", BYTE * 454),
    ]


LPNET_DVR_SOLAR_POWER_STATE = POINTER(NET_DVR_SOLAR_POWER_STATE)


# SF6报警主机状态
class NET_DVR_SF6_ALARMHOST_STATE(Structure):
    _fields_ = [
        ("iSf6Thick1", int), # 第一点SF6浓度
        ("iO2Thick1", int), # 第一点氧气浓度
        ("iTemprature1", int), # 第一点温度
        ("iHumidity1", int), # 第一点湿度
        ("iSf6Thick2", int), # 第二点SF6浓度
        ("iO2Thick2", int), # 第二点氧气浓度
        ("iTemprature2", int), # 第二点温度
        ("iHumidity2", int), # 第三点湿度
        ("iSf6Thick3", int), # 第三点SF6浓度
        ("iO2Thick3", int), # 第三点氧气浓度
        ("iTemprature3", int), # 第三点温度
        ("iHumidity3", int), # 第三点湿度
        ("iSf6Thick4", int), # 第四点SF6浓度
        ("iO2Thick4", int), # 第四点氧气浓度
        ("iTemprature4", int), # 第四点温度
        ("iHumidity4", int), # 第四点湿度
        ("iSf6Thick5", int), # 第五点SF6浓度
        ("iO2Thick5", int), # 第五点氧气浓度
        ("iTemprature5", int), # 第五点温度
        ("iHumidity5", int), # 第五点湿度
        ("iSf6Thick6", int), # 第六点SF6浓度
        ("iO2Thick6", int), # 第六点氧气浓度
        ("iTemprature6", int), # 第六点温度
        ("iHumidity6", int), # 第六点湿度
        ("iSf6Thick7", int), # 第七点SF6浓度
        ("iO2Thick7", int), # 第七点氧气浓度
        ("iTemprature7", int), # 第七点温度
        ("iHumidity7", int), # 第七点湿度
        ("iSf6Thick8", int), # 第八点SF6浓度
        ("iO2Thick8", int), # 第八点氧气浓度
        ("iTemprature8", int), # 第八点温度
        ("iHumidity8", int), # 第八点湿度
        ("iSf6Thick9", int), # 第九点SF6浓度
        ("iO2Thick9", int), # 第九点氧气浓度
        ("iTemprature9", int), # 第九点温度
        ("iHumidity9", int), # 第九点湿度
        ("iSf6Thick10", int), # 第十点SF6浓度
        ("iO2Thick10", int), # 第十点氧气浓度
        ("iTemprature10", int), # 第十点温度
        ("iHumidity10", int), # 第十点湿度
        ("iSf6Thick11", int), # 第十一点SF6浓度
        ("iO2Thick11", int), # 第十一点氧气浓度
        ("iTemprature11", int), # 第十一点温度
        ("iHumidity11", int), # 第十一点湿度
        ("iSf6Thick12", int), # 第十二点SF6浓度
        ("iO2Thick12", int), # 第十二点氧气浓度
        ("iTemprature12", int), # 第十二点温度
        ("iHumidity12", int), # 第十二点湿度
        ("byFanState1", BYTE), # 风机状态1 1：运行，2：停止
        ("byFanState2", BYTE), # 风机状态2 1：运行，2：停止
        ("byFanState3", BYTE), # 风机状态3 1：运行，2：停止
        ("byFanState4", BYTE), # 风机状态4 1：运行，2：停止
        ("byFanState5", BYTE), # 风机状态5 1：运行，2：停止
        ("byFanState6", BYTE), # 风机状态6 1：运行，2：停止
        ("byFanState7", BYTE), # 风机状态7 1：运行，2：停止
        ("byFanState8", BYTE), # 风机状态8 1：运行，2：停止
        ("byFanState9", BYTE), # 风机状态9 1：运行，2：停止
        ("byFanState10", BYTE), # 风机状态10 1：运行，2：停止
        ("byFanState11", BYTE), # 风机状态11 1：运行，2：停止
        ("byFanState12", BYTE), # 风机状态12 1：运行，2：停止
        ("byRes", BYTE * 308),
    ]


LPNET_DVR_SF6_ALARMHOST_STATE = POINTER(NET_DVR_SF6_ALARMHOST_STATE)


# 称重仪状态
class NET_DVR_WEIGHT_STATE(Structure):
    _fields_ = [
        ("iWeight", int), # 称重值,1000倍
        ("byRes", BYTE * 508),
    ]


LPNET_DVR_WEIGHT_STATE = POINTER(NET_DVR_WEIGHT_STATE)


# 气象采集系统状态
class NET_DVR_WEATHER_STATION_STATE(Structure):
    _fields_ = [
        ("iAirTemperature", int), #  空气温度
        ("dwAirHumidity", DWORD), #  空气湿度
        ("dwWindSpeed", DWORD), #  风速
        ("dwWindDirection", DWORD), #  风向
        ("dwIlluminationIntensity", DWORD), #  光照强度
        ("dwCO2", DWORD), #  co2浓度
        ("dwPM25", DWORD), #  PM2.5浓度
        ("dwAirPressure", DWORD), #  大气压力
        ("iSoilTemperature", int), #  土壤温度
        ("dwSoilHumidity", DWORD), #  土壤湿度
        ("dwRainFall", DWORD), # 降雨量
        ("byIsRainSnow", BYTE), #  雨雪情况，1-无雨雪，2-有雨雪
        ("byRes", BYTE * 467),
    ]


LPNET_DVR_WEATHER_STATION_STATE = POINTER(NET_DVR_WEATHER_STATION_STATE)


# 水质监测仪状态
class NET_DVR_WATER_QLT_STATE(Structure):
    _fields_ = [
        ("dwTurbidity", DWORD), #  浊度值
        ("dwChlorine", DWORD), #  余氯值
        ("dwPH", DWORD), #  PH 值
        ("byRes", BYTE * 500),
    ]


LPNET_DVR_WATER_QLT_STATE = POINTER(NET_DVR_WATER_QLT_STATE)


# 燃气监测系统状态
class NET_DVR_FUEL_GAS_DETE_STATE(Structure):
    _fields_ = [
        ("iNatrualGasThick", int), #  天然气浓度
        ("byRes", BYTE * 508),
    ]


LPNET_DVR_FUEL_GAS_DETE_STATE = POINTER(NET_DVR_FUEL_GAS_DETE_STATE)


# 消防主机设备
class NET_DVR_FIRE_ALARM_STATUS(Structure):
    _fields_ = [
        ("byFireAlarm", BYTE * MAX_FIRE_ALARM_ZONE), # 火点状态参数位，1-正常，2-告警
        ("byRes", BYTE * 128), # 保留位
    ]


LPNET_DVR_FIRE_ALARM_STATUS = POINTER(NET_DVR_FIRE_ALARM_STATUS)


class NET_DVR_EXTERNAL_DEVICE_STATE_UNION(Union):
    _fields_ = [
        ("struUpsState", NET_DVR_ALARMHOST_UPS_STATE), # UPS状态
        ("struSwitchPowerState", NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE), # 开关电源状态
        ("struGasDetectorState", NET_DVR_ALARMHOST_GAS_DETECTOR_STATE), # 气体检测系统状态
        ("struTempHumiSensorState", NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE), # 温湿度传感器状态
        ("struAirConditionState", NET_DVR_ALARMHOST_AIRCONDITION_STATE), # 空调状态
        ("struElectricityState", NET_DVR_ALARMHOST_ELECTRICITY_STATE), # 电量表状态
        ("struTransformerTempState", NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE), # 变电器状态
        ("struWaterLevelSensor", NET_DVR_ALARMHOST_WATERLEVEL_SENSOR), # 水位传感器
        ("struDustNoiseSensor", NET_DVR_ALARMHOST_DUSTNOISE_SENSOR), # 扬尘噪声传感器
        ("struEnvironmentLogger", NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER), # 环境采集仪
        ("struWindSpeedState", NET_DVR_WIND_SPEED_STATE), # 风速传感器状态
        ("struGenerateOutputState", NET_DVR_GENERATE_OUTPUT_STATE), # 通用扩展输出模块状态（48路，每位表示1路）
        ("struSoakState", NET_DVR_SOAK_STATE), # 浸水传感器状态
        ("struSolarPowerState", NET_DVR_SOLAR_POWER_STATE), # 太阳能控制器状态
        ("struSF6AlarmHostState", NET_DVR_SF6_ALARMHOST_STATE), # SF6报警主机状态
        ("struWeightState", NET_DVR_WEIGHT_STATE), # 称重仪状态
        ("struWeatherStationState", NET_DVR_WEATHER_STATION_STATE), # 气象采集系统状态
        ("struWaterQltState", NET_DVR_WATER_QLT_STATE), # 水质监测仪状态
        ("struFuelGasDeteState", NET_DVR_FUEL_GAS_DETE_STATE), # 燃气监测系统状态
        ("struFireAlarmStatus", NET_DVR_FIRE_ALARM_STATUS), # 消防主机设备状态
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_EXTERNAL_DEVICE_STATE_UNION = POINTER(NET_DVR_EXTERNAL_DEVICE_STATE_UNION)


class NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDevType", BYTE), # 1-UPS，2-开关电源，3-气体检测系统，4-温湿度传感器，5-空调，6-电量表，7-变电器状态, 8-水位传感器、9-扬尘噪声传感器、10-环境采集仪、11-风速传感器状态、12-通用扩展输出模块状态、13-浸水传感器状态、14-太阳能控制器状态、15-SF6报警主机状态、16-称重仪状态、17-气象采集系统状态、18-水质检测仪状态、19-燃气监测系统状态、20-消防主机状态
        ("byRes1", BYTE * 3),
        ("struDevState", NET_DVR_EXTERNAL_DEVICE_STATE_UNION),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE = POINTER(NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE)


# 通用扩展输出模块控制（48路，每位表示1路）
class NET_DVR_GENERATE_OUTPUT_CTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byOutPutState1", BYTE), # output1-8
        ("byOutPutState2", BYTE), # output9-16
        ("byOutPutState3", BYTE), # output17-24
        ("byOutPutState4", BYTE), # output25-32
        ("byOutPutState5", BYTE), # output33-40
        ("byOutPutState6", BYTE), # output41-48
        ("byOperateType", BYTE), # 操作类型，0-无效，1-开，2-关
        ("Res", BYTE * 65),
    ]


LPNET_DVR_GENERATE_OUTPUT_CTRL = POINTER(NET_DVR_GENERATE_OUTPUT_CTRL)


# UPS报警限值
class NET_DVR_ALARMHOST_UPS_LIMIT_VALUE(Structure):
    _fields_ = [
        ("iInputVolHigh", int), # 越限输入电压值(高值)
        ("iInputVolLow", int), # 越限输入电压值(低值)
        ("iInputFreHigh", int), # 越限输入频率值(高值)
        ("iInputFreLow", int), # 越限输入频率值(低值)
        ("iOutputVolHigh", int), # 越界输出电压值(高值)
        ("iOutputVolLow", int), # 越界输出电压值(低值)
        ("iBatteryVoltageLow", int), # 电池低电压限值
        ("iBatterySurplus", int), # 电池后备时间低 限值
        ("iBatteryTemperatureHigh", int), # 电池温度高限值
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_ALARMHOST_UPS_LIMIT_VALUE = POINTER(NET_DVR_ALARMHOST_UPS_LIMIT_VALUE)


# 温湿度传感器限值
class NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE(Structure):
    _fields_ = [
        ("iTemperatureHighLimit", int), # 温度高限值，单位摄氏度
        ("iTemperatureLowLimit", int), # 温度低限值，单位摄氏度
        ("iHumidityHighLimit", int), # 湿度高限值，单位%
        ("iHumidityLowLimit", int), # 湿度低限值，单位%
        ("byRes", BYTE * 84),
    ]


LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE = POINTER(NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE)


class NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION(Union):
    _fields_ = [
        ("struUpsLimitValue", NET_DVR_ALARMHOST_UPS_LIMIT_VALUE),
        ("struTempHumidityLimitValue", NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE),
    ]


LPNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION = POINTER(NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION)


class NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDevType", BYTE), # 1-UPS，2-温湿度传感器
        ("byRes1", BYTE * 3),
        ("struAlarmValue", NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE = POINTER(NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE)


ALARMHOST_ALARMOUT_NUM = 64 # 触发器个数
MAX_OSD_UNIT_LEN = 8 # OSD单位长度
class NET_DVR_ALARMHOST_SENSOR_JOINT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySensorJointAlarmOut", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 模拟量联动触发器，0-不联动，1-联动
        ("bySensorJointSiren", BYTE * ALARMHOST_MAX_SIREN_NUM), # 模拟量联动警号
        ("bySensorAlarmTypeJointAlarmOut", BYTE * ALARMHOST_ALARMOUT_NUM), # 模拟量按类型联动触发器，该字段是bySensorJointAlarmOut的扩展。数组下标表示触发器号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：1bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
        ("bySesorAlarmTypeJointSiren", BYTE * ALARMHOST_MAX_SIREN_NUM), # 模拟量按类型联动警号，该字段是bySensorJointSiren的扩展。数组下标表示警号序号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
        ("byChan", BYTE), # 通道号
        ("byRes", BYTE * 55),
    ]


LPNET_DVR_ALARMHOST_SENSOR_JOINT_CFG = POINTER(NET_DVR_ALARMHOST_SENSOR_JOINT_CFG)


# UPS报警信息上传
class NET_DVR_ALARMHOST_UPS_ALARMINFO(Structure):
    _fields_ = [
        ("byAlarmType", BYTE), # 报警类型：1.A相输入电压越限 2.B相输入电压越限 3.C相输入电压越限 4.A相输出电压越限5.B相输出电压越限 6.C相输出电压越限7.A相输入频率越限 8.B相输入频率越限9.C相输入频率越限10.整流器电压越限报警 11.过载报警 12.电池电压低报警 13.电池后备时间超低报警 14.电池温度超高报警 15.逆变器关闭报警 16.自动旁路开报警 17.整流器故障报警 18.逆变器故障报警 19.充电器故障报警    20.电池故障报警     21.自动旁路故障报警
        ("byChanNo", BYTE), # 485通道号，从1开始
        ("bySlotNo", BYTE), # 485虚拟槽位号
        ("byRes1", BYTE), # 保留
        ("iAlarmValue", int), # 报警值
        ("byRes2", BYTE * 64), # 保留
    ]


LPNET_DVR_ALARMHOST_UPS_ALARMINFO = POINTER(NET_DVR_ALARMHOST_UPS_ALARMINFO)


# 开关电源报警上传
class NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO(Structure):
    _fields_ = [
        ("byAlarmType", BYTE), # 报警类型：1-电池测试失败 2-AC-DC转换器故障，3-输入线/相电压AB/A越限，4-输入线/相电压BC/B越限，5-输入线/相电压CA/C越限，6-输出电流A越限，7-输出电流B越限，8-输出电流C越限，9整流模块故障，10-风扇故障，11-直流电压越限
        ("byChanNo", BYTE), # 485通道号，从1开始
        ("bySlotNo", BYTE), # 485虚拟槽位号
        ("byRes1", BYTE),
        ("iAlarmValue", int), # 报警值
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO = POINTER(NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO)


*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO;
# 气体检测系统报警
class NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO(Structure):
    _fields_ = [
        ("byAlarmType", BYTE), # 报警类型：1- SF6气体含量异常，2-氧气含量异常，3-温度值异常，4-湿度值异常，5-流量
        ("byChanNo", BYTE), # 485通道号，从1开始
        ("bySlotNo", BYTE), # 485虚拟槽位号
        ("byRes1", BYTE),
        ("iAlarmValue", int), # 报警值
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO = POINTER(NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO)


*LPNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO;
# 温湿度传感器报警
class NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO(Structure):
    _fields_ = [
        ("byAlarmType", BYTE), # 1-温度异常，2-湿度异常
        ("byChanNo", BYTE), # 485通道号
        ("bySlotNo", BYTE), # 485槽位号
        ("byRes1", BYTE),
        ("iAlarmValue", int), # 报警值
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO = POINTER(NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO)


class NET_DVR_485_DEVICE_ALARM_UNION(Union):
    _fields_ = [
        ("struUPSAlarm", NET_DVR_ALARMHOST_UPS_ALARMINFO), # UPS报警
        ("struSwitchPowerAlarm", NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO), # 开关电源报警
        ("struGasDetectSystemAlarm", NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO), # 气体检测系统报警
        ("struTempHumiditySensorAlarm", NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO), # 温湿度传感器报警
        ("byRes", BYTE * 72),
    ]


LPNET_DVR_485_DEVICE_ALARM_UNION = POINTER(NET_DVR_485_DEVICE_ALARM_UNION)


# 485外接设备报警信息
class NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAlarmType", BYTE), # 1-UPS报警，2-开关电源报警，3-气体检测系统报警，4-温湿度传感器报警
        ("byRes1", BYTE * 3),
        ("struAlarmInfo", NET_DVR_485_DEVICE_ALARM_UNION),
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO = POINTER(NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO)


class NET_DVR_ALARMHOST_RS485_SLOT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("sDeviceName", BYTE * NAME_LEN), #  前端设备名称
        ("wDeviceType", WORD), #  前端设备类型ALARM_FRONT_DEVICE _TYPE
        ("wDeviceProtocol", WORD), #  前端设备协议 通过获取协议列表获取
        ("wAddress", WORD), # 设备地址
        ("byChannel", BYTE), # 485通道号
        ("bySlotChan", BYTE), # 槽位号
        ("byRes", BYTE * 60), #  保留字节
    ]


LPNET_DVR_ALARMHOST_RS485_SLOT_CFG = POINTER(NET_DVR_ALARMHOST_RS485_SLOT_CFG)


# 走廊模式
class NET_DVR_CORRIDOR_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableCorridorMode", BYTE), # 是否启用走廊模式 0～不启用， 1～启用
        ("byMirrorMode", BYTE), # 镜像方式，0 关闭1 左右2 上下3 中间
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_CORRIDOR_MODE = POINTER(NET_DVR_CORRIDOR_MODE)


# 人脸侦测
class NET_DVR_DETECT_FACE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableDetectFace", BYTE), # 是否启用 0～不启用， 1～启用
        ("byDetectSensitive", BYTE), # 灵敏度 10个等级 1～10
        ("byEnableDisplay", BYTE), # 启用移动侦测高亮显示，0-否，1-是
        ("byRes", BYTE),
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V40), # 处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("dwMaxRelRecordChanNum", DWORD), # 报警触发的录象通道 数（只读）最大支持数量
        ("dwRelRecordChanNum", DWORD), # 报警触发的录象通道数 实际支持数
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V30), #  报警触发的录象通道
        ("struHolidayTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 假日布防时间
        ("wDuration", WORD), # 报警持续时间 5s 能力集
        ("byRes1", BYTE * 30),
    ]


LPNET_DVR_DETECT_FACE = POINTER(NET_DVR_DETECT_FACE)


class NET_DVR_MUL_STREAM_CHANNEL_GROUP(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwGroup", DWORD), # 组号
        ("struMultiStreamCfg", NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND), # 多码流配置
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_MUL_STREAM_CHANNEL_GROUP = POINTER(NET_DVR_MUL_STREAM_CHANNEL_GROUP)


class NET_DVR_CHANNEL_GROUP(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwChannel", DWORD), # 通道号
        ("dwGroup", DWORD), # 组号
        ("byID", BYTE), # 设备区域设置ID
        ("byRes1", BYTE * 3),
        ("dwPositionNo", DWORD), # 场景位置索引号,IPC是0，IPD是从1开始
        ("byRes", BYTE * 56),
    ]


LPNET_DVR_CHANNEL_GROUP = POINTER(NET_DVR_CHANNEL_GROUP)


class NET_DVR_TIME_DETECTION(Structure):
    _fields_ = [
        ("struSchedTime", NET_DVR_SCHEDTIME), # 时间
        ("byDetSceneID", BYTE), # 检测场景号[1,4],IPC默认是0
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_TIME_DETECTION = POINTER(NET_DVR_TIME_DETECTION)


# 抓拍触发模式支持关联布防时间段和上传中心条件
class NET_DVR_GUARD_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        #
        # 0表示无效，
        ("抓拍VIA模式（视频触发抓拍", 1表示关联),
        # 2 表示关联 抓拍 HVT 模式 （混卡IPC使用）
        #
        ("byRelateType", BYTE),
        ("byGroupNo", BYTE), # 组号
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_GUARD_COND = POINTER(NET_DVR_GUARD_COND)


# 抓拍触发模式支持关联布防时间段和上传中心
class NET_DVR_GUARD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 布防时间
        ("struAlarmSched", NET_DVR_TIME_DETECTION * MAX_DAYS),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V40), # 异常处理方式
        ("dwMaxRelRecordChanNum", DWORD), # 报警触发的录象通道 数（只读）最大支持数量
        ("dwRelRecordChanNum", DWORD), # 本组内实际触发的录象通道数
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V30), # 报警触发的录象通道(0xffff ffff表示后续无效）
        ("struHolidayTime", NET_DVR_TIME_DETECTION * MAX_TIMESEGMENT_V30), # 假日布防时间
        ("byDirection", BYTE), # 触发方向：0-保留；1-全部；2-正向；3-反向
        ("byRes", BYTE * 87),
    ]


LPNET_DVR_GUARD_CFG = POINTER(NET_DVR_GUARD_CFG)


# 抓拍图片参数配置扩展条件结构
class NET_DVR_SNAPINFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD),
        #
        # 0 表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
        # 1 表示关联 抓拍 HVT 模式（混卡IPC使用）
        #
        ("byRelateType", BYTE),
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_SNAPINFO_COND = POINTER(NET_DVR_SNAPINFO_COND)


# 抓拍图片参数配置
class NET_DVR_SNAPINFOCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCurPicType", BYTE), # 0-表示的图片质量，1-表示图片大小
        ("byPicQuality", BYTE), # 图片质量[1,100]
        ("byRes1", BYTE * 2),
        ("dwPicSize", DWORD), # 图片大小[64k,2048k]
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_SNAPINFOCFG = POINTER(NET_DVR_SNAPINFOCFG)


# ptz跟踪方式
PTZ_TRACK_MODE_ALWAYS = 1
PTZ_TRACK_MODE_BYTIME = 2
PTZ_TRACK_MODE_NEXT = 3


# ptz跟踪参数
class NET_VCA_TRAVERSE_PLANE_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("byEnableDualVca", BYTE), #  启用支持智能后检索 0-不启用，1-启用
        ("byEnableHumanMisinfoFilter", BYTE), #  启用人体去误报 0-不启用，1-启用
        ("byEnableVehicleMisinfoFilter", BYTE), #  启用车辆去误报 0-不启用，1-启用
        ("struAlertParam", NET_VCA_TRAVERSE_PLANE * MAX_ALERTLINE_NUM), # 警戒线参数
        ("struAlarmSched", NET_DVR_SCHEDTIME * MAX_DAYS),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V40), # 异常处理方式
        ("dwMaxRelRecordChanNum", DWORD), # 报警触发的录象通道 数（只读）最大支持数量
        ("dwRelRecordChanNum", DWORD), # 报警触发的录象通道 数 实际支持的数量
        ("byRelRecordChan", DWORD * MAX_CHANNUM_V30), # 触发录像的通道号
        ("struHolidayTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 假日布防时间
        ("byRes2", BYTE * 100),
    ]


LPNET_VCA_TRAVERSE_PLANE_DETECTION = POINTER(NET_VCA_TRAVERSE_PLANE_DETECTION)


class NET_VCA_FIELDDETECION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能，是否开启
        ("byEnableDualVca", BYTE), #  启用支持智能后检索 0-不启用，1-启用
        ("byEnableHumanMisinfoFilter", BYTE), #  启用人体去误报 0-不启用，1-启用
        ("byEnableVehicleMisinfoFilter", BYTE), #  启用车辆去误报 0-不启用，1-启用
        ("struIntrusion", NET_VCA_INTRUSION * MAX_INTRUSIONREGION_NUM), # 每个区域的参数设置
        ("struAlarmSched", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V40), # 异常处理方式
        ("dwMaxRelRecordChanNum", DWORD), # 报警触发的录象通道 数（只读）最大支持数量
        ("dwRelRecordChanNum", DWORD), # 报警触发的录象通道 数 实际支持的数量
        ("byRelRecordChan", DWORD * MAX_CHANNUM_V30), # 触发录像通道
        ("struHolidayTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 假日布防时间
        ("byRes2", BYTE * 100),
    ]


LPNET_VCA_FIELDDETECION = POINTER(NET_VCA_FIELDDETECION)


class NET_DVR_ROI_DETECT_NUM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwGroup", DWORD),
        ("dwStreamType", DWORD), # 码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
        ("dwRoiFixNum", DWORD), # 固定区域总数，确定后续再次获取的组号
        ("dwRoiFixID", DWORD * MAX_ROIDETECT_NUM), # IPC现在支持4个，球机现在支持24个
        ("szFixRoiName", BYTE * MAX_ROIDETECT_NUM), # 固定ROI区域名称
        ("dwRoiTrackNum", DWORD), # 自动跟踪区域总数，确定后续再次获取的组号
        ("dwRoiTrackID", DWORD * MAX_ROIDETECT_NUM), # IPC现在支持4个，球机现在支持24个
        ("byRes", BYTE * 320),
    ]


LPNET_DVR_ROI_DETECT_NUM = POINTER(NET_DVR_ROI_DETECT_NUM)


DETECT_FIX_ROI = 0
DETECT_TRACK_ROI = 1


# 条件参数
class NET_DVR_ROI_DETECT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRoiID", DWORD), # 区域检测号 一个PTZ支持4个
        ("struMultiStreamCfg", NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND), # 多码流配置
        ("byRoiDetectType", BYTE), #  DECTECT_ROI_TYPE 的值
        ("byRoiDetectTrackType", BYTE), # 固定区域时，该字段无效；跟踪区域时，1～人脸侦测（IPC）,2～移动物体跟踪,3-车牌跟踪
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_ROI_DETECT_COND = POINTER(NET_DVR_ROI_DETECT_COND)


# 配置参数
# ROI固定区域模式 区域编码功能
class NET_DVR_ROI_FIX_RECT_CFG(Structure):
    _fields_ = [
        ("byEnableFixRoi", BYTE), #  ROI固定区域模式 是否启用 0～不启用， 1～启用
        ("byImageQualityLevel", BYTE), # 图像质量提升等级 1～6
        ("byRes", BYTE * 2),
        ("szFixRoiName", BYTE * NAME_LEN),
        ("struRoiRect", NET_VCA_RECT), # ROI区域
        ("byRes1", BYTE * 468),
    ]


LPNET_DVR_ROI_FIX_RECT_CFG = POINTER(NET_DVR_ROI_FIX_RECT_CFG)


# ROI自动跟踪模式 区域编码功能
class NET_DVR_ROI_TRACK_RECT_CFG(Structure):
    _fields_ = [
        ("byEnableTrackRoi", BYTE), #  ROI自动跟踪模式 是否启用 0～不启用， 1～启用
        ("byImageQualityLevel", BYTE), # 图像质量提升等级 1～6
        ("byModeType", BYTE), #  0 ~ 无, 1～人脸模式(移动和静止的物体), 2~移动物体跟踪(移动的物体), 3-车牌跟踪
        ("byRes", BYTE * 509),
    ]


LPNET_DVR_ROI_TRACK_RECT_CFG = POINTER(NET_DVR_ROI_TRACK_RECT_CFG)


class NET_DVR_ROI_DETECT_UNION(Union):
    _fields_ = [
        ("uLen", DWORD * 128),
        ("strRoiFixRectCfg", NET_DVR_ROI_FIX_RECT_CFG), # 固定区域模式
        ("strRoiTrackRectCfg", NET_DVR_ROI_TRACK_RECT_CFG), # 自动跟踪模式
    ]


LPNET_DVR_ROI_DETECT_UNION = POINTER(NET_DVR_ROI_DETECT_UNION)


class NET_DVR_ROI_DETECT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 560
        ("dwStreamType", DWORD), # 码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
        ("byRoiDetectType", BYTE), #  DECTECT_ROI_TYPE 的值
        ("byRes", BYTE * 3),
        ("uRoiDetectInfo", NET_DVR_ROI_DETECT_UNION), # ROI检测区域
        ("byRes1", BYTE * 36),
    ]


LPNET_DVR_ROI_DETECT_CFG = POINTER(NET_DVR_ROI_DETECT_CFG)


# 虚焦侦测
class NET_VCA_DEFOCUSPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("bySensitiveLevel", BYTE), #  1-100，默认50，灵敏度越高，越容易报警
        ("byRes1", BYTE * 2),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V40), # 异常处理方式
        ("byRes2", BYTE * 24),
    ]


LPNET_VCA_DEFOCUSPARAM = POINTER(NET_VCA_DEFOCUSPARAM)


class NET_PTZ_INFO_EX(Structure):
    _fields_ = [
        ("fPan", float), # P值 精确到小数点后3位 范围[0,360.000]
        ("fTilt", float), # Z值 精确到小数点后3位 范围[-90.000,90.000]
        ("fVisibleZoom", float), # 可见光zoom 精确到小数点后1位 不会超过[0，10000.0]
        ("dwVisibleFocus", DWORD), # 可见光focus[0,65535]
        ("fThermalZoom", float), # 热成像zoom 精确到小数点后1位 不会超过[0，10000.0]
        ("dwThermalFocus", DWORD), # 热成像focus[0,65535]
    ]


LPNET_PTZ_INFO_EX = POINTER(NET_PTZ_INFO_EX)


# IPC5.1.0
class NET_DVR_PRESET_NAME(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wPresetNum", WORD), # 预置点编号
        ("byRes1", BYTE * 2), # 字节对齐
        ("byName", CHAR * NAME_LEN),
        ("wPanPos", WORD), # 水平参数 如果获取到的数据大于360默认减去360
        ("wTiltPos", WORD), # 垂直参数 如果获取到的数据大于360默认减去360
        ("wZoomPos", WORD), # 变倍参数如果获取到的数据大于360默认减去360
        ("byRes2", BYTE),
        ("byPTZPosExEnable", BYTE), # 是否启用PTZ坐标扩展，0~不启用，PTZ坐标值以wPanPos、wTiltPos、wZoomPos为准。1~启用，PTZ坐标值以struPtzPosEx为准
        ("struPtzPosEx", NET_PTZ_INFO_EX), #  ptz坐标扩展(支持高精度PTZ值)
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_PRESET_NAME = POINTER(NET_DVR_PRESET_NAME)


class NET_DVR_SCHEDTASK(Structure):
    _fields_ = [
        ("struSchedTime", NET_DVR_SCHEDTIME), # 时间
        ("wAction", WORD), # /< 定时动作具体动作
        ("wActionNum", WORD), # /< 特殊动作子编号，如预置点，巡航，花样，报警输出，日夜切换，
        ("byres", BYTE * 12),
    ]


LPNET_DVR_SCHEDTASK = POINTER(NET_DVR_SCHEDTASK)


# 定时任务
class NET_DVR_TIME_TASK(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byTaskEnable", BYTE), # /< 使能 1-开，0-关
        ("byRes", BYTE * 3), # /< 字节对齐
        ("struTask", NET_DVR_SCHEDTASK * MAX_DAYS), # /< 7天，每天10时间段
        ("dwParkTime", DWORD), # /< 守望时间 5s-720s
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_TIME_TASK = POINTER(NET_DVR_TIME_TASK)


# 条件结构体
class NET_DVR_CHANNEL_INDEX(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwChannel", DWORD), # 通道号
        ("dwIndex", DWORD), # 索引号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_CHANNEL_INDEX = POINTER(NET_DVR_CHANNEL_INDEX)


class NET_DVR_AUDIO_NAME(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("cName", CHAR * NAME_LEN), # 名称
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_AUDIO_NAME = POINTER(NET_DVR_AUDIO_NAME)


# 登录设备参数
class NET_DVR_LOGIN_DEVICE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byMobileDev", BYTE), # 设备种类, 0- 非移动设备, 1 - 移动设备
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_LOGIN_DEVICE_PARAM = POINTER(NET_DVR_LOGIN_DEVICE_PARAM)


ENUM_RECV_ERRCODE = 0x0


# 码流输出模式
FISHEYE_STREAM_MODE_FISHEYE = 1
FISHEYE_STREAM_MODE_PTZ = 2
FISHEYE_STREAM_MODE_PANORAMA = 3


# 回调数据类型枚举
ENUM_FISHEYE_STREAM_STATUS = 1
ENUM_FISHEYE_PTZPOS = 2
ENUM_FISHEYE_REALTIME_OUTPUT = 3


# 鱼眼码流状态
class NET_DVR_FISHEYE_STREAM_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byStreamMode", BYTE), # 码流输出模式，参见FISHEYE_STREAM_OUTPUT_MODE
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_FISHEYE_STREAM_STATUS = POINTER(NET_DVR_FISHEYE_STREAM_STATUS)


# 长连接回调数据结构体
class NET_DVR_CALLBACK_TYPE_DATA(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号
        ("dwDataType", DWORD), # 参见CALLBACK_TYPE_DATA_ENUM
        ("dwDataLen", DWORD), # 数据长度
        ("pData", BYTE*), # 数据，当dwTypeData为 ENUM_FISHEYE_STREAM_STATUS，其对应为NET_DVR_FISHEYE_STREAM_STATUS
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_CALLBACK_TYPE_DATA = POINTER(NET_DVR_CALLBACK_TYPE_DATA)


# 鱼眼ptz拖动参数
class NET_DVR_DRAG_POS_PARAM(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号
        ("dwPtzChannel", DWORD), # 当dwChannel所指通道模式为FISHEYE_STREAM_MODE_FISHEYE（鱼眼模式时），此值为其拖动所联动的ptz通道。当dwChannel通道模式为非鱼眼时，置为0即可
        ("struToPoint", NET_VCA_POINT), # 拖动画面要跳转到的目标点，目标点位置相对于预览画面的左上角
        ("struOriPoint", NET_VCA_POINT), # 拖动操作起始点,此点为当次拖动操作开始时，鼠标指针相对于预览画面左上角的位置
        ("byRes", BYTE * 56), # 保留
    ]


LPNET_DVR_DRAG_POS_PARAM = POINTER(NET_DVR_DRAG_POS_PARAM)


# 平台查询诊断服务器的状态
class NET_DVR_QUERY_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCpuLoad", BYTE), # CPU资源占用情况, 取值范围：0-100
        ("byMemLoad", BYTE), # Memory资源占用情况，取值范围：0-100
        ("wAbility", WORD), # 诊断服务器能力集，大于0
        ("wRemainAbility", WORD), # 诊断服务器剩余能力，取值范围：大于 0  剩余监控点的个数
        ("wTotalPlanNum", WORD), # 最多64个计划>
        ("wCurPlanNum", WORD), # 当前计划数  最多64个计划>
        ("byRes", BYTE * 62), # 保留
    ]


LPNET_DVR_QUERY_STATUS = POINTER(NET_DVR_QUERY_STATUS)


class NET_DVR_MONITOR_VQDCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用
        ("byDevType", BYTE), # 设备类型：0-非云台设备，1-带云台设备
        ("bySignalPoint", BYTE), # 信号丢失阀值，0-100
        ("byBlurPoint", BYTE), # 图像模糊阀值，0-100
        ("byLumaPoint", BYTE), # 图像过亮阀值，0-100
        ("byChromaPoint", BYTE), # 图像偏色阀值，0-100
        ("bySnowPoint", BYTE), # 噪声干扰阀值，0-100
        ("byStreakPoint", BYTE), # 条纹干扰阀值，0-100
        ("byFreezePoint", BYTE), # 画面冻结阀值，0-100
        ("byPTZPoint", BYTE), # 云台失控阀值，0-100
        ("byMonitorDel", BYTE), # 监控点删除 0-不删除， 1-删除
        ("byContrastThreshold", BYTE), # 对比度异常阈值，0-100
        ("byMonoThreshold", BYTE), # 黑白图像阈值，0-100
        ("byShakeThreshold", BYTE), # 视频抖动阈值，0-100
        ("byFlashThreshold", BYTE), # 视频剧变阈值，0-100
        ("byCoverThreshold", BYTE), # 视频遮挡阈值，0-100
        ("bySceneThreshold", BYTE), # 场景变更阈值，0-100
        ("byDarkThreshold", BYTE), # 图像过暗阈值，0-100
        ("byRes", BYTE * 46),
    ]


LPNET_DVR_MONITOR_VQDCFG = POINTER(NET_DVR_MONITOR_VQDCFG)


# 诊断结果
class NET_DVR_DIAGNOSIS_UPLOAD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sStreamID", CHAR * STREAM_ID_LEN), # /< 流ID，长度小于32个字节
        ("sMonitorIP", CHAR * 64), # /< 监控点ip
        ("dwChanIndex", DWORD), # /< 监控点通道号
        ("dwWidth", DWORD), # /< 图像宽度
        ("dwHeight", DWORD), # /< 图像高度
        ("struCheckTime", NET_DVR_TIME), # /< 检测时间(合并日期和时间字段)，格式：2012-08-06 13:00:00
        ("byResult", BYTE), # /0-未检测 1-正常 2-异常 3-登录失败 4-取流异常
        ("bySignalResult", BYTE), # /< 视频丢失检测结果 0-未检测 1-正常 2-异常
        ("byBlurResult", BYTE), # /< 图像模糊检测结果，0-未检测 1-正常 2-异常
        ("byLumaResult", BYTE), # /< 图像过亮检测结果，0-未检测 1-正常 2-异常
        ("byChromaResult", BYTE), # /< 偏色检测结果，0-未检测 1-正常 2-异常
        ("bySnowResult", BYTE), # /< 噪声干扰检测结果，0-未检测 1-正常 2-异常
        ("byStreakResult", BYTE), # /< 条纹干扰检测结果，0-未检测 1-正常 2-异常
        ("byFreezeResult", BYTE), # /< 画面冻结检测结果，0-未检测 1-正常 2-异常
        ("byPTZResult", BYTE), # /< 云台检测结果，0-未检测 1-正常 2-异常
        ("byContrastResult", BYTE), # 对比度异常检测结果，0-未检测，1-正常，2-异常
        ("byMonoResult", BYTE), # 黑白图像检测结果，0-未检测，1-正常，2-异常
        ("byShakeResult", BYTE), # 视频抖动检测结果，0-未检测，1-正常，2-异常
        ("sSNapShotURL", CHAR * 256), # /<图片URL地址
        ("byFlashResult", BYTE), # 视频剧变检测结果，0-未检测，1-正常，2-异常
        ("byCoverResult", BYTE), # 视频遮挡检测结果，0-未检测，1-正常，2-异常
        ("bySceneResult", BYTE), # 场景变更检测结果，0-未检测，1-正常，2-异常
        ("byDarkResult", BYTE), # 图像过暗检测结果，0-未检测，1-正常，2-异常
        ("byStreamType", BYTE), # 码流类型，0-无效，1-未知，2-国标类型，3-非国标类型
        ("byRes2", BYTE * 59),
    ]


LPNET_DVR_DIAGNOSIS_UPLOAD = POINTER(NET_DVR_DIAGNOSIS_UPLOAD)


class NET_DVR_DOWN_LOAD_REQUEST(Structure):
    _fields_ = [
        ("struStreamInfo", NET_DVR_STREAM_INFO),
        ("sSnapShotURL", CHAR * 256), # /< 诊断抓图URL，长度小于256个字节
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DOWN_LOAD_REQUEST = POINTER(NET_DVR_DOWN_LOAD_REQUEST)


class NET_DVR_VQD_RESULT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sStreamID", CHAR * 32), # /<流ID(监控点ID)，长度小于32个字节
        ("dwPicLength", DWORD), # /图片长度
        ("byStatus", BYTE), # /< 设置结果:0-成功,1-数据有误，2-图片不存在，3-获取图片失败
        ("byRes", BYTE * 31),
        ("*pSnapShot", CHAR), # /< 诊断抓图，是一块图片缓存数据(700k)
    ]


LPNET_DVR_VQD_RESULT_INFO = POINTER(NET_DVR_VQD_RESULT_INFO)


class NET_DVR_PLAN_VQD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sPlanID", BYTE * PLAN_ID_LEN), # /< 计划id，长度小于32个字节
        ("struDetectTime", NET_DVR_SCHEDTIME * MAX_DAYS), # /< 检测时间
        ("byPlanMode", BYTE), # /0:即时计划，1:周期计划
        ("byRes1", BYTE),
        ("byCheckFlag", BYTE), # /< 是否检测，0-不检测，1-检测
        ("bySignal", BYTE), # /<视频丢失 是否检测，0-不检测，1-检测
        ("byBlur", BYTE), # /< 图像模糊 是否检测，0-不检测，1-检测
        ("byLuma", BYTE), # /< 图像过亮是否检测，0-不检测，1-检测
        ("byChroma", BYTE), # /< 偏色检测 是否检测，0-不检测，1-检测
        ("bySnow", BYTE), # /<噪声干扰 是否检测，0-不检测，1-检测
        ("byStreak", BYTE), # /<条纹干扰 是否检测，0-不检测，1-检测
        ("byFreeze", BYTE), # /<画面冻结是否检测，0-不检测，1-检测
        ("byPTZ", BYTE), # /<云台是否检测，0-不检测，1-检测
        ("byEnablePlanRound", BYTE), # /计划循环是否开启
        ("byContrast", BYTE), # 对比度异常是否检测，0-不检测，1-检测
        ("byMono", BYTE), # 黑白图像是否检测，0-不检测，1-检测
        ("byShake", BYTE), # 视频抖动是否检测，0-不检测，1-检测
        ("byFlash", BYTE), # 视频剧变是否检测，0-不检测，1-检测
        ("byCover", BYTE), # 视频遮挡是否检测，0-不检测，1-检测
        ("byScene", BYTE), # 场景变更是否检测，0-不检测，1-检测
        ("byDark", BYTE), # 图像过暗是否检测，0-不检测，1-检测
        ("byRes", BYTE * 13),
    ]


LPNET_DVR_PLAN_VQD_CFG = POINTER(NET_DVR_PLAN_VQD_CFG)


class NET_DVR_TEST_SPOTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byStepCount", BYTE), # 总步数
        ("byStepIndex", BYTE), # 当前第几步
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_TEST_SPOTCFG = POINTER(NET_DVR_TEST_SPOTCFG)


# 第三方IPC列表
ENUM_BUSINESS_INVALID = -1

ENUM_BUSINESS_HIKVISION = 0
ENUM_BUSINESS_PANASONIC = 1
ENUM_BUSINESS_SONY = 2
ENUM_BUSINESS_AXIS = 3
ENUM_BUSINESS_SANYO = 4
ENUM_BUSINESS_BOSCH = 5
ENUM_BUSINESS_ZAVIO = 6
ENUM_BUSINESS_GRANDEYE = 7
ENUM_BUSINESS_PROVIDEO = 8
ENUM_BUSINESS_ARECONT = 9
ENUM_BUSINESS_ACTI = 10
ENUM_BUSINESS_PELCO = 11
ENUM_BUSINESS_VIVOTEK = 12
ENUM_BUSINESS_INFINOVA = 13
ENUM_BUSINESS_DAHUA = 14

ENUM_BUSINESS_HIK_STD_H264 = 0x20
ENUM_BUSINESS_HIK_STD_MPEG4 = 33
ENUM_BUSINESS_SUNELL  = 34
ENUM_BUSINESS_ATEME  = 35
ENUM_BUSINESS_LAUNCH = 36
ENUM_BUSINESS_YAAN = 37
ENUM_BUSINESS_BLUESKY = 38
ENUM_BUSINESS_BLUESKYLIMIT = 39
ENUM_BUSINESS_TDWY = 40
ENUM_BUSINESS_HBGK = 41
ENUM_BUSINESS_SANTACHI = 42
ENUM_BUSINESS_HIGHEASY = 43
ENUM_BUSINESS_SAMSUNG = 44

ENUM_BUSINESS_URL_RTSP = 0x40
ENUM_BUSINESS_ONVIF = 65

ENUM_MAX_BUSINESS_TYPE = 66


# 后端传显统一后第三方IPC列表
ENUM_IPC_PROTOCOL_INVALID = -1
ENUM_IPC_PROTOCOL_HIKVISION = 0
ENUM_IPC_PROTOCOL_PANASONIC  = 1
ENUM_IPC_PROTOCOL_SONY  = 2

ENUM_IPC_PROTOCOL_AXIS = 4
ENUM_IPC_PROTOCOL_SANYO  = 5
ENUM_IPC_PROTOCOL_BOSCH  = 6
ENUM_IPC_PROTOCOL_ZAVIO  = 7
ENUM_IPC_PROTOCOL_GRANDEYE  = 8
ENUM_IPC_PROTOCOL_PROVIDEO  = 9
ENUM_IPC_PROTOCOL_ARECONT  = 10
ENUM_IPC_PROTOCOL_ACTI  = 11
ENUM_IPC_PROTOCOL_PELCO  = 12
ENUM_IPC_PROTOCOL_VIVOTEK  = 13
ENUM_IPC_PROTOCOL_DAHUA  = 14
ENUM_IPC_PROTOCOL_SAMSUNG  = 15

ENUM_IPC_PROTOCOL_PSIA = 17
ENUM_IPC_PROTOCOL_ONVIF  = 18
ENUM_IPC_PROTOCOL_BRICKCOM  = 19
ENUM_IPC_PROTOCOL_GB28181  = 20

ENUM_IPC_PROTOCOL_CANON = 23

ENUM_IPC_PROTOCOL_HUINT = 32
ENUM_IPC_PROTOCOL_INFINOVA  = 33
ENUM_IPC_PROTOCOL_HIK_STD_H264 = 34
ENUM_IPC_PROTOCOL_HIK_STD_MPEG4  = 35
ENUM_IPC_PROTOCOL_SUNELL  = 36
ENUM_IPC_PROTOCOL_ATEME  = 37
ENUM_IPC_PROTOCOL_LAUNCH  = 38
ENUM_IPC_PROTOCOL_YAAN = 39
ENUM_IPC_PROTOCOL_BLUESKY  = 40
ENUM_IPC_PROTOCOL_BLUESKYLIMIT  = 41
ENUM_IPC_PROTOCOL_TDWY  = 42
ENUM_IPC_PROTOCOL_HBGK  = 43
ENUM_IPC_PROTOCOL_SANTACHI = 44
ENUM_IPC_PROTOCOL_HIGHEASY = 45
ENUM_IPC_PROTOCOL_HANBANG  = 46
ENUM_IPC_PROTOCOL_SAMSUNG_3120  = 47
ENUM_IPC_PROTOCOL_SAMSUNG_3080  = 48
ENUM_IPC_PROTOCOL_SAMSUNG_2000 = 49
ENUM_IPC_PROTOCOL_SAMSUNG_5200  = 50
ENUM_IPC_PROTOCOL_JINGYUAN  = 51
ENUM_IPC_PROTOCOL_VIDEOTREC  = 52
ENUM_IPC_PROTOCOL_CHENOVA  = 53
ENUM_IPC_PROTOCOL_FENGHUO  = 54
ENUM_IPC_PROTOCOL_ZB_5301  = 55
ENUM_IPC_PROTOCOL_ZB_5401  = 56
ENUM_IPC_PROTOCOL_HAIXIN = 57
ENUM_IPC_PROTOCOL_ZHONGYINGXIN  = 58
ENUM_IPC_PROTOCOL_AVUN  = 59
ENUM_IPC_PROTOCOL_GOVTY  = 60
ENUM_IPC_PROTOCOL_SAE  = 61
ENUM_IPC_PROTOCOL_DONGFANGWANGLI = 62
ENUM_IPC_PROTOCOL_CHANGHONG = 63
ENUM_IPC_PROTOCOL_H3C  = 64
ENUM_IPC_PROTOCOL_BAIAN  = 65
ENUM_IPC_PROTOCOL_HAT  = 66
ENUM_IPC_PROTOCOL_YUANYE = 67
ENUM_IPC_PROTOCOL_HIKCARD  = 68
ENUM_IPC_PROTOCOL_HAIXINCAP  = 69
ENUM_IPC_PROTOCOL_WENANCAP  = 70
ENUM_IPC_PROTOCOL_XUNMEI  = 71
ENUM_IPC_PROTOCOL_BAIWO  = 72
ENUM_IPC_PROTOCOL_APD  = 73
ENUM_IPC_PROTOCOL_REACHDEV  = 74
ENUM_IPC_PROTOCOL_XUNMEI_DAHUA  = 75
ENUM_IPC_PROTOCOL_HUANGHE = 76
ENUM_IPC_PROTOCOL_LIANCHEN  = 77
ENUM_IPC_PROTOCOL_CHENGYE = 78
ENUM_IPC_PROTOCOL_VISIONDIGI  = 79
ENUM_IPC_PROTOCOL_HENGHE  = 80
ENUM_IPC_PROTOCOL_KODAK  = 81
ENUM_IPC_PROTOCOL_AIRONIX = 82
ENUM_IPC_PROTOCOL_LG = 83
ENUM_IPC_PROTOCOL_HASEE  = 84
ENUM_IPC_PROTOCOL_8000ME  = 85
ENUM_IPC_PROTOCOL_POVITEL  = 86
ENUM_IPC_PROTOCOL_YIVIEW = 87
ENUM_IPC_PROTOCOL_TIANYUE  = 88
ENUM_IPC_PROTOCOL_HOWELL  = 89
ENUM_IPC_PROTOCOL_WAPA = 90
ENUM_IPC_PROTOCOL_SANLE  = 91
ENUM_IPC_PROTOCOL_HIKCARD_ENCRYPTION = 92
ENUM_IPC_PROTOCOL_JUNSDA  = 93
ENUM_IPC_PROTOCOL_LIYUAN  = 94
ENUM_IPC_PROTOCOL_XINCHAN  = 95
ENUM_IPC_PROTOCOL_BITE  = 96
ENUM_IPC_PROTOCOL_MEIAN = 97
ENUM_IPC_PROTOCOL_ROSEEK = 98
ENUM_IPC_PROTOCOL_AEBELL  = 99
ENUM_IPC_PROTOCOL_JSL_ST  = 100
ENUM_IPC_PROTOCOL_VIMICRO = 101
ENUM_IPC_PROTOCOL_UNIVIEW = 102

ENUM_IPC_PROTOCOL_TYPE = 103


class NET_DVR_MRD_SEARCH_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struStreamInfo", NET_DVR_STREAM_INFO), #  监控点
        ("wYear", WORD), #  年
        ("byMonth", BYTE), #  月
        ("byDrawFrame", BYTE), #  0-不抽帧 1-抽帧
        ("byStreamType", BYTE), # 0-主码流 1-子码流
        ("byLocalOrUTC", BYTE), # 0-设备本地时区  1-UTC
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_MRD_SEARCH_PARAM = POINTER(NET_DVR_MRD_SEARCH_PARAM)


class NET_DVR_MRD_SEARCH_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byRecordDistribution", BYTE * LEN_32), #  录像分布，byRecordDistribution[0]=1表示1日存在录像，byRecordDistribution[0]=0表示没有录像，
        # byRecordDistribution[1]表示2日，以此类推
        ("byHasEventRecode", BYTE * LEN_31), # 事件录像 0-无事件录像，1-有事件录像
        ("byRes", BYTE), # 保留
    ]


LPNET_DVR_MRD_SEARCH_RESULT = POINTER(NET_DVR_MRD_SEARCH_RESULT)


class NET_DVR_ACCESS_DEVICE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byGroup", BYTE), #  组号，每组可获取 64个通道，从0开始, 0表示第1组，以此类推
        ("byProType", BYTE), # 协议类型，0-私有协议，1-松下协议，2-索尼
        ("byAccessMode", BYTE), # 接入模式，0-IP地址，1-域名
        ("byRes1", BYTE), # 保留字段，置0
        ("szUserName", CHAR * NAME_LEN), # 用户名
        ("szPassword", CHAR * PASSWD_LEN), # 密码
        ("szDomain", CHAR * MAX_DOMAIN_NAME), # 设备域名
        ("struIP", NET_DVR_IPADDR), # IP地址
        ("wPort", WORD), #  端口号
        ("szGB28181DevID", BYTE * DEV_ID_LEN), # GB28181协议接入时的设备服务器ID
        ("byRes2", BYTE * 2), # 保留字段，置0
    ]


LPNET_DVR_ACCESS_DEVICE_INFO = POINTER(NET_DVR_ACCESS_DEVICE_INFO)


class NET_DVR_ACCESS_DEVICE_CHANNEL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("dwTotalChannelNum", DWORD), # 设备总通道个数，设备不在线时返回0，byChannel无效
        ("byChannel", BYTE * MAX_CHANNUM_V30), # byChannel[i]为0表示第（byGroup+1）*（i-1）通道未接入到NVR，
        # 为1表示该通道已接入到NVR byGroup在NET_DVR_ACCESS_DEVICE_INFO中
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_DVR_ACCESS_DEVICE_CHANNEL_INFO = POINTER(NET_DVR_ACCESS_DEVICE_CHANNEL_INFO)


class NET_DVR_PREVIEW_SWITCH_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 组号
        ("byGroup", BYTE), # 组号，每组可配置64个画面
        ("byVideoOutType", BYTE), # 视频输出接口类型,0-主CVBS,1-HDMI 2-VGA 3-辅助输出一
        # 4-辅助输出二 5-辅助输出三 6-辅助输出四, 7-辅助HDMI, 8-扩展HDMI1,
        # 9-扩展HDMI2, 10-扩展HDMI3, 11-扩展HDMI4, 12-非同源VGA1，
        # 13-非同源VGA2，14-非同源VGA3，15-非同源VGA4，16-同源VGA, 17-主LCD,18-辅助VGA,19-辅助LCD
        ("byGetDefaultPreviewSet", BYTE), # 是否获取预设，0-否，1-是；若为是时，byPreviewNumber字段有效
        ("byPreviewNumber", BYTE), # 预览数目,0-1画面,1-4画面,2-9画面,3-16画面, 4-6画面, 5-8画面6-25画面,7-32画面, 8-36画面 0xfb-自定义分屏4, 0xfc-自定义分屏3, 0xfd-自定义分屏2, 0xfe-自定义分屏1,0xff:最大画面
    ]


LPNET_DVR_PREVIEW_SWITCH_COND = POINTER(NET_DVR_PREVIEW_SWITCH_COND)


class NET_DVR_PREVIEW_SWITCH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  版本管理及结构体大小
        ("wSwitchSeq", WORD * MAX_WINDOW_V40), # bySwitchSeq [i]=6，表示第（组号*64+i+1）个窗口
        # 显示第六通道，为0xff表示该窗口不显示
        ("byPreviewNumber", BYTE), # 预览数目,0-1画面,1-4画面,2-9画面,3-16画面, 4-6画面, 5-8画面，6-25画面,7-32画面, 8-36画面, 9-64画面
        # 0xff:最大画面
        ("byEnableAudio", BYTE), # 是否声音预览,0-不预览,1-预览
        ("bySwitchTime", BYTE), # 切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s, 5-60s 6-120s,7-300s
        ("bySameSource", BYTE), # 是否同源，当视频输出口类型为非同源VGA1-非同源VGA4时有效
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_DVR_PREVIEW_SWITCH_CFG = POINTER(NET_DVR_PREVIEW_SWITCH_CFG)


class NET_DVR_USER_COND(Structure):
    _fields_ = [
        ("szUserName", CHAR * NAME_LEN),
        ("byRes", BYTE * 48),
    ]


LPNET_DVR_USER_COND = POINTER(NET_DVR_USER_COND)


class NET_DVR_USER_RIGHT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAddMonitoringPointRight", BYTE), #  添加监控点（前端设备）权限0-无 1-有
        ("byModMonitoringPointRight", BYTE), #  修改监控点（前端设备）权限0-无 1-有
        ("byDelMonitoringPointRight", BYTE), #  添加监控点（前端设备）权限0-无 1-有
        ("bySetRecordPlanRight", BYTE), #  制定录像策略权限0-无 1-有
        ("byDelRecordPlanRight", BYTE), #  删除录像策略权限0-无 1-有
        ("byEnableOrDisableRecordPlanRight", BYTE), #  启用和禁用录像计划权限0-无 1-有
        ("byManualRecordRight", BYTE), #  启动和停止手动录像权限0-无 1-有
        ("bySetAlarmRecordRight", BYTE), #  报警录像设定权限0-无 1-有
        ("byRecordBackupRight", BYTE), #  录像存档权限0-无 1-有
        ("byRecordDownloadRight", BYTE), #  录像下载权限0-无 1-有
        ("byRecordDeleteRight", BYTE), #  录像删除权限0-无 1-有（保留）
        ("byDelBackupRecordRight", BYTE), #  删除存档录像权限0-无 1-有（保留）
        ("bySetBackupVolumeRight", BYTE), #  设置存档卷权限0-无 1-有
        ("byRecordPlayBackRight", BYTE), #  录像回放权限0-无 1-有 DWORD dwZoneIndex
        ("byLogDeleteRight", BYTE), #  日志清空权限0-无 1-有（保留）
        ("byLogDownloadRight", BYTE), #  日志下载权限0-无 1-有（保留）
        ("byAddUserRight", BYTE), #  添加用户权限0-无 1-有
        ("byDelUserRight", BYTE), #  删除用户权限0-无 1-有
        ("byModUserRight", BYTE), #  修改用户权限0-无 1-有
        ("byAllocUserRight", BYTE), #  用户权限分配权限0-无 1-有
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_USER_RIGHT_CFG = POINTER(NET_DVR_USER_RIGHT_CFG)


class NET_DVR_MACHINE_MAX_NUM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMaxNum", DWORD), #  最大备机数目
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_MACHINE_MAX_NUM_CFG = POINTER(NET_DVR_MACHINE_MAX_NUM_CFG)


# 配置N+1设备工作机模式，NVR需要这步，CVR不需要
class NET_DVR_N_PLUS_ONE_WORK_MODE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWorkMode", BYTE), # 0-工作机 1-备机
        ("byRes", BYTE * 127), # 保留
    ]


LPNET_DVR_N_PLUS_ONE_WORK_MODE_CFG = POINTER(NET_DVR_N_PLUS_ONE_WORK_MODE_CFG)


class NET_DVR_ADD_PARAM(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), #  设备IP
        ("szPassword", CHAR * PASSWD_LEN), # 备机密码，需简易加密
        ("byAddType", BYTE), #  0-（工作机上）添加备机，1-（备机上）添加工作机
        ("byDisableBackup", BYTE), # 备份功能使能开关 0-开启1-关闭 CVR默认开启
    ]


LPNET_DVR_ADD_PARAM = POINTER(NET_DVR_ADD_PARAM)


class NET_DVR_DEL_PARAM(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), #  设备IP
        ("byDelType", BYTE), #  0-删除指定的机器（备机或工作机）1-全删
    ]


LPNET_DVR_DEL_PARAM = POINTER(NET_DVR_DEL_PARAM)


class NET_DVR_NPO_PARAM_UNION(Union):
    _fields_ = [
        ("struAddParam", NET_DVR_ADD_PARAM), # 添加信息
        ("struDelParam", NET_DVR_DEL_PARAM), # 删除信息
    ]


LPNET_DVR_NPO_PARAM_UNION = POINTER(NET_DVR_NPO_PARAM_UNION)


#  N+1模式设备参数
class NET_DVR_N_PLUS_ONE_DEVICE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("unionParam", NET_DVR_NPO_PARAM_UNION),
        ("byType", BYTE), #  0-添加，对应unionParam中的struAddParam 1-删除，对应unionParam中的struDelParam  2-添加且用户名生效，对应unionParam中的struAddParam 和szUserName
        ("byRes", BYTE * 3),
        ("szUserName", CHAR * NAME_LEN), # 用户名
        ("byRes2", BYTE * 220), #  保留
    ]


LPNET_DVR_N_PLUS_ONE_DEVICE_PARAM = POINTER(NET_DVR_N_PLUS_ONE_DEVICE_PARAM)


#  数据回迁
class NET_DVR_DATA_CALLBACK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), #  0-不启用数据回迁 1-启用数据回迁
        ("byDelData", BYTE), #  当byEnable为1是有效 0-不删除备机录像数据 1-删除备机录像数据
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_DATA_CALLBACK_CFG = POINTER(NET_DVR_DATA_CALLBACK_CFG)


class NET_DVR_HD_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySleepStatus", BYTE), # 休眠状态0-不休眠 1-休眠
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_HD_STATUS = POINTER(NET_DVR_HD_STATUS)


class NET_DVR_RAID_BTS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySpeed", BYTE), # 0-高速 1-中速 2-低速
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_RAID_BTS_CFG = POINTER(NET_DVR_RAID_BTS_CFG)


class NET_DVR_LUN_CLONE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSrcLunID", DWORD), #  源LUN ID
        ("dwDstLunID", DWORD), #  目的LUN ID
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LUN_CLONE = POINTER(NET_DVR_LUN_CLONE)


class NET_DVR_LUN_EXPAND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwLunID", DWORD), #  LUN ID
        ("dwHSize", DWORD), #  扩展的大小高32位
        ("dwLSize", DWORD), #  扩展的大小低32位
        ("szArrayIDGroup", CHAR * NAME_LEN), #  使用的阵列ID组，以逗号隔开，为空则为默认
        ("szNewLunName", CHAR * MAX_NAMELEN), #  新LUN名
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LUN_EXPAND = POINTER(NET_DVR_LUN_EXPAND)


class NET_DVR_DVR_NET_DISK_MODIFY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szOldDvrNetDiskName", CHAR * MAX_NAMELEN), #  原DVR网盘共享名
        ("szNewDvrNetDiskName", CHAR * MAX_NAMELEN), #  新DVR网盘共享名
        ("struWarrantIP", NET_DVR_IPADDR), #  新授权的DVR网盘IP
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DVR_NET_DISK_MODIFY = POINTER(NET_DVR_DVR_NET_DISK_MODIFY)


class NET_DVR_NAS_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwLunID", DWORD), #  LUN ID
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_NAS_PARAM = POINTER(NET_DVR_NAS_PARAM)


class NET_DVR_ISCSI_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTargetID", DWORD), #  iSCSI服务的Target ID
        ("dwLunID", DWORD), #  LUN ID
        ("dwAccessMode", DWORD), # 读写方式 0-读写 1-同步读写 2-只读 3-智能只读
        ("struClientIP", NET_DVR_IPADDR), #  客户端IP，0.0.0.0为所以IP
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_ISCSI_PARAM = POINTER(NET_DVR_ISCSI_PARAM)


class NET_DVR_FC_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwStoreLunID", DWORD), #  存储LUN ID
        ("dwLogicLunID", DWORD), #  逻辑LUN ID，-1表示自动生成
        ("dwHbaID", DWORD), #  光纤通道号
        ("dwAccessMode", DWORD), # 读写方式 0-读写 1-同步读写 2-只读 3-智能只读
        ("szClientWWWPN", CHAR * NAME_LEN), #  客户光纤卡
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_FC_PARAM = POINTER(NET_DVR_FC_PARAM)


#  逻辑卷 60字节
class NET_DVR_LUN_PARAM(Structure):
    _fields_ = [
        ("dwHCapacity", DWORD), #  逻辑卷大小高32位
        ("dwLCapacity", DWORD), #  逻辑卷大小低32位
        ("szName", CHAR * MAX_NAMELEN), #  逻辑卷名称
        ("dwBlockSize", DWORD), #  逻辑卷的最小存储单元块大小
        ("szArrayIDGroup", CHAR * NAME_LEN), # 使用的阵列ID组，以逗号隔开，为空则使用默认阵列
    ]


LPNET_DVR_LUN_PARAM = POINTER(NET_DVR_LUN_PARAM)


class NET_DVR_DVR_PARAM(Structure):
    _fields_ = [
        ("dwHCapacity", DWORD), #  DVR网盘大小高32位
        ("dwLCapacity", DWORD), #  DVR网盘大小低32位
        ("szName", CHAR * MAX_NAMELEN), #  DVR网盘名称
        ("dwBlockSize", DWORD), #  逻辑卷的最小存储单元块大小
        ("struWarrantIP", NET_DVR_IPADDR), #  授权的DVR网盘IP
        ("szArrayIDGroup", CHAR * NAME_LEN), # 使用的阵列ID组，以逗号隔开，为空则使用默认阵列
    ]


LPNET_DVR_DVR_PARAM = POINTER(NET_DVR_DVR_PARAM)


class NET_DVR_VD_UNION(Union):
    _fields_ = [
        ("byUnionLen", BYTE * 256), #  联合体大小
        ("struHikVDParam", NET_DVR_OPERATE_VD_PARAM), #  虚拟磁盘
        ("struLunParam", NET_DVR_LUN_PARAM), #  逻辑卷
        ("struDvrParam", NET_DVR_DVR_PARAM), #  DVR网盘
    ]


LPNET_DVR_VD_UNION = POINTER(NET_DVR_VD_UNION)


class NET_DVR_OPERATE_VD_PARAM_EX(Structure):
    _fields_ = [
        ("byVDType", BYTE), # 虚拟磁盘类型：0-私有虚拟磁盘 1-逻辑卷 2-DVR网盘
        ("byRes1", BYTE * 3),
        ("uVDParam", NET_DVR_VD_UNION),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_OPERATE_VD_PARAM_EX = POINTER(NET_DVR_OPERATE_VD_PARAM_EX)


class NET_DVR_CVR_ALARM(Structure):
    _fields_ = [
        ("szFirstType", CHAR * NAME_LEN), # 主类型，不能为空
        ("szFirstIndex", CHAR * NAME_LEN), # 主类型编号
        ("szSecondType", CHAR * NAME_LEN), # 次类型，可以为空
        ("struTime", NET_DVR_TIME), # 报警时间
        ("byStatus", BYTE), # 状态 0-正常 非0-不正常，不同类型值表示意义不同，见下表
        ("byAlarmLevel", BYTE), # 报警级别
        ("byRes1", BYTE * 2),
        ("szSecondIndex", CHAR * NAME_LEN), # 次类型编号，可以为空
        ("szThirdType", CHAR * NAME_LEN), # 第三类型，可以为空
        ("szThirdIndex", CHAR * NAME_LEN), # 第三类型编号
        ("szFourthType", CHAR * NAME_LEN), # 第四类型，可以为空
        ("szFourthIndex", CHAR * NAME_LEN), # 第四类型编号
        ("byRes2", BYTE * 92), # 保留
    ]


LPNET_DVR_CVR_ALARM = POINTER(NET_DVR_CVR_ALARM)


class NET_DVR_WORKING_DEVICE_INFO(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), # 设备IP
        ("byLinkStatus", BYTE), # 连接状态 0-连接失败1-连接成功
        ("byWorkStatus", BYTE), # 工作状态 0-正常1-异常
        ("byBacupStatus", BYTE), # 备份状态0-不在备份1-正在备份
        ("bySyncProgress", BYTE), # 录像同步进度，0表示未开始，100表示同步完成
        ("struSyncBeginTime", NET_DVR_TIME_EX), # 同步开始时间
        ("struSyncEndTime", NET_DVR_TIME_EX), # 同步结束时
        ("szSerialNumber", CHAR * SERIALNO_LEN), # 设备序列号
        ("dwSoftwareVersion", DWORD), # 设备软件版本
        ("byWorkingDeviceGUID", BYTE * GUID_LEN), # 工作机GUID，非字符串，用于备机上搜索工作机录像
        ("szDevTypeName", CHAR * DEV_TYPE_NAME_LEN), # 设备类型名称
        ("wDevType", WORD), # 设备类型值
    ]


LPNET_DVR_WORKING_DEVICE_INFO = POINTER(NET_DVR_WORKING_DEVICE_INFO)


class NET_DVR_REDUNDANT_DEVICE_INFO(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), # 设备IP
        ("byWorkStatus", BYTE), # 工作状态 0-正常1-异常
        ("byBackupStatus", BYTE), # 备份状态0-不在监控 1-正在监控2-正在备份中2-正在同步
        ("wBackupPort", WORD), # 备份端口
    ]


LPNET_DVR_REDUNDANT_DEVICE_INFO = POINTER(NET_DVR_REDUNDANT_DEVICE_INFO)


class NET_DVR_WORKING_DEVICE_INFO_V50(Structure):
    _fields_ = [
        ("struWorkingDeviceInfo", NET_DVR_WORKING_DEVICE_INFO), # 工作机信息
        ("szUserName", CHAR * NAME_LEN), # 用户名
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_WORKING_DEVICE_INFO_V50 = POINTER(NET_DVR_WORKING_DEVICE_INFO_V50)


class NET_DVR_REDUNDANT_DEVICE_INFO_V50(Structure):
    _fields_ = [
        ("struRedundantDeviceInfo", NET_DVR_REDUNDANT_DEVICE_INFO), # 备机信息
        ("szUserName", CHAR * NAME_LEN), # 用户名
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_REDUNDANT_DEVICE_INFO_V50 = POINTER(NET_DVR_REDUNDANT_DEVICE_INFO_V50)


class NET_DVR_NPO_DEV_INFO_UNION(Union):
    _fields_ = [
        ("byUnionLen", BYTE * 512), # 联合体长度
        ("struWorkingDeviceInfo", NET_DVR_WORKING_DEVICE_INFO), # 工作机信息
        ("struRedundantDeviceInfo", NET_DVR_REDUNDANT_DEVICE_INFO), # 备机信息
        ("struWorkingDeviceInfoV50", NET_DVR_WORKING_DEVICE_INFO_V50), # 工作机信息V50
        ("struRedundantDeviceInfoV50", NET_DVR_REDUNDANT_DEVICE_INFO_V50), # 备机信息V50
    ]


LPNET_DVR_NPO_DEV_INFO_UNION = POINTER(NET_DVR_NPO_DEV_INFO_UNION)


class NET_DVR_N_PLUS_ONE_DEVICE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("unionDevInfo", NET_DVR_NPO_DEV_INFO_UNION),
        ("byType", BYTE), # 类型 0-工作机，对应unionDevInfo中的struWorkingDeviceInfo     1-备机，对应unionDevInfo中的struRedundantDeviceInfo
        # 2-工作机V50，对应unionDevInfo中的struWorkingDeviceInfoV50     3-备机V50，对应unionDevInfo中的struRedundantDeviceInfoV50
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_N_PLUS_ONE_DEVICE_INFO = POINTER(NET_DVR_N_PLUS_ONE_DEVICE_INFO)


# ipc升级参数
class NET_DVR_UPGRADE_IPC_PARAM(Structure):
    _fields_ = [
        ("struStreamInfo", NET_DVR_STREAM_INFO * MAX_CHANNUM_V30), #  64个监控点
        ("szFileName", CHAR * 260), #  升级文件名
    ]


LPNET_DVR_UPGRADE_IPC_PARAM = POINTER(NET_DVR_UPGRADE_IPC_PARAM)


class NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE(Structure):
    _fields_ = [
        ("struStreamInfo", NET_DVR_STREAM_INFO), # 监控点
        ("wErrCode", WORD), # 对应错误码
        ("byRes", BYTE * 30), # 保留
    ]


LPNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE = POINTER(NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE)


class NET_DVR_UPGRADE_IPC_ERR_INFO(Structure):
    _fields_ = [
        ("struErrInfoSingle", NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE * MAX_CHANNUM_V30),
    ]


LPNET_DVR_UPGRADE_IPC_ERR_INFO = POINTER(NET_DVR_UPGRADE_IPC_ERR_INFO)


# IPC配置文件导入
class NET_DVR_IPC_CFG_FILE_PARAM(Structure):
    _fields_ = [
        ("szFileName", CHAR * 260), #  配置文件名
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_IPC_CFG_FILE_PARAM = POINTER(NET_DVR_IPC_CFG_FILE_PARAM)


class NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE(Structure):
    _fields_ = [
        ("wRow", WORD), # 出错的行，0表示没出错，1表示第1行出错，以此类推
        ("wErrCode", WORD), # 错误码
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE = POINTER(NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE)


class NET_DVR_IPC_CFG_FILE_ERR_INFO(Structure):
    _fields_ = [
        ("struErrInfoSingle", NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE * MAX_CHANNUM_V30),
    ]


LPNET_DVR_IPC_CFG_FILE_ERR_INFO = POINTER(NET_DVR_IPC_CFG_FILE_ERR_INFO)


class NET_DVR_TRANSFER_SWITCH(Structure):
    _fields_ = [
        ("dwEnable", DWORD),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_TRANSFER_SWITCH = POINTER(NET_DVR_TRANSFER_SWITCH)


class NET_DVR_PTZ_PATTERN(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("dwPatternCmd", DWORD), # 云台轨迹操作命令码,详见下面定义
        ("dwPatternID", DWORD), # 云台轨迹ID（删除所有轨迹时无效）
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PTZ_PATTERN = POINTER(NET_DVR_PTZ_PATTERN)


class NET_DVR_PTZ_PARKACTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用，0-不启用，1-启用
        ("byOneTouchSwitch", BYTE), # 一键开关, 0-不启用，1-启用 (和wActionType组合使用)
        ("byRes1", BYTE * 2),
        ("dwParkTime", DWORD), # 守望等待时间，单位s
        ("wActionType", WORD), # 守望动作类型，0-自动扫描，1-帧扫描，2-随机扫描，3-巡航扫描，4-花样扫描，5-预置点，6-全景扫描，7-垂直扫描, 8-区域扫描
        ("wID", WORD), # ID号（巡航扫描、预置点、花样扫描的ID）
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PTZ_PARKACTION_CFG = POINTER(NET_DVR_PTZ_PARKACTION_CFG)


class NET_DVR_PTZ_MANUALTRACE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("struPoint", NET_VCA_POINT), # 定位坐标
        ("byTrackType", BYTE), # 跟踪类型0、非自动取证(普通取证) 1、高速道路跟踪 2、城市道路跟踪（手动跟踪取证）3、静态取证
        ("byLinkageType", BYTE), # 联动动作: 0-手动跟踪 1-联动不跟踪
        ("byRes", BYTE * 2),
        ("struPointEnd", NET_VCA_POINT), # 定位坐标终点
        ("struTime", NET_DVR_TIME_V30), # 手动跟踪定位，当前时间。
        ("dwSerialNo", DWORD), # 序号；
        ("byRes1", BYTE * 36),
    ]


LPNET_DVR_PTZ_MANUALTRACE = POINTER(NET_DVR_PTZ_MANUALTRACE)


VQD_BLUR_FLAG = 0x00000001
VQD_LUMA_FLAG = 0x00000002
VQD_CHROMA_FLAG = 0x00000004
VQD_SNOW_FLAG = 0x00000008
VQD_STREAK_FLAG = 0x00000010
VQD_FREEZE_FLAG = 0x00000020
VQD_SIGLOSE_FLAG = 0x00000040
VQD_PTZ_FLAG = 0x00000080


class NET_DVR_VQD_LOOP_DIAGNOSE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), #  诊断使能 0 :关闭，开启 1:开启
        ("byRes1", BYTE * 3), # 保留
        ("byVQDTypeEnable", BYTE * 32), # VQD诊断模式，0 --不启用 1--启用  每种诊断类型对应有灵敏度，灵敏度的下标与诊断类型的下标一致
        # 数组0 图像模糊     数组1 亮度异常 数组2 图像偏色
        # 数组3 雪花干扰     数组4 条纹干扰 数组5 画面冻结
        # 数组6 信号丢失     数组7 云台失控
        ("byThresholdValue", BYTE * 32), # 阈值0~100，不同诊断模式有各自对应的阈值
        ("struAlarmHandleType", NET_DVR_HANDLEEXCEPTION_V40), # 报警处理方式
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS),
        ("struHolidayAlarmTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 假日布防时间段
        ("byRes", BYTE * 324), # 保留
    ]


LPNET_DVR_VQD_LOOP_DIAGNOSE_CFG = POINTER(NET_DVR_VQD_LOOP_DIAGNOSE_CFG)


class NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO(Structure):
    _fields_ = [
        ("dwChannelNO", DWORD), # 通道号
        ("dwVQDType", DWORD), #  VQD诊断类型
        ("struDiagnoseTime", NET_DVR_TIME), # 诊断时间
        ("byScoreValue", BYTE), # 分数值 ，百分制
        ("byRes", BYTE * 27),
    ]


LPNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO = POINTER(NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO)


class NET_DVR_VQD_DIAGNOSE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struVQDDiagnoseExceptionInfo", NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO), # 诊断异常信息结构体
    ]


LPNET_DVR_VQD_DIAGNOSE_INFO = POINTER(NET_DVR_VQD_DIAGNOSE_INFO)


class NET_DVR_DEC_RESOURCE_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDecStatus", BYTE * MAX_SUBSYSTEM_NUM_V40),
        # 解码资源状态列表，byDecStatus[i]表示槽位号i的子系统状态，0-无效，1-空闲，2-普通解码(包括普通解码上墙和大屏主从屏)，3-智能解码
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DEC_RESOURCE_LIST = POINTER(NET_DVR_DEC_RESOURCE_LIST)


class NET_DVR_DEC_APPLICANT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDecResource", DWORD), # 申请的解码资源，以分辨率衡量，0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,
        # 6-QVGA(320*240), 7-QQVGA(160*120), 16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,
        # 19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536,
        # 31-2448*2048,32-2448*1200,33-2448*800,34-XGA（1024*768），35-SXGA（1280*1024）,36-WD1(960*576/960*480),
        # 37-1080i,38-WXGA(1440*900),39-HD_F(1920*1080/1280*720),40-HD_H(1920*540/1280*360),41-HD_Q(960*540/630*360)
        ("dwChannel", DWORD), # 智能通道号
        ("struIP", NET_DVR_IPADDR), # 申请者IP
        ("wPort", WORD), # 申请者端口号(智能分析仪通讯端口)
        ("byRes", BYTE * 18),
    ]


LPNET_DVR_DEC_APPLICANT_INFO = POINTER(NET_DVR_DEC_APPLICANT_INFO)


class NET_DVR_DEC_RESOURCE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSlotNum", DWORD), # 槽位号，此参数做释放解码资源和登陆解码子系统校验用
        ("struIP", NET_DVR_IPADDR), # 解码子系统IP地址
        ("wPort", WORD), # 端口号
        ("byRes1", BYTE * 2),
        ("dwDecChan", DWORD), # 解码通道号
        ("sUserName", BYTE * NAME_LEN), #  解码子系统登陆帐号
        ("sPassword", BYTE * PASSWD_LEN), #  解码子系统登陆密码
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_DEC_RESOURCE_INFO = POINTER(NET_DVR_DEC_RESOURCE_INFO)


class NET_DVR_DEC_CHAN_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSlotNum", DWORD), # 槽位号,填申请解码资源时返回的槽位号
        ("dwDecChan", DWORD), # 解码通道号
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_DEC_CHAN_COND = POINTER(NET_DVR_DEC_CHAN_COND)


class NET_DVR_DEC_YUV_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 关联使能，0-无关联，1-关联
        ("byRes1", BYTE * 3),
        # byEnable = 1时以下参数有效
        ("dwYUVAddress", DWORD * 3), # YUV输出地址
        ("wWidth", WORD), # YUV输出宽
        ("wHeight", WORD), # YUV输出高
        ("byEnableAudio", BYTE), # 使能音频，0-不启用，1-启用
        ("byRes2", BYTE * 3),
        ("dwAudioAddr", DWORD), # 音频输出地址
        ("byRes3", BYTE * 16),
    ]


LPNET_DVR_DEC_YUV_CFG = POINTER(NET_DVR_DEC_YUV_CFG)


class NET_DVR_INPUT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byChanType", BYTE), # 接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
        ("byRes1", BYTE * 3),
        ("dwChanNo", DWORD), # 通道号，设备通道号，支持byChanType所有类型
        ("dwSubChanNo", DWORD), # 槽位号，485槽位号，在byChanType为3-485通道时有效，表示通道号下的子通道号
        ("dwVariableNo", DWORD), # 变量编号，当byChanType为2-本地开关量通道时(1-输入，2-输出)
        ("byRemoteType", BYTE), # 获取变量类型，0-全部类型，1-遥信，2-遥测
        ("byLinkageIPCType", BYTE), # 联动IPC配置类型：0-默认，1-按变量号配置，2-按通道号配置
        ("byLinkageTriggerType", BYTE), # 联动触发器配置类型：0-默认，1-按变量号配置，2-按通道号配置
        ("byRes2", BYTE * 57),
    ]


LPNET_DVR_INPUT_INFO = POINTER(NET_DVR_INPUT_INFO)


class NET_DVR_ALARM_VARIABLE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wVariableIndex", WORD), # 变量编号，只能获取
        ("wVariableType", WORD), # 变量类型 1-模拟量 2-开关量，只能获取
        ("sDescribe", BYTE * NAME_LEN), # 变量描述
        ("byLimitLineType", BYTE), # 报警限值配置类型，0-不支持报警限值配置，1-两限值配置（即上限、下限），2-四限值配置
        ("byRemoteType", BYTE), # 变量远动系统类型：0-全部类型，1-遥信，2遥测
        ("byOsdEnabled", BYTE), # 变量是否支持OSD叠加:0-默认，1-支持，2-不支持
        ("byRes", BYTE * 29), # 保留
    ]


LPNET_DVR_ALARM_VARIABLE_CFG = POINTER(NET_DVR_ALARM_VARIABLE_CFG)


# 模拟量点号相关参数
class NET_DVR_ALARM_SENSOR_POINT_CFG(Structure):
    _fields_ = [
        ("nMeasureHigh", int), #  量程上限 外部值*1000传入 可以为负数
        ("nMeasureLow", int), #  量程下限 外部值*1000传入
        ("byAlarmMode", BYTE), #  报警模式，五种，-HHHH、-HHHL、-HHLL、HLLL、-LLLL，
        # 即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
        ("byRes1", BYTE * 3),
        ("nAlarmValue", int * 4), #  报警限
        ("dwOsdCfg", DWORD), #  模拟量字符叠加，按位表示0-15对应视频通道1-16
        ("dwSensitive", DWORD), #  灵敏度范围10~1000。外部 float*1000。 灵敏度表示当实时值的变化超过灵敏度的范围时，则表示实时值发生了变化，否则认为没有发生变化。如：灵敏度为0.1，则表示前后检测的两个值之差大于0.1时，则认为数据发生变化，需要上传。如果为1，则表示变化超过1时上报。
        ("dwIPChanOsd", DWORD), #  数字通道叠加模拟量字符，按位表示，0~31对应数字通道1-32
        ("szOSDUnit", CHAR * MAX_OSD_UNIT_LEN), # OSD叠加单位
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_ALARM_SENSOR_POINT_CFG = POINTER(NET_DVR_ALARM_SENSOR_POINT_CFG)


# 开关量点号相关参数或485遥信信号
class NET_DVR_ALARM_SWITCH_POINT_CFG(Structure):
    _fields_ = [
        ("dwIPCChanOsd", DWORD), # 支持osd开关量叠加的IPC通道信息，按位表示，0~31对应数字通道1-32
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_ALARM_SWITCH_POINT_CFG = POINTER(NET_DVR_ALARM_SWITCH_POINT_CFG)


# 模拟量点号相关参数或485遥测信号
class NET_DVR_ALARM_POINT_PARAM_UNION(Union):
    _fields_ = [
        ("byLength", BYTE * 64), # 联合体长度为64
        ("struSensor", NET_DVR_ALARM_SENSOR_POINT_CFG), # 模拟量（或485遥测信号）相关参数
        ("struSwitch", NET_DVR_ALARM_SWITCH_POINT_CFG), # 开关量（或485遥信信号）相关参数
    ]


LPNET_DVR_ALARM_POINT_PARAM_UNION = POINTER(NET_DVR_ALARM_POINT_PARAM_UNION)


# 点号信息
class NET_DVR_ALARM_POINT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPointNo", DWORD), # 点号
        ("sPointDescribe", BYTE * NAME_LEN), # 点号描述
        ("struPointParam", NET_DVR_ALARM_POINT_PARAM_UNION), # 当变量类型为模拟量或485遥信信号时，使用结构体struSensor，当变量类型为开关量或485遥信信号时，使用结构体struSwitch
        ("byPointType", BYTE), # 点号类型，1-模拟量，2-开关量
        ("byChanType", BYTE), # 接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
        ("byRes1", BYTE * 2),
        ("dwChanNo", DWORD), # 通道号
        ("dwSubChanNo", DWORD), # 槽位号
        ("dwVariableNo", DWORD), # 变量编号，当byChanType为开关量时(1-输入信号，2-输出信号)
        ("byRes", BYTE * 16), # 保留
    ]


LPNET_DVR_ALARM_POINT_CFG = POINTER(NET_DVR_ALARM_POINT_CFG)


# 历史数据查询
class NET_DVR_ALARMHOST_ALARM_MODE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDataUploadMode", BYTE), # 1-按通道上传，2-按监测点上传
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_ALARMHOST_ALARM_MODE_CFG = POINTER(NET_DVR_ALARMHOST_ALARM_MODE_CFG)


class NET_DVR_ALARMHOST_POINT_VALUE(Structure):
    _fields_ = [
        ("byChanType", BYTE), # 接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
        ("byPointType", BYTE), # 点类型，1-遥测（模拟量），2-遥信（开关量）
        ("byRes1", BYTE * 2), # 保留
        ("dwChanNo", DWORD), # 485通道号，0xffffffff表示无效，通道类型为1时：表示本地模拟量通道号，通道类型为2时表示本地开关量通道号，通道类型为3时表示485通道号。
        ("dwSubChanNo", DWORD), # 槽位号， 0xffffffff表示无效，通道类型为3时使用
        ("dwVariableNo", DWORD), # 变量编号，0xffffffff表示无效
        ("dwPointNo", DWORD), # 104点号，0xffffffff表示无效
        ("iValue", int), # 监测点的值
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_ALARMHOST_POINT_VALUE = POINTER(NET_DVR_ALARMHOST_POINT_VALUE)


class NET_DVR_ALARMHOST_DATA_UNION(Union):
    _fields_ = [
        ("byLength", BYTE * 40),
        ("struPointValue", NET_DVR_ALARMHOST_POINT_VALUE), # 监测点实时数据
    ]


LPNET_DVR_ALARMHOST_DATA_UNION = POINTER(NET_DVR_ALARMHOST_DATA_UNION)


class NET_DVR_ALARMHOST_DATA_UPLOAD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDataType", BYTE), # 数据类型，1-监测点实时数据上传
        ("byRes1", BYTE * 3),
        ("struAlarmData", NET_DVR_ALARMHOST_DATA_UNION),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_ALARMHOST_DATA_UPLOAD = POINTER(NET_DVR_ALARMHOST_DATA_UPLOAD)


class NET_DVR_INPUTVOLUME(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byAudioInputChan", BYTE), # 音频输入通道号
        ("byRes", BYTE * 63), #  保留字节
    ]


LPNET_DVR_INPUTVOLUME = POINTER(NET_DVR_INPUTVOLUME)


class NET_DVR_AUDIOOUT_VOLUME(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAudioOutVolume", BYTE), #  输出音量等级：归一化为0-100；
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_AUDIOOUT_VOLUME = POINTER(NET_DVR_AUDIOOUT_VOLUME)


class NET_DVR_FUZZY_UPGRADE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sUpgradeInfo", CHAR * MAX_UPGRADE_INFO_LEN),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FUZZY_UPGRADE = POINTER(NET_DVR_FUZZY_UPGRADE)


class NET_DVR_RS485_WORK_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWorkMode", BYTE), # 工作模式，0-控制台，1-私有透明通道，2-透明通道
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_RS485_WORK_MODE = POINTER(NET_DVR_RS485_WORK_MODE)


class NET_DVR_TRANSPARENT_CLIENT_SINGLE(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能透明通道，0-不使能，1-使能
        ("byRes1", BYTE * 3),
        ("struIP", NET_DVR_IPADDR), # 远程设备IP地址
        ("wPort", WORD), # 远程设备端口
        ("byRes2", BYTE * 18),
    ]


LPNET_DVR_TRANSPARENT_CLIENT_SINGLE = POINTER(NET_DVR_TRANSPARENT_CLIENT_SINGLE)


class NET_DVR_TRANSPARENT_SERVER_SINGLE(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能透明通道，0-不使能，1-使能
        ("byRes1", BYTE * 3),
        ("struIP", NET_DVR_IPADDR), # 允许接入的远程设备IP
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_TRANSPARENT_SERVER_SINGLE = POINTER(NET_DVR_TRANSPARENT_SERVER_SINGLE)


class NET_DVR_TRANSPARENT_CLIENT_MODE(Structure):
    _fields_ = [
        ("struClientSingle", NET_DVR_TRANSPARENT_CLIENT_SINGLE * MAX_TRANSPARENT_CHAN_NUM),
        ("byRes", BYTE * 320),
    ]


LPNET_DVR_TRANSPARENT_CLIENT_MODE = POINTER(NET_DVR_TRANSPARENT_CLIENT_MODE)


class NET_DVR_TRANSPARENT_SERVER_MODE(Structure):
    _fields_ = [
        ("wPort", WORD), # 本地监听的端口号，和RS485口一一对应
        ("byRes1", BYTE * 2),
        ("struServerSingle", NET_DVR_TRANSPARENT_SERVER_SINGLE * MAX_TRANSPARENT_ACCESS_NUM),
        ("byRes2", BYTE * 332),
    ]


LPNET_DVR_TRANSPARENT_SERVER_MODE = POINTER(NET_DVR_TRANSPARENT_SERVER_MODE)


class NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION(Union):
    _fields_ = [
        ("byRes", BYTE * 512),
        ("struClientMode", NET_DVR_TRANSPARENT_CLIENT_MODE), # 客户端模式参数
        ("struServerMode", NET_DVR_TRANSPARENT_SERVER_MODE), # 服务器模式参数
    ]


LPNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION = POINTER(NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION)


class NET_DVR_TRANSPARENT_CHAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWorkMode", BYTE), # 工作模式，1-客户端模式，2-服务器模式
        ("byRes", BYTE * 3),
        ("struTransparentPara", NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION),
    ]


LPNET_DVR_TRANSPARENT_CHAN_CFG = POINTER(NET_DVR_TRANSPARENT_CHAN_CFG)


class NET_DVR_NAKED_DATA_INFO(Structure):
    _fields_ = [
        ("sSocketIP", CHAR * 128),
        ("wSocktPort", WORD),
        ("byRes", BYTE * 258),
    ]


LPNET_DVR_NAKED_DATA_INFO = POINTER(NET_DVR_NAKED_DATA_INFO)


NAKED_DATA_TYPE_NOT_DEFINED = 0
NAKED_DATA_TYPE_POS_INFO = 1


class NET_DVR_NAKED_DATA_PARAM(Structure):
    _fields_ = [
        ("wPort", WORD), # IP端口号，对于Pos信息接收，该值为0，则使用默认端口7050
        ("byRes", BYTE * 130), # 保留字节
    ]


LPNET_DVR_NAKED_DATA_PARAM = POINTER(NET_DVR_NAKED_DATA_PARAM)


UPLOAD_POS_INFO = 1001 # 上传Pos信息
class NET_DVR_POS_INFO(Structure):
    _fields_ = [
        ("struVerHead", NET_DVR_STRUCTHEAD), # 版本头
        ("dwChannelNum", DWORD), # 通道号
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_POS_INFO = POINTER(NET_DVR_POS_INFO)


MAX_IGNORE_STRING_NUM = 4
FILTERRULE_NUM = 4
MAX_POS_FILTER_DATA_LEN = 128
class NET_DVR_POS_OSD_REGION(Structure):
    _fields_ = [
        ("struStart", NET_VCA_POINT), # 起点坐标
        ("struEnd", NET_VCA_POINT), # 终点坐标
    ]


LPNET_DVR_POS_OSD_REGION = POINTER(NET_DVR_POS_OSD_REGION)


class NET_DVR_POS_ACTION(Structure):
    _fields_ = [
        ("dwDelayTime", DWORD), # delay time(5-3600s)
        ("byPrevOsd", BYTE), # overlay osd on preview
        ("byRes1", BYTE * 3), # preserve
        ("struOsdPosInfo", NET_DVR_POS_OSD_REGION), # overlay osd rect info
        ("byRes", BYTE * 64), # preserve
    ]


LPNET_DVR_POS_ACTION = POINTER(NET_DVR_POS_ACTION)


class NET_DVR_GENERIC_START(Structure):
    _fields_ = [
        ("sData", BYTE * MAX_POS_FILTER_DATA_LEN), # 交易开始标志，目前最大为32，只有anyCharacter为否时才生效
        ("byExclusive", BYTE), # 是否包含标志本身 0-包含 1-不包含
        ("byFlagType", BYTE), # 标志类型：0-字符串；1-十六进制
        ("byRes", BYTE * 2), # 保留
    ]


LPNET_DVR_GENERIC_START = POINTER(NET_DVR_GENERIC_START)


class NET_DVR_GENERIC_END(Structure):
    _fields_ = [
        ("sData", BYTE * MAX_POS_FILTER_DATA_LEN), # 交易结束标志，目前最大为32
        ("byExclusive", BYTE), # 是否包含标志本身 0-包含 1-不包含
        ("byFlagType", BYTE), # 标志类型：0-字符串；1-十六进制
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_GENERIC_END = POINTER(NET_DVR_GENERIC_END)


class NET_DVR_GENERIC_DATA_CFG(Structure):
    _fields_ = [
        ("sData", BYTE * MAX_POS_FILTER_DATA_LEN), # 数据标志，目前最大为32
        ("byFlagType", BYTE), # 标志类型：0-字符串；1-十六进制
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_GENERIC_DATA_CFG = POINTER(NET_DVR_GENERIC_DATA_CFG)


class NET_DVR_IGNORE_STRING(Structure):
    _fields_ = [
        ("sData", BYTE * MAX_POS_FILTER_DATA_LEN), # 忽略的字符，目前最大为32
    ]


LPNET_DVR_IGNORE_STRING = POINTER(NET_DVR_IGNORE_STRING)


class NET_DVR_POS_GENERIC(Structure):
    _fields_ = [
        ("byCaseSensitive", BYTE), # 是否区分大小写，0->不区分，1->区分
        ("byRes1", BYTE * 7),
        ("struTransactionStart", NET_DVR_GENERIC_START), # 交易开始
        ("struTransactionEnd", NET_DVR_GENERIC_END), # 交易结束
        ("struLineDeli", NET_DVR_GENERIC_DATA_CFG), # 行间隔符
        ("struIgnoreString", NET_DVR_IGNORE_STRING * MAX_IGNORE_STRING_NUM), # 忽略字符串，目前为4个
        ("byRes", BYTE * 40), # 保留
    ]


LPNET_DVR_POS_GENERIC = POINTER(NET_DVR_POS_GENERIC)


class NET_DVR_POS_AVE(Structure):
    _fields_ = [
        ("dwPosAddr", DWORD), # pos地址编号
        ("byRes", BYTE * 948),
    ]


LPNET_DVR_POS_AVE = POINTER(NET_DVR_POS_AVE)


SERIAL_NUM_LEN = 8
class NET_DVR_POS_NUCLEUS(Structure):
    _fields_ = [
        ("szEmployeeNo", CHAR * SERIAL_NUM_LEN), # 员工编号，如1（备注：标题e<employee#>）
        ("szTerminalNo", CHAR * SERIAL_NUM_LEN), #  Pos机编号，如1（备注：标题t<terminal#>）
        ("szShiftNo", CHAR * SERIAL_NUM_LEN), # 轮班（备注：标题s<shift#>）
        ("byRes", BYTE * 928),
    ]


LPNET_DVR_POS_NUCLEUS = POINTER(NET_DVR_POS_NUCLEUS)


ENUM_UTF8 = 0
ENUM_GB2312 = 1
ENUM_LATIN1 = 2
ENUM_LATIN2 = 3
ENUM_LATIN3 = 4
ENUM_LATIN4 = 5
ENUM_CYRILLIC = 6
ENUM_ARABIC = 7
ENUM_GREEK = 8
ENUM_HEBREW = 9
ENUM_TURKISH = 10
ENUM_NORDIC = 11
ENUM_THAI = 12
ENUM_LATIN7 = 13
ENUM_LATIN8 = 14
ENUM_LATIN9 = 15
ENUM_LATIN10 = 16
ENUM_CENTRAL_EUROPEAN = 17
ENUM_CYRILLIC_SCRIPT = 18
ENUM_HEBREW_DOS862 = 19


class NET_DVR_POS_FILTER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 规则使能
        ("byCharSetType", BYTE), # 编码方式0-UTF-8,1-GB2312
        ("byRes1", BYTE), # 保留
        ("byProtocolType", BYTE), # 协议类型，1->generic text协议(universal Protocol), 2->AVE VSI-ADD     3->AVE Vnet,4-EPSON(该类型无需处理pos协议参数), 5-NUCLEUS
        # 6- Gilbarco（配置对应结构体NET_DVR_POS_GENERIC）,7- NCR（配置对应结构体NET_DVR_POS_GENERIC）
        ("uPosProtocol", NET_DVR_POS_PROTOCOL_UNION), # POS协议
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_DVR_POS_FILTER_CFG = POINTER(NET_DVR_POS_FILTER_CFG)


class NET_DVR_NET_SNIFF(Structure):
    _fields_ = [
        ("byEnableSourcePort", BYTE), # 是否启用对数据源端口过滤  0-不启用，1-启用
        ("byEnableDestAddr", BYTE), # 是否启用对目标IP地址进行过滤 0-不启用，1-启用
        ("byEnableDestPort", BYTE), # 是否启用对目标地址的端口号进行过滤
        ("byRes1", BYTE), # 保留
        ("bySourceIpAddr", BYTE * MAX_DOMAIN_NAME), # 数据源地址
        ("byDestinationIpAddr", BYTE * MAX_DOMAIN_NAME), # 数据发送目标地址
        ("wSourcePort", WORD), # 数据源端口号
        ("wDestinationPort", WORD), # 数据发送目标端口号
        ("byRes", BYTE * 16), # 保留
    ]


LPNET_DVR_NET_SNIFF = POINTER(NET_DVR_NET_SNIFF)


class NET_DVR_NET_RECEIVE(Structure):
    _fields_ = [
        ("wNetPort", WORD), # device net port
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_NET_RECEIVE = POINTER(NET_DVR_NET_RECEIVE)


class NET_DVR_MONITOR_INFO(Structure):
    _fields_ = [
        ("wPort", WORD), # 监听端口号
        ("byRes1", BYTE * 2),
        ("struRestrictRemoteIP", NET_DVR_IPADDR), # 保留限制远程访问IP
        ("byRes", BYTE * 164),
    ]


LPNET_DVR_MONITOR_INFO = POINTER(NET_DVR_MONITOR_INFO)


class NET_DVR_POS_CONNECTMODE_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 312), # 联合体长度，无实际意义
        ("struNetRecv", NET_DVR_NET_RECEIVE), # 网络接受模式
        ("struTcpMonitor", NET_DVR_MONITOR_INFO), # 网络监听模式
        ("struRS232", NET_DVR_SINGLE_RS232), # 串口方式
        ("struUdpMonitor", NET_DVR_MONITOR_INFO), # 网络监听-UDP模式
        ("struSniff", NET_DVR_NET_SNIFF), # 网络侦听模式
        ("struMcast", NET_DVR_ADDRESS), # 多播模式
        ("struUSBRS232", NET_DVR_USB_RS232), # USB转串口方式
    ]


LPNET_DVR_POS_CONNECTMODE_UNION = POINTER(NET_DVR_POS_CONNECTMODE_UNION)


# DVR与POS连接方式配置结构体
class NET_DVR_CONNECT_POS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byConnectMode", BYTE), # 连接模式:0->网络监听(TCP),1->网络接受,2->串口接收3-网络监听（UDP）,4-网络侦听,5-多播
        ("byRes1", BYTE * 3), # 保留
        ("uPosConnMode", NET_DVR_POS_CONNECTMODE_UNION), # 连接模式配置
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_CONNECT_POS_CFG = POINTER(NET_DVR_CONNECT_POS_CFG)


class NET_DVR_CHAN_FILTER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byFilterID", BYTE), # POS过滤规则ID
        ("byFontSize", BYTE), # 字号大小，0-- 8*16  1--16*32  2--32*64
        ("byShowPosInfo", BYTE), # 码流中是否叠加pos信息
        ("byOverlayMode", BYTE), # 叠加方式，0-滚屏，1-翻页
        ("dwDelayTime", DWORD), # delay time(5-3600s)
        ("struOsdPosInfo", NET_DVR_POS_OSD_REGION), # overlay osd rect info
        ("struOsdColor", NET_DVR_RGB_COLOR), # OSD颜色
        ("struAlarmSched", NET_DVR_SCHEDTIME * MAX_DAYS),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V40), # 异常处理方式
        # 异常处理方式中报警输出号与组号绑定，即组号为0时，表示关联的报警输出号范围为1-64，当组号为1时，表示关联的报警输出号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的报警出号无效
        ("dwMaxRelRecordChanNum", DWORD), # 报警触发的录象通道数（只读）最大支持数量
        ("dwRelRecordChanNum", DWORD), # 本组内关联的录象通道数
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V30), # 触发录像通道
        # 关联的录像通道号与组号绑定，即组号为0时，表示关联的通道号范围为1-64，当组号为1时，表示关联的通道号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组内后续的关联通道号无效
        ("dwTimeOut", DWORD), # time Out(5-3600s) 数据超时指在多长时间接收不到POS数据即判定一次数据包的结束。
        ("byRes", BYTE * 60), # 保留
    ]


LPNET_DVR_CHAN_FILTER_CFG = POINTER(NET_DVR_CHAN_FILTER_CFG)


MAX_LAN_ENCODE_LEN = 32 # 语言编码格式最大长度
class NET_DVR_DEVICE_LAN_ENCODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLanEncode", BYTE * MAX_LAN_ENCODE_LEN), # 设备语言编码格式
        ("byRes", BYTE * 28),
    ]


LPNET_DVR_DEVICE_LAN_ENCODE = POINTER(NET_DVR_DEVICE_LAN_ENCODE)


class NET_DVR_SCENECHANGE_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能，是否开启 0~不开启,1~开启
        ("bySensitiveLevel", BYTE), #  1-100，默认50，灵敏度越高，越容易报警
        ("byRes1", BYTE * 2),
        ("struAlarmSched", NET_DVR_SCHEDTIME * MAX_DAYS),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V40), # 异常处理方式
        ("dwMaxRelRecordChanNum", DWORD), # 报警触发的录象通道 数（只读）最大支持数量
        ("dwRelRecordChanNum", DWORD), # 报警触发的录象通道 数 实际支持的数量
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V30), # 触发录像通道
        # 报警触发的录象通道（四字节的通道号，初始值是 0xffffffff）
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_SCENECHANGE_DETECTION = POINTER(NET_DVR_SCENECHANGE_DETECTION)


class NET_DVR_SCENECHANGE_DETECTION_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byRes", BYTE * 126), #  保留字节
    ]


LPNET_DVR_SCENECHANGE_DETECTION_RESULT = POINTER(NET_DVR_SCENECHANGE_DETECTION_RESULT)


PREVIEW_MOD = 0
ALARM_MOD = 1
PLAYBACK_MOD = 2
MAX_TYPE = 3


# 车位信息
class NET_DVR_PARK_INFO(Structure):
    _fields_ = [
        ("sPlateNo", CHAR * MAX_PlATE_NO_LEN), # 车牌号码
        ("sParkIndex", CHAR * MAX_PlATE_NO_LEN), # 车位编号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PARK_INFO = POINTER(NET_DVR_PARK_INFO)


class NET_DVR_CROSSLINE_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDevInfo", NET_VCA_DEV_INFO),
        ("struTriggerTime", NET_DVR_TIME_EX), # 触发时间
        ("struParkInfo", NET_DVR_PARK_INFO), # 车位信息
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_CROSSLINE_ALARM = POINTER(NET_DVR_CROSSLINE_ALARM)


class NET_DVR_STREAM_SRC_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamID", NET_DVR_STREAM_INFO), # 流信息
        ("struStreamSrcInfo", NET_DVR_STREAM_SRC_INFO), # 流源信息
    ]


LPNET_DVR_STREAM_SRC_CFG = POINTER(NET_DVR_STREAM_SRC_CFG)


class NET_DVR_ENCODEINFO(Structure):
    _fields_ = [
        ("byFormatType", BYTE), # 封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP, 9-RTP+PS（国标：GB28181），0xff-无效
        ("byVideoEncType", BYTE), # 视频编码类型，0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，0xff-无效
        ("wWidth", WORD), # 图像宽度
        ("wHeight", WORD), # 图像高度
        ("byRes1", BYTE * 2),
        ("dwVideoBitrate", DWORD), # 视频码率,单位Kbps
        ("dwVideoFrameRate", DWORD), # 帧率，200起表示小于1帧/秒的状态，其余值表示实际帧率值,200-1/2,201-1/4,202-1/8,203-1/16
        ("byAudioEncType", BYTE), # 音频编码类型，0-G722，1-G711_U，2-G711_A，5-MPEG2,6-G726，7-AAC,0xff-无效
        ("byRes2", BYTE * 15),
    ]


LPNET_DVR_ENCODEINFO = POINTER(NET_DVR_ENCODEINFO)


class NET_DVR_TRANSSTATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamInfo", NET_DVR_STREAM_INFO), # 流ID、转码通道信息
        ("byMode", BYTE), # 转码模式，1-主动转码，2-被动转码
        ("byLinkNums", BYTE), # 连接数
        ("byPassiveTransMode", BYTE), # 被动转码模式，0-无效，1-实时流，2-文件流
        ("byRes", BYTE),
        ("struDstIPInfo", NET_DVR_ADDRESS * MAX_LINK), # 目标转码ip地址
        ("byTransResource", BYTE), # 所使用的转码资源数，按D1计算
        ("byRes1", BYTE * 15),
        ("struSrcEncodeInfo", NET_DVR_ENCODEINFO), # 源编码信息
        ("struDstEncodeInfo", NET_DVR_ENCODEINFO * MAX_LINK), # 目标编码信息
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_TRANSSTATUS = POINTER(NET_DVR_TRANSSTATUS)


class NET_DVR_TRANSDEVICE_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTotalResource", DWORD), # 全部转码资源，以D1为单位计算
        ("dwIdleResource", DWORD), # 剩余转码资源，以D1为单位计算
        ("byCpuLoad", BYTE), # CPU利用率
        ("byRes", BYTE * 67),
    ]


LPNET_DVR_TRANSDEVICE_STATUS = POINTER(NET_DVR_TRANSDEVICE_STATUS)


class NET_DVR_DEV_WORK_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWorkMode", BYTE), # 1-通道模式，2-流ID模式
        ("byDisplayMode", BYTE), # 0-普通，1-畅显
        ("byEnableVcaDec", BYTE), # 是否启用智能解码，0-不启用，非0-启用
        ("byRes", BYTE * 61),
    ]


LPNET_DVR_DEV_WORK_MODE = POINTER(NET_DVR_DEV_WORK_MODE)


class NET_DVR_PASSIVETRANSINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byStreamType", BYTE), #  码流类型，0-主码流，1-子码流
        ("byLinkMode", BYTE), #  0：TCP方式,1：UDP方式（保留）
        ("byPassiveTransMode", BYTE), # 被动转码模式，1-实时流，2-文件流
        ("byRes1", BYTE * 5),
        ("byDataType", BYTE), # 缓冲区类型，1-SDP，2-码流头
        ("byRes2", BYTE),
        ("wDataLength", WORD), # 数据长度
        ("*pBuffer", CHAR), # 缓冲区
        ("byRes3", BYTE * 32), #  保留
    ]


LPNET_DVR_PASSIVETRANSINFO = POINTER(NET_DVR_PASSIVETRANSINFO)


class NET_DVR_BASEMAP_CONTROL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否显示，1-显示，0-隐藏
        ("byBaseMapType", BYTE), # 底图类型，1-图片底图，2-超高清输入底图，3-底图轮训
        ("byBaseMapCircleNo", BYTE), # 底图轮训参数编号，byBaseMapType为3时有效
        ("byRes1", BYTE),
        ("dwBaseMapNo", DWORD), # 底图号；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入口号（1字节矩阵号+1字节子板号+1字节输入口号+1字节保留）
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_BASEMAP_CONTROL_CFG = POINTER(NET_DVR_BASEMAP_CONTROL_CFG)


class NET_DVR_VIRTUAL_SCREEN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwResolution", DWORD), # 分辨率，MAKE_RESOLUTION宏定义的值，从电视墙能力获取支持的分辨率值
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_VIRTUAL_SCREEN_CFG = POINTER(NET_DVR_VIRTUAL_SCREEN_CFG)


class NET_DVR_BASEMAP_WINCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE),
        ("byWndOperateMode", BYTE), # 窗口操作模式，0-统一坐标，1-分辨率坐标
        ("byRes1", BYTE * 6),
        ("struWinPosition", NET_DVR_RECTCFG_EX), # 目的窗口(相对显示墙),底图窗口的起始坐标和大小必须是基准坐标的整数倍
        ("struResolution", NET_DVR_RECTCFG_EX), # 目的窗口分辨率坐标，获取或按分辨率坐标设置有效
        ("dwXCoordinate", DWORD), # LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
        ("dwYCoordinate", DWORD), # LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_BASEMAP_WINCFG = POINTER(NET_DVR_BASEMAP_WINCFG)


class NET_DVR_BASEMAP_PIC_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sPicName", BYTE * NAME_LEN), # 图片名称
        ("byUsed", BYTE), # 是否已存在，0-不存在，1-存在
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_BASEMAP_PIC_INFO = POINTER(NET_DVR_BASEMAP_PIC_INFO)


class NET_DVR_MATRIX_LOGO_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwLogoSize", DWORD), # LOGO大小，包括BMP的文件头，图片大小超限，限100K，高和宽须是32的倍数
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_MATRIX_LOGO_INFO = POINTER(NET_DVR_MATRIX_LOGO_INFO)


class NET_DVR_MATRIX_LOGO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byExist", BYTE), # logo是否存在，0-不存在，1-存在（此参数只能获取）
        ("byRes1", BYTE * 3),
        ("dwLogoSize", DWORD), # LOGO大小，包括BMP的文件头(此参数只能获取)
        ("byLogoName", BYTE * NAME_LEN), # logo名称
        ("dwLogoNo", DWORD), # logo编号（获取所有logo信息时有效）
        ("byRes2", BYTE * 28),
    ]


LPNET_DVR_MATRIX_LOGO_CFG = POINTER(NET_DVR_MATRIX_LOGO_CFG)


class NET_DVR_WIN_LOGO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwLogoNo", DWORD), # logo号
        ("byEnable", BYTE), # logo是否显示，1-显示，0-隐藏
        ("byRes1", BYTE * 3),
        ("dwCoordinateX", DWORD), # 图片显示区域X坐标
        ("dwCoordinateY", DWORD), # 图片显示区域Y坐标
        ("byFlash", BYTE), # 是否闪烁1-闪烁，0-不闪烁
        ("byTranslucent", BYTE), # 是否半透明1-半透明，0-不半透明
        ("byRes2", BYTE * 34), # 保留
    ]


LPNET_DVR_WIN_LOGO_CFG = POINTER(NET_DVR_WIN_LOGO_CFG)


class NET_DVR_BIG_SCREEN_AUDIO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwWinIndex", DWORD), # 窗口号，从1开始，0表示底图
        ("byEnable", BYTE), # 是否打开音频，1-打开音频，0-关闭音频
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_BIG_SCREEN_AUDIO_CFG = POINTER(NET_DVR_BIG_SCREEN_AUDIO_CFG)


class NET_DVR_WIN_ZOOM_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byZoomStatus", BYTE), # 0-正常状态，1-放大状态
        ("byRes1", BYTE * 3),
        ("struPointFrame", NET_DVR_POINT_FRAME), # 放大区域，当byZoomStatus为1时有效
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_WIN_ZOOM_STATUS = POINTER(NET_DVR_WIN_ZOOM_STATUS)


class NET_DVR_RESUME_INITRACKPOS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构大小
        ("dwChannel", DWORD), #       通道号
        ("byRes", BYTE * 16), #  保留字节
    ]


LPNET_DVR_RESUME_INITRACKPOS_CFG = POINTER(NET_DVR_RESUME_INITRACKPOS_CFG)


class NET_DVR_TEST_SELFCHECK_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("bySelfCheckStatus", BYTE), # 自检状态值 0-未开始，1-成功，2-失败，3-自检中
        ("byRes", BYTE * 23), # 保留字节
    ]


LPNET_DVR_TEST_SELFCHECK_RESULT = POINTER(NET_DVR_TEST_SELFCHECK_RESULT)


class NET_DVR_TEST_COMMAND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byTestCommand", BYTE * MAX_TEST_COMMAND_NUM),
        # 0-表示不开启测试， 1-表示开启测试
        # 数组下标0 开启老化测试程序
        # 数组下标1 红外灯进入测试模式
        # 数组下标2 ICR老化测试，0表示关闭，1表示开启，可以与bit0 组合，如0000_0001(只开启巡航老化)、0000_0101（同时开启巡航和ICR老化）、0000_0100（只开启ICR老化）
        # 数组下标3 -球机pt自矫正功能状态，0表示球机自矫正功能未清除，1表示球机自矫正功能已清除
        # 数组下标4 花样扫描测试程序，0表示关闭，1表示开启
        # 数组下标5 电子罗盘校正程序，0表示关闭，1表示开启
        ("wICRIntervalTime", WORD), # icr间隔时间（byTestCommand 数组下表2内的值为1时，ICR开关间隔时间，单位秒）
        ("byElectronicCompassState", BYTE), # 罗盘状态返回， 0-正常， 1-不正常
        ("byRes1", BYTE * 1),
        ("fDeviceTem", float), # 设备机芯温度，精确度0.001
        ("byTemp", BYTE * 9), # 用于多个温敏设备， 下标0-全景的温敏， 标1-4：全景1的4个sensor的温敏， 标5-8：全景2的4个sensor的温敏,目前用于鹰眼全景
        ("byRes", BYTE * 3), # 保留字节
    ]


LPNET_DVR_TEST_COMMAND = POINTER(NET_DVR_TEST_COMMAND)


class NET_DVR_AGING_TRICK_SCAN(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byAging", BYTE), #  表示设置的参数 为老化前工具还是老化后工具， 0-老化前、1-老化后
        ("byWriteReadEnalbe", BYTE), # 读写指令使能，0-设置读指令， 1-设置写指令
        ("byRes", BYTE * 126), # 保留字节
    ]


LPNET_DVR_AGING_TRICK_SCAN = POINTER(NET_DVR_AGING_TRICK_SCAN)


IPC_PARAM_AGING_TRICK_SCAN = 0x00000001 # 清除花样扫描参数设置
class NET_DVR_IPC_PARAM_TYPE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwParamType", DWORD), # 参数类型，按位表示
        # #define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 清除花样扫描参数设置
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_IPC_PARAM_TYPE = POINTER(NET_DVR_IPC_PARAM_TYPE)


class NET_DVR_ECCENTRIC_CORRECT_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byEccentricCorrectState", BYTE), #  偏心矫正状态，0-校正失败、1-校正成功、2-校正中
        ("byRes", BYTE * 127), # 保留字节
    ]


LPNET_DVR_ECCENTRIC_CORRECT_STATE = POINTER(NET_DVR_ECCENTRIC_CORRECT_STATE)


MAX_DEVMODULE_NUM = 8
class NET_DVR_TEST_DEVMODULE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byDevFanModuleType", BYTE * MAX_DEVMODULE_NUM), # 测试的设备类型
        # 0-不开启测试,1-开启测试
        # bit0-测试风扇1
        # bit1-测试风扇2
        ("byDevHeaterModuleType", BYTE * MAX_DEVMODULE_NUM), # 测试的设备类型
        # 0-不开启测试,1-开启测试
        # bit0-测试加热器1
        # bit1-测试加热器2
        ("byRes", BYTE * 22), # 保留字节
    ]


LPNET_DVR_TEST_DEVMODULE_CFG = POINTER(NET_DVR_TEST_DEVMODULE_CFG)


# 出入口条件
class NET_DVR_BARRIERGATE_COND(Structure):
    _fields_ = [
        ("byLaneNo", BYTE), # 车道号（0-表示无效值(设备需要做有效值判断),1-车道1）
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_BARRIERGATE_COND = POINTER(NET_DVR_BARRIERGATE_COND)


class NET_DVR_VEHICLE_CONTROL(Structure):
    _fields_ = [
        ("byGateOperateType", BYTE), # 0-无操作,1-开道闸
        ("byRes1", BYTE),
        ("wAlarmOperateType", WORD), # 0-无操作,bit0-继电器输出报警 bit1-布防上传报警 bit3-告警主机上传（可复选）(0-表示关，1-表示开)
        ("byRes2", BYTE * 8),
    ]


LPNET_DVR_VEHICLE_CONTROL = POINTER(NET_DVR_VEHICLE_CONTROL)


class NET_DVR_RELAY_PARAM(Structure):
    _fields_ = [
        ("byAccessDevInfo", BYTE), # 0-不接入设备，1-开道闸、2-关道闸、3-停道闸、4-报警信号、5-常亮灯
        ("byRes", BYTE * 3),
    ]


LPNET_DVR_RELAY_PARAM = POINTER(NET_DVR_RELAY_PARAM)


# 出入口配置
class NET_DVR_ENTRANCE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), #  使能0-表示关闭，1-表示打开
        ("byBarrierGateCtrlMode", BYTE), # 0-相机自动控制，1-平台外部控制
        ("byRes1", BYTE * 2),
        ("dwRelateTriggerMode", DWORD), # 关联触发模式 参考ITC_TRIGGERMODE_TYPE
        # 0x00: 不做匹配
        # 0x01: 车牌匹配（带车牌颜色）
        # 0x02: 车牌匹配（不带车牌颜色）
        # 0x04: 卡号匹配
        ("dwMatchContent", DWORD), # 异常处理,异常处理方式的"或"结果
        ("struRelayRelateInfo", NET_DVR_RELAY_PARAM * MAX_RELAY_NUM), # 继电器关联配置信息(一个继电器只能控制一个接入设备) 数组0表示继电器1 数组1表示继电器2 依次类推 12
        ("byGateSingleIO", BYTE * MAX_IOIN_NUM), # 单个IO触发参数，单个IO触发参数，数组0表示IO1，数组1表示IO2，依次类推  具体数组值的含义（0-无，1-道闸开到位，2-道闸关到位，3-消防报警）
        # 车辆信息管控
        # 数组0表示临时车辆配置的模式
        # 数组1-黑名单车辆的模式,
        # 数组2-白名单车辆的模式
        ("struVehicleCtrl", NET_DVR_VEHICLE_CONTROL * MAX_VEHICLE_TYPE_NUM), # 车辆信息管控
        ("byNotCloseCarFollow", BYTE), # 启用跟车不落闸使能，0~为不启用，1~启用
        ("byParkingDetectEnabled", BYTE), # 启用驻车检测使能，0~为不启用，1~启用
        ("byParkingDetectJudgeTime", BYTE), # 驻车检测判断时间，单位秒
        ("byRes2", BYTE * 61),
    ]


LPNET_DVR_ENTRANCE_CFG = POINTER(NET_DVR_ENTRANCE_CFG)


# # # # # # # # # # # # # # 出入口参数配置 end# # # # # # # # # # # # # # # /
#  道闸控制
class NET_DVR_BARRIERGATE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byLaneNo", BYTE), # 道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
        #
        # 若老的平台不支持byUnlock字段，该字段将赋值为0，通过“0-关闭道闸,1-开启道闸,2-停止道闸”中的任何一种操作皆可进行解锁。
        # 若新平台支持byUnlock字段，需byUnlock字段赋值为1，并结合4~解锁道闸来进行解锁。byUnlock字段赋值为1后，“0-关闭道闸,1-开启道闸,2-停止道闸”操作将不可用于解锁。
        #
        ("byBarrierGateCtrl", BYTE), # 0-关闭道闸,1-开启道闸,2-停止道闸 3-锁定道闸,4~解锁道闸
        ("byEntranceNo", BYTE), # 出入口编号 [1,8]
        ("byUnlock", BYTE), # 启用解锁使能，0~为不启用，1~启用
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_BARRIERGATE_CFG = POINTER(NET_DVR_BARRIERGATE_CFG)


# 出入口黑白名单的数据同步
class NET_DVR_VEHICLE_CONTROL_LIST_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号0xff - 全部通道（ITC 默认是1）
        ("dwDataIndex", DWORD), # 数据流水号（平台维护的数据唯一值，客户端操作的时候，该值不会起效。该值主要用于数据增量同步）
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("byListType", BYTE), # 名单属性（黑白名单）0-白名单，1-黑名单
        ("byPlateType", BYTE), # 车牌类型
        ("byPlateColor", BYTE), # 车牌颜色
        ("byRes", BYTE * 21),
        ("sCardNo", CHAR * MAX_CARDNO_LEN), #  卡号
        ("struStartTime", NET_DVR_TIME_V30), # 有效开始时间
        ("struStopTime", NET_DVR_TIME_V30), # 有效结束时间
        # 操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0）2014-03-03
        ("sOperateIndex", CHAR * MAX_OPERATE_INDEX_LEN),
        ("byRes1", BYTE * 224), #  保留字节
    ]


LPNET_DVR_VEHICLE_CONTROL_LIST_INFO = POINTER(NET_DVR_VEHICLE_CONTROL_LIST_INFO)


# 数据全部获取接口 （长连接获取）
class NET_DVR_VEHICLE_CONTROL_COND(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号0xffffffff - 全部通道（ITC 默认是1）
        ("dwOperateType", DWORD), # 操作类型，参照VCA_OPERATE _TYPE。（可复选）
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("sCardNo", CHAR * MAX_CARDNO_LEN), #  卡号
        ("byListType", BYTE), # 名单属性（黑白名单）0-白名单，1-黑名单，0xff-全部
        # 2014-02-25
        ("byRes1", BYTE * 3),
        ("dwDataIndex", DWORD), # 数据流水号
        ("byRes", BYTE * 116),
    ]


LPNET_DVR_VEHICLE_CONTROL_COND = POINTER(NET_DVR_VEHICLE_CONTROL_COND)


# 黑白名单数据需要同步报警
class NET_DVR_VEHICLE_CONTROL_LIST_DSALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDataIndex", DWORD), # 数据流水号（这个值返回设备当前接收到的数据的最后一个数据流水号,平台同步的时候从下一个流水号开始同步）
        ("sOperateIndex", CHAR * MAX_OPERATE_INDEX_LEN), # 操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0） 2014-03-03
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_VEHICLE_CONTROL_LIST_DSALARM = POINTER(NET_DVR_VEHICLE_CONTROL_LIST_DSALARM)


# 车辆报警（黑白名单）
class NET_DVR_VEHICLE_CONTROL_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byListType", BYTE), # 名单属性（黑白名单）0-白名单，1-黑名单，2-临时名单
        ("byPlateType", BYTE), # 车牌类型
        ("byPlateColor", BYTE), # 车牌颜色
        ("byRes1", BYTE),
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("sCardNo", CHAR * MAX_CARDNO_LEN), #  卡号
        ("struAlarmTime", NET_DVR_TIME_V30), # 报警时间
        ("dwChannel", DWORD), # 设备通道号，如果直连的是IPC，则为ipc通道号；如果连的DVR\nvr,则为DVR\NVR的通道号
        ("dwPicDataLen", DWORD), # 图片数据大小，0表示无图片，不为0是表示后面带图片数据
        ("byPicType", BYTE), # 图片类型，0-JPEG
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("byRes3", BYTE * 2),
        ("*pPicData", CHAR),
        ("byRes2", BYTE * 48),
    ]


LPNET_DVR_VEHICLE_CONTROL_ALARM = POINTER(NET_DVR_VEHICLE_CONTROL_ALARM)


# 消防报警
class NET_DVR_FIRE_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAlarmTime", NET_DVR_TIME_V30), # 报警时间
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_FIRE_ALARM = POINTER(NET_DVR_FIRE_ALARM)


# 清除设备车牌黑名单数据库信息
class NET_DVR_VEHICLE_CONTROL_DELINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDelType", DWORD), # 删除条件类型，删除条件类型，参照VCA_OPERATE _TYPE。（可复选）
        ("sLicense", CHAR * 16), # 车牌号码
        ("sCardNo", CHAR * 48), #  卡号
        ("byPlateType", BYTE), # 车牌类型
        ("byPlateColor", BYTE), # 车牌颜色
        ("byOperateType", BYTE), # 删除操作类型(0-条件删除,0xff-删除全部)
        # 2014-02-25
        ("byListType", BYTE), # 名单属性（黑白名单）0-白名单，1-黑名单 2014-03-03
        ("dwDataIndex", DWORD), # 数据流水号
        # 操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0）2014-03-03
        ("sOperateIndex", CHAR * MAX_OPERATE_INDEX_LEN),
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_VEHICLE_CONTROL_DELINFO = POINTER(NET_DVR_VEHICLE_CONTROL_DELINFO)


# 常亮灯功能
class NET_DVR_GATELAMP_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byLaneNo", BYTE), # 道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
        ("byBrightlampCtrl", BYTE), # 0-关闭常亮灯，1-开启常亮灯
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_GATELAMP_INFO = POINTER(NET_DVR_GATELAMP_INFO)


# SDI矩阵1.0
MATRIX_MAX_OUTPUT_NUM = 256 # 矩阵最大输出通道个数
class NET_DVR_MATRIX_BASE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwValidInputNum", DWORD), # 有效的输入通道数
        ("dwValidOutputNum", DWORD), # 有效的输出通道数
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_MATRIX_BASE_CFG = POINTER(NET_DVR_MATRIX_BASE_CFG)


class NET_DVR_MATRIX_SWITCH_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwInputChan", DWORD), # 输入通道号，为0表示取消和指定输出的关联关系
        ("dwOutputChan", DWORD), # 要切换到的输出通道号, (屏幕服务器为屏幕索引号(1字节设备号+1字节保留+2字节屏幕索引号)), 0xffffffff表示切换到所有输出
        ("dwMatrixID", DWORD), # 矩阵ID号
        ("byRes", BYTE * 28),
    ]


LPNET_DVR_MATRIX_SWITCH_INFO = POINTER(NET_DVR_MATRIX_SWITCH_INFO)


class NET_DVR_IO_RELATION_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwIORelation", DWORD * MATRIX_MAX_OUTPUT_NUM), # 输出通道关联的输入通道, dwIORelation[i] = j表示输出通道(i + 1)和输入通道j关联,
        # dwIORelation[i] = 0表示输出通道i + 1未关联输入通道
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_IO_RELATION_INFO = POINTER(NET_DVR_IO_RELATION_INFO)


# 批量接口配置
class NET_DVR_EXTERNAL_DEVCOND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byExternalDevTpye", BYTE), # 0-其他(保留)，1-远距离读头设备，2-出入口控制机，3-led屏  0xff-全部信息（长连接获取时使用）
        ("byRelativeIndex", BYTE), # 0-其他(保留)，索引(相对于接入类型) 范围 1~8 Led的相对索引范围是（1～255）   0xff-全部信息（长连接获取时使用）
        # BYTE   byLaneID; 逻辑车道号
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_EXTERNAL_DEVCOND = POINTER(NET_DVR_EXTERNAL_DEVCOND)

# 长连接获取配置
class NET_DVR_EXTERNAL_DEVSTATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sDevName", CHAR * MAX_DEVNAME_LEN), # 设备名称
        ("byExternalDevTpye", BYTE), # 0-其他(保留)，1-远距离读头设备，2-出入口控制机，3-led屏  0xff-全部信息（长连接获取时使用）
        ("byRelativeIndex", BYTE), # 0-其他(保留)，相对索引(相对于接入类型能) 范围 1~8  0xff-全部信息（长连接获取时使用）
        ("byOnline", BYTE), # 0-不在线，1-在线
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_EXTERNAL_DEVSTATUS = POINTER(NET_DVR_EXTERNAL_DEVSTATUS)


# 终端出入口检测配置
class NET_DVR_ENTRANCEDET_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        # 离线检测开启时，如果检测到设备在线，则由终端匹配卡片信息，并发送道闸控制指令给出入口控制机；否则由出入口控制机自身匹配控制道闸
        ("byOfflineDetEnable", BYTE), # 离线检测 0-关闭，1-开启
        ("byDetCycle", BYTE), # 检测周期（0～60 单位 s）
        ("byDevCtrlCode", BYTE), # 出入口控制机拨码地址，用于区分设备(1-255)
        ("byRes", BYTE * 61),
    ]


LPNET_DVR_ENTRANCEDET_CFG = POINTER(NET_DVR_ENTRANCEDET_CFG)


# 终端出入口控制(控制接口 下发卡片信息)
class NET_DVR_ENTRANCEDEV_COMMAND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byDevCtrlCode", BYTE), # 出入口控制机拨码地址，用于区分设备(1-255)
        ("byManualIssuedData", BYTE), # 手动数据下发 0-关闭，1-开启
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_ENTRANCEDEV_COMMAND = POINTER(NET_DVR_ENTRANCEDEV_COMMAND)


# 终端出入口控制(控制接口 清空下发卡片信息)
class NET_DVR_ENISSUED_DATADEL(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byDevCtrlCode", BYTE), # 出入口控制机拨码地址，用于区分设备(1-255)
        ("byRes", BYTE * 27),
    ]


LPNET_DVR_ENISSUED_DATADEL = POINTER(NET_DVR_ENISSUED_DATADEL)


# 出入口过车收费明细（监听方式）
# 出入口交接班数据（监听方式）
class NET_DVR_CURTRIGGERMODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTriggerType", DWORD), # 触发类型，详见ITC_TRIGGERMODE_TYPE
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_CURTRIGGERMODE = POINTER(NET_DVR_CURTRIGGERMODE)


class NET_DVR_TEMP_HUMI(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  内容长度 && 版本（用于后期扩展）
        ("dwChannel", DWORD), #  通道号，默认1
        ("iHumidity", int), #  湿度，整数部分：val/1000，小数部分：val%1000
        ("iTemp", int), #  温度，整数部分：val/1000，小数部分：val%100
        ("byRes", BYTE * 8), #  保留字节
    ]


LPNET_DVR_TEMP_HUMI = POINTER(NET_DVR_TEMP_HUMI)


class NET_DVR_ALARMSOUNDMODE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  内容长度 && 版本（用于后期扩展）
        ("dwChannel", DWORD), #  通道号，默认1
        ("dwSoundMode", DWORD), #  报警模式: 0提醒模式；1警报模式；2静音模式
        ("byRes", BYTE * 12), #  保留字节
    ]


LPNET_DVR_ALARMSOUNDMODE_CFG = POINTER(NET_DVR_ALARMSOUNDMODE_CFG)


class NET_DVR_SECURITYMODE(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  内容长度 && 版本（用于后期扩展）
        ("dwChannel", DWORD), #  通道号，默认1
        ("dwMode", DWORD), #  安全模式: 1启用，码流加密；2不启用，码流不加密
        ("szRandCode", CHAR * 6), # 设备出厂的"随机验证码"
        ("byRes", BYTE * 6), #  保留字节
    ]


LPNET_DVR_SECURITYMODE = POINTER(NET_DVR_SECURITYMODE)


class NET_DVR_MOBILE_CAPTUREPIC_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPreviewFpsAdjMode", BYTE), #  预览帧率调节模式:0-不调节，标准帧率预览,1-标准低帧率预览,2-根据GPS速度进行帧率调节
        ("bySelPeccType", BYTE), #  是否选择违章类型
        ("byOptHabit", BYTE), #  取证操作习惯, 0:长按取证1:短按两次取证
        ("byEnablePeccRec", BYTE), #  1: 使能违章录像抓取, 0: 禁止违章录像抓取
        ("byPicSize", BYTE), # 0=CIF,1=QCIF,2=D1,3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6-VGA，7-XVGA，8-HD900p，9-HD1080，10-2560*1920，11-1600*304，12-2048*1536，13-2448*2048,14-2448*1200，15-2448*800，16-XGA(1024*768)，17-SXGA(1280*1024),18-WD1(960*576/960*480),19-1080i
        ("byPicQuality", BYTE), #  图片质量系数 0-最好 1-较好 2-一般
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_MOBILE_CAPTUREPIC_CFG = POINTER(NET_DVR_MOBILE_CAPTUREPIC_CFG)


class NET_DVR_CMS_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAddr", NET_DVR_IPADDR), #  平台服务器IP
        ("wServerPort", WORD), #  平台服务器侦听端口，
        ("bySeverProtocolType", BYTE), # 平台协议类型 1-私有，2-Ehome
        ("byStatus", BYTE), # 设备注册到该平台的状态，1-未注册，2-已注册
        ("sDeviceId", BYTE * NAME_LEN), # 设备ID，由平台提供
        ("sPassWord", CHAR * PASSWD_LEN), # 密码
        # ******** IPC5.1.7 新增参数 Begin 2014-03-21**********
        ("sPlatformEhomeVersion", BYTE * NAME_LEN), # 平台EHOME协议版本
        # ******** IPC5.1.7 新增参数 end 2014-03-21**********
        ("byNetWork", BYTE), # 网络类型：0- 无意义，1-自动，2-有线网络优先，3-有线网络，4-3G网络（无线网络），5-有线网络1，6-有线网络2
        ("byAddressType", BYTE), # 0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
        ("byProtocolVersion", BYTE), # 协议版本 0 - 无意义, 1 – v2.0，2 – v4.0,3-v2.6
        ("byRes1", BYTE),
        ("sDomainName", BYTE * MAX_DOMAIN_NAME), # 平台服务器域名，byAddressType为2时有效
        ("byEnable", BYTE), # 0-关闭，1-开启
        ("byRes", BYTE * 139), #  保留字节
    ]


LPNET_DVR_CMS_PARAM = POINTER(NET_DVR_CMS_PARAM)


# 条件结构
class NET_DVR_HEATMAP_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byDetSceneID", BYTE), # 检测场景号[1],球机当前支持1个场景, IPC默认是0
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_HEATMAP_COND = POINTER(NET_DVR_HEATMAP_COND)


class NET_DVR_HEATMAP_PARAM(Structure):
    _fields_ = [
        ("byTargetTrackEnable", BYTE), # 目标跟踪：0-关闭，1-开启，默认0-关闭
        ("bySensitivity", BYTE), # 灵敏度参数，范围1-100，默认50
        ("byBackgroundUpdateRate", BYTE), # 背景更新速度：范围1-100，默认50
        ("bySceneChangeLevel", BYTE), # 场景变化等级：范围1-100，默认50
        ("byMinTargetSize", BYTE), # 最小目标尺寸：范围1-100，默认50
        #
        # 0-	默认上传类型：COMM_UPLOAD_HEATMAP_RESULT；
        # 1-	上传类型：COMM_UPLOAD_HEATMAP_RESULT_PDC 和 COMM_UPLOAD_HEATMAP_RESULT_DURATION；
        #
        ("byUploadHeatMapResultType", BYTE),
        ("byDayReport", BYTE),
        ("byWeekReport", BYTE),
        ("fConfidence", float), # 置信度[0.00,100.00]
        ("byMonthReport", BYTE),
        ("byYearReport", BYTE),
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_HEATMAP_PARAM = POINTER(NET_DVR_HEATMAP_PARAM)


MAX_HEATMAPREGION_NUM = 8
# 热度图检测配置结构
class NET_DVR_HEATMAP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能，是否开启
        ("byRes", BYTE * 3),
        ("struRegion", NET_VCA_POLYGON * MAX_HEATMAPREGION_NUM), # 区域范围
        ("struHeatMap", NET_DVR_HEATMAP_PARAM),
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V40), # 异常处理方式
        # 布防时间
        ("struAlarmSched", NET_DVR_SCHEDTIME * MAX_DAYS),
        ("byRes1", BYTE * 512),
    ]


LPNET_DVR_HEATMAP_CFG = POINTER(NET_DVR_HEATMAP_CFG)


# 热度图报警上传
class NET_DVR_HEATMAP_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDevInfo", NET_VCA_DEV_INFO), # 设备信息
        ("struStartTime", NET_DVR_TIME_EX), # 开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 结束时间
        ("dwMaxHeatMapValue", DWORD), # 最大热度值
        ("dwMinHeatMapValue", DWORD), # 最小热度值
        ("dwTimeHeatMapValue", DWORD), #  (时间热度值)平均热度值
        ("wArrayLine", WORD), # 图片像素点行值
        ("wArrayColumn", WORD), # 图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）
        ("pBuffer", BYTE*), # 热度图片像素点数据信息
        ("byDetSceneID", BYTE), # 检测场景号[1],球机当前支持1个场景, IPC默认是0
        ("byBrokenNetHttp", BYTE), # 断网续传标志位，0-不是重传数据，1-重传数据
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byTimeDiffFlag", BYTE), # 时差字段是否有效  0-时差无效， 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14，+表示东区
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 30, 45，+表示东区
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14， +表示东区
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 30, 45，+表示东区
        ("byArrayUnitType", BYTE), # 矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型），1-byte，2-short,4-int
        ("byRes1", BYTE * 2),
        ("dwTotalTime", DWORD), # 停留时间总和，单位秒，按人员停留时间报警时上传
        ("byRes", BYTE * 112),
    ]


LPNET_DVR_HEATMAP_RESULT = POINTER(NET_DVR_HEATMAP_RESULT)


# 热度图报警查找 条件结构体
class NET_DVR_HEATMAP_QUERY_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("struStartTime", NET_DVR_TIME_EX), # 开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 结束时间
        ("byReportType", BYTE), # 0-无效值，1-日报表，2-周报表，3-月报表，4-年报表
        ("byDetSceneID", BYTE), # 检测场景号[1],球机当前支持1个场景, IPC默认是0
        ("byHeatMapInfoType", BYTE), # 0~获取空间热度图片方式，1~获取空间热度矩阵信息方式，2~获取空间热度图片和空间热度矩阵信息
        ("byStatisticalModel", BYTE), # 统计模式  0s-保留（默认），1-停留时间，2-按人数统计）
        ("byRes", BYTE * 124),
    ]


LPNET_DVR_HEATMAP_QUERY_COND = POINTER(NET_DVR_HEATMAP_QUERY_COND)


# 热度图报警查找
class NET_DVR_HEATMAP_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartTime", NET_DVR_TIME_EX), # 间隔开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 间隔结束时间
        ("dwHeatMapPicLen", DWORD), # 空间热度图片长度(当含有图片的时候，该字段为非0，没有图片的时候，该字段为0)
        ("pBuffer", BYTE*), # 热度图片数据信息
        ("dwTimeHeatMapValue", DWORD), # 时间热度值(含有空热度图的时候,该字段不需要传值)
        ("dwHeatMapMaxValue", DWORD), # 检测区域最高热度点人员活动时间(s)(空间热度图时有效)
        ("dwHeatMapMinValue", DWORD), # 检测区域最低热度点人员活动时间(s) (空间热度图时有效)
        ("wArrayLine", WORD), # 图片像素点行值 （上传热度矩阵信息时生效）
        ("wArrayColumn", WORD), # 图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）（上传热度矩阵信息时生效）
        ("pArrayBuffer", BYTE*), # 热度矩阵数据信息（矩阵数据的透传，信息长度为wArrayLine* wArrayColumn*单元数据类型长度（例如byArrayUnitType为1表示为int型，这里就要乘以4个字节））
        ("byArrayUnitType", BYTE), # 矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型），0~byte，1~int；(当设备有返回矩阵信息时生效)
        ("byRes", BYTE * 107),
    ]


LPNET_DVR_HEATMAP_INFO = POINTER(NET_DVR_HEATMAP_INFO)


class NET_DVR_PDC_QUERY_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("struStartTime", NET_DVR_TIME_EX), # 开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 结束时间
        ("byReportType", BYTE), # 0-无效值，1-日报表，2-周报表，3-月报表，4-年报表
        ("byEnableProgramStatistics", BYTE), # 是否按节目统计，0-否，1-是
        ("byTriggerPeopleCountingData", BYTE), # 触发客流统计数据的使能, 0-否，1-是
        ("byMultiChannelSearch", BYTE), # 多通道查询使能, 0-否，1-是（pSearchChannel 、dwSearchChannelNum有效）
        ("dwPlayScheduleNo", DWORD), # 按节目统计时关联的日程号
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("byRes1", BYTE * 3),
        ("dwSearchChannelNum", DWORD), # 查询通道数目
        ("pSearchChannel", CHARP), # 查询通道号，大小为sizeof(DWORD)* dwSearchChannelNum
        ("byChild", BYTE), # 只检测儿童, 0-否，1-是
        ("byMinTimeInterva", BYTE), #  最小时间间隔,0-无效，1-15分钟, 2-30分钟, 3一小时, 4-天, 5-周, 6-月
        ("byStatisticType", BYTE), # 统计类型，0-无效值，1-进入人数，2-离开人数，3-全部,4-进入离开重复人数,5-人脸属性(需要下发具体支持的人脸属性),0-无效值表示不进行统计类型的条件查询，相当于保留字节。全部表示统计类型为进入和离开（不包括经过）。
        ("byFaceExpression", BYTE),
        ("byGender", BYTE),
        ("byMask", BYTE),
        ("byAgeGroup", BYTE),
        ("byGlasses", BYTE), # 是否带眼镜，0-未知，1-是，2-否，3-戴墨镜,  4 - 全部,  0xff-算法支持，但是没有识别出来
        ("byRes", BYTE * 96),
    ]


LPNET_DVR_PDC_QUERY_COND = POINTER(NET_DVR_PDC_QUERY_COND)


class NET_DVR_PROGRAM_INFO(Structure):
    _fields_ = [
        ("dwProgramNo", DWORD), # 节目编号
        ("sProgramName", BYTE * NAME_LEN), # 节目名称
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_PROGRAM_INFO = POINTER(NET_DVR_PROGRAM_INFO)


class NET_DVR_POSINFO_OVERLAY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), #  Pos信息叠加，0-不叠加，1-叠加
        ("byBackpackEnanble", BYTE), # 是否叠加背包信息是否叠加，0-不叠加，1-叠加
        ("bySexEnanble", BYTE), # 是否叠加性别信息是否叠加，0-不叠加，1-叠加
        ("byCarryEnanble", BYTE), # 是否叠加拎东西信息是否叠加，0-不叠加，1-叠加
        ("byRideEnanble", BYTE), # 是否叠加骑车信息是否叠加，0-不叠加，1-叠加
        ("byMaskEnanble", BYTE), # 是否叠加带口罩信息是否叠加，0-不叠加，1-叠加
        ("byHatEnanble", BYTE), # 是否叠加戴帽子信息是否叠加，0-不叠加，1-叠加
        ("bySleeveEnanble", BYTE), # 是否叠加长短袖情况，0-不叠加，1-叠加
        ("byPantsTypeEnanble", BYTE), # 是否叠加裤子属性信息是否叠加，0-不叠加，1-叠加
        ("byHairEnanble", BYTE), # 是否叠加长短发信息是否叠加，0-不叠加，1-叠加
        ("byGlassesEnanble", BYTE), # 是否叠加戴眼镜信息是否叠加，0-不叠加，1-叠加
        ("byAgeEnanble", BYTE), # 是否叠加年龄信息是否叠加，0-不叠加，1-叠加
        ("byHeightEnanble", BYTE), # 是否叠加身高信息是否叠加，0-不叠加，1-叠加
        ("byRes", BYTE * 511),
    ]


LPNET_DVR_POSINFO_OVERLAY = POINTER(NET_DVR_POSINFO_OVERLAY)


class NET_DVR_PDC_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartTime", NET_DVR_TIME_EX), # 开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 结束时间
        ("dwEnterNum", DWORD), # 进入人数
        ("dwLeaveNum", DWORD), # 离开人数
        ("struProgramInfo", NET_DVR_PROGRAM_INFO), # 节目信息
        ("dwPeoplePassing", DWORD), # 经过人数
        ("byRes1", BYTE * 8), # 保留字节
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("byRes3", BYTE * 3), # 保留字节
        ("dwDuplicatePeople", DWORD), #  重复人数
        ("dwExpressionUnknown", DWORD), # 表情未知
        ("dwPokerFace", DWORD), # 表情中性
        ("dwHappy", DWORD), # 表情高兴
        ("dwSurprised", DWORD), # 表情惊讶
        ("dwDisgusted", DWORD), # 表情厌恶
        ("dwSad", DWORD), # 表情难过
        ("dwAngry", DWORD), # 表情愤怒
        ("dwContemptuous", DWORD), # 表情轻蔑
        ("dwPanic", DWORD), # 表情害怕
        ("dwGenderUnknown", DWORD), # 性别未知
        ("dwFemale", DWORD), # 性别女
        ("dwMale", DWORD), # 性别男
        ("dwMaskUnknown", DWORD), # 面具未知
        ("dwMaskYes", DWORD), # 戴面具
        ("dwMaskNo", DWORD), # 不戴面具
        ("dwGlassUnknown", DWORD), # 眼镜未知
        ("dwGlassYes", DWORD), # 戴眼镜
        ("dwGlassNo", DWORD), # 不戴眼镜
        ("dwSunglasses", DWORD), # 墨镜
        ("dwAgeGroupUnknown", DWORD), # 年龄段未知
        ("dwChild", DWORD), # 年龄段少年
        ("dwYoung", DWORD), # 年龄段青年
        ("dwMiddle", DWORD), # 年龄段中年
        ("dwOld", DWORD), # 年龄段老年
        ("dwInfant", DWORD), # 年龄段婴幼儿
        ("dwKid", DWORD), # 年龄段儿童
        ("dwTeenager", DWORD), # 年龄段青少年
        ("dwPrime", DWORD), # 年龄段壮年
        ("dwMiddleAged", DWORD), # 年龄段中老年
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PDC_RESULT = POINTER(NET_DVR_PDC_RESULT)


class NET_DVR_MOBILE_PLATE_RECOGCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDefaultCHN", BYTE * MAX_CHJC_NUM), # 设备运行省份的汉字简写  3
        ("byTimeOsd", BYTE), #  时间信息叠加 0 - 不叠加， 1- 叠加
        ("byRecogResultOsd", BYTE), # 识别结果叠加  0 - 不叠加， 1- 叠加
        ("byRecogHint", BYTE), # 识别成功提示 0 - 不提示， 1- 提示
        ("byRecogDir", BYTE), # 识别方向 0: 正向, 1: 背向
        ("byRecogEnv", BYTE), # 识别环境 0: 白天, 1: 晚上
        ("byRecogPlateType", BYTE), # 0-小车牌识别，1-大车牌识别
        ("byUploadPlate", BYTE), # 是否上传车牌 0 -不上传， 1-上传
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_MOBILE_PLATE_RECOGCFG = POINTER(NET_DVR_MOBILE_PLATE_RECOGCFG)


class NET_DVR_MOBILE_RADAR_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableRadar", BYTE), #  0:不开启雷达  1:开启雷达
        ("byEnableAlarm", BYTE), #  0:不开启报警  1:开启报警
        ("wOverSpeed", WORD), #  范围为20~250
        ("bySpeedUnits", BYTE), #  0:公里/小时   1:英里/小时
        ("bydirection", BYTE), #  0:反向（雷达与车相向） 1:正向（雷达与车反向）
        ("byMeasureMode", BYTE), #  0:静态 (雷达状态)       1:动态 (雷达状态)
        ("byTargetType", BYTE), #  0:最快(雷达测速车辆最快)  1:最近(雷达测速车辆最近)
        ("bySensitivity", BYTE), #  灵敏度[0,100]
        ("byCaptureNum", BYTE), #  抓拍张数[0,255]
        ("byUploadPlate", BYTE), # 是否上传超速抓拍图片 0-不上传，1-上传
        ("byRes", BYTE * 61),
    ]


LPNET_DVR_MOBILE_RADAR_CFG = POINTER(NET_DVR_MOBILE_RADAR_CFG)


class NET_DVR_MOBILE_LOCALPLATECHK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCheck", BYTE), #  稽查任务是否进行黑名单稽查 0-稽查，1-不稽查
        ("byCheckAlarm", BYTE), #  稽查成功报警 0-不报警，1-报警
        ("byCheckHint", BYTE), #  稽查成功提示 (软件提示) 0-不提示，1-提示
        ("byUploadBlackCar", BYTE), # 是否上传黑车信息 0-不上传，1-上传
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_MOBILE_LOCALPLATECHK_CFG = POINTER(NET_DVR_MOBILE_LOCALPLATECHK_CFG)


class NET_DVR_VEHICLE_CHECK(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号0xff - 全部通道（默认是1,代表一个通道）
        ("struPlateInfo", NET_DVR_PLATE_INFO), # 车牌信息
        ("wIllegalType", WORD), # 违章类型采用国标定义 （参考附件）
        ("byRes", BYTE * 2),
        ("sIllegalTypeInfo", CHAR * 128), #  违规类型信息（128）
        ("struIllegalTime", NET_DVR_TIME_V30), # 违规时间
        ("byIllegalVehicleNum", BYTE), # 车辆违法次数
        ("byRes1", BYTE * 3),
        ("sCustomInfo", CHAR * 64), # 自定义信息
        ("byRes2", BYTE * 128), #  保留字节
    ]


LPNET_DVR_VEHICLE_CHECK = POINTER(NET_DVR_VEHICLE_CHECK)


ENUM_DVR_VEHICLE_CHECK = 1
ENUM_MSC_SEND_DATA = 2
ENUM_ACS_SEND_DATA = 3
ENUM_TME_CARD_SEND_DATA = 4
ENUM_TME_VEHICLE_SEND_DATA = 5
ENUM_DVR_DEBUG_CMD = 6
ENUM_DVR_SCREEN_CTRL_CMD = 7
ENUM_CVR_PASSBACK_SEND_DATA = 8
ENUM_ACS_INTELLIGENT_IDENTITY_DATA = 9
ENUM_VIDEO_INTERCOM_SEND_DATA = 10
ENUM_SEND_JSON_DATA = 11


ENUM_DVR_ERROR_CODE = 1
ENUM_MSC_RECV_DATA = 2
ENUM_ACS_RECV_DATA = 3


class NET_DVR_WIPER_CONTINUEWORK_PARAM(Structure):
    _fields_ = [
        ("byWorkTimeInterval", BYTE), # 工作时间间隔（单位：秒）[2s~60s]
        ("byRes", BYTE * 3),
        ("dwContinueWorkTime", DWORD), # 持续工作时间（单位：秒）[2min~24h]界面显示按分钟单位
        ("byRes1", BYTE * 8),
    ]


LPNET_DVR_WIPER_CONTINUEWORK_PARAM = POINTER(NET_DVR_WIPER_CONTINUEWORK_PARAM)


class NET_DVR_WIPERMODE_PARAM_UNION(Union):
    _fields_ = [
        ("uLen", BYTE * 16),
        # 当byWiperWorkMode = 1时生效
        ("struWiperContinueWorkParam", NET_DVR_WIPER_CONTINUEWORK_PARAM),
    ]


LPNET_DVR_WIPERMODE_PARAM_UNION = POINTER(NET_DVR_WIPERMODE_PARAM_UNION)


class NET_DVR_WIPERINFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 雨刷工作模式
        # 0-单次模式，1-持续模式（针对配置结构NET_DVR_ROTATE_OPERATE_PARAM），2-智能模式，0xff-关闭
        ("byWiperWorkMode", BYTE),
        ("byRes1", BYTE),
        ("wSensitivity", WORD), # 降雨灵敏度
        ("byRes", BYTE * 20),
        ("ustruWiperModeParam", NET_DVR_WIPERMODE_PARAM_UNION),
    ]


LPNET_DVR_WIPERINFO_CFG = POINTER(NET_DVR_WIPERINFO_CFG)


# 保存自动对焦参数
class NET_DVR_AUTOFOCUS_TESTCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 24), #  保留字节
    ]


LPNET_DVR_AUTOFOCUS_TESTCFG = POINTER(NET_DVR_AUTOFOCUS_TESTCFG)


class NET_DVR_VIDEO_OUT_CFG(Structure):
    _fields_ = [
        ("byDisplayMode", BYTE), # 显示模式，1-标准，2-冷色，3-暖色，0xff-自定义
        ("byBrightnessLevel", BYTE), #  亮度值0-100
        ("byContrastLevel", BYTE), #  对比度0-100
        ("bySharpnessLevel", BYTE), #  锐度0-100
        ("bySaturationLevel", BYTE), #  饱和度0-100
        ("byHueLevel", BYTE), #  色调0-100
        ("byImageMode", BYTE), #  图像模式，0-正常模式，1-夜模式1，2-夜模式2，3-夜模式3，4-日照模式1，5-日照模式2，6-日照模式3
        ("byRes", BYTE * 5), #  保留
    ]


LPNET_DVR_VIDEO_OUT_CFG = POINTER(NET_DVR_VIDEO_OUT_CFG)


# 色温
class NET_DVR_COLOR_TEMPERATURE_CFG(Structure):
    _fields_ = [
        ("byRed", BYTE), # 红色， 0-100
        ("byGreen", BYTE), # 绿色， 0-100
        ("byBlue", BYTE), # 蓝色，0-100
        ("byRedOffset", BYTE), # 红色偏移，0-100
        ("byGreenOffset", BYTE), # 绿色偏移，0-100
        ("byBlueOffset", BYTE), # 蓝色偏移，0-100
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_COLOR_TEMPERATURE_CFG = POINTER(NET_DVR_COLOR_TEMPERATURE_CFG)


class NET_DVR_ADC_CFG(Structure):
    _fields_ = [
        ("byGainR", BYTE), # 增益R， 0-100
        ("byGainG", BYTE), # 增益G，0-100
        ("byGainB", BYTE), # 增益B，0-100
        ("byOffsetR", BYTE), # 偏移量R，0-100
        ("byOffsetG", BYTE), # 偏移量G，0-100
        ("byOffsetB", BYTE), # 偏移量B，0-100
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_ADC_CFG = POINTER(NET_DVR_ADC_CFG)


class NET_DVR_SCREEN_EDGE_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用屏幕边缘 0-不启用 1-启用
        ("byLeftEdge", BYTE), # 左边缘，0-100
        ("byRightEdge", BYTE), # 右边缘，0-100
        ("byTopEdge", BYTE), # 上边缘，0-100
        ("byLowerEdge", BYTE), # 下边缘，0-100
        ("byRes", BYTE * 7),
    ]


LPNET_DVR_SCREEN_EDGE_CFG = POINTER(NET_DVR_SCREEN_EDGE_CFG)


class NET_DVR_SCREEN_DISPLAY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCfgType", BYTE), # 设置的参数类型，获取时此参数无效，0-无效，1-背光参数，2-视频参数，3-色温参数，4-ADC参数，5-屏幕边缘参数
        ("byBackLight", BYTE), # 背光 0~100
        ("byRes1", BYTE * 2),
        ("struVideoOutCfg", NET_DVR_VIDEO_OUT_CFG), # 视频参数（画面模式）
        ("struColorTempCfg", NET_DVR_COLOR_TEMPERATURE_CFG), # 色温参数
        ("struAdcCfg", NET_DVR_ADC_CFG), # ADC参数
        ("struScreenEdgeCfg", NET_DVR_SCREEN_EDGE_CFG), # 屏幕边缘参数
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_SCREEN_DISPLAY_CFG = POINTER(NET_DVR_SCREEN_DISPLAY_CFG)


# 模拟遥控类型
REMOTE_CTRL_POWERSUPPLY_OPEN = 1
REMOTE_CTRL_POWERSUPPLY_CLOSE = 2
REMOTE_CTRL_SIGNALSOURCE = 3
REMOTE_CTRL_MENU = 4
REMOTE_CTRL_DETERMINATION = 5
REMOTE_CTRL_ON = 6
REMOTE_CTRL_UNDER = 7
REMOTE_CTRL_LEFT = 8
REMOTE_CTRL_RIGHT = 9
REMOTE_CTRL_INFO = 10
REMOTE_CTRL_RETURN = 11
REMOTE_CTRL_NUM = 12


# 模拟遥控按键
class NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byControlType", BYTE), # 1-电源开，2-电源关，3-信号源，4-菜单，5-确定，6-上，7-下，8-左，9-右,  10-INFO, 11-返回上一层,12-数字按键,13-开关一体按键
        ("byControlParam", BYTE), # 操作参数，操作类型为12时，表示按键值（0-9），其他操作时此参数无效
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL = POINTER(NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL)


# 屏幕信号源配置
class NET_DVR_SCREEN_SIGNAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySignalSourceType", BYTE), # 输入源索引，见枚举 NET_DVR_CAM_MODE
        ("byNoSignalPic", BYTE), # 无信号画面模式，1-蓝屏，2-黑屏，3-LOGO画面
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_SCREEN_SIGNAL_CFG = POINTER(NET_DVR_SCREEN_SIGNAL_CFG)


# 屏幕拼接配置
class NET_DVR_SCREEN_SPLICE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySpliceIndex", BYTE), # 自拼接屏号，0就是没有拼接，其他值表示自拼接屏的屏号。例如拼接0101~0202这4块屏，则这4块屏的bySpliceIndex必须相同，且非0.
        ("bySpliceX", BYTE), # 屏幕在自拼接屏中的行位置
        ("bySpliceY", BYTE), # 屏幕在自拼接屏中的列位置
        ("byWidth", BYTE), # 拼接规模宽，以屏幕为单位
        ("byHeight", BYTE), # 拼接规模高，以屏幕为单位
        ("byRes", BYTE * 11),
    ]


LPNET_DVR_SCREEN_SPLICE_CFG = POINTER(NET_DVR_SCREEN_SPLICE_CFG)


# 风扇工作方式配置
class NET_DVR_SCREEN_FAN_WORK_MODE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWorkMode", BYTE), # 1-常开，2-自动
        ("byTemperatureLimitValue", BYTE), # 风扇开启的温度阀值，工作模式为自动时该参数有效。
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_SCREEN_FAN_WORK_MODE_CFG = POINTER(NET_DVR_SCREEN_FAN_WORK_MODE_CFG)


# VGA信号配置
class NET_DVR_SCREEN_VGA_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableAutoAdjust", BYTE), # 是否自动调整，0-否，1-是，当自动调整启用时以下参数无效
        ("byHorizontalPosition", BYTE), # 水平位置 0-100
        ("byVerticalPosition", BYTE), # 垂直位置 0-100
        ("byClock", BYTE), # 时钟 ，0-100
        ("byPhase", BYTE), # 相位，0-100
        ("byRes", BYTE * 11),
    ]


LPNET_DVR_SCREEN_VGA_CFG = POINTER(NET_DVR_SCREEN_VGA_CFG)


# 屏幕菜单配置
class NET_DVR_SCREEN_MENU_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMenuLanguage", BYTE), # 语言，1-中文，2-英文
        ("byTransparency", BYTE), # 透明度 0-不透明，1-低，2-中，3-高
        ("byDuration", BYTE), # 持续时间，0-常开，1-5秒，2-15秒，3-30秒
        ("byRes", BYTE * 13),
    ]


LPNET_DVR_SCREEN_MENU_CFG = POINTER(NET_DVR_SCREEN_MENU_CFG)


# 画中画
class NET_DVR_PIP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用画中画 0-不启用 1-启用
        ("bySubWindowSource", BYTE), # 子画面信号源，参考枚举NET_DVR_CAM_MODE
        ("bySubWindowBorderColor", BYTE), # 子画面边框颜色， 1-蓝色，2-黑色
        ("byRes1", BYTE),
        ("struPosition", NET_DVR_RECTCFG), # 子画面位置，屏幕总大小为100*100
        ("byRes2", BYTE * 12),
    ]


LPNET_DVR_PIP_CFG = POINTER(NET_DVR_PIP_CFG)


# 透雾配置
class NET_DVR_DEFOG_LCD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDefogEnable", BYTE), # 开启透雾开关，0~关闭，1~开启
        ("byDefogModel", BYTE), # 透雾模式，0~自动去雾，1~手动去雾
        ("byDefogLevel", BYTE), # 透雾强度等级，1-7个等级，默认等级为4。等级1为0.5；等级2为0.55；等级3为0.60；等级4为0.65；等级5为0.70；等级6为0.75；等级7为0.80。（去雾模式为手动去雾时，可配置去雾强度等级）
        ("byRes", BYTE * 33),
    ]


LPNET_DVR_DEFOG_LCD = POINTER(NET_DVR_DEFOG_LCD)


# 屏幕维墙
class NET_DVR_SCREEN_WALL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 状态开关。0-为关闭；1-为开启
        ("byRes", BYTE * 35),
    ]


LPNET_DVR_SCREEN_WALL_CFG = POINTER(NET_DVR_SCREEN_WALL_CFG)


# 屏幕位置
class NET_DVR_SCREEN_POS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byScreenRowNum", BYTE), # 屏幕行号。
        ("byScreenColNum", BYTE), # 屏幕列号。
        ("byRes", BYTE * 34),
    ]


LPNET_DVR_SCREEN_POS_CFG = POINTER(NET_DVR_SCREEN_POS_CFG)


class NET_DVR_VIDEO_AUDIOIN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体的长度
        ("dwChanNo", DWORD), # 视音频通道号， 绑定且启用后，被绑定的语音对讲通道则作为该通道的音频源
        ("byEnable", BYTE), # 是否启用语音对讲作为音频输入源 0-不启用 1-启用
        ("byRes", BYTE * 31), # 保留
    ]


LPNET_DVR_VIDEO_AUDIOIN_CFG = POINTER(NET_DVR_VIDEO_AUDIOIN_CFG)


class NET_DVR_VCA_DETECTION_CFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 使能
        ("byRes1", BYTE * 3),
        ("struAlarmSched", NET_DVR_SCHEDTIME * MAX_DAYS),
        ("dwHandleType", DWORD), # 异常处理,异常处理方式的"或"结果
        # 0x00: 无响应
        # 0x01: 监视器上警告
        # 0x02: 声音警告
        # 0x04: 上传中心
        # 0x08: 触发报警输出
        # 0x10: 触发JPRG抓图并上传Email
        # 0x20: 无线声光报警器联动
        # 0x40: 联动电子地图(目前只有PCNVR支持)
        # 0x200: 抓图并上传FTP
        ("dwMaxRelAlarmOutChanNum", DWORD), # 触发的报警输出通道数（只读）最大支持数量
        ("dwRelAlarmOut", DWORD * MAX_ALARMOUT_V40), # * 实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0开始顺序读取，如果遇到0xffffffff则后续无效
        # 触发的录像通道
        ("dwMaxRecordChanNum", DWORD), # 设备支持的最大关联录像通道数-只读
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V40), #  实际触发录像通道，按值表示,采用紧凑型排列，从下标0开始顺序读取，如果遇到0xffffffff,则后续无效
        ("dwEnablePresetChanNum", DWORD), # 当前已启用预置点的数目
        ("struPresetChanInfo", NET_DVR_PRESETCHAN_INFO * MAX_CHANNUM_V40), # 启用的预置点信息，当dwEnablePresetChanNum不为0时，数组下标0-(dwEnablePresetChanNum -1)有效，当为0时，表示未启用预置点
        ("byRes2", BYTE * 516), # 保留
        ("dwEnableCruiseChanNum", DWORD), # 当前已启用巡航的通道数目
        ("struCruiseChanInfo", NET_DVR_CRUISECHAN_INFO * MAX_CHANNUM_V40), # 启用巡航功能通道的信息，当dwEnableCruiseChanNum不为0时，数组下标0-( dwEnableCruiseChanNum -1)有效，当为0时，表示未启用巡航
        ("dwEnablePtzTrackChanNum", DWORD), # 当前已启云台轨迹通道数目
        ("struPtzTrackInfo", NET_DVR_PTZTRACKCHAN_INFO * MAX_CHANNUM_V40), # 调用云台轨迹的通道信息，当dwEnablePtzTrackChanNum不为0时，数组下标0-(dwEnablePresetChanNum -1)有效，当为0时，表示未启用云台轨迹
        ("struHolidayTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 假日布防时间
        ("byRes", BYTE * 224),
    ]


LPNET_DVR_VCA_DETECTION_CFG_V40 = POINTER(NET_DVR_VCA_DETECTION_CFG_V40)


class NET_DVR_CLOUD_STORAGE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnableCS", BYTE), # 开启云存储服务  0-关闭 1-开启
        ("byRes", BYTE * 511), # 保留
    ]


LPNET_DVR_CLOUD_STORAGE_CFG = POINTER(NET_DVR_CLOUD_STORAGE_CFG)


class NET_DVR_CHAN_RECORD_STATUS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byValid", BYTE), # 是否有效
        # (只读)录像类型，0: 不在录像；1：在录像 2-空闲
        # 3-无连接 4-无输入视频 5-未加载 6-存档中 7-回传中
        # 8-用户名或密码错 9-未验证,10-存档中和录像中 11-录像回传中和录像中
        ("byRecord", BYTE),
        ("dwRelatedHD", DWORD), # 关联磁盘
        ("byOffLineRecord", BYTE), # 断网录像功能 0-关闭 1-开启
        ("byRes", BYTE * 63), # 保留字节
    ]


LPNET_DVR_CHAN_RECORD_STATUS_CFG = POINTER(NET_DVR_CHAN_RECORD_STATUS_CFG)


MAX_CAMERAID_LEN = 64
class NET_DVR_UPLOAD_RECORD_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRecordType", DWORD), # 录像类型  0- 定时录像，1- 移动侦测录像，2- 报警录像，3- 报警或移动侦测录像，4- 报警和移动侦测录像， 5- 命令触发，6- 手动录像，7- 震动报警，8- 环境触发报警，9- 智能报警，10- 回传录像
        ("sCameraID", BYTE * MAX_CAMERAID_LEN), # camera id
        ("struStartTime", NET_DVR_TIME_EX), # 录像开始时间
        ("struStopTime", NET_DVR_TIME_EX), # 录像结束时间
        ("dwStoragePoolID", DWORD), # 存储池ID
        ("byFormatType", BYTE), # 封装类型：1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP，9-RTP+PS（国标：GB28181），0xff-无效
        ("byVideoEncType", BYTE), # 视频编码类型：0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，8-MPEG2，0xfe- 自动（和源一致），0xff-无效
        ("byAudioEncType", BYTE), # 音频编码类型：0-G722，1-G711_U，2-G711_A，5-MP2L2，6-G726，7-AAC，0xfe- 自动（和源一致），0xff-无效
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("byRes", BYTE * 120),
    ]


LPNET_DVR_UPLOAD_RECORD_INFO = POINTER(NET_DVR_UPLOAD_RECORD_INFO)


# 补光灯参数配置  条件结构体
class NET_DVR_IOOUT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySyncOutputNo", BYTE), # 同步输出号(0-F1,1-F2,2-F3)
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_IOOUT_COND = POINTER(NET_DVR_IOOUT_COND)


# 信号灯同步参数
class NET_DVR_SIGNAL_SYNCCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wPhase", WORD), # 相位(0~360)
        ("byLineLock", BYTE), # 电源同步 0-否，1-是
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_SIGNAL_SYNCCFG = POINTER(NET_DVR_SIGNAL_SYNCCFG)


#  萤石EZVIZ接入参数结构体
class NET_DVR_EZVIZ_ACCESS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), #  启用EZVIZ接入 0～禁用，1～启用
        # ******** IPC5.1.7 新增参数 Begin 2014-03-21**********
        ("byDeviceStatus", BYTE), # 设备是否在线状态，0-保留，1-在线，2-离线
        ("byAllowRedirect", BYTE), # 是否允许重定向,0-保留,1-是,2-否,0表示保持不变,兼容老SDK接新设备的情况
        ("byDomainName", BYTE * MAX_DOMAIN_NAME), # 域名服务器地址
        ("byRes1", BYTE),
        ("byVerificationCode", BYTE * NET_SDK_MAX_VERIFICATION_CODE_LEN), # 萤石云验证码
        ("byNetMode", BYTE), # 网络模式，0-无意义，1-自动，2-有线网络优先，3-有线网络(默认)，4-无线网络
        ("byOfflineStatus", BYTE), # 设备离线具体状态: 0-保留，1-萤石注册验证码无效。该字段为只读，且当DeviceStatus为2时生效。
        ("byEnableTiming", BYTE), #  启用EZVIZ校时 0～禁用，1～启用
        ("byRes2", BYTE),
        ("byOperateCode", BYTE * NET_SDK_MAX_OPERATE_CODE_LEN), # 操作码，用户绑定设备时使用
        ("byRes", BYTE * 344),
    ]


LPNET_DVR_EZVIZ_ACCESS_CFG = POINTER(NET_DVR_EZVIZ_ACCESS_CFG)


class NET_DVR_ALARM_RELATE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        #
        # 0表示移动侦测，
        # 1表示视频遮挡，
        # 2表示视频丢失，
        # 3表示PIR报警，
        # 4表示无线报警，
        # 5表示呼救报警，
        # 6表示智能抓图，
        # 7表示人脸侦测，
        # 8表示越界侦测侦测，
        # 9表示区域入侵侦测，
        # 10表示场景变更侦测，
        # 11 表示异常侦测，
        # 0xff 表示报警输入
        #
        ("byAlarmType", BYTE),
        # 联动动作 0-无效,1-抓图上传FTP,2-Jpeg抓图上传Email
        ("byRelateActType", BYTE),
        ("byRes", BYTE * 2),
        # 报警输入号或者通道号或者无线编号
        # (当byAlarmType ==0xff时,dwChannel表示的是报警输入号)
        # (当byAlarmType ==4时,dwChannel表示的是无线编号)
        ("dwChannel", DWORD),
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_ALARM_RELATE_COND = POINTER(NET_DVR_ALARM_RELATE_COND)


class NET_DVR_ALARM_RELATE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMaxRelateChanNum", DWORD), # 触发的报警关联通道数（只读）最大支持数量
        # dwRelateChan的初始值是0xffffffff;数组内填写是实际的通道号;
        ("dwRelateChan", DWORD * MAX_CHANNUM_V40),
        ("byRes1", BYTE * 256),
    ]


LPNET_DVR_ALARM_RELATE_CFG = POINTER(NET_DVR_ALARM_RELATE_CFG)


class NET_DVR_PTZ_BASICPARAMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byProportionalPan", BYTE), # 启用比例变倍配置 0-否，1-是
        ("byPresetFreezing", BYTE), # 启用预置点视频冻结 0-否，1-是
        ("byPresetSpeed", BYTE), # 预置点速度等级 1--8，默认4
        ("byKeyboardCtrlSpeed", BYTE), # 手控速度等级0-低,1-中,2-高
        ("byAutoScanSpeed", BYTE), # 扫描速度等级：1--40，默认28
        ("byZoomingSpeed", BYTE), # 变倍速度：1--3，默认3
        ("byManualControlSpeed", BYTE), # 手控速度模式：0-兼容，1-行人，2-非机动车，3-机动车，4-自适应
        ("byPTZMotionTrack", BYTE), # 启用运动跟踪（锁定云台操作） 0-默认（开启），1-关闭
        ("byRes", BYTE * 124),
    ]


LPNET_DVR_PTZ_BASICPARAMCFG = POINTER(NET_DVR_PTZ_BASICPARAMCFG)


class NET_DVR_PTZ_OSDCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byZoomStatus", BYTE), # 镜头倍数显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
        ("byPtStatus", BYTE), # 方位角显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
        ("byPresetStatus", BYTE), # 预置点标题显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
        ("byPositionDisplayFormat", BYTE), # 方位角显示格式 0-按照PT显示(例 P179|T-02)，1-按照方位显示(SE123|T-02)
        ("byRes", BYTE * 124),
    ]


LPNET_DVR_PTZ_OSDCFG = POINTER(NET_DVR_PTZ_OSDCFG)


class NET_DVR_PTZ_POWEROFFMEMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byResumeTimePoint", BYTE), # 掉电记忆模式：Oxff-禁用、1-30秒、2-60秒、3-300秒、4-600秒，默认30秒
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_PTZ_POWEROFFMEMCFG = POINTER(NET_DVR_PTZ_POWEROFFMEMCFG)


class NET_DVR_PTZ_LIMITCOND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("byLimitMode", BYTE), # 限位模式 0-保留，1-键控限位，2-扫描限位
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_PTZ_LIMITCOND = POINTER(NET_DVR_PTZ_LIMITCOND)


class NET_DVR_PTZ_LIMITCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 启用使能，0-否，1-是
        ("byLimitStatus", BYTE), # 限位状态 0-未限位，1-已限位（不可编辑）
        ("byRes", BYTE * 122),
    ]


LPNET_DVR_PTZ_LIMITCFG = POINTER(NET_DVR_PTZ_LIMITCFG)


class NET_DVR_PTZ_LIMITCTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("byLimitMode", BYTE), # 限位模式 0-保留，1-键控限位，2-扫描限位
        ("byWorkMode", BYTE), # 0-设置，1-清除
        ("byRes", BYTE * 122),
    ]


LPNET_DVR_PTZ_LIMITCTRL = POINTER(NET_DVR_PTZ_LIMITCTRL)


class NET_DVR_PTZ_LOCKCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWorkMode", BYTE), # 云台锁定控制 0-解锁，1-锁定
        ("byRes", BYTE * 123),
    ]


LPNET_DVR_PTZ_LOCKCFG = POINTER(NET_DVR_PTZ_LOCKCFG)


class NET_DVR_PTZLOCKINFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_PTZLOCKINFO_COND = POINTER(NET_DVR_PTZLOCKINFO_COND)


class NET_DVR_PTZLOCKINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRemainingSec", DWORD), # 剩余秒数
        ("byRes", BYTE * 128), # 保留字节
    ]


LPNET_DVR_PTZLOCKINFO = POINTER(NET_DVR_PTZLOCKINFO)


class NET_DVR_CRUISEPOINT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("wRouteNo", WORD), # 巡航路径号
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_CRUISEPOINT_COND = POINTER(NET_DVR_CRUISEPOINT_COND)


class NET_DVR_CRUISEPOINT_PARAM(Structure):
    _fields_ = [
        ("wPresetNo", WORD), # 预置点
        ("wDwell", WORD), # 停留时间
        ("bySpeed", BYTE), # 速度
        ("bySupport256PresetNo", BYTE), # 兼容之前的 第256号预置点是否生效
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_CRUISEPOINT_PARAM = POINTER(NET_DVR_CRUISEPOINT_PARAM)


class NET_DVR_CRUISEPOINT_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 最大支持128个巡航点
        ("struCruisePoint", NET_DVR_CRUISEPOINT_PARAM * MAX_CRUISE_POINT_NUM),
        ("Res", BYTE * 64), # 保留
    ]


LPNET_DVR_CRUISEPOINT_V40 = POINTER(NET_DVR_CRUISEPOINT_V40)


class NET_DVR_CRUISEPOINT_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 最大支持256个巡航点
        ("struCruisePoint", NET_DVR_CRUISEPOINT_PARAM * MAX_CRUISEPOINT_NUM_V50),
        ("Res", BYTE * 64), # 保留
    ]


LPNET_DVR_CRUISEPOINT_V50 = POINTER(NET_DVR_CRUISEPOINT_V50)


class NET_DVR_TEST_VERSION_HEAD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwParam1", DWORD),
        ("byParam2", BYTE),
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_TEST_VERSION_HEAD = POINTER(NET_DVR_TEST_VERSION_HEAD)


class NET_DVR_TEST_VERSION_HEAD_V1(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwParam1", DWORD),
        ("byParam2", BYTE),
        ("byRes", BYTE * 31),
        ("dwParam1_1", DWORD),
        ("byParam1_2", BYTE),
        ("byRes1", BYTE * 31),
    ]


LPNET_DVR_TEST_VERSION_HEAD_V1 = POINTER(NET_DVR_TEST_VERSION_HEAD_V1)


class NET_DVR_TEST_VERSION_HEAD_V2(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwParam1", DWORD),
        ("byParam2", BYTE),
        ("byRes", BYTE * 31),
        ("dwParam1_1", DWORD),
        ("byParam1_2", BYTE),
        ("byRes1", BYTE * 31),
        ("dwParam2_1", DWORD),
        ("byParam2_2", BYTE),
        ("byRes2", BYTE * 31),
    ]


LPNET_DVR_TEST_VERSION_HEAD_V2 = POINTER(NET_DVR_TEST_VERSION_HEAD_V2)


MAX_DISPLAY_NUM = 512 # 最大显示输出个数
MAX_LEDCONTENT_NUM = 512 # 虚拟LED字符串最大长度
MAX_PPT_CHAN = 128 # PPT长度
class NET_DVR_VIDEOWALLDISPLAYMODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("byRes1", BYTE * 3),
        ("struRect", NET_DVR_RECTCFG_EX), # 坐标范围，依据基准坐标计算出支持的拼控模式
        ("sName", BYTE * NAME_LEN), # 电视墙名称
        ("byRes2", BYTE * 100),
    ]


LPNET_DVR_VIDEOWALLDISPLAYMODE = POINTER(NET_DVR_VIDEOWALLDISPLAYMODE)


class NET_DVR_DISPLAYPARAM(Structure):
    _fields_ = [
        ("dwDisplayNo", DWORD), # 显示输出号
        ("byDispChanType", BYTE), # 输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, \
        # 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI,11-VGA/DVI自适应，12-HDBaseT,13-HDTVI, 14-TVI，0xff-无效
        #
        ("byRes", BYTE * 11),
    ]


LPNET_DVR_DISPLAYPARAM = POINTER(NET_DVR_DISPLAYPARAM)


class NET_DVR_DISPLAYCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDisplayParam", NET_DVR_DISPLAYPARAM * MAX_DISPLAY_NUM),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_DISPLAYCFG = POINTER(NET_DVR_DISPLAYCFG)


class NET_DVR_VIDEOWALLDISPLAYPOSITION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE),
        ("byCoordinateType", BYTE), # 坐标类型。0-基准坐标，1-实际坐标
        ("byRes1", BYTE * 2),
        # 墙号,1字节墙号+3字节保留
        ("dwVideoWallNo", DWORD),
        ("dwDisplayNo", DWORD), # 显示输出号
        # 坐标须为基准坐标的整数倍（1920*1920），宽度和高度值不用设置，即为基准值
        ("struRectCfg", NET_DVR_RECTCFG_EX),
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_VIDEOWALLDISPLAYPOSITION = POINTER(NET_DVR_VIDEOWALLDISPLAYPOSITION)


# 窗口信息
class NET_DVR_VIDEOWALLWINDOWPOSITION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 窗口使能,0-不使能，1-使能
        ("byWndOperateMode", BYTE), # 窗口操作模式，0-统一坐标，1-分辨率坐标
        ("byRes1", BYTE * 6),
        ("dwWindowNo", DWORD), # 窗口号
        ("dwLayerIndex", DWORD), # 窗口相对应的图层号，图层号到最大即置顶，置顶操作
        ("struRect", NET_DVR_RECTCFG_EX), # 目的窗口统一坐标(相对显示墙)，获取或按统一坐标设置时有效
        ("struResolution", NET_DVR_RECTCFG_EX), # 目的窗口分辨率坐标，获取或按分辨率坐标设置有效
        ("dwXCoordinate", DWORD), # LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
        ("dwYCoordinate", DWORD), # LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
        ("byRes2", BYTE * 36),
    ]


LPNET_DVR_VIDEOWALLWINDOWPOSITION = POINTER(NET_DVR_VIDEOWALLWINDOWPOSITION)


class NET_DVR_VIDEO_WALL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 窗口号：1字节墙号+1字节保留+2字节窗口号
        ("dwWindowNo", DWORD),
        ("dwSceneNo", DWORD), # 场景号
        ("dwDestWallNo", DWORD), # 目的墙号
        ("dwDestSceneNo", DWORD), # 目的场景号
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_VIDEO_WALL_INFO = POINTER(NET_DVR_VIDEO_WALL_INFO)


class NET_DVR_VIRTUALLED_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("byDispMode", BYTE), # 显示模式，1-透明，2-半透明，3-覆盖
        ("byWndOperateMode", BYTE), # 窗口操作模式，0-统一坐标，1-分辨率坐标
        ("byType", BYTE), # 虚拟LED类型，0-文本，1-时间
        ("byDirection", BYTE), # 虚拟LED方向，0-水平方向，1-垂直方向
        ("byTimeType", BYTE), # 时间类型，byType为1时有效，0-无效，1-只显示时间，2-显示日期和时间
        ("byDateFormat", BYTE), # 日期显示格式，byTimeType为2时有效
        # 0-无效，1-XXXX-XX-XX(年月日)，2-XX-XX-XXXX(月日年)，3-XX-XX-XXXX(日月年)，4-XXXX年XX月XX日，5-XX月XX日XXXX年，6-XX日XX月XXXX年
        ("byTimeFormat", BYTE), # 时间显示格式，byTimeType不为零时有效
        # 0-无效，1-H:MM:SS，2-HH:MM:SS
        ("struContentColor", NET_DVR_RGB_COLOR), # 字体颜色
        ("struBackColor", NET_DVR_RGB_COLOR), # 背景颜色
        ("struRect", NET_DVR_RECTCFG_EX),
        ("dwContentNum", DWORD), # 文本内容长度，byType为0时有效
        ("byLedContent", BYTE * MAX_LEDCONTENT_NUM), # 文本内容，byType为0时有效
        ("byMoveMode", BYTE), # 移动模式，1-普通；2-平滑；3-静止
        ("byFontSize", BYTE), # 字体大小，1-1倍，2-2倍，3-4倍
        ("byMoveDirection", BYTE), # 移动方向，0-默认（从左到右），1-从左到右，2-从右到左，3-从上到下，4-从下到上，动态虚拟LED时有效
        ("byMoveSpeed", BYTE), # 移动速度，1-速度1，2-速度2，动态虚拟LED时有效
        ("struResolution", NET_DVR_RECTCFG_EX), # 目的窗口分辨率坐标，获取或按分辨率坐标设置有效
        ("dwXCoordinate", DWORD), # LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
        ("dwYCoordinate", DWORD), # LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
        ("byHourFormat", BYTE), # 时间制式，byTimeType不为零时有效，0-无效，1-12小时制，2-24小时制
        ("byAMFormat", BYTE), # AM格式，byHourFormat为1时有效，0-无效，1-AM，2-上午
        ("byPMFormat", BYTE), # PM格式，byHourFormat为1时有效，0-无效，1-PM，2-下午
        ("byAlignmentX", BYTE), # 水平对齐方式，byDirection为0时有效，0-无效，1-左对齐，2-居中对齐，3-右对齐
        ("byAlignmentY", BYTE), # 垂直对齐方式，byDirection为1时有效，0-无效，1-顶端对齐，2-居中对齐，3-底端对齐
        ("byFontType", BYTE), # 字体类型，0-默认，1-宋体，2-黑体，3-楷体
        ("byRes2", BYTE * 90),
    ]


LPNET_DVR_VIRTUALLED_PARAM = POINTER(NET_DVR_VIRTUALLED_PARAM)


class NET_DVR_IMAGE_CUT_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCutMode", BYTE), # 图像切割模式，1-4:3,2-16:9
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_IMAGE_CUT_MODE = POINTER(NET_DVR_IMAGE_CUT_MODE)


class NET_DVR_USING_SERIALPORT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSerialPort", DWORD), # 当前使用串口号
        ("byProtocolType", BYTE), # 串口协议类型，1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 ， 4-LCD-DLP， 5-LCD-S3 , 6-LCD-D20，7-LCD-L2,8-LCD-Z1，9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_USING_SERIALPORT = POINTER(NET_DVR_USING_SERIALPORT)


class NET_DVR_VIDEOWALLSCENECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sSceneName", BYTE * NAME_LEN), # 场景名称
        ("byEnable", BYTE), # 场景是否有效 1-有效，0-无效
        ("bySceneIndex", BYTE), # 场景号，只能获取。获取所有场景时使用该参数
        ("byRes", BYTE),
    ]


LPNET_DVR_VIDEOWALLSCENECFG = POINTER(NET_DVR_VIDEOWALLSCENECFG)


class NET_DVR_SCENE_CONTROL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struVideoWallInfo", NET_DVR_VIDEO_WALL_INFO), # 电视墙信息
        ("dwCmd", DWORD), # 场景控制命令，1-场景模式切换（如果要切换的是当前场景，则不进行切换），2-初始化场景（将此场景的配置清空，如果是当前场景，则同时对当前场景进行清屏操作），3-强制切换（无论是否是当前场景，强制切换），4-保存当前模式到某场景 5-删除场景 ,6-场景复制
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_SCENE_CONTROL_INFO = POINTER(NET_DVR_SCENE_CONTROL_INFO)


class NET_DVR_SHOW_CONTROL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDisplayNo", DWORD), # 显示输出口号，0xffffffff表示对所用输出口进行操作
        ("byEnable", BYTE), # 使能显示，0-不显示，1-显示
        ("byChanType", BYTE), # 显示的通道类型，1-显示通道号，2-虚拟屏号
        ("byRes1", BYTE * 2),
        ("dwWallNo", DWORD), # 墙号，1字节墙号（高位）+3字节保留，显示屏幕序号时有效
        ("byRes2", BYTE * 56),
    ]


LPNET_DVR_SHOW_CONTROL_INFO = POINTER(NET_DVR_SHOW_CONTROL_INFO)


class NET_DVR_BUF_INFO(Structure):
    _fields_ = [
        ("pBuf", VOIDP), # 缓冲区指针
        ("nLen", DWORD), # 缓冲区长度
    ]


LPNET_DVR_BUF_INFO = POINTER(NET_DVR_BUF_INFO)


class NET_DVR_IN_PARAM(Structure):
    _fields_ = [
        ("struCondBuf", NET_DVR_BUF_INFO), # 条件缓冲区
        ("struInParamBuf", NET_DVR_BUF_INFO), # 参数缓冲区
        ("dwRecvTimeout", DWORD), # 接收数据超时时间，单位：ms,置0采用接口默认超时
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_IN_PARAM = POINTER(NET_DVR_IN_PARAM)


class NET_DVR_OUT_PARAM(Structure):
    _fields_ = [
        ("struOutBuf", NET_DVR_BUF_INFO), # 输出参数缓冲区
        ("lpStatusList", VOIDP), # 状态缓冲区
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_OUT_PARAM = POINTER(NET_DVR_OUT_PARAM)


class NET_DVR_AUDIO_CHAN_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 音频通道号组合（1字节设备号+1字节子板号+2字节音频通道号）
        ("byRes", BYTE * 48),
    ]


LPNET_DVR_AUDIO_CHAN_INFO = POINTER(NET_DVR_AUDIO_CHAN_INFO)


class NET_DVR_AUDIO_CHAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sChanName", BYTE * NAME_LEN), # 音频通道名称
        ("byEnable", BYTE), # 音频是否开启， 0-关， 1-开
        ("byAudioSwitchType", BYTE), # 音频切换方式，1-按前端源方式，2-按窗口解码源方式
        ("byRes", BYTE * 2),
        ("struAudioSrcInfo", NET_DVR_PU_STREAM_CFG_V41), # 音频源信息 byAudioSwitchType为1时有效
        ("dwWindowNo", DWORD), # 子窗口号（1字节墙号+1字节子窗口号+2字节窗口号），byAudioSwitchType为2时有效
        ("byRes2", BYTE * 28),
    ]


LPNET_DVR_AUDIO_CHAN_CFG = POINTER(NET_DVR_AUDIO_CHAN_CFG)


MAX_SUBBOARD_NUM = 42 # 集中式大屏设备板数目
MAX_SINGLE_BOARD_EXCEPTION_NUM = 16 # 单板最大并发异常数
class NET_DVR_MAINBOARD_SERIAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySerialWorkMode", BYTE), # 串口工作模式，1-RS484,2-RS232
        ("byFunType", BYTE), # 串口功能，1-键盘控制，2-屏幕控制，3-透明通道模式 4-PTZ控制  5-矩阵控制 6-控制台
        ("byDataBit", BYTE), #  数据有几位 0－5位，1－6位，2－7位，3－8位
        ("byStopBit", BYTE), #  停止位 0－1位，1－2位
        ("dwBaudRate", DWORD), # 波特率0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k
        ("byParity", BYTE), #  校验 0－无校验，1－奇校验，2－偶校验
        ("byFlowcontrol", BYTE), #  0－无，1－软流控,2-硬流控
        ("wProtocol", WORD), # 串口协议，不同串口功能对应串口协议不一样
        ("byVariable", BYTE), # 串口是否可变，1-不可变  2-可变 （只获取）
        ("byGateWayEnable", BYTE), # 是否用于网关，0-不用于网关，!0用于网关
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_MAINBOARD_SERIAL_CFG = POINTER(NET_DVR_MAINBOARD_SERIAL_CFG)


class NET_DVR_SUBBOARD_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byBoardType", BYTE), # 类型，0-主板，1-DVI-I输入，2-YPbPr输入，3-BNC输入，4-SDI输入， 5-DVI双链路输入， 6-普通解码板输入， 7-DVI-I输出， 8-SDI输出, 9-增强型解码板输入，10-DP输入，11-HDTVI输入，12-HDBaseT输出，13-HDMI输入，14-HDBaseT，15-DVI-T输入，16-HDMI输出，17-HDMI-HD输入 ,18-HDMI-UHD输入 , 19-DP_UHD输入,0xff-未知类型 类型，0-主板，1-DVI-I输入，2-YPbPr输入，3-BNC输入，4-SDI输入， 5-DVI双链路输入， 6-普通解码板输入， 7-DVI-I输出， 8-SDI输出, 9-增强型解码板输入，10-DP输入，11-HDTVI输入，12-HDBaseT输出，13-HDMI输入，14-HDBaseT，15-DVI-T输入，16-HDMI输出，17-HDMI-HD输入 ,18-HDMI-UHD输入 , 19-DP_UHD输入,0xff-未知类型
        ("byInterfaceNum", BYTE), # 接口数
        ("byStatus", BYTE), # 状态，0-异常， 1-正常
        ("bySyncStatus", BYTE), #  超高清板同步状态，0-未启用同步， 1-启用同步
        ("dwSlotNo", DWORD), # 所在槽位号
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_SUBBOARD_INFO = POINTER(NET_DVR_SUBBOARD_INFO)


class NET_DVR_DEVICE_SUBBOARD_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byBackBoardType", BYTE), # 背板类型， 1-4U， 2-8U， 3-13U, 0xff-未知类型
        ("bySoltNum", BYTE), # 槽位数目
        ("byBoardNum", BYTE), # 有效数目
        ("byRes1", BYTE * 1),
        ("struSubBoadInfo", NET_DVR_SUBBOARD_INFO * MAX_SUBBOARD_NUM), # 前byBoardNum项有效
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_DEVICE_SUBBOARD_INFO = POINTER(NET_DVR_DEVICE_SUBBOARD_INFO)


class NET_DVR_DEVICE_BOARD_EXCEPINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byExceptNum", BYTE), # 异常项数
        ("byRes1", BYTE * 3),
        ("byMajor", BYTE * MAX_SINGLE_BOARD_EXCEPTION_NUM), # 主类型
        ("wMinor", WORD * MAX_SINGLE_BOARD_EXCEPTION_NUM), # 次类型
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_DEVICE_BOARD_EXCEPINFO = POINTER(NET_DVR_DEVICE_BOARD_EXCEPINFO)


class NET_DVR_LINEARSCAN(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("byLinearScanType", BYTE), # 限位类型，0-保留,1-左边界设置,2-右边界设置
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_LINEARSCAN = POINTER(NET_DVR_LINEARSCAN)


# 码流附加信息
class NET_DVR_STREAM_ATTACHINFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byStreamWithVca", BYTE), # 码流中叠加智能信息，可供进行后检索。0-不叠加,1-叠加
        ("byRes", BYTE * 127), # 保留
    ]


LPNET_DVR_STREAM_ATTACHINFO_CFG = POINTER(NET_DVR_STREAM_ATTACHINFO_CFG)


class NET_DVR_SUBSYSTEM_NETCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDefaultRoute", BYTE), # 默认路由，0表示struEtherNet[0]，1表示struEtherNet[1]
        ("byNetworkCardNum", BYTE), # 设备实际可配置的网卡数目
        ("byRes1", BYTE * 2), # 保留
        ("struEtherNet", NET_DVR_ETHERNET_MULTI), # 以太网口
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_SUBSYSTEM_NETCFG = POINTER(NET_DVR_SUBSYSTEM_NETCFG)


# 配置清除
class NET_DVR_CLEARCTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("byAllPreset", BYTE), # 清除所有的预置点：0-否,1-是
        ("byAllPatrols", BYTE), # 清除所有的巡航路径：0-否,1-是
        ("byAllPatterms", BYTE), # 清除所有的花样扫描：0-否,1-是
        ("byAllPrivacyMasks", BYTE), # 清除所有的隐私块：0-否,1-是
        ("byAllPTZLimited", BYTE), # 清除所有的限位设置：0-否,1-是
        ("byAllScheduledTasks", BYTE), # 清除所有的定时任务：0-否,1-是
        ("byAllParkAction", BYTE), # 清除所有的守望：0-否,1-是
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_CLEARCTRL = POINTER(NET_DVR_CLEARCTRL)


# 云台优先配置信息
class NET_DVR_PTZ_PRIORITIZECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPTZPrioritize", BYTE), # 云台优先：0-Rs485，1-网络，默认网络
        ("byRes", BYTE * 3),
        ("dwDelay", DWORD), # 延时：2---200秒
        ("byRes1", BYTE * 124),
    ]


LPNET_DVR_PTZ_PRIORITIZECFG = POINTER(NET_DVR_PTZ_PRIORITIZECFG)


# 零方位角控制
class NET_DVR_INITIALPOSITIONCTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("byWorkMode", BYTE), # 0-设置，1-清除
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_INITIALPOSITIONCTRL = POINTER(NET_DVR_INITIALPOSITIONCTRL)


# 隐私遮蔽参数
class NET_DVR_PRIVACY_MASKS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("byRegionalID", BYTE), # 区域ID号 1～24
        # 删除当前ID对应的隐私遮蔽信息 0-保留，1-删除 （WriteOnly）
        ("byDelPrivacyMaskCfg", BYTE),
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_PRIVACY_MASKS_COND = POINTER(NET_DVR_PRIVACY_MASKS_COND)


class NET_DVR_PRIVACY_MASKS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用 0-否，1-是
        # 隐私遮蔽区域配置参数是否显示  0-否，1-是 （ReadOnly）
        ("byPrivacyMaskCfgEnable", BYTE),
        ("byColorType", BYTE), # 0-保留,1-灰、2-红、3-绿、4-蓝、5-橙、6-黄、0xff-马赛克
        ("byActiveZoomRatio", BYTE), # 屏蔽倍率：1--100
        ("sPrivacyMaskName", CHAR * NAME_LEN), # 遮挡区域名称，只使用16个字节
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        # 当前区域坐标是否有效 0-否，1-是 （针对单个区域设置区域坐标信息，和单场景下的多区域设置区域坐标信息）
        ("byCurrentRegionEnable", BYTE),
        # 当前倍率使用字段 0- byActiveZoomRatio ;1- fActiveZoomRatio(支持能力节点curActiveZoomRatioType)
        ("byCurZoomRatio", BYTE),
        ("byRes", BYTE * 2),
        ("fActiveZoomRatio", float), # 屏蔽倍率(精确到小数点1位)：[1.0-100.0]
        ("byRes1", BYTE * 120),
    ]


LPNET_DVR_PRIVACY_MASKS_CFG = POINTER(NET_DVR_PRIVACY_MASKS_CFG)


# 全局使能
class NET_DVR_PRIVACY_MASKS_ENABLECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 启用使能，0-否，1-是
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_PRIVACY_MASKS_ENABLECFG = POINTER(NET_DVR_PRIVACY_MASKS_ENABLECFG)


# 智能运动跟踪配置信息
class NET_DVR_SMARTTRACKCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 启动使能 0-否，1-是
        ("byRes", BYTE * 3),
        ("dwDuration", DWORD), # 持续时间：0--300秒，默认300秒
        ("byRes1", BYTE * 124),
    ]


LPNET_DVR_SMARTTRACKCFG = POINTER(NET_DVR_SMARTTRACKCFG)


# 跟踪倍率
class NET_DVR_ZOOMRATIOCTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ZOOMRATIOCTRL = POINTER(NET_DVR_ZOOMRATIOCTRL)


# 拨码开关信息
class NET_DVR_DIAL_SWITCH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSwitchState", DWORD), # 拨号开关状态
        ("byRes", BYTE * 28),
    ]


LPNET_DVR_DIAL_SWITCH_CFG = POINTER(NET_DVR_DIAL_SWITCH_CFG)


class NET_ALARM_RECORDFILE_LOSS(Structure):
    _fields_ = [
        ("struInspectStart", NET_DVR_TIME_EX), # 巡检开始时间
        ("struInspectEnd", NET_DVR_TIME_EX), # 巡检结束时间
        ("struIP", NET_DVR_IPADDR), # 录像丢失对应通道的IP地址
        ("dwChanNo", DWORD), # 通道号
        ("dwIDIndex", DWORD), # 编码器ID
        ("sName", BYTE * STREAM_ID_LEN), # 编码器名称
        ("struLossStartTime", NET_DVR_TIME_EX), # 录像丢失开始时间
        ("struLossEndTime", NET_DVR_TIME_EX), # 录像丢失结束时间
        ("dwLostNum", DWORD), # 录像丢失个数 0xffffffff表示全部丢失
        ("byRes", BYTE * 240),
    ]


LPNET_ALARM_RECORDFILE_LOSS = POINTER(NET_ALARM_RECORDFILE_LOSS)


class NET_ALARM_STREAM_EXCEPTION(Structure):
    _fields_ = [
        ("struIP", NET_DVR_IPADDR), # 发生视频异常通道的IP地址
        ("dwChanNo", DWORD), # 通道号
        ("dwIDIndex", DWORD), # 编码器ID
        ("sName", BYTE * STREAM_ID_LEN), # 编码器名称
        ("byExceptionCase", BYTE), # 异常原因，0-数据写入异常 1-网络接收异常
        ("byRes", BYTE * 307), # 保留
    ]


LPNET_ALARM_STREAM_EXCEPTION = POINTER(NET_ALARM_STREAM_EXCEPTION)


class NET_ALARM_RESOURCE_USAGE(Structure):
    _fields_ = [
        ("byLevel", BYTE), # 使用情况，严重程度递增： 0-正常，1-一级告警上限 2-二级告警上限 3-三级告警上限
        ("byRes", BYTE * 491), # 保留
    ]


LPNET_ALARM_RESOURCE_USAGE = POINTER(NET_ALARM_RESOURCE_USAGE)


class NET_ALARM_RECORD_EXCEPTION(Structure):
    _fields_ = [
        ("byReason", BYTE), # 异常原因 0-录像卷满 1-录像卷异常 2-无可用lun卷
        ("byRes1", BYTE * 3), # 保留
        ("sVolumeName", BYTE * MAX_VOLUMENAME_LEN),
        ("dwVolumeID", DWORD), # 录像卷ID（硬盘号）
        ("byRes", BYTE * 452), # 保留
    ]


LPNET_ALARM_RECORD_EXCEPTION = POINTER(NET_ALARM_RECORD_EXCEPTION)


class NET_ALARM_CVR_SUBINFO_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 492), # 联合体长度
        ("struRecordLost", NET_ALARM_RECORDFILE_LOSS), # 录像丢失
        ("struStreamException", NET_ALARM_STREAM_EXCEPTION), # 取流异常
        ("struResourceUsage", NET_ALARM_RESOURCE_USAGE), # 资源使用
        ("struRecordException", NET_ALARM_RECORD_EXCEPTION), # 录像异常
    ]


LPNET_ALARM_CVR_SUBINFO_UNION = POINTER(NET_ALARM_CVR_SUBINFO_UNION)


MAX_VARIABLE_DATA_NUM = 65535 # 最大可变数据个数
class NET_DVR_ALARMINFO_DEV_V40(Structure):
    _fields_ = [
        ("dwAlarmType", DWORD), # 报警子类型 0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；6-编码器(通道)移动侦测报警；
        # 7-编码器(通道)遮挡报警; 8-录像丢失报警; 9-视频实时监测报警; 10-资源使用率告警; 11- CVR自动修复异常， 12-录像异常
        ("struTime", NET_DVR_TIME),
        ("uSubAlarmInfo", NET_ALARM_CVR_SUBINFO_UNION), # 报警信息子结构 报警类型为8,9,10,11,12时该联合体有效
        ("byRes", BYTE * 256),
        ("dwNumber", DWORD), # 可变数据个数
        ("*pNO", WORD), # 当类型为0、3、6、7时，可能会有通道号；当类型为5时，可能会有磁盘号。可表示的值范围为0~65535
    ]


LPNET_DVR_ALARMINFO_DEV_V40 = POINTER(NET_DVR_ALARMINFO_DEV_V40)


class NET_DVR_CONTROL_START_CFG(Structure):
    _fields_ = [
        ("byUseDefine", BYTE), # 使用自定义， 0-使用默认，1-使用自定义
        ("byRes1", BYTE),
        ("wCourseIndex", WORD), # 课程索引
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CONTROL_START_CFG = POINTER(NET_DVR_CONTROL_START_CFG)


class NET_DVR_CONTROL_DELAY_CFG(Structure):
    _fields_ = [
        ("byUseDefine", BYTE), # 使用自定义， 0-使用默认，1-使用自定义
        ("byRes1", BYTE),
        ("wDelayTime", WORD), # 录像延长时间<继续录像时间以此为准>，单位s
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CONTROL_DELAY_CFG = POINTER(NET_DVR_CONTROL_DELAY_CFG)


class NET_DVR_CONTROL_INFO_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 132), # 联合体长度
        ("struStartCfg", NET_DVR_CONTROL_START_CFG), # 一键开始
        ("struDelayCfg", NET_DVR_CONTROL_DELAY_CFG), # 一键延迟
    ]


LPNET_DVR_CONTROL_INFO_UNION = POINTER(NET_DVR_CONTROL_INFO_UNION)


class NET_DVR_RECORDING_CONTROL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("wCmdType", WORD), # 控制命令类型，0-一键开始，1-一键结束，2-一键暂停，3-一键恢复，4-一键延长,5-一键开始屏蔽 6-一键停止屏蔽
        ("byRes1", BYTE), # 保留
        ("struControlInfo", NET_DVR_CONTROL_INFO_UNION), # 控制信息，具体使用结合控制命令类型
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_RECORDING_CONTROL_CFG = POINTER(NET_DVR_RECORDING_CONTROL_CFG)


class NET_DVR_RECORDING_HOST_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwOneKeyDelayTime", DWORD), # 一键本地延迟时间  录像继续录的时间 单位 S
        ("byDirectedMode", BYTE), # 导播模式，0-自动导播，1手动导播，2-半自动导播
        ("byClassroomType", BYTE), # 教室类型，0-无效，1-主教室，2-从教室
        ("byCourseDataStorageEnabled", BYTE), # 课堂数据统计是否存储在硬盘, 0-不存储，1-存储
        ("byElectronicEnlargeMode", BYTE), # 是否使用电子放大导播, 0-不使用，1-使用
        ("byRes", BYTE * 124), # 保留
    ]


LPNET_DVR_RECORDING_HOST_CFG = POINTER(NET_DVR_RECORDING_HOST_CFG)


class NET_DVR_STATISTIC_DATA_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTypeTarget", DWORD), # 统计对象类型，详见TARGET_TYPE
        ("struStartTime", NET_DVR_TIME), # 开始统计时间
        ("struStopTime", NET_DVR_TIME), # 结束统计时间
        ("byRes", BYTE * 280),
    ]


LPNET_DVR_STATISTIC_DATA_COND = POINTER(NET_DVR_STATISTIC_DATA_COND)


class NET_DVR_STATISTIC_DATA_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTypeTarget", DWORD), # 统计对象类型，详见TARGET_TYPE
        ("struStartTime", NET_DVR_TIME), # 事件开始时间
        ("struStopTime", NET_DVR_TIME), # 事件结束时间
        ("byRes", BYTE * 300),
    ]


LPNET_DVR_STATISTIC_DATA_CFG = POINTER(NET_DVR_STATISTIC_DATA_CFG)


class NET_DVR_AUTO_TRACK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struSDIInfo", NET_DVR_DIRECT_CONNECT_CHAN_INFO * MAX_CHANNUM_V30),
        # SDI通道，设备端实际的流返回形式是模拟通道，而控制前端使用IP通道。
        ("byCameraType", BYTE * MAX_CHANNUM_V30), # 通道接入的相机类型，值为 0-无意义，1-老师跟踪，2-学生跟踪，3-老师全景，4-学生全景，5-多媒体，6-教师定位,7-学生定位,8-板书定位,9-板书相机, 0xff-未接入
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_AUTO_TRACK_CFG = POINTER(NET_DVR_AUTO_TRACK_CFG)


class NET_DVR_PUBLISH_FTP_CFG(Structure):
    _fields_ = [
        ("byProtocolType", BYTE), # 协议类型 0-FTP，1-SFTP
        ("byRes1", BYTE), # 保留
        ("wFTPPort", WORD), # 端口
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # IP或者域名,需要设备解析
        # 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
        ("szUserName", BYTE * NAME_LEN), # 用户名<加密>
        ("szPassWord", BYTE * PASSWD_LEN), # 密码<加密>
        ("szCustomDir", BYTE * 128), # 发布目录,支持目录结构
        ("byRes", BYTE * 12), # 保留
    ]


LPNET_DVR_PUBLISH_FTP_CFG = POINTER(NET_DVR_PUBLISH_FTP_CFG)


class NET_DVR_PUBLISH_HTTP_CFG(Structure):
    _fields_ = [
        ("strUrl", BYTE * 256), # 发布的URL地址信息
    ]


LPNET_DVR_PUBLISH_HTTP_CFG = POINTER(NET_DVR_PUBLISH_HTTP_CFG)


class NET_DVR_PUBLISH_FTP_CFG_DIR(Structure):
    _fields_ = [
        ("byProtocolType", BYTE), # 协议类型 0-FTP，1-SFTP
        ("byRes1", BYTE), # 保留
        ("wFTPPort", WORD), # 端口
        ("byAddress", BYTE * MAX_DOMAIN_NAME), # IP或者域名,需要设备解析
        # 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
        ("szUserName", BYTE * NAME_LEN), # 用户名<加密>
        ("szPassWord", BYTE * PASSWD_LEN), # 密码<加密>
        ("byDirLevel", BYTE), # 0 = 不使用目录结构，直接保存在根目录,1 = 使用1级目录,2=使用2级目录
        ("byTopDirMode", BYTE), #  一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址                     0xff=使用自定义
        ("bySubDirMode", BYTE), # 二级目录，0x1=使用通道名称,0x2=使用通道号，0x3=使用课程名称，0x4-使用授课日期，0xff-使用自定义
        ("byRes2", BYTE),
        ("byTopCustomDir", BYTE * MAX_CUSTOMDIR_LEN), # 自定义一级目录
        ("bySubCustomDir", BYTE * MAX_CUSTOMDIR_LEN), # 自定义二级目录
        ("byRes", BYTE * 72), # 保留
    ]


LPNET_DVR_PUBLISH_FTP_CFG_DIR = POINTER(NET_DVR_PUBLISH_FTP_CFG_DIR)


class NET_DVR_PUBLISH_ADD_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 256), # 联合体长度
        ("struHttpCfg", NET_DVR_PUBLISH_HTTP_CFG), # http地址信息
        ("struFtpCfg", NET_DVR_PUBLISH_FTP_CFG), # ftp地址信息
        ("struDirFtpCfg", NET_DVR_PUBLISH_FTP_CFG_DIR), # 按目录方式的FTP
    ]


LPNET_DVR_PUBLISH_ADD_UNION = POINTER(NET_DVR_PUBLISH_ADD_UNION)


class NET_DVR_RECORD_PUBLISH_INFO(Structure):
    _fields_ = [
        ("byPublish", BYTE), # 是否发布，0-不发布， 1-发布
        ("byRes1", BYTE * 3),
        ("dwStreamType", DWORD), # 一键发布码流类型，按位表示
        # &0x1-表示主码流
        # &0x2-表示子码流
        # &0x4-表示码流三
        ("byRes", BYTE * 12), # 保留
    ]


LPNET_DVR_RECORD_PUBLISH_INFO = POINTER(NET_DVR_RECORD_PUBLISH_INFO)


class NET_DVR_PUBLISH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byPublishType", BYTE), # 发布方式，0-http,1-ftp,2-Dir FTP
        ("byRes1", BYTE * 3), # 保留
        ("struPublishAddr", NET_DVR_PUBLISH_ADD_UNION), # 一键发布地址信息
        ("struChanPublish", NET_DVR_RECORD_PUBLISH_INFO * MAX_CHANNUM_V30), # 通道录像发布信息 struChanPublis[0]表示通道1对应录像发布信息
        ("struDirectChanPublish", NET_DVR_RECORD_PUBLISH_INFO), # 导播通道录像发布信息
        ("byUploadTime", BYTE), # 是否启动定时ftp上传功能 0-无意义，1-不启动，2-启用
        ("byTimerMode", BYTE), # 0-无意义，1-按课表定时上传最近一节课的录像，2-按时间点方式上传前24小时录像
        ("byUploadStartHour", BYTE), # 按时间定时上传起始时间  时
        ("byUoploadStartMin", BYTE), # 按时间定时上传 开始时间 分
        ("byRes", BYTE * 1020), # 保留
    ]


LPNET_DVR_PUBLISH_CFG = POINTER(NET_DVR_PUBLISH_CFG)


class NET_DVR_ONEKEY_PUBLISH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byUseDefine", BYTE), # 使用自定义  0-使用默认发布配置信息，1-使用自定义发布配置信息
        ("byRes1", BYTE * 3),
        ("struChanPublish", NET_DVR_RECORD_PUBLISH_INFO * MAX_CHANNUM_V30), # 通道录像发布信息 struChanPublis[0]表示通道1对应录像发布信息
        ("struDirectChanPublish", NET_DVR_RECORD_PUBLISH_INFO), # 导播通道录像发布信息
        ("struStartTime", NET_DVR_TIME_EX), # 课程开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 课程结束时间
        ("bySchedulePublish", BYTE), # 是否按课表发布，0不按课表发布1按课表发布
        ("sFileName", BYTE * COURSE_NAME_LEN), # 发布文件名称
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_ONEKEY_PUBLISH_CFG = POINTER(NET_DVR_ONEKEY_PUBLISH_CFG)


class NET_DVR_COURSE_RECORDING_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sCourseName", CHAR * COURSE_NAME_LEN),
        ("sInstructorName", CHAR * INSTRUCTOR_NAME_LEN),
        ("sCourseDescription", CHAR * COURSE_DESCRIPTION_LEN),
        ("byIndex", BYTE), # 课程索引
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_COURSE_RECORDING_INFO = POINTER(NET_DVR_COURSE_RECORDING_INFO)


class NET_DVR_EACH_LESSON_INFO(Structure):
    _fields_ = [
        ("struSchedTime", NET_DVR_SCHEDTIME), # 课程起止时间
        ("wCourseIndex", WORD), # 课程索引
        ("wSessionIndex", WORD), # 节次
        ("byRes", BYTE * 4), # 保留
    ]


LPNET_DVR_EACH_LESSON_INFO = POINTER(NET_DVR_EACH_LESSON_INFO)


#  流录像状态
class NET_DVR_CURRICULUM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struLessonInfo", NET_DVR_EACH_LESSON_INFO * MAX_TIMESEGMENT_V40), # 每节课信息
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_CURRICULUM_CFG = POINTER(NET_DVR_CURRICULUM_CFG)


class NET_DVR_DATE(Structure):
    _fields_ = [
        ("wYear", WORD), # 年
        ("byMonth", BYTE), # 月
        ("byDay", BYTE), # 日
    ]


LPNET_DVR_DATE = POINTER(NET_DVR_DATE)


class NET_DVR_BACKUP_RECORD_INFO(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用
        ("byRes", BYTE * 11),
        # 备份码流类型，按位表示
        # &0x1-表示主码流
        # &0x2-表示子码流
        # &0x4-表示码流三
        ("dwStreamType", DWORD),
    ]


LPNET_DVR_BACKUP_RECORD_INFO = POINTER(NET_DVR_BACKUP_RECORD_INFO)


class NET_DVR_BACKUP_RECORD_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struChanBackUp", NET_DVR_BACKUP_RECORD_INFO * MAX_CHANNUM_V30), # 需要备份的通道,数组下标对应相应的通道号
        ("struDirectedChanBackUp", NET_DVR_BACKUP_RECORD_INFO), # 导播通道备份信息
        ("byRes", BYTE * 256), #  保留字节
    ]


LPNET_DVR_BACKUP_RECORD_PARAM = POINTER(NET_DVR_BACKUP_RECORD_PARAM)


# 室内机编号
class NET_DVR_INDOOR_UNIT_DEVICEID(Structure):
    _fields_ = [
        ("wFloorNumber", SHORT), # 层号
        ("wRoomNumber", WORD), # 房间号
        ("wDevIndex", WORD), # 室内机编号，0-10
        ("byRes", BYTE * 122), # 保留
    ]


LPNET_DVR_INDOOR_UNIT_DEVICEID = POINTER(NET_DVR_INDOOR_UNIT_DEVICEID)


# 门口机编号
class NET_DVR_OUTDOOR_UNIT_DEVICEID(Structure):
    _fields_ = [
        ("wPeriod", WORD), # 期号, 范围[0,9]
        ("wBuildingNumber", WORD), # 楼号
        ("wUnitNumber", WORD), # 单元号
        ("wFloorNumber", SHORT), # 层号
        ("wDevIndex", WORD), # 门口机序号，每一层中门口机的序号唯一，从0开始
        ("byRes", BYTE * 118), # 保留
    ]


LPNET_DVR_OUTDOOR_UNIT_DEVICEID = POINTER(NET_DVR_OUTDOOR_UNIT_DEVICEID)


# 围墙机编号
class NET_DVR_OUTDOOR_FENCE_DEVICEID(Structure):
    _fields_ = [
        ("wPeriod", WORD), # 期号, 范围[0,9]
        ("wDevIndex", WORD), # 围墙机序号，每一层中门口机的序号唯一，从0开始
        ("byRes", BYTE * 124), # 保留
    ]


LPNET_DVR_OUTDOOR_FENCE_DEVICEID = POINTER(NET_DVR_OUTDOOR_FENCE_DEVICEID)


# 管理机编号
class NET_DVR_MANAGE_UNIT_DEVICEID(Structure):
    _fields_ = [
        ("wPeriod", WORD), # 期号，范围[0,9]
        ("wDevIndex", WORD), # 管理机序号，每一期中管理机的序号唯一,从0开始
        ("byRes", BYTE * 124), # 保留
    ]


LPNET_DVR_MANAGE_UNIT_DEVICEID = POINTER(NET_DVR_MANAGE_UNIT_DEVICEID)


# 可视对讲设备编号联合体
class NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 128), # 联合体大小
        ("struIndoorUnit", NET_DVR_INDOOR_UNIT_DEVICEID), # 室内机
        ("struOutdoorUnit", NET_DVR_OUTDOOR_UNIT_DEVICEID), # 门口机/门禁智能设备
        ("struManageUnit", NET_DVR_MANAGE_UNIT_DEVICEID), # 管理机
        ("struFenceUnit", NET_DVR_OUTDOOR_FENCE_DEVICEID), # 围墙机
        ("struVillaOutdoorUnit", NET_DVR_OUTDOOR_UNIT_DEVICEID), # 别墅门口机
        ("struAgainConfirmUnit", NET_DVR_OUTDOOR_UNIT_DEVICEID), # 二次确认机
    ]


LPNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION = POINTER(NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION)


# 设备编号参数结构体
class NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byUnitType", BYTE), # 设备类型，1-门口机，2-管理机 4-围墙机,5-别墅门口机，6-二次确认机，7-门禁智能设备
        ("byIsAutoReg", BYTE), # 是否自动注册，0-否，1-是
        ("byRes1", BYTE * 2), # 保留
        ("uVideoIntercomUnit", NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION), # 取值参考byUnitType
        ("byRes2", BYTE * 128), # 保留
    ]


LPNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG = POINTER(NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG)


# 权限密码类型
ENUM_PRIVILEGE_PASSWORD_ENGINEERING = 1
ENUM_PRIVILEGE_PASSWORD_SETUPALARM = 2
ENUM_PRIVILEGE_PASSWORD_HOUSEHOLDER_UNLOCK = 3
ENUM_PRIVILEGE_PASSWORD_ANTI_HIJACKING = 4
ENUM_PRIVILEGE_PASSWORD_PUBLIC1 = 5
ENUM_PRIVILEGE_PASSWORD_PUBLIC2 = 6
ENUM_PRIVILEGE_PASSWORD_PUBLIC3 = 7
ENUM_PRIVILEGE_PASSWORD_SENDCARD = 8


# 权限密码信息
class NET_DVR_PRIVILEGE_PASSWORD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byPwdType", BYTE), # 密码类型，参考PRIVILEGE_PASSWORD_TYPE_ENUM
        ("byRes1", BYTE * 3), # 保留
        ("byOldPassword", BYTE * PASSWD_LEN), # 旧密码
        ("byNewPassword", BYTE * PASSWD_LEN), # 新密码
        ("byRes2", BYTE * 128), # 保留
    ]


LPNET_DVR_PRIVILEGE_PASSWORD_CFG = POINTER(NET_DVR_PRIVILEGE_PASSWORD_CFG)


# 室内机操作时间配置
class NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG(Structure):
    _fields_ = [
        ("dwMaxMonitoringTime", DWORD), # 最大监视时间，范围[10,60]秒
        ("dwMaxRingTime", DWORD), # 最大振铃时间，范围[15,60]秒
        ("dwCallForwardingTime", DWORD), # 呼叫转移超时时间，范围[0,20]秒
        ("dwRingDurationTime", DWORD), # 响铃超时时间，范围[30,60]秒，默认30秒
        ("byRes", BYTE * 112), # 保留
    ]


LPNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG = POINTER(NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG)


# 室外机操作时间配置
class NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG(Structure):
    _fields_ = [
        ("dwMaxMessageTime", DWORD), # 最大留言时间，范围[30,60]秒
        ("dwMaxTalkTime", DWORD), # 最大通话时间，范围[90,120]秒
        ("byRes", BYTE * 120), # 保留
    ]


LPNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG = POINTER(NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG)


# 管理机操作时间配置
class NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG(Structure):
    _fields_ = [
        ("dwMaxMonitoringTime", DWORD), # 最大监视时间，范围[10,60]秒
        ("dwMaxRingTime", DWORD), # 最大振铃时间，范围[15,60]秒
        ("dwMaxTalkTime", DWORD), # 最大通话时间，单位s
        ("byRes", BYTE * 116), # 保留
    ]


LPNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG = POINTER(NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG)


# 可视对讲操作时间联合体
class NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 128), # 联合体大小
        ("struIndoorUnit", NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG), # 室内机
        ("struOutdoorUnit", NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG), # 门口机/围墙机/别墅门口机/二次确认机
        ("struManageUnit", NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG), # 管理机
    ]


LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION = POINTER(NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION)


# 可视对讲操作时间配置
class NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byUnitType", BYTE), # 设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机
        ("byRes1", BYTE * 3), # 保留
        ("uVideoIntercomUnit", NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION), # 取值参考byUnitType
        ("byRes2", BYTE * 128), # 保留
    ]


LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG = POINTER(NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG)


# 室内机关联的网络设备
class NET_DVR_INDOOR_UNIT_RELATEDEV(Structure):
    _fields_ = [
        ("struOutdoorUnit", NET_DVR_IPADDR), # 主门口机IP
        ("struManageUnit", NET_DVR_IPADDR), # 管理机IP
        ("struSIPServer", NET_DVR_IPADDR), # SIP服务器IP
        ("struAgainUnit", NET_DVR_IPADDR), # 二次确认机IP
        ("byOutDoorType", BYTE), # 主门口机类型，0保留，1-主单元门口机，2-主别墅门口机
        ("byOutInConnectMode", BYTE), # 门口机与室内分机组网模式：1-门口机与室内分机同一局域网,2-门口机与室内分机不同局域网；
        ("byIndoorConnectMode", BYTE), # 室内主机与室内分机组网模式：1-通过无线网卡、2-通过有线网卡；
        ("byRes1", BYTE),
        ("struIndoorUnit", NET_DVR_IPADDR), # 室内主机IP
        ("byManageCenterID", BYTE * 32), # 标准sip模式下使用，管理中心ID，支持数字，字母，@和.
        ("byRes", BYTE * 268), # 保留
    ]


LPNET_DVR_INDOOR_UNIT_RELATEDEV = POINTER(NET_DVR_INDOOR_UNIT_RELATEDEV)


# 门口机相关联的网络设备
class NET_DVR_OUTDOOR_UNIT_RELATEDEV(Structure):
    _fields_ = [
        ("struMainOutdoorUnit", NET_DVR_IPADDR), # 主门口机IP，副门口机时有效
        ("struManageUnit", NET_DVR_IPADDR), # 管理机IP
        ("struSIPServer", NET_DVR_IPADDR), # SIP服务器IP，副门口机时无效
        ("byManageCenterID", BYTE * 32), # 标准sip模式下使用，管理中心ID，支持数字，字母，@和.
        ("byRes", BYTE * 560), # 保留
    ]


LPNET_DVR_OUTDOOR_UNIT_RELATEDEV = POINTER(NET_DVR_OUTDOOR_UNIT_RELATEDEV)


# 二次确认机相关联的网络设备
class NET_DVR_AGAIN_RELATEDEV(Structure):
    _fields_ = [
        ("struSIPServer", NET_DVR_IPADDR), # SIP服务器IP
        ("struCenterAddr", NET_DVR_IPADDR), # 中心平台IP
        ("wCenterPort", WORD), # 中心平台端口
        ("byRes1", BYTE * 2),
        ("struIndoorUnit", NET_DVR_IPADDR), # 室内主机IP
        ("struAgainAddr", NET_DVR_IPADDR), # 主二次确认机IP（副二次确认机配置该字段）
        ("byRes", BYTE * 444), # 保留
    ]


LPNET_DVR_AGAIN_RELATEDEV = POINTER(NET_DVR_AGAIN_RELATEDEV)


# 管理机相关联的网络设备
class NET_DVR_MANAGE_UNIT_RELATEDEV(Structure):
    _fields_ = [
        ("struSIPServer", NET_DVR_IPADDR), # SIP服务器IP
        ("byRes", BYTE * 880), # 保留
    ]


LPNET_DVR_MANAGE_UNIT_RELATEDEV = POINTER(NET_DVR_MANAGE_UNIT_RELATEDEV)


# 可视对讲关联网络设备参数结构体
class NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION(Union):
    _fields_ = [
        ("dwRes", DWORD * 256), # 联合体大小
        ("struIndoorUnit", NET_DVR_INDOOR_UNIT_RELATEDEV), # 室内机
        ("struMainOutdoorUnit", NET_DVR_OUTDOOR_UNIT_RELATEDEV), # 门口机/围墙机/门禁智能设备
        ("struManageUnit", NET_DVR_MANAGE_UNIT_RELATEDEV), # 管理机
        ("struVillaUnit", NET_DVR_OUTDOOR_UNIT_RELATEDEV), # 别墅门口机
        ("struAgainUnit", NET_DVR_AGAIN_RELATEDEV), # 二次确认机
    ]


LPNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION = POINTER(NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION)


# 关联网络设备参数结构体
class NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byUnitType", BYTE), # 设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-门禁智能设备
        ("byRes1", BYTE * 3), # 保留
        ("uVideoIntercomUnit", NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION), # 取值参考byUnitType
        ("byRes2", BYTE * 128), # 保留
    ]


LPNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG = POINTER(NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG)


class NET_DVR_CONTROL_GATEWAY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwGatewayIndex", DWORD), # 门禁序号，从1开始
        ("byCommand", BYTE), # 操作命令，0-关闭，1-打开，2-常开（通道状态），3-恢复（普通状态）
        ("byLockType", BYTE), # 锁类型，0-普通（以前默认都为0）,1-智能锁
        ("wLockID", WORD), # 锁ID，从1开始（远程开门口机锁时，0表示门口机本机控制器上接的锁、1表示外接控制器上接的锁）
        ("byControlSrc", BYTE * NAME_LEN), # 操作发起源信息
        ("byControlType", BYTE), # 开锁类型，1-监视，2-通话
        ("byRes3", BYTE * 3),
        ("byPassword", BYTE * PASSWD_LEN), # 锁密码，当byLockType为智能锁时有效
        ("byRes2", BYTE * 108), # 保留
    ]


LPNET_DVR_CONTROL_GATEWAY = POINTER(NET_DVR_CONTROL_GATEWAY)


# 公告图片信息结构体
class NET_DVR_NOTICE_PIC(Structure):
    _fields_ = [
        ("pPicData", BYTE*), # 图片指针
        ("dwPicDataLen", DWORD), # 图片数据长度
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_DVR_NOTICE_PIC = POINTER(NET_DVR_NOTICE_PIC)


# 公告数据
class NET_DVR_NOTICE_DATA(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struTime", NET_DVR_TIME_EX), # 公告时间
        ("byNoticeNumber", BYTE * MAX_NOTICE_NUMBER_LEN), # 公告编号
        ("byNoticeTheme", BYTE * MAX_NOTICE_THEME_LEN), # 公告主题
        ("byNoticeDetail", BYTE * MAX_NOTICE_DETAIL_LEN), # 公告详情
        ("byLevel", BYTE), # 公告等级，1-广告类信息；2-物业信息；3-报警类信息4-通知类信息
        ("byPicNum", BYTE), # 公告图片数量
        ("byRes1", BYTE * 2), # 保留
        ("struNoticePic", NET_DVR_NOTICE_PIC * MAX_NOTICE_PIC_NUM), # 公告图片
        ("byRes2", BYTE * 128), # 保留
    ]


LPNET_DVR_NOTICE_DATA = POINTER(NET_DVR_NOTICE_DATA)


# 操作权限验证参数
class NET_DVR_OPERATION_AUTH(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byPassword", BYTE * PASSWD_LEN), # 验证密码
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_OPERATION_AUTH = POINTER(NET_DVR_OPERATION_AUTH)


# 开锁类型
ENUM_UNLOCK_PASSWORD = 1
ENUM_UNLOCK_HIJACKING = 2
ENUM_UNLOCK_CARD = 3
ENUM_UNLOCK_HOUSEHOLDER = 4
ENUM_UNLOCK_CENTER_PLATFORM = 5
ENUM_UNLOCK_BLUETOOTH = 6
ENUM_UNLOCK_QR_CODE = 7
ENUM_UNLOCK_FACE = 8
ENUM_UNLOCK_FINGERPRINT = 9
ENUM_UNLOCK_DYNAMIC_CODE = 10


# 开锁记录
class NET_DVR_UNLOCK_RECORD_INFO(Structure):
    _fields_ = [
        ("byUnlockType", BYTE), # 开锁方式，参考UNLOCK_TYPE_ENUM
        ("byRes1", BYTE * 3), # 保留
        ("byControlSrc", BYTE * NAME_LEN), # 操作发起源信息，刷卡开锁时为卡号，蓝牙开锁时为萤石的APP账号，二维码开锁时为访客的手机号，其余情况下为设备编号
        ("dwPicDataLen", DWORD), # 图片数据长度
        ("pImage", BYTE*), # 图片指针
        ("dwCardUserID", DWORD), # 持卡人ID
        ("nFloorNumber", SHORT), # 刷卡开锁时有效，为楼层号
        ("wRoomNumber", WORD), # 操作发起源附加信息，刷卡开锁时有效，为房间号，
        ("wLockID", WORD), # （对于门口机，0-表示本机控制器上接的锁、1-表示外接控制器上接的锁）
        ("byRes2", BYTE * 2),
        ("byLockName", BYTE * LOCK_NAME_LEN), # 刷卡开锁时有效，锁名称，对应门参数配置中门名称
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
        ("byRes", BYTE * 136), # 保留
    ]


LPNET_DVR_UNLOCK_RECORD_INFO = POINTER(NET_DVR_UNLOCK_RECORD_INFO)


# 公告信息阅读回执
class NET_DVR_NOTICEDATA_RECEIPT_INFO(Structure):
    _fields_ = [
        ("byNoticeNumber", BYTE * MAX_NOTICE_NUMBER_LEN), # 公告编号
        ("byRes", BYTE * 224), # 保留
    ]


LPNET_DVR_NOTICEDATA_RECEIPT_INFO = POINTER(NET_DVR_NOTICEDATA_RECEIPT_INFO)


# 认证记录（设备未实现）
class NET_DVR_AUTH_INFO(Structure):
    _fields_ = [
        ("byAuthResult", BYTE), # 认证结果：0-无效，1-认证成功，2-认证失败
        ("byAuthType", BYTE), # 认证方式：0-无效，1-指纹，2-人脸
        ("byRes1", BYTE * 2), # 保留
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("dwPicDataLen", DWORD), # 图片数据长度（当认证方式byAuthType为人脸时有效）
        ("pImage", BYTE*), # 图片指针（当认证方式byAuthType为人脸时有效）
        ("byRes", BYTE * 212), # 保留
    ]


LPNET_DVR_AUTH_INFO = POINTER(NET_DVR_AUTH_INFO)


# 车牌信息上传
class NET_DVR_UPLOAD_PLATE_INFO(Structure):
    _fields_ = [
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("byColor", BYTE), # 车牌颜色，参考结构VCA_PLATE_COLOR
        ("byRes", BYTE * 239), # 保留
    ]


LPNET_DVR_UPLOAD_PLATE_INFO = POINTER(NET_DVR_UPLOAD_PLATE_INFO)


class NET_DVR_SEND_CARD_INFO(Structure):
    _fields_ = [
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("byRes", BYTE * 224), # 保留
    ]


LPNET_DVR_SEND_CARD_INFO = POINTER(NET_DVR_SEND_CARD_INFO)


# 可视对讲事件记录信息联合体
class NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON(Union):
    _fields_ = [
        ("byLen", BYTE * 256), # 联合体大小
        ("struUnlockRecord", NET_DVR_UNLOCK_RECORD_INFO), # 开锁记录
        ("struNoticedataReceipt", NET_DVR_NOTICEDATA_RECEIPT_INFO), # 公告信息阅读回执
        ("struAuthInfo", NET_DVR_AUTH_INFO), # 认证记录（设备未实现）
        ("struUploadPlateInfo", NET_DVR_UPLOAD_PLATE_INFO), # 车牌信息上传
        ("struSendCardInfo", NET_DVR_SEND_CARD_INFO), # 门口机发卡,对应设备处于发卡状态，刷卡时上传该事件
    ]


LPNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON = POINTER(NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON)


# 可视对讲事件记录
class NET_DVR_VIDEO_INTERCOM_EVENT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struTime", NET_DVR_TIME_EX), # 时间
        ("byDevNumber", BYTE * MAX_DEV_NUMBER_LEN), # 设备编号
        ("byEventType", BYTE), # 事件信息类型，1-开锁记录，2-公告信息阅读回执，3-认证记录，4-车牌信息上传，5非法卡刷卡事件，6-门口机发卡记录(需要启动门口机发卡功能，刷卡时才会上传该事件)
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("byRes1", BYTE * 2), # 保留
        ("uEventInfo", NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON), # 事件信息，具体内容参考byEventType取值
        ("dwIOTChannelNo", DWORD), # IOT通道号
        ("byRes2", BYTE * 252), # 保留
    ]


LPNET_DVR_VIDEO_INTERCOM_EVENT = POINTER(NET_DVR_VIDEO_INTERCOM_EVENT)


# 防区报警信息
class NET_DVR_ZONE_ALARM_INFO(Structure):
    _fields_ = [
        ("byZoneName", BYTE * NAME_LEN), # 防区名称
        ("dwZonendex", DWORD), # 防区号
        ("byZoneType", BYTE), # 防区类型，参考DETECTOR_TYPE
        ("byRes", BYTE * 219), # 保留
    ]


LPNET_DVR_ZONE_ALARM_INFO = POINTER(NET_DVR_ZONE_ALARM_INFO)


# 锁报警信息
class NET_DVR_LOCK_ALARM_INFO(Structure):
    _fields_ = [
        ("dwLockID", DWORD), # 锁ID，从0开始
        ("byRes", BYTE * 252), # 保留字节
    ]


LPNET_DVR_LOCK_ALARM_INFO = POINTER(NET_DVR_LOCK_ALARM_INFO)


class NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 256), # 联合体大小
        ("struZoneAlarm", NET_DVR_ZONE_ALARM_INFO), # 防区报警
        ("struLockAlarm", NET_DVR_LOCK_ALARM_INFO), # 锁报警信息
    ]


LPNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION = POINTER(NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION)


# 可视对讲报警信息联合体
class NET_DVR_VIDEO_INTERCOM_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struTime", NET_DVR_TIME_EX), # 报警时间
        ("byDevNumber", BYTE * MAX_DEV_NUMBER_LEN), # 设备编号
        ("byAlarmType", BYTE), # 报警类型，1-防区报警，2-防拆报警，3-劫持报警，4-多次密码开锁失败报警,5-门没开，6-门没关 7-SOS 、8-通话对讲，9-智能锁劫持指纹报警， 10-智能锁劫持密码报警，11-智能锁撬门报警，12-智能锁门锁锁定报警，13-智能锁电量不足报警 ,14-黑名单报警,15-智能锁掉线
        # ，16-门禁安全模块防拆报警，17-设备开始对讲，18-设备停止对讲
        ("byRes1", BYTE * 3), # 保留
        ("uAlarmInfo", NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION), # 报警信息，具体内容参考字段byAlarmType取值
        ("wLockID", WORD), # （0-表示门口机本机控制器上接的锁、1-表示外接控制器上接的锁）（报警类型为5和6时有效）
        ("byRes3", BYTE * 2), # 保留
        ("dwIOTChannelNo", DWORD), # IOT通道号
        ("byRes2", BYTE * 248), # 保留
    ]


LPNET_DVR_VIDEO_INTERCOM_ALARM = POINTER(NET_DVR_VIDEO_INTERCOM_ALARM)


class NET_DVR_PEOPLE_REGION(Structure):
    _fields_ = [
        ("byID", BYTE), # 区域ID
        ("byNumber", BYTE), # 区域中的人员数量 0-表示区域中没有人员
        ("byDressType", BYTE), # 着装类型 0-未知，1-法袍、2-徽章、3-制服
        ("byRes", BYTE),
        ("struRegion", NET_VCA_RECT),
        ("dwPicLen", DWORD), # 检测图片长度 (0表示没有长度)
        ("pPicBuffer", CHARP), # 具体的图片数据
        ("byRes1", BYTE * 24), # 保留(预留后期扩展区域属性)
    ]


LPNET_DVR_PEOPLE_REGION = POINTER(NET_DVR_PEOPLE_REGION)


class NET_DVR_PEOPLE_DETECTION_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("struPeopleRegion", NET_DVR_PEOPLE_REGION * MAX_PEOPLE_DETECTION_NUM),
        # 人员检测报警类型
        # （0-    未知，
        # （1-    审讯室内打架斗殴报警
        # （2-    审讯人员瞌睡检测报警
        # （3-    被审讯人员起身检测报警
        # （4-    审判人员检测）
        #
        ("byPeopleAlarmType", BYTE),
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_PEOPLE_DETECTION_RESULT = POINTER(NET_DVR_PEOPLE_DETECTION_RESULT)


class NET_DVR_SUPPLEMENTLIGHT(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能 0-关，1-开
        ("byMode", BYTE), # 补光灯模式 0-自动，1-定时
        ("byHighBeamBrightness", BYTE), # 远光灯亮度[0,10]
        ("byLowBeamBrightness", BYTE), # 近光灯亮度[0,10]
        ("struSchedTime", NET_DVR_SCHEDULE_DAYTIME), # 定时时间段
        ("wFilteringTime", WORD), # 过滤时间(s)[0,120]
        ("byBrightness", BYTE), # 补光灯亮度[0,10]（当支持该参数时， byHighBeamBrightness、byLowBeamBrightness不生效）
        ("bySensitivity", BYTE), # 补光灯灵敏度[0,7],默认4（当byMode为自动时生效）
        ("byBrightnessRegulatMode", BYTE), #  亮度调节模式，0-手动，1-自动（当为自动时byBrightness不生效）
        ("byMaxBrightness", BYTE), # 补光灯最大亮度（仅亮度调节模式为自动时生效），[0,100]，默认50
        ("byRes", BYTE * 58),
    ]


LPNET_DVR_SUPPLEMENTLIGHT = POINTER(NET_DVR_SUPPLEMENTLIGHT)


class NET_DVR_EXTERNALDEVICE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struSupplementLight", NET_DVR_SUPPLEMENTLIGHT), # 补光灯结构信息
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_EXTERNALDEVICE = POINTER(NET_DVR_EXTERNALDEVICE)


class NET_DVR_TEMPERATURE_TRIGGER_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChan", DWORD), # 通道号
        ("dwPreset", DWORD), # 预置点号
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_TEMPERATURE_TRIGGER_COND = POINTER(NET_DVR_TEMPERATURE_TRIGGER_COND)


# (球机支持，软件实现，补光灯是设计在设备内部的)
class NET_DVR_BUILTIN_SUPPLEMENTLIGHT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byMode", BYTE), # 补光灯模式 0-定时，1-开启，2-关闭，3-自动（非光敏，算法画面识别）
        ("byBrightnessLimit", BYTE), # 亮度限制[0,100]
        ("bySupplementLightMode", BYTE), # 补光灯类型,0~白光模式,1~混合模式
        ("byMixedLightRegulatMode", BYTE), # 混合补光灯亮度调节模式,0~自动,1~手动,当bySupplementLightMode = 1时生效
        ("byLrLightBrightness", BYTE), # 红外亮度控制[0,100],当byMixedLightRegulatMode = 1时生效。
        ("byHighLrLightBrightness", BYTE), #  远光红外光亮度配置[0,100],当byMixedLightRegulatMode = 1时生效
        ("byHighBrightnessLimit", BYTE), #  远光白光亮度配置[0,100],当byMixedLightRegulatMode = 1时生效
        ("byLowLrLightBrightness", BYTE), #  近光红外光亮度配置[0,100],当byMixedLightRegulatMode = 1时生效
        ("struSchedTime", NET_DVR_SCHEDULE_DAYTIME), # 定时时间段
        ("byLowBrightnessLimit", BYTE), # 近光白光亮度配置[0,100],当byMixedLightRegulatMode = 1时生效
        ("byWhiteLightBrightness", BYTE), #  白光灯亮度
        ("byIrLightbrightnessLimit", BYTE), # 混光球机,红外亮度限制
        ("byWhiteLightbrightnessLimit", BYTE), # 混光球机,白光亮度限制
        ("byRes1", BYTE * 252),
    ]


LPNET_DVR_BUILTIN_SUPPLEMENTLIGHT = POINTER(NET_DVR_BUILTIN_SUPPLEMENTLIGHT)


class NET_DVR_OIS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byMode", BYTE), # 是否光学防抖：0-关闭，1-普通，2-专家
        ("byOISLevel", BYTE), # 光学防抖等级，0-低，1-中，2-高
        ("byOISSensitivity", BYTE), # 光学防抖灵敏度，0-低，1-中，2-高
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_OIS_CFG = POINTER(NET_DVR_OIS_CFG)


class NET_DVR_MACFILTER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否开启MAC地址过滤：0-否，1-是
        ("byPermissionType", BYTE), # MAC地址过滤类型，0-禁止，1-允许
        ("byRes1", BYTE * 2),
        ("szMacAddress", BYTE * MAC_ADDRESS_NUM),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_MACFILTER_CFG = POINTER(NET_DVR_MACFILTER_CFG)


class NET_DVR_EAGLEFOCUSING_SENCE(Structure):
    _fields_ = [
        ("byRuleType", BYTE), # 规则类型，0-线
        ("bySceneID", BYTE), # 场景ID，0-保留， 1是表示场景1,2表示场景2，其余依次类推
        ("wRate", WORD), # 倍率，50-100
        ("struRegion", NET_VCA_POLYGON), #  区域范围
        ("bySpotNum", BYTE), # 在标定线上取多少个点进行标定，3-5，默认3
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_EAGLEFOCUSING_SENCE = POINTER(NET_DVR_EAGLEFOCUSING_SENCE)


class NET_DVR_EAGLEFOCUSING_CALCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnabled", BYTE), # 是否开启标定：0-中止标定，1-开始标定（该节点设置时有效，获取时无效）
        ("byRes1", BYTE * 3),
        ("struEagleFoucsing", NET_DVR_EAGLEFOCUSING_SENCE * MAX_SENCE_NUM),
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_EAGLEFOCUSING_CALCFG = POINTER(NET_DVR_EAGLEFOCUSING_CALCFG)


class NET_DVR_EAGLEFOCUSING_CTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能：0-关闭鹰视聚焦，1-开启鹰视聚焦
        ("byHeightCompensationEnable", BYTE), # 高度补偿使能
        ("byHeightCompensationValue", BYTE), # 高度补偿值, 范围1-5,默认3,一个值代表0.5米
        ("byRes", BYTE * 509),
    ]


LPNET_DVR_EAGLEFOCUSING_CTRL = POINTER(NET_DVR_EAGLEFOCUSING_CTRL)


class NET_DVR_SMARTCALIBRATION_REGION(Structure):
    _fields_ = [
        ("byRuleID", BYTE), # 规则编号
        ("byMode", BYTE), # 0-default Mode,1-pix Mode,2-actual Mode
        ("byStrategy", BYTE), # 过滤策略 0-area(面积),1-widthHeight(宽高) (<!---,if mode == pix Mode -->)
        ("byPriority", BYTE), # 优先级 0-默认值, 1-低，2-中，3-高
        ("struMaxTargetSize", NET_VCA_POLYGON), # 最大目标尺寸
        ("struMinTargetSize", NET_VCA_POLYGON), # 最小目标尺寸
    ]


LPNET_DVR_SMARTCALIBRATION_REGION = POINTER(NET_DVR_SMARTCALIBRATION_REGION)


RULE_REGION_MAX = 128
class NET_DVR_SMARTCALIBRATION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        # SmartType:
        # 0-linedetection,
        # 1-fielddetection,
        # 2-regionEntrance,
        # 3-regionExiting,
        # 4-loitering,
        # 5-rapidMove,
        # 6-parking,
        # 7-unattendedBaggage,
        # 8-attendedBaggage
        #
        ("bySmartType", BYTE), # 智能类型
        ("byRes", BYTE * 3),
        ("strRegion", NET_DVR_SMARTCALIBRATION_REGION * RULE_REGION_MAX),
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_SMARTCALIBRATION_CFG = POINTER(NET_DVR_SMARTCALIBRATION_CFG)


class NET_DVR_SMARTCALIBRATION_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        # SmartType:
        # 0-linedetection,
        # 1-fielddetection,
        # 2-regionEntrance,
        # 3-regionExiting,
        # 4-loitering,
        # 5-rapidMove,
        # 6-parking,
        # 7-unattendedBaggage,
        # 8-attendedBaggage
        #
        ("bySmartType", BYTE), # 智能类型
        ("byRes", BYTE * 3),
        ("dwChannel", DWORD), # 通道号
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_SMARTCALIBRATION_COND = POINTER(NET_DVR_SMARTCALIBRATION_COND)


class NET_DVR_SMARTCALIBRATION_REGION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("strRegion", NET_DVR_SMARTCALIBRATION_REGION * RULE_REGION_MAX),
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_SMARTCALIBRATION_REGION_CFG = POINTER(NET_DVR_SMARTCALIBRATION_REGION_CFG)


class NET_DVR_OSD_BATTERY_POWER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struOSDBatteryPower", NET_VCA_POINT), # 客流统计显示OSD显示左上角坐标
        ("byOSDBatteryPower", BYTE), # 电池电量OSD叠加显示使能,  0-否，1-是
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_OSD_BATTERY_POWER_CFG = POINTER(NET_DVR_OSD_BATTERY_POWER_CFG)


CARD_PARAM_CARD_VALID = 0x00000001 # 卡是否有效参数
CARD_PARAM_VALID = 0x00000002 # 有效期参数
CARD_PARAM_CARD_TYPE = 0x00000004 # 卡类型参数
CARD_PARAM_DOOR_RIGHT = 0x00000008 # 门权限参数
CARD_PARAM_LEADER_CARD = 0x00000010 # 首卡参数
CARD_PARAM_SWIPE_NUM = 0x00000020 # 最大刷卡次数参数
CARD_PARAM_GROUP = 0x00000040 # 所属群组参数
CARD_PARAM_PASSWORD = 0x00000080 # 卡密码参数
CARD_PARAM_RIGHT_PLAN = 0x00000100 # 卡权限计划参数
CARD_PARAM_SWIPED_NUM = 0x00000200 # 已刷卡次数
class NET_DVR_VALID_PERIOD_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能有效期，0-不使能，1使能
        ("byBeginTimeFlag", BYTE), # 是否限制起始时间的标志，0-不限制，1-限制
        ("byEnableTimeFlag", BYTE), # 是否限制终止时间的标志，0-不限制，1-限制
        ("byTimeDurationNo", BYTE), # 有效期索引,从0开始（时间段通过SDK设置给锁，后续在制卡时，只需要传递有效期索引即可，以减少数据量）
        ("struBeginTime", NET_DVR_TIME_EX), # 有效期起始时间
        ("struEndTime", NET_DVR_TIME_EX), # 有效期结束时间
        ("byTimeType", BYTE), # 时间类型：0-设备本地时间（默认），1-UTC时间（对于struBeginTime，struEndTime字段有效）
        ("byRes2", BYTE * 31),
    ]


LPNET_DVR_VALID_PERIOD_CFG = POINTER(NET_DVR_VALID_PERIOD_CFG)


class NET_DVR_CARD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwModifyParamType", DWORD),
        # 需要修改的卡参数，设置卡参数时有效，按位表示，每位代表一种参数，1为需要修改，0为不修改
        # #define CARD_PARAM_CARD_VALID       0x00000001 卡是否有效参数
        # #define CARD_PARAM_VALID            0x00000002  有效期参数
        # #define CARD_PARAM_CARD_TYPE        0x00000004  卡类型参数
        # #define CARD_PARAM_DOOR_RIGHT       0x00000008  门权限参数
        # #define CARD_PARAM_LEADER_CARD      0x00000010  首卡参数
        # #define CARD_PARAM_SWIPE_NUM        0x00000020  最大刷卡次数参数
        # #define CARD_PARAM_GROUP            0x00000040  所属群组参数
        # #define CARD_PARAM_PASSWORD         0x00000080  卡密码参数
        # #define CARD_PARAM_RIGHT_PLAN       0x00000100  卡权限计划参数
        # #define CARD_PARAM_SWIPED_NUM       0x00000200  已刷卡次数
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("byCardValid", BYTE), # 卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
        ("byCardType", BYTE), # 卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，默认普通卡
        ("byLeaderCard", BYTE), # 是否为首卡，1-是，0-否
        ("byRes1", BYTE),
        ("dwDoorRight", DWORD), # 门权限，按位表示，1为有权限，0为无权限，从低位到高位表示对门1-N是否有权限
        ("struValid", NET_DVR_VALID_PERIOD_CFG), # 有效期参数
        ("dwBelongGroup", DWORD), # 所属群组，按位表示，1-属于，0-不属于，从低位到高位表示是否从属群组1-N
        ("byCardPassword", BYTE * CARD_PASSWORD_LEN), # 卡密码
        ("byCardRightPlan", BYTE * MAX_DOOR_NUM), # 卡权限计划，取值为计划模板编号，同个门不同计划模板采用权限或的方式处理
        ("dwMaxSwipeTime", DWORD), # 最大刷卡次数，0为无次数限制
        ("dwSwipeTime", DWORD), # 已刷卡次数
        ("wRoomNumber", WORD), # 房间号
        ("wFloorNumber", SHORT), # 层号
        ("byRes2", BYTE * 20),
    ]


LPNET_DVR_CARD_CFG = POINTER(NET_DVR_CARD_CFG)


class NET_DVR_CARD_USER_INFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sUsername", BYTE * NAME_LEN), #  用户名
        ("byRes2", BYTE * 256), # byRes2[0]--网络报警主机用作用户号
    ]


LPNET_DVR_CARD_USER_INFO_CFG = POINTER(NET_DVR_CARD_USER_INFO_CFG)


ACS_PARAM_DOOR_STATUS_WEEK_PLAN = 0x00000001 # 门状态周计划参数
ACS_PARAM_VERIFY_WEEK_PALN = 0x00000002 # 读卡器周计划参数
ACS_PARAM_CARD_RIGHT_WEEK_PLAN = 0x00000004 # 卡权限周计划参数
ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN = 0x00000008 # 门状态假日计划参数
ACS_PARAM_VERIFY_HOLIDAY_PALN = 0x00000010 # 读卡器假日计划参数
ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN = 0x00000020 # 卡权限假日计划参数
ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP = 0x00000040 # 门状态假日组参数
ACS_PARAM_VERIFY_HOLIDAY_GROUP = 0x00000080 # 读卡器验证方式假日组参数
ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP = 0x00000100 # 卡权限假日组参数
ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE = 0x00000200 # 门状态计划模板参数
ACS_PARAM_VERIFY_PALN_TEMPLATE = 0x00000400 # 读卡器验证方式计划模板参数
ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE = 0x00000800 # 卡权限计划模板参数
ACS_PARAM_CARD = 0x00001000 # 卡参数
ACS_PARAM_GROUP = 0x00002000 # 群组参数
ACS_PARAM_ANTI_SNEAK_CFG = 0x00004000 # 反潜回参数
ACS_PAPAM_EVENT_CARD_LINKAGE = 0x00008000 # 事件及卡号联动参数
ACS_PAPAM_CARD_PASSWD_CFG = 0x00010000 # 密码开门使能参数
ACS_PARAM_PERSON_STATISTICS_CFG = 0x00020000 # 人数统计参数
ACS_PARAM_BLACK_LIST_PICTURE = 0x00040000 # 黑名单图片参数
ACS_PARAM_ID_BLACK_LIST = 0x00080000 # 身份证黑名单参数
ACS_PARAM_EXAM_INFO = 0x00100000 # 考试信息参数
ACS_PARAM_EXAMINEE_INFO = 0x00200000 # 考生信息参数
ACS_PARAM_FAILED_FACE_INFO = 0x00400000 # 升级设备人脸建模失败记录
class NET_DVR_ACS_PARAM_TYPE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwParamType", DWORD), # 参数类型，按位表示
        # #define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 门状态周计划参数
        # #define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 读卡器周计划参数
        # #define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 卡权限周计划参数
        # #define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 门状态假日计划参数
        # #define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 读卡器假日计划参数
        # #define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 卡权限假日计划参数
        # #define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 门状态假日组参数
        # #define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 读卡器验证方式假日组参数
        # #define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 卡权限假日组参数
        # #define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 门状态计划模板参数
        # #define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 读卡器验证方式计划模板参数
        # #define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 卡权限计划模板参数
        # #define ACS_PARAM_CARD                         0x00001000 卡参数
        # #define ACS_PARAM_GROUP                        0x00002000 群组参数
        # #define ACS_PARAM_ANTI_SNEAK_CFG               0x00004000 反潜回参数
        # #define ACS_PAPAM_EVENT_CARD_LINKAGE          0x00008000 事件及卡号联动参数
        # #define ACS_PAPAM_CARD_PASSWD_CFG             0x00010000 密码开门使能参数
        # #define ACS_PARAM_PERSON_STATISTICS_CFG       0x00020000 人数统计参数
        # #define ACS_PARAM_BLACK_LIST_PICTURE          0x00040000 黑名单图片参数
        # #define ACS_PARAM_ID_BLACK_LIST               0x00080000 身份证黑名单参数
        # #define ACS_PARAM_EXAM_INFO                   0x00100000 考试信息参数
        # #define ACS_PARAM_EXAMINEE_INFO               0x00200000 考生信息参数
        # #define ACS_PARAM_FAILED_FACE_INFO             0x00400000 升级设备人脸建模失败记录
        ("wLocalControllerID", WORD), # 就地控制器序号[1,64],0代表门禁主机
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_ACS_PARAM_TYPE = POINTER(NET_DVR_ACS_PARAM_TYPE)


class NET_DVR_VIDEO_INTERCOM_IOIN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byIOUseType", BYTE), # 用途，0-禁用，1-开门按钮，2-门状态，0xff-自定义
        ("byRes", BYTE * 63), #  保留字节
    ]


LPNET_DVR_VIDEO_INTERCOM_IOIN_CFG = POINTER(NET_DVR_VIDEO_INTERCOM_IOIN_CFG)


class NET_DVR_VIDEO_INTERCOM_IOOUT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byIOUseType", BYTE), # 用途，0-禁用，1-电锁，0xff-自定义
        ("byRes", BYTE * 63), #  保留字节
    ]


LPNET_DVR_VIDEO_INTERCOM_IOOUT_CFG = POINTER(NET_DVR_VIDEO_INTERCOM_IOOUT_CFG)


class NET_DVR_ELEVATORCONTROL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnable", BYTE), # 是否启用梯控，0-否，1-是
        ("byRes1", BYTE), # 保留
        ("byInterfaceType", BYTE), # 接口类型，0-无，1-RS485,2-网口
        ("byRS485Protocol", BYTE), # RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
        ("byNetworkType", BYTE), # 网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
        ("byRes", BYTE * 63), #  保留字节
    ]


LPNET_DVR_ELEVATORCONTROL_CFG = POINTER(NET_DVR_ELEVATORCONTROL_CFG)


class NET_DVR_ELEVATORCONTROL_CFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("byEnable", BYTE), # 是否启用梯控，0-否，1-是
        ("byRes1", BYTE), # 保留
        ("byInterfaceType", BYTE), # 接口类型，0-无，1-RS485,2-网口
        ("byRS485Protocol", BYTE), # RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
        ("byNetworkType", BYTE), # 网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
        ("byRes2", BYTE), # 保留
        ("wServerPort", WORD), # 梯控服务器端口号，当网卡协议类型为1-私有 时有效
        ("struServerIP", NET_DVR_IPADDR), # 梯控服务器IP，当网卡协议类型为1-私有 时有效
        ("byRes", BYTE * 256), #  保留字节
    ]


LPNET_DVR_ELEVATORCONTROL_CFG_V40 = POINTER(NET_DVR_ELEVATORCONTROL_CFG_V40)


class NET_DVR_ELEVATORCONTROL_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用梯控，0-否，1-是
        ("byNegativeFloor", BYTE), # 负楼层层数
        ("byInterfaceType", BYTE), # 接口类型，0-无，1-RS485,2-网口
        ("byRS485Protocol", BYTE), # RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
        ("byNetworkType", BYTE), # 网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
        ("byElevatorControlType", BYTE), # 梯控器类型：0-无效，1-DS-K2201，2-DS-K2210
        ("wServerPort", WORD), # 梯控服务器端口号，当网卡协议类型为1-私有 时有效
        ("struServerIP", NET_DVR_IPADDR), # 梯控服务器IP，当网卡协议类型为1-私有 时有效
        ("sUserName", BYTE * NET_DVR_LOGIN_USERNAME_MAX_LEN), # 用户名，当网卡协议类型为1-私有 时有效（只能设置，不能获取）
        ("sPassword", BYTE * NET_DVR_LOGIN_PASSWD_MAX_LEN), # 密码，当网卡协议类型为1-私有 时有效（只能设置，不能获取）
        ("byRes", BYTE * 256), # 保留字节
    ]


LPNET_DVR_ELEVATORCONTROL_CFG_V50 = POINTER(NET_DVR_ELEVATORCONTROL_CFG_V50)


class NET_DVR_ROOM_CUSTOM_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRoomNumber", DWORD), # 房间数目（设置时有效）
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ROOM_CUSTOM_COND = POINTER(NET_DVR_ROOM_CUSTOM_COND)


class NET_DVR_ROOM_CUSTOM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFormerRoomNo", DWORD), # 原房间号
        ("dwCustomRoomNo", DWORD), # 自定义序号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ROOM_CUSTOM_CFG = POINTER(NET_DVR_ROOM_CUSTOM_CFG)


class NET_DVR_ROOM_CUSTOM_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFormerRoomNo", DWORD), # 原房间号
        ("byStatus", BYTE), # 下发状态：0-无效，1-失败，2-处理中，3-成功
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_ROOM_CUSTOM_STATUS = POINTER(NET_DVR_ROOM_CUSTOM_STATUS)


class NET_DVR_VIDEOINTERCOM_STREAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byVisDevID", BYTE * MAX_NAMELEN), #  可视对讲设备编号，即长号，设备类型为IPC时全部为0
        ("byDeviceName", BYTE * NAME_LEN), # 设备名称
        ("bySourceType", BYTE), # 视频源类型，0无意义，1-IPC、2-DVR/DVS/NVR、3-门口机、4-围墙机、5-二次确认机
        ("byRes", BYTE * 255), # 保留
    ]


LPNET_DVR_VIDEOINTERCOM_STREAM = POINTER(NET_DVR_VIDEOINTERCOM_STREAM)


UNLOCK_PASSWORD_LEN = 8 # 解除密码长度
LOCAL_CONTROLLER_NAME_LEN = 32 # 就地控制器名称长度
class NET_DVR_DOOR_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDoorName", BYTE * DOOR_NAME_LEN), # 门名称
        ("byMagneticType", BYTE), # 门磁类型，0-常闭，1-常开
        ("byOpenButtonType", BYTE), # 开门按钮类型，0-常闭，1-常开
        ("byOpenDuration", BYTE), # 开门持续时间，1-255s（楼层继电器动作时间）
        ("byDisabledOpenDuration", BYTE), # 残疾人卡开门持续时间，1-255s
        ("byMagneticAlarmTimeout", BYTE), # 门磁检测超时报警时间，0-255s，0表示不报警
        ("byEnableDoorLock", BYTE), # 是否启用闭门回锁，0-否，1-是
        ("byEnableLeaderCard", BYTE), # 是否启用首卡常开功能，0-否，1-是
        ("byLeaderCardMode", BYTE), # 首卡模式，0-不启用首卡功能，1-首卡常开模式，2-首卡授权模式（使用了此字段，则byEnableLeaderCard无效）
        ("dwLeaderCardOpenDuration", DWORD), # 首卡常开持续时间，1-1440min
        ("byStressPassword", BYTE * STRESS_PASSWORD_LEN), # 胁迫密码
        ("bySuperPassword", BYTE * SUPER_PASSWORD_LEN), # 超级密码
        ("byUnlockPassword", BYTE * UNLOCK_PASSWORD_LEN), # 解除码NET_DVR_LOCAL_CONTROLLER_STATUS
        ("byUseLocalController", BYTE), # 只读，是否连接在就地控制器上，0-否，1-是
        ("byRes1", BYTE),
        ("wLocalControllerID", WORD), # 只读，就地控制器序号，1-64,0代表未注册
        ("wLocalControllerDoorNumber", WORD), # 只读，就地控制器的门编号，1-4,0代表未注册
        ("wLocalControllerStatus", WORD), # 只读，就地控制器在线状态：0-离线，1-网络在线，2-环路1上的RS485串口1，3-环路1上的RS485串口2，4-环路2上的RS485串口1，5-环路2上的RS485串口2，6-环路3上的RS485串口1，7-环路3上的RS485串口2，8-环路4上的RS485串口1，9-环路4上的RS485串口2（只读）
        ("byLockInputCheck", BYTE), # 是否启用门锁输入检测(1字节，0不启用，1启用，默认不启用)
        ("byLockInputType", BYTE), # 门锁输入类型(1字节，0常闭，1常开，默认常闭)
        ("byDoorTerminalMode", BYTE), # 门相关端子工作模式(1字节，0防剪防短，1普通，默认防剪防短)
        ("byOpenButton", BYTE), # 是否启用开门按钮(1字节，0是，1否，默认是)
        ("byLadderControlDelayTime", BYTE), # 梯控访客延迟时间，1-255min
        ("byRes2", BYTE * 43),
    ]


LPNET_DVR_DOOR_CFG = POINTER(NET_DVR_DOOR_CFG)


class NET_DVR_VIS_DEV_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szDevNumber", BYTE * MAX_DEV_NUMBER_LEN), # 设备编号
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_VIS_DEV_INFO = POINTER(NET_DVR_VIS_DEV_INFO)


class NET_DVR_VIS_REGISTER_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwID", DWORD), # ID
        ("szDevNumber", BYTE * MAX_DEV_NUMBER_LEN), # 设备编号
        ("byMACAddr", BYTE * MACADDR_LEN), # mac地址
        ("byRes1", BYTE * 2), # 保留
        ("sSerialNumber", BYTE * SERIALNO_LEN), # 设备序列号
        ("struDevIP", NET_DVR_IPADDR), # 设备IP地址
        ("struRegisterTime", NET_DVR_TIME_EX), # 注册时间
        ("byRegisterType", BYTE), # 注册类型，0-保留、1-门口机，2-管理机、3-室内机、4-围墙机、5-别墅门口机、6-二次确认机、7-8700客户端、8-4200客户端
        ("byRes", BYTE * 127), # 保留
    ]


LPNET_DVR_VIS_REGISTER_INFO = POINTER(NET_DVR_VIS_REGISTER_INFO)


class NET_DVR_CALLER_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("wBuildingNo", WORD), # 楼号
        ("wFloorNo", SHORT), # 层号
        ("byZoneNo", BYTE), # 期号
        ("byUnitNo", BYTE), # 单元号
        ("byDevNo", BYTE), # 设备编号
        ("byDevType", BYTE), # 设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-8700客户端，8-4200客户端，9-APP, 10- 门铃机，11-VOIP客户端，12-监控点IPC设备
        ("byLockNum", BYTE), # 锁数量0-按照老的逻辑走，其他值-代表实际锁的数量
        ("byHighDevNo", BYTE), #  设备编号高8位,用于支持1-9999的范围
        ("byRes1", BYTE * 2), #  保留
        ("byVoipNo", BYTE * 16), #  VOIP客户端号码 byDevType：为11时有效
        ("byRes", BYTE * 80), #  保留
    ]


LPNET_DVR_CALLER_INFO = POINTER(NET_DVR_CALLER_INFO)


class NET_DVR_CALL_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byCallStatus", BYTE), # 获取通话状态，1-无呼叫、2-响铃、3-正在通话
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_CALL_STATUS = POINTER(NET_DVR_CALL_STATUS)


MAX_SERVER_DEVICE_NUMBER = 16 # 最大设备数量
class NET_DVR_SERVER_DEVICE_CFG(Structure):
    _fields_ = [
        ("byDeviceName", BYTE * NAME_LEN), # 设备名称
        ("byDeviceType", BYTE), # 设备类型，1-门口机，2-管理机，3-室内机
        ("byDeviceID", BYTE), # 门口机编号
        ("byLockNum", BYTE), # 锁数量0-按照老的逻辑走，其他值-代表实际锁的数量
        ("byRes", BYTE * 5), # 保留
    ]


LPNET_DVR_SERVER_DEVICE_CFG = POINTER(NET_DVR_SERVER_DEVICE_CFG)


class NET_DVR_SERVER_DEVICE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwDeviceNum", DWORD), # 设备数
        ("struDeviceCfg", NET_DVR_SERVER_DEVICE_CFG * MAX_SERVER_DEVICE_NUMBER), # 设备信息
        ("byRes", BYTE * 200), # 保留
    ]


LPNET_DVR_SERVER_DEVICE_INFO = POINTER(NET_DVR_SERVER_DEVICE_INFO)


class NET_DVR_VIDEO_CALL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCmdType", DWORD), # 信令类型  0-请求呼叫，1-取消本次呼叫，2-接听本次呼叫 3-拒绝本地来电呼叫 4-被叫响铃超时 5-结束本次通话，6-设备正在通话中，7-客户端正在通话中，8室内机不在线
        ("wPeriod", WORD), # 期号, 范围[0,9]
        ("wBuildingNumber", WORD), # 楼号
        ("wUnitNumber", WORD), # 单元号
        ("wFloorNumber", SHORT), # 层号
        ("wRoomNumber", WORD), # 房间号
        ("wDevIndex", WORD), # 设备编号
        ("byUnitType", BYTE), # 设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-8700客户端，8-4200客户端，9-APP
        ("byRes", BYTE * 115), # 保留
    ]


LPNET_DVR_VIDEO_CALL_PARAM = POINTER(NET_DVR_VIDEO_CALL_PARAM)


MAX_SCREEN_ADDRESS_LEN = 16 # 特征码最大长度
MAX_DAY_TIME_POINT = 8 # 每天最大时间点个数
MAX_TIME_POINT = 16 # 每年最大时间点个数
class NET_DVR_DEV_IP_INFO(Structure):
    _fields_ = [
        ("byUserName", BYTE * NAME_LEN), # 用户名
        ("byPassWord", BYTE * PASSWD_LEN), # 密码
        ("struIPAddr", NET_DVR_IPADDR), # IP地址
        ("wPort", WORD), # 端口号
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_DEV_IP_INFO = POINTER(NET_DVR_DEV_IP_INFO)


class NET_DVR_SCREEN_BASE_INFO(Union):
    _fields_ = [
        ("byScreenAddress", BYTE * MAX_SCREEN_ADDRESS_LEN), # 屏幕特征码，设备添加方式为0时有效
        ("struIPInfo", NET_DVR_DEV_IP_INFO), # 屏幕ip地址信息
        ("byRes", BYTE * 100),
    ]


LPNET_DVR_SCREEN_BASE_INFO = POINTER(NET_DVR_SCREEN_BASE_INFO)


class NET_DVR_SCREEN_INDEX_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnbale", BYTE), # 使能，0-不使能，1-使能
        ("byDevAddType", BYTE), # 设备添加方式，0-按特征码(服务器和屏幕使用串口通信)，1-按IP地址(服务器和屏幕使用网络通信)
        ("byRes1", BYTE * 2),
        ("struScreenBaseInfo", NET_DVR_SCREEN_BASE_INFO), # 屏幕设备基本信息
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_SCREEN_INDEX_CFG = POINTER(NET_DVR_SCREEN_INDEX_CFG)


# 模拟遥控器参数
class NET_DVR_SIMULATE_REMOTE_CTRL(Structure):
    _fields_ = [
        ("byControlType", BYTE), # 1-电源开，2-电源关，3-信号源，4-菜单，5-确定，6-上，7-下，8-左，9-右,  10-INFO, 11-返回上一层,12-数字按键
        ("byControlParam", BYTE), # 操作参数，操作类型为12时，表示按键值(0-9)，其他操作时此参数无效
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_SIMULATE_REMOTE_CTRL = POINTER(NET_DVR_SIMULATE_REMOTE_CTRL)


# 屏幕维墙参数
class NET_DVR_SCREEN_WALL_CTRL(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 状态开关。0-为关闭；1-为开启
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_SCREEN_WALL_CTRL = POINTER(NET_DVR_SCREEN_WALL_CTRL)


# 区域放大还原参数
class NET_DVR_AREA_ZOOM_CFG(Structure):
    _fields_ = [
        ("byCmd", BYTE), # 区域放大还原指令，1-放大，2-还原
        ("byRes", BYTE * 3),
        ("struArea", NET_DVR_RECTCFG), # 需要放大的区域，以1920*1920作为屏幕总大小，还原时此参数无效
    ]


LPNET_DVR_AREA_ZOOM_CFG = POINTER(NET_DVR_AREA_ZOOM_CFG)


class NET_DVR_SCREEN_CONTROL_PARAM(Union):
    _fields_ = [
        ("struInputCtrl", NET_DVR_INPUT_INTERFACE_CTRL),
        ("struDisplayCtrl", NET_DVR_DISPLAY_COLOR_CTRL),
        ("struPositionCtrl", NET_DVR_DISPLAY_POSITION_CTRL),
        ("struSimulateRemoteCrtl", NET_DVR_SIMULATE_REMOTE_CTRL), # 模拟遥控按键
        ("struScreenWallCtrl", NET_DVR_SCREEN_WALL_CTRL), # 屏幕维墙参数
        ("struZoomArea", NET_DVR_AREA_ZOOM_CFG), # 区域放大还原参数
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_SCREEN_CONTROL_PARAM = POINTER(NET_DVR_SCREEN_CONTROL_PARAM)


class NET_DVR_SCREEN_CONTROL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCommand", DWORD), #  控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制
        ("byProtocol", BYTE), # 串口协议类型,1:LCD-S1,2:LCD-S2
        ("byRes1", BYTE * 3),
        ("struControlParam", NET_DVR_SCREEN_CONTROL_PARAM),
        ("byRes2", BYTE * 52),
    ]


LPNET_DVR_SCREEN_CONTROL = POINTER(NET_DVR_SCREEN_CONTROL)


class NET_DVR_SCREEN_CONTROL_V41(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySerialNo", BYTE), # 串口号
        ("byRes", BYTE * 2),
        ("byProtocol", BYTE), #  串口协议类型 1-LCD-S1,2-LCD-S2,3-LCD-L1,4-LCD-DLP,5-LCD-S3,6-LCD-D20，7-LCD-L2,8-LCD-Z1，
        # 9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,
        # 16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+,21-LCD-D20/Z  0xff-无效，使用预先绑定的协议类型
        ("dwCommand", DWORD), #  控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制，6-模拟遥控按键,7-显示屏幕状态,
        # 8-显示屏幕特征码（此命令矩形区域起始坐标设为（0,0），宽高均设为0xffffffff）, 9-屏幕维墙,10-恢复屏幕默认参数，11-显示IP（此命令矩形区域起始坐标设为（0,0），宽高均设为0xffffffff）,12-屏幕USB升级 13-区域放大还原
        ("struControlParam", NET_DVR_SCREEN_CONTROL_PARAM),
        ("byWallNo", BYTE), #  电视墙号
        ("byDevNo", BYTE), # 设备号
        ("bySubboardNo", BYTE), # 子板号
        ("byRes1", BYTE),
        ("struRect", NET_DVR_RECTCFG_EX), # 根据坐标进行计算，基准坐标
        ("byRes2", BYTE * 28),
    ]


LPNET_DVR_SCREEN_CONTROL_V41 = POINTER(NET_DVR_SCREEN_CONTROL_V41)


class NET_DVR_MSC_SPLICE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySpliceNo", BYTE), # 拼接屏号
        ("byWallNo", BYTE), # 电视墙号
        ("byEnable", BYTE), # 是否使能，0-否，1-是
        ("byRes1", BYTE * 1),
        ("struRectCfg", NET_DVR_RECTCFG_EX), # 需要进行拼接的区域，获取的时候此参数填0
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_MSC_SPLICE_CFG = POINTER(NET_DVR_MSC_SPLICE_CFG)


class NET_DVR_MSC_SCREEN_INTERFACE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byInterfaceType", BYTE), # 输入源索引，见枚举 INPUT_INTERFACE_TYPE
        ("byNoSignalPic", BYTE), # 无信号画面模式，1-蓝屏，2-黑屏，3-LOGO画面
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_MSC_SCREEN_INTERFACE_CFG = POINTER(NET_DVR_MSC_SCREEN_INTERFACE_CFG)


# 背光参数
class NET_DVR_MSC_SCREEN_BACKLIGHT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byBacklight", BYTE), # 背光，0-100
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_MSC_SCREEN_BACKLIGHT_CFG = POINTER(NET_DVR_MSC_SCREEN_BACKLIGHT_CFG)


# 画中画参数
class NET_DVR_MSC_SCREEN_PIP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用画中画 0-不启用 1-启用
        ("bySubWindowSource", BYTE), # 子画面信号源，参考枚举INPUT_INTERFACE_TYPE
        ("bySubWindowBorderColor", BYTE), # 子画面边框颜色， 1-蓝色，2-黑色
        ("byRes1", BYTE),
        ("struPosition", NET_DVR_RECTCFG_EX), # 子画面位置，屏幕总大小为1920*1920
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_MSC_SCREEN_PIP_CFG = POINTER(NET_DVR_MSC_SCREEN_PIP_CFG)


class NET_DVR_SCREEN_WORK_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFanStatus", BYTE), # 风扇状态，0-关，1-开
        ("byFanExceptionStatus", BYTE), # 风扇异常状态，0-不支持，1-正常，2-异常
        ("byRes1", BYTE * 2),
        ("dwWorkingHours", DWORD), # 累积工作时长，单位：小时
        ("byVersion", BYTE * VERSION_LEN), # 软件版本号
        ("iTemperature", int), # 板卡温度，精确到个位，单位：摄氏度
        ("byTempState", BYTE), # 板卡温度状态，0-不支持，1-正常，2-异常
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_SCREEN_WORK_STATE = POINTER(NET_DVR_SCREEN_WORK_STATE)


# 开机logo参数
class NET_DVR_BOOT_LOGO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 开机是否显示logo,0-不显示，1-显示
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_BOOT_LOGO_CFG = POINTER(NET_DVR_BOOT_LOGO_CFG)


# 音频参数
class NET_DVR_LCD_AUDIO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMute", BYTE), # 是否静音，0-否，1-是
        ("byVolume", BYTE), # 音量大小，0-100
        ("byBalance", CHAR), # 声道平衡，-50-+50
        ("byRes", BYTE * 33),
    ]


LPNET_DVR_LCD_AUDIO_CFG = POINTER(NET_DVR_LCD_AUDIO_CFG)


# 屏幕参数联合体
class NET_DVR_MSC_SCREEN_PARAM(Union):
    _fields_ = [
        ("struInterfaceCfg", NET_DVR_MSC_SCREEN_INTERFACE_CFG), # 输入源参数
        ("struFanWorkMode", NET_DVR_SCREEN_FAN_WORK_MODE_CFG), # 风扇工作模式参数
        ("struVgaCfg", NET_DVR_SCREEN_VGA_CFG), # VGA信号参数
        ("struMenuCfg", NET_DVR_SCREEN_MENU_CFG), # 屏幕菜单参数
        ("struOutEffectCfg", NET_DVR_VIDEO_OUT_CFG), # 显示效果参数
        ("struColorTemperatureCfg", NET_DVR_COLOR_TEMPERATURE_CFG), # 色温参数
        ("struAdcCfg", NET_DVR_ADC_CFG), # ADC参数
        ("struScreenEdgeCfg", NET_DVR_SCREEN_EDGE_CFG), # 屏幕边缘参数
        ("struBacklight", NET_DVR_MSC_SCREEN_BACKLIGHT_CFG), # 背光参数
        ("struPicInPicCfg", NET_DVR_MSC_SCREEN_PIP_CFG), # 画中画参数
        ("struDefog", NET_DVR_DEFOG_LCD), # 去雾参数
        ("struWorkState", NET_DVR_SCREEN_WORK_STATE), # 屏幕工作状态
        ("struBootLogoCfg", NET_DVR_BOOT_LOGO_CFG), # 开始显示logo参数
        ("struAudioCfg", NET_DVR_LCD_AUDIO_CFG), # 音频参数
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_MSC_SCREEN_PARAM = POINTER(NET_DVR_MSC_SCREEN_PARAM)


class NET_DVR_MSC_SCREEN_PARAM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byParamType", BYTE), # 参数类型，1-输入源参数，2-风扇工作模式参数，3-VGA信号参数，4-屏幕菜单参数，5-显示效果参数，6-色温参数，7-ADC参数，8-屏幕边缘参数，9-背光参数，10-画中画参数，11-透雾参数，12-屏幕工作状态（只能获取），13-开机LOGO是否显示参数  14-音频参数
        ("byRes1", BYTE * 3),
        ("struParam", NET_DVR_MSC_SCREEN_PARAM), # 屏幕参数
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_MSC_SCREEN_PARAM_CFG = POINTER(NET_DVR_MSC_SCREEN_PARAM_CFG)


class NET_DVR_MSC_SCREEN_REMOTE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWallNo", BYTE), # 电视墙号
        ("byRes1", BYTE * 3),
        ("struRectCfg", NET_DVR_RECTCFG_EX), # 屏幕区域
        ("struScreenParam", NET_DVR_MSC_SCREEN_PARAM_CFG), # 配置的屏幕参数
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_MSC_SCREEN_REMOTE_CFG = POINTER(NET_DVR_MSC_SCREEN_REMOTE_CFG)


class NET_DVR_MSC_SCREEN_PARAM_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWallNo", BYTE), # 电视墙号
        ("byParamType", BYTE), # 参数类型，1-输入源参数，2-风扇工作模式参数，3-VGA信号参数，4-屏幕菜单参数，5-显示效果参数，6-色温参数，7-ADC参数，8-屏幕边缘参数，9-背光参数，10-画中画参数，11-透雾参数，12-屏幕工作状态（只能获取），13-开机LOGO是否显示参数 14-音频参数
        ("byRes1", BYTE * 2),
        ("struRectCfg", NET_DVR_RECTCFG_EX), # 屏幕区域
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_MSC_SCREEN_PARAM_COND = POINTER(NET_DVR_MSC_SCREEN_PARAM_COND)


class NET_DVR_SWITCH_DAY_TIME(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该时间点,0-不启用，1-启用
        ("bySwitchType", BYTE), # 开关机类型，0-关机，1-开机
        ("byRes1", BYTE * 2),
        ("struTimePoint", NET_DVR_DAYTIME), # 开关机时间点
        ("byRes2", BYTE * 8),
    ]


LPNET_DVR_SWITCH_DAY_TIME = POINTER(NET_DVR_SWITCH_DAY_TIME)


class NET_DVR_SWITCH_TIME_POINT(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该时间点,0-不启用，1-启用
        ("bySwitchType", BYTE), # 开关机类型，0-关机，1-开机
        ("byRes1", BYTE * 2),
        ("struTimePoint", NET_DVR_SYSTEM_TIME), # 开关机时间点
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_SWITCH_TIME_POINT = POINTER(NET_DVR_SWITCH_TIME_POINT)


class NET_DVR_TIME_SWITCH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSwitchDayTime", NET_DVR_SWITCH_DAY_TIME * MAX_DAYS), # 周开关机计划
        ("struSwitchTimePoint", NET_DVR_SWITCH_TIME_POINT * MAX_TIME_POINT), # 按时间点开关机参数
        ("byRes1", BYTE * 3),
        ("byEnable", BYTE), # 是否启用定时开关机,0-不启用，1-启用
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_TIME_SWITCH_CFG = POINTER(NET_DVR_TIME_SWITCH_CFG)


class NET_DVR_VIDEO_WALL_AREA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWallNo", BYTE), # 电视墙号
        ("byRes1", BYTE * 3),
        ("struRect", NET_DVR_RECTCFG_EX), # 屏幕范围
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_VIDEO_WALL_AREA = POINTER(NET_DVR_VIDEO_WALL_AREA)


class NET_DVR_DELAY_TIME(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDelayTime", DWORD), # 延时时间，0-3000，单位：ms
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DELAY_TIME = POINTER(NET_DVR_DELAY_TIME)


# 双目标定类型
ENUM_BV_CALIBRATION_NONE = 0
ENUM_BV_CALIBRATION_DIRECT = 1
ENUM_BV_CALIBRATION_SAMPLE = 2


# 样本标定点
class NET_DVR_BV_SAMPLE_CALIB_POINT(Structure):
    _fields_ = [
        ("byCalibPtID", BYTE), # 标定点ID，范围[1,5]。表示此点在双目标定过程中的序号
        ("byRes1", BYTE * 3), # 保留
        ("struPoint", NET_VCA_POINT), # 标定点坐标
        ("byRes2", BYTE * 16), # 保留
    ]


LPNET_DVR_BV_SAMPLE_CALIB_POINT = POINTER(NET_DVR_BV_SAMPLE_CALIB_POINT)


# 开始样本标定输入参数
class NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM(Structure):
    _fields_ = [
        ("dwCameraHeight", DWORD), # 摄像机高度，单位cm
        ("dwHumanHeight", DWORD), # 人体身高，单位cm
        ("byRes", BYTE * 248), # 保留
    ]


LPNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM = POINTER(NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM)


# 设置样本标定输入参数
class NET_DVR_BV_SAMPLE_CALIB_SET_PARAM(Structure):
    _fields_ = [
        ("struCalibPoint", NET_DVR_BV_SAMPLE_CALIB_POINT), # 标定点。即当人员保持直立行走，人脸出现在特定画面区域中时，此点表示对象两眼连线的中点。
        ("byRes", BYTE * 228), # 保留
    ]


LPNET_DVR_BV_SAMPLE_CALIB_SET_PARAM = POINTER(NET_DVR_BV_SAMPLE_CALIB_SET_PARAM)


# 结束样本标定输入参数
class NET_DVR_BV_SAMPLE_CALIB_END_PARAM(Structure):
    _fields_ = [
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_BV_SAMPLE_CALIB_END_PARAM = POINTER(NET_DVR_BV_SAMPLE_CALIB_END_PARAM)


# 样本标定输入参数联合体
class NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION(Union):
    _fields_ = [
        ("byRes", BYTE * 256), # 保留
        ("struCalibBegin", NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM), # 开始标定输入参数
        ("struCalibSet", NET_DVR_BV_SAMPLE_CALIB_SET_PARAM), # 设置标定输入参数
        ("struCalibEnd", NET_DVR_BV_SAMPLE_CALIB_END_PARAM), # 结束标定输入参数
    ]


LPNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION = POINTER(NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION)


# 样本标定命令枚举
ENUM_BV_SAMPLE_CALIB_BEGIN = 1
ENUM_BV_SAMPLE_CALIB_SETTING = 2
ENUM_BV_SAMPLE_CALIB_END = 3


# 样本标定结构体
class NET_DVR_BV_SAMPLE_CALIBRATION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD), # 通道号
        ("byCommand", BYTE), # 标定命令，参见BV_SAMPLE_CALIB_CMD _ENUM
        ("byRes1", BYTE * 3), # 保留
        ("uCalibParam", NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION), # 标定输入参数，取值依赖于字段byCommand
        ("byRes2", BYTE * 256), # 保留
    ]


LPNET_DVR_BV_SAMPLE_CALIBRATION = POINTER(NET_DVR_BV_SAMPLE_CALIBRATION)


# 双目样本标定信息
class NET_DVR_BV_SAMPLE_CALIB_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwCameraHeight", DWORD), # 摄像机高度，单位cm
        ("fPitchAngle", float), # 摄像机俯视角度[0°, 60°],
        ("fInclineAngle", float), # 摄像机倾斜角度[-20°,20°]
        ("struCalibPoint", NET_DVR_BV_SAMPLE_CALIB_POINT * MAX_SAMPLE_NUM), # 标定点组
        ("struCalibPointEx", NET_DVR_BV_SAMPLE_CALIB_POINT * MAX_SAMPLE_NUM_EX), # 标定点组扩展
        ("byRes", BYTE * 60), # 保留
    ]


LPNET_DVR_BV_SAMPLE_CALIB_CFG = POINTER(NET_DVR_BV_SAMPLE_CALIB_CFG)


# 双目图像校正参数结构体
class NET_DVR_BINOC_RECTIFY_PARAM(Structure):
    _fields_ = [
        ("fCamInternalMatrix", float * 3), # 相机内参矩阵，包括焦距及主点坐标
        ("fDistCoeffs", float * 8), # 镜头畸变系数
        ("fRotateMatrix", float * 3), # 校正后的旋转矩阵
        ("fProjectMatrix", float * 3), # 校正后的投影矩阵
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_BINOC_RECTIFY_PARAM = POINTER(NET_DVR_BINOC_RECTIFY_PARAM)


# 左右相机校正参数
# 输出视频类型
class NET_DVR_OUTPUT_VIDEO_TYPE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byType", BYTE), # 输出视频类型，1-拼接图，2-深度图
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_OUTPUT_VIDEO_TYPE = POINTER(NET_DVR_OUTPUT_VIDEO_TYPE)


MAX_CHECK_485CHAN = 64 # 485自检设备通道号个数
class NET_DVR_DEVICE_SELF_CHECK_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRS485Chan", DWORD * MAX_CHECK_485CHAN), # RS485通断情况有问题的通道号，值表示通道号，位表示槽位号
        ("dwSensorChan", DWORD * 4), # 模拟量无效的通道号，按位表示
        ("byRes", BYTE * 32), #  保留字节
    ]


LPNET_DVR_DEVICE_SELF_CHECK_STATE = POINTER(NET_DVR_DEVICE_SELF_CHECK_STATE)


# 设置完全获取出厂值
class NET_DVR_COMPLETE_RESTORE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_COMPLETE_RESTORE_INFO = POINTER(NET_DVR_COMPLETE_RESTORE_INFO)


class NET_DVR_UPLOAD_PICTURE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 图片对应的通道号
        ("byPictureType", BYTE), # 图片格式,0-bmp，1-jpeg，2-PNG 3-SWF 4-GIF
        ("byRes1", BYTE * 3),
        ("struTime", NET_DVR_TIME_V30), # 图片生成时间
        ("sPictureBuffer", CHARP), # 图片缓冲区
        ("dwPictureLength", DWORD), # 图片长度
        ("dwPicMangeNo", DWORD), # 图片管理号
        ("sPicName", BYTE * NAME_LEN), # 图片名称
        ("byUseType", BYTE), # 图片使用类型：0-屏保图片 1-开机logo图片
        ("byRes", BYTE * 91),
    ]


LPNET_DVR_UPLOAD_PICTURE_INFO = POINTER(NET_DVR_UPLOAD_PICTURE_INFO)


MAX_UPLOADFILE_URL_LEN = 240
class NET_DVR_UPLOAD_FILE_RET(Structure):
    _fields_ = [
        ("sUrl", BYTE * MAX_UPLOADFILE_URL_LEN), # url
        ("byRes", BYTE * 260),
    ]


LPNET_DVR_UPLOAD_FILE_RET = POINTER(NET_DVR_UPLOAD_FILE_RET)


class NET_DVR_FACE_EXTRA_INFO(Structure):
    _fields_ = [
        ("struVcaRect", NET_VCA_RECT * MAX_FACE_PIC_NUM), # 人脸子图坐标信息
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FACE_EXTRA_INFO = POINTER(NET_DVR_FACE_EXTRA_INFO)


class NET_DVR_PIC_EXTRA_INFO_UNION(Union):
    _fields_ = [
        ("byUnionLen", BYTE * 544), # 联合体长度，无实际意义
        ("struFaceExtraInfo", NET_DVR_FACE_EXTRA_INFO), # 人脸侦测信息
    ]


LPNET_DVR_PIC_EXTRA_INFO_UNION = POINTER(NET_DVR_PIC_EXTRA_INFO_UNION)


class NET_DVR_FIND_PICTURE_V40(Structure):
    _fields_ = [
        ("sFileName", CHAR * PICTURE_NAME_LEN), # 图片名
        ("struTime", NET_DVR_TIME), # 图片的时间
        ("dwFileSize", DWORD), # 图片的大小
        ("sCardNum", CHAR * CARDNUM_LEN_V30), # 卡号
        ("byPlateColor", BYTE), # 参考结构 VCA_PLATE_COLOR
        ("byVehicleLogo", BYTE), # 参考结构 VLR_VEHICLE_CLASS
        ("byFileType", BYTE), # 文件类型， :0定时抓图1 移动侦测抓图 2 报警抓图3  报警 | 移动侦测抓图 4 报警 & 移动侦测抓图     6 手动抓图 ,9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测, 0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询
        ("byRecogResult", BYTE), # 识别结果参考结构VTR_RESULT
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("byEventSearchStatus", BYTE), # 连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
        ("byRes1", BYTE * 2), #   保留字节
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
        ("fFaceSnapTemperature", float), #  人脸抓拍温度信息，精确到小数点后1位 ，(浮点数 + 100） * 10 取正数传输），单位固定为摄氏度（℃）。当byFileType为0x25-人脸抓拍时有效，其余情况下该字段为0值
        ("byRes", BYTE * 68), #   保留字节
        ("uPicExtraInfo", NET_DVR_PIC_EXTRA_INFO_UNION), # 图片附件信息
    ]


LPNET_DVR_FIND_PICTURE_V40 = POINTER(NET_DVR_FIND_PICTURE_V40)


class NET_DVR_FIND_PICTURE_V50(Structure):
    _fields_ = [
        ("sFileName", CHAR * PICTURE_NAME_LEN), # 图片名
        ("struTime", NET_DVR_TIME), # 图片的时间
        ("dwFileSize", DWORD), # 图片的大小
        ("sCardNum", CHAR * CARDNUM_LEN_V30), # 卡号
        ("byPlateColor", BYTE), # 参考结构 VCA_PLATE_COLOR
        ("byVehicleLogo", BYTE), # 参考结构 VLR_VEHICLE_CLASS
        ("byFileType", BYTE), # 文件类型， :0定时抓图1 移动侦测抓图 2 报警抓图3  报警 | 移动侦测抓图 4 报警 & 移动侦测抓图     6 手动抓图 ,9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测
        ("byRecogResult", BYTE), # 识别结果参考结构VTR_RESULT
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("byEventSearchStatus", BYTE), # 连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
        ("struAddr", NET_DVR_ADDRESS), # 图片所在的地址信息，图片下载时用到
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30,0, 30, 45
        ("byRes", BYTE * 253), #   保留字节
        ("uPicExtraInfo", NET_DVR_PIC_EXTRA_INFO_UNION), # 图片附件信息
    ]


LPNET_DVR_FIND_PICTURE_V50 = POINTER(NET_DVR_FIND_PICTURE_V50)


class NET_DVR_THUMBNAILS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("struStreamInfo", NET_DVR_STREAM_INFO), # 流信息
        ("bySearchDataType", BYTE), #  查找数据类型 0-I帧数据（CVR 一路的情况下，1s最多28个I帧），1-图片数据
        ("byRes", BYTE * 3), #  保留字节
        ("struStartTime", NET_DVR_TIME_V30), # 查找开始时间
        ("struStopTime", NET_DVR_TIME_V30), #  查找结束时间
        ("dwIntervalTime", DWORD), # 间隔时间，单位秒，范围：0~24*60*60，若查找结束时间等于查找开始时间，则填0，填其他值无效
        ("byRes1", BYTE * 512), #  保留字节
    ]


LPNET_DVR_THUMBNAILS_COND = POINTER(NET_DVR_THUMBNAILS_COND)


class NET_DVR_THUMBNAILS_RESULT(Structure):
    _fields_ = [
        ("byResultDataType", BYTE), #  查找结果数据类型0-I帧数据（CVR 一路的情况下，1s最多28个I帧），1-系统头数据， 2-图片数据
        ("byIFrameType", BYTE), #  I帧类型，0-数据帧，1-参考帧（本数据只需送入播放库，但是不需要转为图片显示）
        ("byRes1", BYTE * 2), #  保留字节
        ("struTime", NET_DVR_TIME_SEARCH), # 数据时间
        ("byRes", BYTE * 252), #  保留字节
        ("dwFileSize", DWORD), # 数据大小
        ("pBuffer", CHARP), # 数据信息(数据类型和条件结构体中NET_DVR_THUMBNAILS_RESULT 的字段 byResultDataType 值相关)
    ]


LPNET_DVR_THUMBNAILS_RESULT = POINTER(NET_DVR_THUMBNAILS_RESULT)


class NET_DVR_REGIONENTRANCE_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        #
        # 检测目标，可支持多选，具体定义为：
        # 0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
        # 0x01 ~ 人，
        # 0x02 ~ 车，
        # 0x04 ~ 其他，
        # 该字段支持多选，按位取值，例如3表示1+2.
        #
        ("byDetectionTarget", BYTE),
        ("byRes", BYTE * 62), # 保留
    ]


LPNET_DVR_REGIONENTRANCE_REGION = POINTER(NET_DVR_REGIONENTRANCE_REGION)


class NET_DVR_REGION_ENTRANCE_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byEnableHumanMisinfoFilter", BYTE), #  启用人体去误报 0-不启用，1-启用
        ("byEnableVehicleMisinfoFilter", BYTE), #  启用车辆去误报 0-不启用，1-启用
        ("byRes1", BYTE * 1),
        ("struRegion", NET_DVR_REGIONENTRANCE_REGION * MAX_REGION_NUM),
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_REGION_ENTRANCE_DETECTION = POINTER(NET_DVR_REGION_ENTRANCE_DETECTION)


class NET_DVR_SMART_REGION_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("dwRegion", DWORD), # 区域ID号
    ]


LPNET_DVR_SMART_REGION_COND = POINTER(NET_DVR_SMART_REGION_COND)


class NET_DVR_ENTRANCE_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_ENTRANCE_REGION = POINTER(NET_DVR_ENTRANCE_REGION)


class NET_DVR_DENSEFOGDETECTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("bySensitivity", BYTE), # 灵敏度参数，范围[0,100]
        ("byRes", BYTE * 258),
    ]


LPNET_DVR_DENSEFOGDETECTION_CFG = POINTER(NET_DVR_DENSEFOGDETECTION_CFG)


class NET_DVR_EVENT_TRIGGER(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struHandleException", NET_DVR_HANDLEEXCEPTION_V41), # 异常处理方式
        ("dwRelRecordChan", DWORD * MAX_CHANNUM_V40), # 实际触发录像通道，按值表示，采用紧凑型排列，从下标0开始顺序读取，中间遇到0xffffffff则后续无效。
        ("struPresetChanInfo", NET_DVR_PRESETCHAN_INFO * MAX_CHANNUM_V40), # 启用的预置点信息
        ("struCruiseChanInfo", NET_DVR_CRUISECHAN_INFO * MAX_CHANNUM_V40), # 启用巡航功能通道的信息
        ("struPtzTrackInfo", NET_DVR_PTZTRACKCHAN_INFO * MAX_CHANNUM_V40), # 调用云台轨迹的通道信息
        ("byDirection", BYTE), # 触发方向：0-保留；1-全部；2-正向；3-反向
        ("byRes2", BYTE * 255),
    ]


LPNET_DVR_EVENT_TRIGGER = POINTER(NET_DVR_EVENT_TRIGGER)


class NET_DVR_EVENT_SCHEDULE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHolidayAlarmTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 假日布防时间
        ("bySceneID", BYTE * MAX_DAYS), # 场景号,目前支持1~4场景，0为无效。该场景号与布防时间中每个时间段一一对应。
        ("byRes", BYTE * 72),
    ]


LPNET_DVR_EVENT_SCHEDULE = POINTER(NET_DVR_EVENT_SCHEDULE)


class NET_DVR_ANR_ARMING_HOST(Structure):
    _fields_ = [
        ("dwSize", DWORD), # sizeof(NET_DVR_ANR_ ARMING_HOST)
        ("struANRArmingHostIpAddr", NET_DVR_IPADDR), # 断网续传的主机IP地址
        ("wANRAlarmHostPort", WORD), # 断网续传的主机布防端口号
        ("byANRAlarmType", BYTE), # 断网续传连接类型， 0-SDK私有断网续传连接，1-ehome断网续传连接
        ("byConfirmMechanismEnabled", BYTE), #  是否开启确认机制方式布防连接，0-保留，1-没有开启 2-开启
        ("byRes", BYTE * 512), # 保留字节
    ]


LPNET_DVR_ANR_ARMING_HOST = POINTER(NET_DVR_ANR_ARMING_HOST)


class NET_DVR_REGIONEXITING_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        #
        # 检测目标，可支持多选，具体定义为：
        # 0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
        # 0x01 ~ 人，
        # 0x02 ~ 车，
        # 0x04 ~ 其他，
        # 该字段支持多选，按位取值，例如3表示1+2.
        #
        ("byDetectionTarget", BYTE),
        ("byRes", BYTE * 62), # 保留
    ]


LPNET_DVR_REGIONEXITING_REGION = POINTER(NET_DVR_REGIONEXITING_REGION)


class NET_DVR_REGION_EXITING_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byEnableHumanMisinfoFilter", BYTE), #  启用人体去误报 0-不启用，1-启用
        ("byEnableVehicleMisinfoFilter", BYTE), #  启用车辆去误报 0-不启用，1-启用
        ("byRes1", BYTE * 1),
        ("struRegion", NET_DVR_REGIONEXITING_REGION * MAX_REGION_NUM),
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_REGION_EXITING_DETECTION = POINTER(NET_DVR_REGION_EXITING_DETECTION)


class NET_DVR_LOITERING_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        ("byTimeThreshold", BYTE), # 时间阈值，范围[0-10]，单位：s
        ("byRes", BYTE * 62), # 保留
    ]


LPNET_DVR_LOITERING_REGION = POINTER(NET_DVR_LOITERING_REGION)


class NET_DVR_LOITERING_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("struRegion", NET_DVR_LOITERING_REGION * MAX_REGION_NUM),
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_LOITERING_DETECTION = POINTER(NET_DVR_LOITERING_DETECTION)


class NET_DVR_GROUPDETECTION_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("byObjectOccup", BYTE), # 占比，范围[1-100]
        ("bySensitivityLevel", BYTE), # 灵敏度，范围1-100，默认65
        ("byDurationTime", BYTE), # 持续时间，范围1-600秒，默认3秒
        ("byFilterTime", BYTE), # 过滤时间，范围1-10分钟（表示，触发报警后，在此时间内不再触发报警）
        ("byMinTriggerNumber", BYTE), # 最低触发人数，范围2-50人，默认5人
        ("byLinkageTime", BYTE), # 联动球机检测时间，范围5-30秒，默认5秒（枪机触发后，联动球机转到触发报警的位置后停留的时间，该配置不区分枪机球机是否同一个账户登录，可以不同）
        ("byRes", BYTE * 58), # 保留
    ]


LPNET_DVR_GROUPDETECTION_REGION = POINTER(NET_DVR_GROUPDETECTION_REGION)


class NET_DVR_POS_HIDDEN_INFORMATION(Structure):
    _fields_ = [
        ("szKeyWord", CHAR * KEY_WORD_NUM),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_POS_HIDDEN_INFORMATION = POINTER(NET_DVR_POS_HIDDEN_INFORMATION)


class NET_DVR_HIDDEN_INFORMATION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFuncType", BYTE), # 0-Pos功能
        ("Res1", BYTE * 3),
        ("struPosInfo", NET_DVR_POS_HIDDEN_INFORMATION),
        ("byRes", BYTE * 1024),
    ]


LPNET_DVR_HIDDEN_INFORMATION_CFG = POINTER(NET_DVR_HIDDEN_INFORMATION_CFG)


class NET_DVR_GROUP_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("struRegion", NET_DVR_GROUPDETECTION_REGION * MAX_REGION_NUM),
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_GROUP_DETECTION = POINTER(NET_DVR_GROUP_DETECTION)


class NET_DVR_RAPIDMOVE_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        #
        # 检测目标，可支持多选，具体定义为：
        # 0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
        # 0x01 ~ 人，
        # 0x02 ~ 车，
        # 0x04 ~ 其他，
        # 该字段支持多选，按位取值，例如3表示1+2.
        #
        ("byDetectionTarget", BYTE),
        ("byRes", BYTE * 62), # 保留
    ]


LPNET_DVR_RAPIDMOVE_REGION = POINTER(NET_DVR_RAPIDMOVE_REGION)


class NET_DVR_RAPIDMOVE_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("struRegion", NET_DVR_RAPIDMOVE_REGION * MAX_REGION_NUM),
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_RAPIDMOVE_DETECTION = POINTER(NET_DVR_RAPIDMOVE_DETECTION)


class NET_DVR_PARKING_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        ("byTimeThreshold", BYTE), # 时间阈值，范围[0-10]，单位：s
        ("byRes", BYTE * 62), # 保留
    ]


LPNET_DVR_PARKING_REGION = POINTER(NET_DVR_PARKING_REGION)


class NET_DVR_PARKING_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("struRegion", NET_DVR_PARKING_REGION * MAX_REGION_NUM),
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_PARKING_DETECTION = POINTER(NET_DVR_PARKING_DETECTION)


class NET_DVR_UNATTENDED_BAGGAGE_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        ("byTimeThreshold", BYTE), # 时间阈值，范围[0-10]，单位：s
        ("wTimeThreshold", WORD), # 时间阈值，范围[5-3600], 单位：s
        ("byTimeThresholdMode", BYTE), # (只写字段，用于兼容区域)0-字段byTimeThreshold生效，1-字段wTimeThreshold生效
        ("byRes", BYTE * 59), # 保留留
    ]


LPNET_DVR_UNATTENDED_BAGGAGE_REGION = POINTER(NET_DVR_UNATTENDED_BAGGAGE_REGION)


class NET_DVR_UNATTENDED_BAGGAGE_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("struRegion", NET_DVR_UNATTENDED_BAGGAGE_REGION * MAX_REGION_NUM),
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_UNATTENDED_BAGGAGE_DETECTION = POINTER(NET_DVR_UNATTENDED_BAGGAGE_DETECTION)


class NET_DVR_ATTENDED_BAGGAGE_REGION(Structure):
    _fields_ = [
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1-100]
        ("byTimeThreshold", BYTE), # 时间阈值，范围[0-10]，单位：s
        ("wTimeThreshold", WORD), # 时间阈值，范围[5-3600], 单位：s
        ("byTimeThresholdMode", BYTE), # (只写字段，用于兼容区域)0-字段byTimeThreshold生效，1-字段wTimeThreshold生效
        ("byRes", BYTE * 59), # 保留
    ]


LPNET_DVR_ATTENDED_BAGGAGE_REGION = POINTER(NET_DVR_ATTENDED_BAGGAGE_REGION)


class NET_DVR_ATTENDED_BAGGAGE_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("struRegion", NET_DVR_ATTENDED_BAGGAGE_REGION * MAX_REGION_NUM),
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_ATTENDED_BAGGAGE_DETECTION = POINTER(NET_DVR_ATTENDED_BAGGAGE_DETECTION)


class NET_DVR_REGION_CLIP_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("dwStreamType", DWORD), # 码流类型：0- 主码流，1- 子码流，2- 第三码流
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_REGION_CLIP_COND = POINTER(NET_DVR_REGION_CLIP_COND)


class NET_DVR_REGION_CLIP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("wResolutionWidth", WORD), # 分辨率的长
        ("wResolutionHeight", WORD), # 分辨率的宽
        ("struRegion", NET_VCA_POLYGON * MAX_REGION_NUM),
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_REGION_CLIP_CFG = POINTER(NET_DVR_REGION_CLIP_CFG)


MAX_DIALNUM_LENGTH = 32
class NET_DVR_WIRELESSDIAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否启用无线拨号：0-否，1- 是
        ("byDialMode", BYTE), #  0-自动（Auto）、1-手动（Manual），默认自动，手动模式下可设置拨号计划、下线时间、手动拨号
        ("byNetworkMode", BYTE), # 0-自动，1-4G优先，2-3G优先，3-手动切换2G，4-手动切换3G，5-手动切换4G，6-有线优先
        ("byRes1", BYTE),
        ("byDialNum", BYTE * MAX_DIALNUM_LENGTH), # 拨号号码
        ("byUserName", BYTE * NAME_LEN), # 用户名
        ("byPassword", BYTE * NAME_LEN), # 密码
        ("byAPNName", BYTE * NAME_LEN), # APN
        ("byUIMCardNum", BYTE * NAME_LEN), # 手机号码
        ("byVerifProtocol", BYTE), #  0-自动（Auto），1-CHAP，2-PAP
        ("byRes2", BYTE),
        ("wMTU", WORD), # MTU
        ("dwOffineTime", DWORD), # 下线时间，30-65535，单位秒，手动模式下有效
        ("byNetAPN", BYTE * NAME_LEN), # 私有专网APN字段配置
        ("byEnabled4G", BYTE), # 是否开启4G功能：0-否，1- 是
        ("byEnabledDNS", BYTE), # 是否开启DNS功能：0-否，1- 是
        ("byRes3", BYTE * 30),
    ]


LPNET_DVR_WIRELESSDIAL_CFG = POINTER(NET_DVR_WIRELESSDIAL_CFG)


class NET_DVR_WIRELESSDIAL_SCHEDULE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 布防时间
        ("struHolidayAlarmTime", NET_DVR_SCHEDTIME * MAX_TIMESEGMENT_V30), # 假日布防时间段
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_WIRELESSDIAL_SCHEDULE = POINTER(NET_DVR_WIRELESSDIAL_SCHEDULE)


MAX_LENGTH_32 = 32
class NET_DVR_WIRELESSDIAL_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byRealtimeMode", BYTE * MAX_LENGTH_32), # 实时模式(CDMA 1x、EVDO、HYBRID、GSM、GPRS、EDGE、WCDMA、HSDPA、HSUPA、HSPA、TDSCDMA、TD-LTE、FDD-LTE)
        ("byUIMStatus", BYTE * MAX_LENGTH_32), # UIM状态(UNKNOWN-未知,VALID-有效,NOVALID-无效,ROAM-漫游,NOEXIST-不存在,
        # WRONGPINCODE-PIN码错误,NONETWORKSERVICE-无网络服务,
        # ONLYSUPPORTEMERGENCYCALL-网络仅支持紧急呼叫，PINCODELOCKED—PIN码锁定
        ("dwSignalQuality", DWORD), # 信号质量，1-5
        ("byDialStatus", BYTE * MAX_LENGTH_32), # 拨号状态码(disconnect-拨号断开,dialing-正在拨号,success-拨号成功,shmError-拨号异常,
        # certificationFailure-认证失败,invalidDialingCharacters-拨号字符无效,
        # networkTimeout –网络超时,wirelessModemError—无线模块错误,SIMError---SIM卡错误,,networkError-网络错误，unknown –未知错误)
        ("struIpAddr", NET_DVR_IPADDR), # IP地址
        ("struIPMask", NET_DVR_IPADDR), # 掩码地址
        ("struGatewayIPMask", NET_DVR_IPADDR), # 网关地址
        ("struDnsServerIpAddr", NET_DVR_IPADDR), # DNS地址
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_WIRELESSDIAL_STATUS = POINTER(NET_DVR_WIRELESSDIAL_STATUS)


class NET_DVR_WIRELESSDIAL_CONNECT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwInterface", DWORD), # 网卡编号，1,2……
        ("byEnableConnect", BYTE), # 是否连网，0-断网，1-连网
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_WIRELESSDIAL_CONNECT_PARAM = POINTER(NET_DVR_WIRELESSDIAL_CONNECT_PARAM)


class NET_DVR_LITESTORAGE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 使能 0-不启用,1-启用
        ("byStorageTime", BYTE), # 存储时间 1-30 默认7天
        ("byLevel", BYTE), # 等级参数，0-无效值（保留），1-低，2-中(默认)，3-高；
        ("byRes", BYTE),
        ("fCapacity", float), # 可用SD卡录像空间，只读
        ("byDefLowStorageTime", BYTE), #  低模式下推荐天数 只读
        ("byDefMediumStorageTime", BYTE), #  中模式下推荐天数 只读
        ("byDefHighStorageTime", BYTE), #  高模式下推荐天数 只读
        ("byRes1", BYTE * 61),
    ]


LPNET_DVR_LITESTORAGE = POINTER(NET_DVR_LITESTORAGE)


class NET_DVR_CALIBRATION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struRegion", NET_VCA_POLYGON), # 标定区域
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_CALIBRATION = POINTER(NET_DVR_CALIBRATION)


class NET_DVR_STD_CONFIG(Structure):
    _fields_ = [
        ("lpCondBuffer", VOIDP), # [in]条件参数(结构体格式),例如通道号等.可以为NULL
        ("dwCondSize", DWORD), # [in] lpCondBuffer指向的内存大小
        ("lpInBuffer", VOIDP), # [in]输入参数(结构体格式),设置时不为NULL，获取时为NULL
        ("dwInSize", DWORD), # [in] lpInBuffer指向的内存大小
        ("lpOutBuffer", VOIDP), # [out]输出参数(结构体格式),获取时不为NULL,设置时为NULL
        ("dwOutSize", DWORD), # [in] lpOutBuffer指向的内存大小
        ("lpStatusBuffer", VOIDP), # [out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
        ("dwStatusSize", DWORD), # [in] lpStatusBuffer指向的内存大小
        ("lpXmlBuffer", VOIDP), # [in/out]byDataType = 1时有效,xml格式数据
        ("dwXmlSize", DWORD), # [in/out]lpXmlBuffer指向的内存大小,获取时同时作为输入和输出参数，获取成功后会修改会实际长度，设置时表示实际长度，而不是整个内存大小
        ("byDataType", BYTE), # [in]输入/输出参数类型,0-使用结构体类型lpInBuffer/lpOutBuffer有效,1-使用XML类型lpXmlBuffer有效
        ("byRes", BYTE * 23),
    ]


LPNET_DVR_STD_CONFIG = POINTER(NET_DVR_STD_CONFIG)


class NET_DVR_STD_CONTROL(Structure):
    _fields_ = [
        ("lpCondBuffer", VOIDP), # [in]条件参数(码字格式),例如通道号等.可以为NULL
        ("dwCondSize", DWORD), # [in] dwCondSize指向的内存大小
        ("lpStatusBuffer", VOIDP), # [out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
        ("dwStatusSize", DWORD), # [in] lpStatusBuffer指向的内存大小
        ("lpXmlBuffer", VOIDP), # [in/out]byDataType = 1时有效,xml格式数据
        ("dwXmlSize", DWORD), # [in/out]lpXmlBuffer指向的内存大小,获取时同时作为输入和输出参数，获取成功后会修改会实际长度，设置时表示实际长度，而不是整个内存大小
        ("byDataType", BYTE), # [in]输入/输出参数类型,0-使用结构体类型lpCondBuffer有效,1-使用XML类型lpXmlBuffer有效
        ("byRes", BYTE * 55),
    ]


LPNET_DVR_STD_CONTROL = POINTER(NET_DVR_STD_CONTROL)


MAX_FILE_PATH_LEN = 256 # 文件路径长度
class NET_DVR_MIME_UNIT(Structure):
    _fields_ = [
        # 格式如下
        # Content-Disposition: form-data; name="upload"; filename="C:\Users\test\Desktop\11.txt"
        # Content-Type: text/plain
        ("szContentType", CHAR * 32), # 对应Content-Type
        ("szName", CHAR * MAX_FILE_PATH_LEN), # 对应name字段
        ("szFilename", CHAR * MAX_FILE_PATH_LEN), # 对应filename字段
        ("dwContentLen", DWORD), # Content的长度
        ("pContent", CHARP), # 数据指针
        ("bySelfRead", BYTE), #  0-外界传入文件 1-内部读取数据（通过szFilename传递完整路径）
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_MIME_UNIT = POINTER(NET_DVR_MIME_UNIT)


class NET_DVR_XML_CONFIG_INPUT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("lpRequestUrl", VOIDP), # 请求信令，字符串格式
        ("dwRequestUrlLen", DWORD), # 请求信令长度，字符串长度
        ("lpInBuffer", VOIDP), # 输入参数缓冲区，XML格式
        ("dwInBufferSize", DWORD), # 输入参数缓冲区大小
        ("dwRecvTimeOut", DWORD), # 接收超时时间，单位：ms，填0则使用默认超时5s
        ("byForceEncrpt", BYTE), # 是否强制加密，0-否，1-是
        ("byNumOfMultiPart", BYTE), # 0-无效，其他值表示报文分段个数，非零时lpInBuffer传入的是NET_DVR_MIME_UNIT结构体数组的指针，该值即代表结构体个数
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_XML_CONFIG_INPUT = POINTER(NET_DVR_XML_CONFIG_INPUT)


class NET_DVR_XML_CONFIG_OUTPUT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("lpOutBuffer", VOIDP), # 输出参数缓冲区，XML格式
        ("dwOutBufferSize", DWORD), # 输出参数缓冲区大小(内存大小)
        ("dwReturnedXMLSize", DWORD), # 实际输出的XML内容大小
        ("lpStatusBuffer", VOIDP), # 返回的状态参数(XML格式),获取命令成功时不会赋值,如果不需要,可以置NULL
        ("dwStatusSize", DWORD), # 状态缓冲区大小(内存大小)
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_XML_CONFIG_OUTPUT = POINTER(NET_DVR_XML_CONFIG_OUTPUT)


class NET_DVR_JSON_DATA_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("*lpJsonData", void), # JSON报文
        ("dwJsonDataSize", DWORD), # JSON报文大小
        ("*lpPicData", void), # 图片内容
        ("dwPicDataSize", DWORD), # 图片内容大小
        ("dwInfraredFacePicSize", DWORD), # 红外人脸图片数据大小，等于0时，代表无人脸图片数据(当JSON报文为当ResponseStatus（JSON）报文时，该字段无意义；当Inbound Data（JSON）报文中没有infraredFaceURL时，该字段需要带上二进制图片内容）
        ("lpInfraredFacePicBuffer", VOIDP), # 红外人脸图片数据缓存
        ("byRes", BYTE * 248), # 保留
    ]


LPNET_DVR_JSON_DATA_CFG = POINTER(NET_DVR_JSON_DATA_CFG)


class NET_DVR_SIMPLE_DAYTIME(Structure):
    _fields_ = [
        ("byHour", BYTE), # 时
        ("byMinute", BYTE), # 分
        ("bySecond", BYTE), # 秒
        ("byRes", BYTE),
    ]


LPNET_DVR_SIMPLE_DAYTIME = POINTER(NET_DVR_SIMPLE_DAYTIME)


class NET_DVR_TIME_SEGMENT(Structure):
    _fields_ = [
        ("struBeginTime", NET_DVR_SIMPLE_DAYTIME), # 开始时间点
        ("struEndTime", NET_DVR_SIMPLE_DAYTIME), # 结束时间点
    ]


LPNET_DVR_TIME_SEGMENT = POINTER(NET_DVR_TIME_SEGMENT)


class NET_DVR_SINGLE_PLAN_SEGMENT(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否使能，1-使能，0-不使能
        ("byDoorStatus", BYTE), # 门状态模式（梯控模式），0-无效，1-休眠，2-常开状态（自由），3-常闭状态（禁用），4-普通状态（门状态计划使用）
        ("byVerifyMode", BYTE), # 验证方式，0-无效，1-刷卡，2-刷卡+密码(读卡器验证方式计划使用)，3-刷卡,4-刷卡或密码(读卡器验证方式计划使用), 5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码（无先后顺序），10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，
        # 13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡,23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码
        # ,28-人脸或密码,29-工号+人脸+密码,30-刷卡或人脸或人脸+刷卡
        ("byRes", BYTE * 5),
        ("struTimeSegment", NET_DVR_TIME_SEGMENT), # 时间段参数
    ]


LPNET_DVR_SINGLE_PLAN_SEGMENT = POINTER(NET_DVR_SINGLE_PLAN_SEGMENT)


class NET_DVR_WEEK_PLAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否使能，1-使能，0-不使能
        ("byRes1", BYTE * 3),
        ("struPlanCfg", NET_DVR_SINGLE_PLAN_SEGMENT * MAX_DAYS), # 周计划参数
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_WEEK_PLAN_CFG = POINTER(NET_DVR_WEEK_PLAN_CFG)


class NET_DVR_HOLIDAY_PLAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否使能，1-使能，0-不使能
        ("byRes1", BYTE * 3),
        ("struBeginDate", NET_DVR_DATE), # 假日开始日期
        ("struEndDate", NET_DVR_DATE), # 假日结束日期
        ("struPlanCfg", NET_DVR_SINGLE_PLAN_SEGMENT * MAX_TIMESEGMENT_V30), # 时间段参数
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_HOLIDAY_PLAN_CFG = POINTER(NET_DVR_HOLIDAY_PLAN_CFG)


class NET_DVR_HOLIDAY_PLAN_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwHolidayPlanNumber", DWORD), # 假日计划编号
        ("wLocalControllerID", WORD), # 就地控制器序号[1,64]
        ("byRes", BYTE * 106),
    ]


LPNET_DVR_HOLIDAY_PLAN_COND = POINTER(NET_DVR_HOLIDAY_PLAN_COND)


class NET_DVR_WEEK_PLAN_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwWeekPlanNumber", DWORD), # 周计划编号
        ("wLocalControllerID", WORD), # 就地控制器序号[1,64]
        ("byRes", BYTE * 106),
    ]


LPNET_DVR_WEEK_PLAN_COND = POINTER(NET_DVR_WEEK_PLAN_COND)


class NET_DVR_HOLIDAY_GROUP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用，1-启用，0-不启用
        ("byRes1", BYTE * 3),
        ("byGroupName", BYTE * HOLIDAY_GROUP_NAME_LEN), # 假日组名称
        ("dwHolidayPlanNo", DWORD * MAX_HOLIDAY_PLAN_NUM), # 假日计划编号，就前填充，遇0无效
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_HOLIDAY_GROUP_CFG = POINTER(NET_DVR_HOLIDAY_GROUP_CFG)


class NET_DVR_HOLIDAY_GROUP_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwHolidayGroupNumber", DWORD), # 假日组编号
        ("wLocalControllerID", WORD), # 就地控制器序号[1,64]
        ("byRes", BYTE * 106),
    ]


LPNET_DVR_HOLIDAY_GROUP_COND = POINTER(NET_DVR_HOLIDAY_GROUP_COND)


class NET_DVR_PLAN_TEMPLATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用，1-启用，0-不启用
        ("byRes1", BYTE * 3),
        ("byTemplateName", BYTE * TEMPLATE_NAME_LEN), # 模板名称
        ("dwWeekPlanNo", DWORD), # 周计划编号，0为无效
        ("dwHolidayGroupNo", DWORD * MAX_HOLIDAY_GROUP_NUM), # 假日组编号，就前填充，遇0无效
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_PLAN_TEMPLATE = POINTER(NET_DVR_PLAN_TEMPLATE)


class NET_DVR_PLAN_TEMPLATE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPlanTemplateNumber", DWORD), # 计划模板编号，从1开始，最大值从门禁能力集获取
        ("wLocalControllerID", WORD), # 就地控制器序号[1,64]，0无效
        ("byRes", BYTE * 106),
    ]


LPNET_DVR_PLAN_TEMPLATE_COND = POINTER(NET_DVR_PLAN_TEMPLATE_COND)


class NET_DVR_DOOR_STATUS_PLAN(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTemplateNo", DWORD), # 计划模板编号，为0表示取消关联，恢复默认状态（普通状态）
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_DOOR_STATUS_PLAN = POINTER(NET_DVR_DOOR_STATUS_PLAN)


class NET_DVR_CARD_READER_PLAN(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTemplateNo", DWORD), # 计划模板编号，为0表示取消关联，恢复默认状态（刷卡开门）
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_CARD_READER_PLAN = POINTER(NET_DVR_CARD_READER_PLAN)


class NET_DVR_GROUP_COMBINATION_INFO(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该群组组合
        ("byMemberNum", BYTE), # 刷卡成员数量
        ("bySequenceNo", BYTE), # 群组刷卡次序号
        ("byRes", BYTE),
        ("dwGroupNo", DWORD), # 群组编号,0xffffffff表示远程开门，0xfffffffe表示超级密码
    ]


LPNET_DVR_GROUP_COMBINATION_INFO = POINTER(NET_DVR_GROUP_COMBINATION_INFO)


class NET_DVR_MULTI_CARD_GROUP_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该多重卡组参数，0-不启用，1-启用
        ("byEnableOfflineVerifyMode", BYTE), # 是否启用主机离线时验证方式（超级密码代替远程开门）
        ("byRes1", BYTE * 2),
        ("dwTemplateNo", DWORD), # 启用多重卡功能的计划模板编号
        ("struGroupCombination", NET_DVR_GROUP_COMBINATION_INFO * GROUP_COMBINATION_NUM), # 群组组合参数
    ]


LPNET_DVR_MULTI_CARD_GROUP_CFG = POINTER(NET_DVR_MULTI_CARD_GROUP_CFG)


class NET_DVR_MULTI_CARD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用多重卡功能，0-不启用，1-启用
        ("bySwipeIntervalTimeout", BYTE), # 刷卡间隔超时时间，1-255s，默认10s
        ("byRes1", BYTE * 2),
        ("struGroupCfg", NET_DVR_MULTI_CARD_GROUP_CFG * MULTI_CARD_GROUP_NUM), # 群组刷卡参数
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_MULTI_CARD_CFG = POINTER(NET_DVR_MULTI_CARD_CFG)


class NET_DVR_GROUP_COMBINATION_INFO_V50(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该群组组合
        ("byMemberNum", BYTE), # 刷卡成员数量
        ("bySequenceNo", BYTE), # 群组刷卡次序号
        ("byRes", BYTE),
        ("dwGroupNo", DWORD), # 群组编号,0xffffffff表示远程开门，0xfffffffe表示超级密码
    ]


LPNET_DVR_GROUP_COMBINATION_INFO_V50 = POINTER(NET_DVR_GROUP_COMBINATION_INFO_V50)


class NET_DVR_MULTI_CARD_GROUP_CFG_V50(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用该多重卡组参数，0-不启用，1-启用
        ("byEnableOfflineVerifyMode", BYTE), # 是否启用主机离线时验证方式（超级密码代替远程开门），1-启用，0-不启用
        ("byRes1", BYTE * 2),
        ("dwTemplateNo", DWORD), # 启用多重卡功能的计划模板编号
        ("struGroupCombination", NET_DVR_GROUP_COMBINATION_INFO_V50 * GROUP_COMBINATION_NUM), # 群组组合参数
    ]


LPNET_DVR_MULTI_CARD_GROUP_CFG_V50 = POINTER(NET_DVR_MULTI_CARD_GROUP_CFG_V50)


class NET_DVR_MULTI_CARD_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用多重卡功能，0-不启用，1-启用
        ("bySwipeIntervalTimeout", BYTE), # 刷卡间隔超时时间，1-255s，默认10s
        ("byRes1", BYTE * 2),
        ("struGroupCfg", NET_DVR_MULTI_CARD_GROUP_CFG_V50 * NET_SDK_MULTI_CARD_GROUP_NUM_20), # 群组刷卡参数
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_MULTI_CARD_CFG_V50 = POINTER(NET_DVR_MULTI_CARD_CFG_V50)


# 2014-12-03  T1测试状态结构体
class NET_DVR_T1TEST_PARAMCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("wPort", WORD), # 端口号
        # (设备通过端口控制（端口号设备端固定，上层不做配置），开始单独socket连接，单独交互T1测试内容，走XML格式)
        # 0- 关闭(关闭设备的连接线程，释放端口)，1- 开启(设备内部单独起连接线程)
        ("byPortState", BYTE),
        ("byRes", BYTE * 61), # 保留
    ]


LPNET_DVR_T1TEST_PARAMCFG = POINTER(NET_DVR_T1TEST_PARAMCFG)


CARD_PARAM_CARD_VALID = 0x00000001 # 卡是否有效参数
CARD_PARAM_VALID = 0x00000002 # 有效期参数
CARD_PARAM_CARD_TYPE = 0x00000004 # 卡类型参数
CARD_PARAM_DOOR_RIGHT = 0x00000008 # 门权限参数
CARD_PARAM_LEADER_CARD = 0x00000010 # 首卡参数
CARD_PARAM_SWIPE_NUM = 0x00000020 # 最大刷卡次数参数
CARD_PARAM_GROUP = 0x00000040 # 所属群组参数
CARD_PARAM_PASSWORD = 0x00000080 # 卡密码参数
CARD_PARAM_RIGHT_PLAN = 0x00000100 # 卡权限计划参数
CARD_PARAM_SWIPED_NUM = 0x00000200 # 已刷卡次数
CARD_PARAM_EMPLOYEE_NO = 0x00000400 # 工号
CARD_PARAM_NAME = 0x00000800 # 姓名
CARD_PARAM_DEPARTMENT_NO = 0x00001000 # 部门编号
CARD_SCHEDULE_PLAN_NO = 0x00002000 # 排班计划编号
CARD_SCHEDULE_PLAN_TYPE = 0x00004000 # 排班计划类型
CARD_ROOM_NUMBER = 0x00008000 # 房间号
CARD_SIM_NO = 0x00010000 # SIM卡号（手机号）
CARD_FLOOR_NUMBER = 0x00020000 # 楼层号
CARD_USER_TYPE = 0x00040000 # 用户类型
class NET_DVR_ANTI_SNEAK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能反潜回功能，1-使能，0-不使能
        ("byRes1", BYTE * 3),
        ("dwStartCardReaderNo", DWORD), # 反潜回起始读卡器编号
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_ANTI_SNEAK_CFG = POINTER(NET_DVR_ANTI_SNEAK_CFG)


class NET_DVR_CARD_READER_ANTI_SNEAK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否加入反潜回路径，1-加入，0-不加入
        ("byRes1", BYTE * 3),
        ("dwFollowUpCardReader", DWORD * MAX_SNEAK_PATH_NODE), # 后续读卡器编号，为0表示不关注起始读卡器编号
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_CARD_READER_ANTI_SNEAK_CFG = POINTER(NET_DVR_CARD_READER_ANTI_SNEAK_CFG)


class NET_DVR_PHONE_DOOR_RIGHT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byOpenRight", BYTE * MAX_DOOR_NUM_256), # 按数组表示,是否有开门权限，-无权限，-有权限
        ("byCloseRight", BYTE * MAX_DOOR_NUM_256), # 按数组表示,是否有关门权限，-无权限，-有权限
        ("byNormalOpenRight", BYTE * MAX_DOOR_NUM_256), # 按数组表示,是否有常开权限，-无权限，-有权限
        ("byNormalCloseRight", BYTE * MAX_DOOR_NUM_256), # 按数组表示,是否有常闭权限，-无权限，-有权限
        ("byArmRight", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 按数组表示,是否有布防权限，-无权限，-有权限
        ("byDisarmRight", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 按数组表示,是否有撤防权限，-无权限，-有权限
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_PHONE_DOOR_RIGHT_CFG = POINTER(NET_DVR_PHONE_DOOR_RIGHT_CFG)


class NET_DVR_MULTI_DOOR_INTERLOCK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用多门互锁功能，1-启用，0-不启用
        ("byRes1", BYTE * 3),
        ("dwMultiDoorGroup", DWORD * MAX_MULTI_DOOR_INTERLOCK_GROUP), # 多门互锁组参数，取值为门编号
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_MULTI_DOOR_INTERLOCK_CFG = POINTER(NET_DVR_MULTI_DOOR_INTERLOCK_CFG)


class NET_DVR_CARD_READER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否使能，1-使能，0-不使能
        ("byCardReaderType", BYTE), # 读卡器类型，1-DS-K110XM/MK/C/CK，2-DS-K192AM/AMP，3-DS-K192BM/BMP，4-DS-K182AM/AMP，5-DS-K182BM/BMP，6-DS-K182AMF/ACF，7-韦根或485不在线,8- DS-K1101M/MK，9- DS-K1101C/CK，10- DS-K1102M/MK/M-A
        # 11- DS-K1102C/CK，12- DS-K1103M/MK，13- DS-K1103C/CK，14- DS-K1104M/MK，15- DS-K1104C/CK，16- DS-K1102S/SK/S-A，17- DS-K1102G/GK，18- DS-K1100S-B，19- DS-K1102EM/EMK，20- DS-K1102E/EK，
        # 21- DS-K1200EF，22- DS-K1200MF，23- DS-K1200CF，24- DS-K1300EF，25- DS-K1300MF，26- DS-K1300CF，27- DS-K1105E，28- DS-K1105M，29- DS-K1105C，30- DS-K182AMF，31- DS-K196AMF，32-DS-K194AMP
        # 33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C，35-DS-K1T105E/E-C/M/M-C/C/C-C，36-DS-K1T803F/MF/SF/EF，37-DS-K1A801F/MF/SF/EF,38-DS-K1107M/MK,39-DS-K1107E/EK,
        # 40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
        ("byOkLedPolarity", BYTE), # OK LED极性，0-阴极，1-阳极
        ("byErrorLedPolarity", BYTE), # Error LED极性，0-阴极，1-阳极
        ("byBuzzerPolarity", BYTE), # 蜂鸣器极性，0-阴极，1-阳极
        ("bySwipeInterval", BYTE), # 重复刷卡间隔时间，单位：秒
        ("byPressTimeout", BYTE), # 按键超时时间，单位：秒
        ("byEnableFailAlarm", BYTE), # 是否启用读卡失败超次报警，0-不启用，1-启用
        ("byMaxReadCardFailNum", BYTE), # 最大读卡失败次数
        ("byEnableTamperCheck", BYTE), # 是否支持防拆检测，0-disable ，1-enable
        ("byOfflineCheckTime", BYTE), # 掉线检测时间 单位秒
        ("byFingerPrintCheckLevel", BYTE), # 指纹识别等级，1-1/10误认率，2-1/100误认率，3-1/1000误认率，4-1/10000误认率，5-1/100000误认率，6-1/1000000误认率，7-1/10000000误认率，8-1/100000000误认率，9-3/100误认率，10-3/1000误认率，11-3/10000误认率，12-3/100000误认率，13-3/1000000误认率，14-3/10000000误认率，15-3/100000000误认率，16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
        ("byUseLocalController", BYTE), # 只读，是否连接在就地控制器上，0-否，1-是
        ("byRes1", BYTE),
        ("wLocalControllerID", WORD), # 只读，就地控制器序号，1-64,0代表未注册
        ("wLocalControllerReaderID", WORD), # 只读，就地控制器的读卡器ID，0代表未注册
        ("wCardReaderChannel", WORD), # 只读，读卡器通信通道号，0韦根或离线，1-RS485A,2-RS485B
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_CARD_READER_CFG = POINTER(NET_DVR_CARD_READER_CFG)


class NET_DVR_CARD_READER_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否使能，1-使能，0-不使能
        ("byCardReaderType", BYTE), # 读卡器类型，1-DS-K110XM/MK/C/CK，2-DS-K192AM/AMP，3-DS-K192BM/BMP，4-DS-K182AM/AMP，5-DS-K182BM/BMP，6-DS-K182AMF/ACF，7-韦根或485不在线，8- DS-K1101M/MK，9- DS-K1101C/CK，10- DS-K1102M/MK/M-A，11- DS-K1102C/CK，12- DS-K1103M/MK，13- DS-K1103C/CK，14- DS-K1104M/MK，15- DS-K1104C/CK，16- DS-K1102S/SK/S-A，17- DS-K1102G/GK，18- DS-K1100S-B，19- DS-K1102EM/EMK，20- DS-K1102E/EK，21- DS-K1200EF，22- DS-K1200MF，23- DS-K1200CF，24- DS-K1300EF，25- DS-K1300MF，26- DS-K1300CF，27- DS-K1105E，28- DS-K1105M，29- DS-K1105C，30- DS-K182AMF，31- DS-K196AMF，32-DS-K194AMP，33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C，35-DS-K1T105E/E-C/M/M-C/C/C-C,36-DS-K1T803F/F-M/F-S/F-E,37-DS-K1A801F/F-M/F-S/F-E,38-DS-K1107M/MK,39-DS-K1107E/EK,40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
        ("byOkLedPolarity", BYTE), # OK LED极性，0-阴极，1-阳极
        ("byErrorLedPolarity", BYTE), # Error LED极性，0-阴极，1-阳极
        ("byBuzzerPolarity", BYTE), # 蜂鸣器极性，0-阴极，1-阳极
        ("bySwipeInterval", BYTE), # 重复刷卡间隔时间，单位：秒
        ("byPressTimeout", BYTE), # 按键超时时间，单位：秒
        ("byEnableFailAlarm", BYTE), # 是否启用读卡失败超次报警，0-不启用，1-启用
        ("byMaxReadCardFailNum", BYTE), # 最大读卡失败次数
        ("byEnableTamperCheck", BYTE), # 是否支持防拆检测，0-disable ，1-enable
        ("byOfflineCheckTime", BYTE), # 掉线检测时间 单位秒
        ("byFingerPrintCheckLevel", BYTE), # 指纹识别等级，1-1/10误认率，2-1/100误认率，3-1/1000误认率，4-1/10000误认率，5-1/100000误认率，6-1/1000000误认率，7-1/10000000误认率，8-1/100000000误认率，9-3/100误认率，10-3/1000误认率，11-3/10000误认率，12-3/100000误认率，13-3/1000000误认率，14-3/10000000误认率，15-3/100000000误认率，16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure（目前门禁不支持）
        ("byUseLocalController", BYTE), # 只读，是否连接在就地控制器上，0-否，1-是
        ("byRes1", BYTE),
        ("wLocalControllerID", WORD), # 只读，就地控制器序号, byUseLocalController=1时有效，1-64,0代表未注册
        ("wLocalControllerReaderID", WORD), # 只读，就地控制器的读卡器ID，byUseLocalController=1时有效，0代表未注册
        ("wCardReaderChannel", WORD), # 只读，读卡器通信通道号，byUseLocalController=1时有效，0韦根或离线，1-RS485A,2-RS485B
        ("byFingerPrintImageQuality", BYTE), # 指纹图像质量，0-无效，1-低质量(V1)，2-中等质量(V1)，3-高质量(V1)，4-最高质量(V1)，5-低质量(V2)，6-中等质量(V2)，7-高质量(V2)，8-最高质量(V2)
        ("byFingerPrintContrastTimeOut", BYTE), # 指纹对比超时时间，0-无效，范围1-20代表:1s-20s，0xff-无限大
        ("byFingerPrintRecogizeInterval", BYTE), # 指纹连续识别间隔，0-无效，范围1-10代表:1s-10s，0xff-无延迟
        ("byFingerPrintMatchFastMode", BYTE), # 指纹匹配快速模式，0-无效，范围1-5代表:快速模式1-快速模式5，0xff-自动
        ("byFingerPrintModuleSensitive", BYTE), # 指纹模组灵敏度，0-无效，范围1-8代表：灵敏度级别1-灵敏度级别8
        ("byFingerPrintModuleLightCondition", BYTE), # 指纹模组光线条件，0-无效，1-室外，2-室内
        ("byFaceMatchThresholdN", BYTE), # 人脸比对阀值，范围0-100
        ("byFaceQuality", BYTE), # 人脸质量，范围0-100
        ("byFaceRecogizeTimeOut", BYTE), # 人脸识别超时时间，范围1-20代表：1s-20s，0xff-无限大
        ("byFaceRecogizeInterval", BYTE), # 人脸连续识别间隔，0-无效，范围1-10代表：1s-10s，0xff-无延迟
        ("wCardReaderFunction", WORD), # 只读，读卡器种类，按位表示：第1位-指纹，第二位-人脸，第三位-指静脉
        ("byCardReaderDescription", BYTE * CARD_READER_DESCRIPTION), # 读卡器描述
        ("wFaceImageSensitometry", WORD), # 只读，人脸图像曝光度，范围0-65535
        ("byLivingBodyDetect", BYTE), # 真人检测，0-无效，1-不启用，2-启用
        ("byFaceMatchThreshold1", BYTE), # 人脸1:1匹配阀值，范围0-100
        ("wBuzzerTime", WORD), # 蜂鸣时间，范围0s-5999s（0-代表长鸣）
        ("byFaceMatch1SecurityLevel", BYTE), # 人脸1:1识别安全等级，0-无效，1-一般，2-较强，3-极强
        ("byFaceMatchNSecurityLevel", BYTE), # 人脸1:N识别安全等级，0-无效，1-一般，2-较强，3-极强
        ("byEnvirMode", BYTE), # 人脸识别环境模式，0-无效，1-室内，2-其他；
        ("byLiveDetLevelSet", BYTE), # 活体检测阈值等级设置，0-无效，1-低，2-中，3-高；
        ("byLiveDetAntiAttackCntLimit", BYTE), # 活体检测防攻击次数， 0-无效，1-255次（客户端、设备统一次数限制，根据能力级限制）；
        ("byEnableLiveDetAntiAttack", BYTE), # 活体检测防攻击使能，0-无效，1-不启用，2-启用
        ("bySupportDelFPByID", BYTE), # 只读，读卡器是否支持按手指ID删除指纹，0-无效，1-不支持，2-支持
        ("byFaceContrastMotionDetLevel", BYTE), # 人脸比对时移动侦测级别，0-无效，1-低，2-中，3-高，0xff-禁用
        ("byDayFaceMatchThresholdN", BYTE), # 白天人脸1:N匹配阀值，范围0-100
        ("byNightFaceMatchThresholdN", BYTE), # 夜晚人脸1:N匹配阀值，范围0-100
        ("byFaceRecogizeEnable", BYTE), # 人脸识别使能：0-无效，1-开启，2-关闭
        ("byBlackFaceMatchThreshold", BYTE), # 黑名单匹配阀值，范围0-100
        ("byRes3", BYTE),
        ("byDefaultVerifyMode", BYTE), # 只读，读卡器默认验证方式（出厂默认），1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码
        ("dwFingerPrintCapacity", DWORD), # 只读，指纹容量
        ("dwFingerPrintNum", DWORD), # 只读，已存在指纹数量
        ("byEnableFingerPrintNum", BYTE), # 只读，指纹容量使能：0-不使能，1-使能（只有当该字段为1-使能时，dwFingerPrintCapacity和dwFingerPrintNum才有效）
        ("byRes", BYTE * 231),
    ]


LPNET_DVR_CARD_READER_CFG_V50 = POINTER(NET_DVR_CARD_READER_CFG_V50)


class NET_DVR_FAILED_FACE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_FAILED_FACE_COND = POINTER(NET_DVR_FAILED_FACE_COND)


class NET_DVR_FAILED_FACE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号
        ("byErrorCode", BYTE), # 建模失败详细错误,0-无效，1-读取文件失败，2-打开文件失败，3-内存不足，4-注册人脸失败，5-眼间距太小，6-卡权限不存在
        ("byRes1", BYTE * 3),
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
        ("byRes", BYTE * 92),
    ]


LPNET_DVR_FAILED_FACE_INFO = POINTER(NET_DVR_FAILED_FACE_INFO)


class NET_DVR_FACE_PARAM_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号（设置时该参数可不设置）
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 人脸的读卡器是否有效，0-无效，1-有效（设置时该参数可不设置）
        ("dwFaceNum", DWORD), # 设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
        ("byFaceID", BYTE), # 人脸编号，有效值范围为1-2   0xff表示该卡所有人脸（设置时该参数可不设置）
        ("byRes", BYTE * 127), # 保留
    ]


LPNET_DVR_FACE_PARAM_COND = POINTER(NET_DVR_FACE_PARAM_COND)


class NET_DVR_FACE_PARAM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号
        ("dwFaceLen", DWORD), # 人脸数据长度<DES加密处理>，设备端返回的即加密后的数据
        ("pFaceBuffer", CHARP), # 人脸数据指针
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 需要下发人脸的读卡器，按数组表示，从低位到高位表示，0-不下发该读卡器，1-下发到该读卡器
        ("byFaceID", BYTE), # 人脸编号，有效值范围为1-2
        ("byFaceDataType", BYTE), # 人脸数据类型：0-模板（默认），1-图片
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_FACE_PARAM_CFG = POINTER(NET_DVR_FACE_PARAM_CFG)


class NET_DVR_FACE_PARAM_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号
        ("byCardReaderRecvStatus", BYTE * MAX_CARD_READER_NUM_512), # 人脸读卡器状态，按字节表示，0-失败，1-成功，2-重试或人脸质量差，3-内存已满(人脸数据满)，4-已存在该人脸，5-非法人脸ID
        # ,6-算法建模失败，7-未下发卡权限，8-未定义（保留），9-人眼间距小距小，10-图片数据长度小于1KB，11-图片格式不符（png/jpg/bmp）,12-图片像素数量超过上限，13-图片像素数量低于下限，14-图片信息校验失败，15-图片解码失败，16-人脸检测失败，17-人脸评分失败
        ("byErrorMsg", BYTE * ERROR_MSG_LEN), # 下发错误信息，当byCardReaderRecvStatus为4时，表示已存在人脸对应的卡号
        ("dwCardReaderNo", DWORD), # 纹读卡器编号，可用于下发错误返回
        ("byTotalStatus", BYTE), # 下发总的状态，0-当前人脸未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
        ("byFaceID", BYTE), # 人脸编号，有效值范围为1-2
        ("byRes", BYTE * 130),
    ]


LPNET_DVR_FACE_PARAM_STATUS = POINTER(NET_DVR_FACE_PARAM_STATUS)


class NET_DVR_FACE_PARAM_BYCARD(Structure):
    _fields_ = [
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 人脸的读卡器信息，按数组表示
        ("byFaceID", BYTE * MAX_FACE_NUM), # 需要删除的人脸编号，按数组下标，值表示0-不删除，1-删除该人脸
        ("byRes1", BYTE * 42), # 保留
    ]


LPNET_DVR_FACE_PARAM_BYCARD = POINTER(NET_DVR_FACE_PARAM_BYCARD)


class NET_DVR_FACE_PARAM_BYREADER(Structure):
    _fields_ = [
        ("dwCardReaderNo", DWORD), # 按值表示，人脸读卡器编号
        ("byClearAllCard", BYTE), # 是否删除所有卡的人脸信息，0-按卡号删除人脸信息，1-删除所有卡的人脸信息
        ("byRes1", BYTE * 3), # 保留
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号
        ("byRes", BYTE * 548), # 保留
    ]


LPNET_DVR_FACE_PARAM_BYREADER = POINTER(NET_DVR_FACE_PARAM_BYREADER)


class NET_DVR_DEL_FACE_PARAM_MODE(Union):
    _fields_ = [
        ("uLen", BYTE * 588), # 联合体长度
        ("struByCard", NET_DVR_FACE_PARAM_BYCARD), # 按卡号的方式删除
        ("struByReader", NET_DVR_FACE_PARAM_BYREADER), # 按读卡器的方式删除
    ]


LPNET_DVR_DEL_FACE_PARAM_MODE = POINTER(NET_DVR_DEL_FACE_PARAM_MODE)


class NET_DVR_FACE_PARAM_CTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMode", BYTE), # 删除方式，0-按卡号方式删除，1-按读卡器删除
        ("byRes1", BYTE * 3), # 保留
        ("struProcessMode", NET_DVR_DEL_FACE_PARAM_MODE), # 处理方式
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_FACE_PARAM_CTRL = POINTER(NET_DVR_FACE_PARAM_CTRL)


class NET_DVR_LOCAL_CONTROLLER_STATUS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wLocalControllerID", WORD), # 就地控制器序号(分控器序号),为0表示所有
        ("byRes", BYTE * 306),
    ]


LPNET_DVR_LOCAL_CONTROLLER_STATUS_COND = POINTER(NET_DVR_LOCAL_CONTROLLER_STATUS_COND)


class NET_DVR_LOCAL_CONTROLLER_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wLocalControllerID", WORD), # 就地控制器序号(分控器序号)
        ("byLocalAntiDismantleStatus", BYTE), # 就地控制器防拆状态，0-关闭，1-开启
        ("byPowerSupplyStatus", BYTE), # 设备供电状态，1-交流电供电，2-蓄电池供电
        ("wBatteryVoltage", WORD), # 蓄电池电压值，实际值乘10，单位：伏特
        ("byBatteryLowVoltage", BYTE), # 蓄电池是否处于低压状态，0-否，1-是
        ("byFireAlarm", BYTE), # 消防报警，0-正常，1-短接报警，2-断开报警
        ("bySerialNumber", BYTE * SERIALNO_LEN), # 设备序列号
        ("byMagneticStatus", BYTE * MAX_DOOR_NUM), #  门磁状态：0正常关闭，1正常开启，2破坏短路报警，3破坏断路报警，4异常报警
        ("byDoorLockStatus", BYTE * MAX_DOOR_NUM), # 门锁状态，0正常关闭，1正常开启，2破坏短路报警，3破坏断路报警，4异常报警
        ("byCardReaderOnlineStatus", BYTE * MAX_CARD_READER_NUM), # 读卡器在线状态，0-不在线，1-在线
        ("wLocalControllerStatus", WORD), # 只读，就地控制器在线状态(分控器在线状态)：0-离线，1-网络在线，2-环路1上的RS485串口1，3-环路1上的RS485串口2，4-环路2上的RS485串口1，5-环路2上的RS485串口2，6-环路3上的RS485串口1，7-环路3上的RS485串口2，8-环路4上的RS485串口1，9-环路4上的RS485串口2（只读）
        ("byRes2", BYTE * 122),
    ]


LPNET_DVR_LOCAL_CONTROLLER_STATUS = POINTER(NET_DVR_LOCAL_CONTROLLER_STATUS)


class NET_DVR_ONLINE_LOCAL_CONTROLLER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLocalControllerName", BYTE * LOCAL_CONTROLLER_NAME_LEN), # 就地控制器名称
        ("wLocalControllerID", WORD), # 就地控制器序号
        ("wDevPort", WORD), #  设备端口号
        ("struDevIP", NET_DVR_IPADDR), #  设备IP地址
        ("struSubnetMask", NET_DVR_IPADDR), #  设备子网掩码
        ("struGateway", NET_DVR_IPADDR), #  设备网关
        ("bySearchProgress", BYTE), # 搜索进度，0表示未开始，100表示同步完成
        ("byEffectData", BYTE), # 是否为有效数据,0表示有效，1表示设备只返回搜索进度，作为心跳包
        ("byRes", BYTE * 302),
    ]


LPNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG = POINTER(NET_DVR_ONLINE_LOCAL_CONTROLLER_CFG)


class NET_DVR_ACS_WORK_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDoorLockStatus", BYTE * MAX_DOOR_NUM), # 门锁状态，0-关，1-开
        ("byDoorStatus", BYTE * MAX_DOOR_NUM), # 门状态，1-休眠，2-常开状态，3-常闭状态，4-普通状态
        ("byMagneticStatus", BYTE * MAX_DOOR_NUM), # 门磁状态，0-闭合，1-开启
        ("byCaseStatus", BYTE * MAX_CASE_SENSOR_NUM), # 事件触发器状态，0-无输入，1-有输入
        ("wBatteryVoltage", WORD), # 蓄电池电压值，实际值乘10，单位：伏特
        ("byBatteryLowVoltage", BYTE), # 蓄电池是否处于低压状态，0-否，1-是
        ("byPowerSupplyStatus", BYTE), # 设备供电状态，1-交流电供电，2-蓄电池供电
        ("byMultiDoorInterlockStatus", BYTE), # 多门互锁状态，0-关闭，1-开启
        ("byAntiSneakStatus", BYTE), # 反潜回状态，0-关闭，1-开启
        ("byHostAntiDismantleStatus", BYTE), # 主机防拆状态，0-关闭，1-开启
        ("byIndicatorLightStatus", BYTE), # 指示灯状态，0-掉线，1-在线
        ("byCardReaderOnlineStatus", BYTE * MAX_CARD_READER_NUM), # 读卡器在线状态，0-不在线，1-在线
        ("byCardReaderAntiDismantleStatus", BYTE * MAX_CARD_READER_NUM), # 读卡器防拆状态，0-关闭，1-开启
        ("byCardReaderVerifyMode", BYTE * MAX_CARD_READER_NUM), # 读卡器当前验证方式，1-刷卡，2-刷卡+密码，3-刷卡，4-刷卡或密码
        ("bySetupAlarmStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 报警输入口布防状态，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
        ("byAlarmInStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 报警输入口报警状态，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
        ("byAlarmOutStatus", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 报警输出口状态，0-对应报警输出口无报警，1-对应报警输出口有报警
        ("dwCardNum", DWORD), # 已添加的卡数量
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_ACS_WORK_STATUS = POINTER(NET_DVR_ACS_WORK_STATUS)


class NET_DVR_ACS_WORK_STATUS_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDoorLockStatus", BYTE * MAX_DOOR_NUM_256), # 门锁状态(继电器开合状态)，0-正常关，1-正常开，2-短路报警，3-断路报警，4-异常报警
        ("byDoorStatus", BYTE * MAX_DOOR_NUM_256), # 门状态(楼层状态)，1-休眠，2-常开状态(自由)，3-常闭状态(禁用)，4-普通状态(受控)
        ("byMagneticStatus", BYTE * MAX_DOOR_NUM_256), # 门磁状态，0-正常关，1-正常开，2-短路报警，3-断路报警，4-异常报警
        ("byCaseStatus", BYTE * MAX_CASE_SENSOR_NUM), # 事件触发器状态，0-无输入，1-有输入
        ("wBatteryVoltage", WORD), # 蓄电池电压值，实际值乘10，单位：伏特
        ("byBatteryLowVoltage", BYTE), # 蓄电池是否处于低压状态，0-否，1-是
        ("byPowerSupplyStatus", BYTE), # 设备供电状态，1-交流电供电，2-蓄电池供电
        ("byMultiDoorInterlockStatus", BYTE), # 多门互锁状态，0-关闭，1-开启
        ("byAntiSneakStatus", BYTE), # 反潜回状态，0-关闭，1-开启
        ("byHostAntiDismantleStatus", BYTE), # 主机防拆状态，0-关闭，1-开启
        ("byIndicatorLightStatus", BYTE), # 指示灯状态，0-掉线，1-在线
        ("byCardReaderOnlineStatus", BYTE * MAX_CARD_READER_NUM_512), # 读卡器在线状态，0-不在线，1-在线
        ("byCardReaderAntiDismantleStatus", BYTE * MAX_CARD_READER_NUM_512), # 读卡器防拆状态，0-关闭，1-开启
        ("byCardReaderVerifyMode", BYTE * MAX_CARD_READER_NUM_512), # 读卡器当前验证方式，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码
        ("bySetupAlarmStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 报警输入口布防状态，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
        ("byAlarmInStatus", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 按位表示报警输入口报警状态，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
        ("byAlarmOutStatus", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 按位表示报警输出口状态，0-对应报警输出口无报警，1-对应报警输出口有报警
        ("dwCardNum", DWORD), # 已添加的卡数量
        ("byFireAlarmStatus", BYTE), # 消防报警状态显示：0-正常、1-短路报警、2-断开报警
        ("byBatteryChargeStatus", BYTE), # 电池充电状态：0-无效；1-充电中；2-未充电
        ("byMasterChannelControllerStatus", BYTE), # 主通道控制器在线状态：0-无效；1-不在线；2-在线
        ("bySlaveChannelControllerStatus", BYTE), # 从通道控制器在线状态：0-无效；1-不在线；2-在线
        ("byAntiSneakServerStatus", BYTE), # 反潜回服务器状态：0-无效，1-未启用，2-正常，3-断开
        ("byRes3", BYTE * 3),
        ("dwWhiteFaceNum", DWORD), # 已添加的白名单人脸数量（通过能力集判断）
        ("dwBlackFaceNum", DWORD), # 已添加的黑名单人脸数量（通过能力集判断）
        ("byRes2", BYTE * 108),
    ]


LPNET_DVR_ACS_WORK_STATUS_V50 = POINTER(NET_DVR_ACS_WORK_STATUS_V50)


class NET_DVR_CASE_SENSOR_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byHostBuzzer", BYTE), # 触发主机蜂鸣器，0-不触发，1-触发
        ("byRes1", BYTE * 3),
        ("byCardReaderBuzzer", BYTE * MAX_CARD_READER_NUM), # 触发读卡器蜂鸣器，1-触发，0-不触发
        ("byAssociateAlarmOut", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 关联触发的报警输出，1-关联，0-不关联
        ("byDoorOpen", BYTE * MAX_DOOR_NUM), # 对门1-N关联门打开，0-不关联，1-关联（即打开）
        ("byDoorClose", BYTE * MAX_DOOR_NUM), # 对门1-N关联门关闭，0-不关联，1-关联（即关闭）
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_CASE_SENSOR_CFG = POINTER(NET_DVR_CASE_SENSOR_CFG)


ENUM_UPGRADE_DVR = 0
ENUM_UPGRADE_ADAPTER = 1
ENUM_UPGRADE_VCALIB = 2
ENUM_UPGRADE_OPTICAL = 3
ENUM_UPGRADE_ACS = 4
ENUM_UPGRADE_AUXILIARY_DEV = 5
ENUM_UPGRADE_LED = 6
ENUM_UPGRADE_INTELLIGENT = 7


class NET_DVR_ACS_EVENT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号，为0无效
        ("byCardType", BYTE), # 卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
        ("byWhiteListNo", BYTE), # 白名单单号,1-8，为0无效
        ("byReportChannel", BYTE), # 报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
        ("byCardReaderKind", BYTE), # 读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
        ("dwCardReaderNo", DWORD), # 读卡器编号，为0无效
        ("dwDoorNo", DWORD), # 门编号(楼层编号)，为0无效（当接的设备为人员通道设备时，门1为进方向，门2为出方向）
        ("dwVerifyNo", DWORD), # 多重卡认证序号，为0无效
        ("dwAlarmInNo", DWORD), # 报警输入号，为0无效
        ("dwAlarmOutNo", DWORD), # 报警输出号，为0无效
        ("dwCaseSensorNo", DWORD), # 事件触发器编号
        ("dwRs485No", DWORD), # RS485通道号，为0无效
        ("dwMultiCardGroupNo", DWORD), # 群组编号
        ("wAccessChannel", WORD), # 人员通道号
        ("byDeviceNo", BYTE), # 设备编号，为0无效
        ("byDistractControlNo", BYTE), # 分控器编号，为0无效
        ("dwEmployeeNo", DWORD), # 工号，为0无效
        ("wLocalControllerID", WORD), # 就地控制器编号，0-门禁主机，1-64代表就地控制器
        ("byInternetAccess", BYTE), # 网口ID：（1-上行网口1,2-上行网口2,3-下行网口1）
        ("byType", BYTE), # 防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 0xff-无
        ("byMACAddr", BYTE * MACADDR_LEN), # 物理地址，为0无效
        ("bySwipeCardType", BYTE), # 刷卡类型，0-无效，1-二维码
        ("byRes2", BYTE),
        ("dwSerialNo", DWORD), # 事件流水号，为0无效
        ("byChannelControllerID", BYTE), # 通道控制器ID，为0无效，1-主通道控制器，2-从通道控制器
        ("byChannelControllerLampID", BYTE), # 通道控制器灯板ID，为0无效（有效范围1-255）
        ("byChannelControllerIRAdaptorID", BYTE), # 通道控制器红外转接板ID，为0无效（有效范围1-255）
        ("byChannelControllerIREmitterID", BYTE), # 通道控制器红外对射ID，为0无效（有效范围1-255）
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_ACS_EVENT_INFO = POINTER(NET_DVR_ACS_EVENT_INFO)


class NET_DVR_ACS_EVENT_INFO_EXTEND(Structure):
    _fields_ = [
        ("dwFrontSerialNo", DWORD), # 事件流水号，为0无效（若该字段为0，平台根据dwSerialNo判断是否丢失事件；若该字段不为0，平台根据该字段和dwSerialNo字段共同判断是否丢失事件）（主要用于解决报警订阅后导致dwSerialNo不连续的情况）
        ("byUserType", BYTE), # 人员类型：0-无效，1-普通人（主人），2-来宾（访客），3-黑名单人，4-管理员
        ("byCurrentVerifyMode", BYTE), # 读卡器当前验证方式：0-无效，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码
        ("byCurrentEvent", BYTE), # 是否为实时事件：0-无效，1-是（实时事件），2-否（离线事件）
        ("byPurePwdVerifyEnable", BYTE), # 设备是否支持纯密码认证， 0-不支持，1-支持
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）（对于设备来说，如果使用了工号（人员ID）字段，byEmployeeNo一定要传递，如果byEmployeeNo可转换为dwEmployeeNo，那么该字段也要传递；对于上层平台或客户端来说，优先解析byEmployeeNo字段，如该字段为空，再考虑解析dwEmployeeNo字段）
        ("byAttendanceStatus", BYTE), # 考勤状态：0-未定义,1-上班，2-下班，3-开始休息，4-结束休息，5-开始加班，6-结束加班
        ("byStatusValue", BYTE), # 考勤状态值
        ("byRes2", BYTE * 2),
        ("byUUID", BYTE * NET_SDK_UUID_LEN), # UUID（该字段仅在对接萤石平台过程中才会使用）
        ("byDeviceName", BYTE * NET_DEV_NAME_LEN), # 设备序列号
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_ACS_EVENT_INFO_EXTEND = POINTER(NET_DVR_ACS_EVENT_INFO_EXTEND)


class NET_DVR_ACS_ALARM_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMajor", DWORD), # 报警主类型，参考宏定义
        ("dwMinor", DWORD), # 报警次类型，参考宏定义
        ("struTime", NET_DVR_TIME), # 时间
        ("sNetUser", BYTE * MAX_NAMELEN), # 网络操作的用户名
        ("struRemoteHostAddr", NET_DVR_IPADDR), # 远程主机地址
        ("struAcsEventInfo", NET_DVR_ACS_EVENT_INFO), # 详细参数
        ("dwPicDataLen", DWORD), # 图片数据大小，不为0是表示后面带数据
        ("*pPicData", CHAR),
        ("wInductiveEventType", WORD), # 归纳事件类型，0-无效，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("byRes1", BYTE), # 保留字节
        ("dwIOTChannelNo", DWORD), # IOT通道号
        ("*pAcsEventInfoExtend", CHAR), # byAcsEventInfoExtend为1时，表示指向一个NET_DVR_ACS_EVENT_INFO_EXTEND结构体
        ("byAcsEventInfoExtend", BYTE), # pAcsEventInfoExtend是否有效：0-无效，1-有效
        ("byTimeType", BYTE), # 时间类型：0-设备本地时间，1-UTC时间（struTime的时间）
        ("byRes", BYTE * 10),
    ]


LPNET_DVR_ACS_ALARM_INFO = POINTER(NET_DVR_ACS_ALARM_INFO)


JUDGE_MAX_VIDEOOUT_NUM = 9
class NET_DVR_AUDIO_ACTIVATION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用
        ("byRes1", BYTE * 3),
        ("dwChanNo", DWORD), # 语音激励的视频通道号
        ("bySensitivity", BYTE), # 灵敏度 1-100，灵敏度越高，表示较低的音量就能使能该音频输入激励功能；灵敏度越低，表示需要较高的音量才能使能该音频输入的激励功能
        ("byPriority", BYTE), # 优先级  0-优先级0，1-优先级1， 值越大级别越高
        ("wDelayTime", WORD), # 语音激励结束画面切换延迟时间，单位s, 超时后自动回到预置点1对应的画面
        ("byRes2", BYTE), # 保留
        ("byEnablePreset", BYTE), # 是否启用预置点
        ("wPreset", WORD), # 预置点
        ("wBase", WORD), # 基准点编号
        ("byRes3", BYTE * 2),
        ("byVoChanNo", BYTE * JUDGE_MAX_VIDEOOUT_NUM), # 语音激励是否输出到视频输出口。值0表示不输出，1-表示输出。下标表示通道顺序如下：0-VGA1,1-VGA2, 2-VGA3,3-VGA4,4-VGA5~10,5-HDMI1,6-HDMI2
        ("byRes", BYTE * 255), # 保留
    ]


LPNET_DVR_AUDIO_ACTIVATION_CFG = POINTER(NET_DVR_AUDIO_ACTIVATION_CFG)


class NET_DVR_INFRARED_OUTPUT_CTRL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byIROutPort", BYTE), # 红外输出索引，1-红外输出口1，2-红外输出口2
        ("byIRCmdIndex", BYTE), # 红外学码命令对应的索引；
        ("byRes", BYTE * 254), # 保留
    ]


LPNET_DVR_INFRARED_OUTPUT_CTRL_CFG = POINTER(NET_DVR_INFRARED_OUTPUT_CTRL_CFG)


MAX_IR_CMD_NAME_LEN = 32 # 红外输出命令名称长度
MAX_IR_CMD_NUM = 32 # 红外命令个数
class NET_DVR_INFRARED_CMD_INFO(Structure):
    _fields_ = [
        ("sCmdName", CHAR * MAX_IR_CMD_NAME_LEN), # 红外命令名称
        ("byRes", BYTE * 8), # 保留
    ]


LPNET_DVR_INFRARED_CMD_INFO = POINTER(NET_DVR_INFRARED_CMD_INFO)


class NET_DVR_INFRARED_CMD_NAME_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sIROutName", BYTE * MAX_IR_CMD_NAME_LEN), # 红外输出口名称
        ("struIRCmdInfo", NET_DVR_INFRARED_CMD_INFO * MAX_IR_CMD_NUM), # 红外命令子信息
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_INFRARED_CMD_NAME_CFG = POINTER(NET_DVR_INFRARED_CMD_NAME_CFG)


ENUM_SENDDATA = 0x0
ENUM_SEND_LEARN_IR_CMD_START = 1
ENUM_SEND_LEARN_IR_CMD_END = 0x2


class NET_DVR_INFRARED_LEARN_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byIROutPort", BYTE), # 红外输出索引，1-红外输出口1，2-红外输出口2
        ("byIRCmdIndex", BYTE), # 红外学码命令对应的索引
        ("byRes", BYTE * 30), # 保留
    ]


LPNET_DVR_INFRARED_LEARN_INFO = POINTER(NET_DVR_INFRARED_LEARN_INFO)


class NET_DVR_INFRARED_LEARN_END(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("bySaveLearnInfo", BYTE), # 保存学码信息，0-保存，1-不保存
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_INFRARED_LEARN_END = POINTER(NET_DVR_INFRARED_LEARN_END)


MAX_VIDEOIN_TYPE_NUM = 10 # 最大支持的视频输入源类型
class NET_DVR_VIDEOIN_TYPE_INFO(Structure):
    _fields_ = [
        ("wInType", WORD), # 输入源类型  0-SDI,1-VGA, 2-HDMI,3-IP,4-PIP
        ("wInNum", WORD), # 支持的输入个数
        ("wStartNo", WORD), # 输入对应的起始号
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_VIDEOIN_TYPE_INFO = POINTER(NET_DVR_VIDEOIN_TYPE_INFO)


class NET_DVR_TRIAL_SYSTEM_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byVideoInTypeNum", BYTE), # 视频输入源类型个数
        ("byRes1", BYTE * 3),
        ("struVideoIn", NET_DVR_VIDEOIN_TYPE_INFO * MAX_VIDEOIN_TYPE_NUM), # 视频输入源
        ("byRes", BYTE * 512), # 保留
    ]


LPNET_DVR_TRIAL_SYSTEM_INFO = POINTER(NET_DVR_TRIAL_SYSTEM_INFO)


class NET_DVR_CASE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byCaseNo", BYTE * CASE_NO_LEN), # 案件编号
        ("byCaseName", BYTE * CASE_NAME_LEN), # 案件名称；
        ("byLitigant1", BYTE * LITIGANT_LEN), # 当事人1；
        ("byLitigant2", BYTE * LITIGANT_LEN), # 当事人2；
        ("byChiefJudge", BYTE * CHIEF_JUDGE_LEN), # 审判长
        ("byCaseType", BYTE), # 案件类型；1-刑事案件、2-民事案件、3- sCaseTypeCustom生效
        ("byShowCaseInfoTime", BYTE), #  案件信息显示时间,单位秒, 取值范围1~30
        ("byRes1", BYTE * 2), # 保留
        ("sCaseTypeCustom", CHAR * NET_SDK_CASETYPE_LEN), # 自定义案件类型
        ("byRes", BYTE * 220), # 保留
    ]


LPNET_DVR_CASE_INFO = POINTER(NET_DVR_CASE_INFO)


MICROPHONE_NUM = 16
FAN_NUM = 8
FPGA_NUM = 8
MAIN_BOARD = 8
LOCAL_INPUT_NUM = 24
LAMP_STATE_NAME = 32
LAMP_NAME = 32
FILE_NAME_LEN = 32
class NET_DVR_LAMP_STATUS(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否启用
        ("byRes1", BYTE * 3),
        ("byLampName", BYTE * LAMP_NAME), # Lamp 名称，报警输出3、4口为Lamp1。报警5、6输出口为lamp2。
        ("byLampState1", BYTE * LAMP_STATE_NAME), # 状态1对应名称，
        ("byLampState2", BYTE * LAMP_STATE_NAME), # 状态2对应名称
        ("byLampState3", BYTE * LAMP_STATE_NAME), # 状态3对应名称
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LAMP_STATUS = POINTER(NET_DVR_LAMP_STATUS)


# 实时信息
class NET_DVR_TPS_PARAM(Structure):
    _fields_ = [
        ("byStart", BYTE), #  开始码
        ("byCMD", BYTE), #  命令号，01-进入指令，02-离开指令，03-拥堵状态指令(为03时，只有byLaneState和byQueueLen有效)，04-多线圈状态（为04时，wLoopState和wStateMask有效，表示byLane车道上多个线圈的过车状态）
        ("wSpaceHeadway", WORD), # 车头间距，以米来计算
        ("wDeviceID", WORD), #  设备ID
        ("wDataLen", WORD), #  数据长度
        ("byLane", BYTE), #  对应车道号
        ("bySpeed", BYTE), #  对应车速（KM/H）
        ("byLaneState", BYTE), #  车道状态；0-无状态，1-畅通，2-拥挤，3-堵塞
        ("byQueueLen", BYTE), #  堵塞状态下排队长度（比如50米）
        ("wLoopState", WORD), # 线圈状态，第几位表示几号线圈状态。状态1-到达，0-离开，线圈编号从镜头由近到远依次增大，用户在解析时优先解析车道号，再解析线圈号，单个车道的线圈号是唯一的。
        ("wStateMask", WORD), # 线圈状态掩码，掩码位为1对应wLoopState状态位有效，为0表示无效
        ("dwDownwardFlow", DWORD), # 当前车道 从上到下车流量
        ("dwUpwardFlow", DWORD), # 当前车道 从下到上车流量
        ("byJamLevel", BYTE), # 拥堵等级，当byLaneState为3时有效，1-轻度，2-中度，3-重度
        ("byVehicleDirection", BYTE), # 0-未知，1-由上而下，2-由下而上
        ("byJamFlow", BYTE), # 拥堵新增流量，每新增一辆车就上报一次累计车辆的信息
        ("byChannelizationLane", BYTE), # 渠化车道号（渠化表示，车道数量变化的情况，一般为路口车道的数目）
        ("byVehicleType", BYTE), # 车型识别：0- 未知，1- 客车(大型)，2- 货车(大型)，3- 轿车(小型)，4- 非机动车
        ("byRes1", BYTE * 5), # 保留
        ("wTimeHeadway", WORD), #  车头时距，以秒计算
    ]


LPNET_DVR_TPS_PARAM = POINTER(NET_DVR_TPS_PARAM)


class NET_DVR_PANORAMA_LINKAGE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 0-关闭，1-开启
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_PANORAMA_LINKAGE = POINTER(NET_DVR_PANORAMA_LINKAGE)


#  交通参数统计信息
class NET_DVR_TPS_STATISTICS_PARAM(Structure):
    _fields_ = [
        ("byStart", BYTE), #  开始码
        ("byCMD", BYTE), #  命令号， 08-定时成组数据指令
        ("byRes", BYTE * 2), #  预留字节
        ("wDeviceID", WORD), #  设备ID
        ("wDataLen", WORD), #  数据长度
        ("byTotalLaneNum", BYTE), #  有效车道总数
        ("byRes1", BYTE * 15),
        ("struStartTime", NET_DVR_TIME_V30), # 统计开始时间
        ("dwSamplePeriod", DWORD), # 统计时间,单位秒
        ("struLaneParam", NET_DVR_TPS_LANE_PARAM * MAX_TPS_RULE),
    ]


LPNET_DVR_TPS_STATISTICS_PARAM = POINTER(NET_DVR_TPS_STATISTICS_PARAM)


DPC_CORRECT = 1 # 校正
DPC_CORRECT_CANCEL = 2 # 取消校正
DPC_CROSS_DISPALY_OPEN = 3 # 坏点检测十字叉显示开启
DPC_CROSS_DISPALY_CLOSE = 4 # 坏点检测十字叉显示关闭
DPC_POINT = 5 # 坏点校正坐标
DPC_UP = 6 # 坏点校正坐标点向上偏移
DPC_DOWN = 7 # 坏点校正坐标点向下偏移
DPC_RIGHT = 8 # 坏点校正坐标点向右偏移
DPC_LEFT = 9 # 坏点校正坐标点向左偏移
DPC_ALL_CORRECT = 10 # 所有坏点校正
DPC_SAVE = 11 # 坏点保存
class NET_DVR_DPC_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("wCtrlType", WORD), # 参考宏定义
        #
        # 手动校正：默认为手动校正模式，使用wCtrlType操作类型进行手动校正。
        # 自动校正：设备将自动进行校正，无需再进行手动校正，此时wCtrlType、struPoint参数无效。
        #
        ("byDPCMode", BYTE), # 坏点校正模式：0-手动校正，1-自动校正
        ("byRes", BYTE),
        ("struPoint", NET_VCA_POINT), # 输入的图像平面坐标，归一化到0-1
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_DPC_PARAM = POINTER(NET_DVR_DPC_PARAM)


# 非均匀性校正(FFC)手动模式
class NET_DVR_FFC_MANUAL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FFC_MANUAL_INFO = POINTER(NET_DVR_FFC_MANUAL_INFO)


# 非均匀性校正(FFC)背景补偿
class NET_DVR_FFC_BACKCOMP_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FFC_BACKCOMP_INFO = POINTER(NET_DVR_FFC_BACKCOMP_INFO)


# 存储服务器开关状态
class NET_DVR_STORAGE_SERVER_SWITCH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 存储图片开关；按位表示，0-关闭，1-开启
        # 数组0-移动侦测抓图(暂不支持)
        # 数组1-报警抓图(暂不支持)
        # ……
        #
        ("byPicEnable", BYTE * MAX_PIC_SWITCH_STORAGE_SERVER),
        # 存储附加信息开关；按位表示，0-关闭，1-开启
        # 数组0-热度图(暂不支持)
        # 数组1-客流量(暂不支持)
        # ……
        #
        ("byAddInfoEnable", BYTE * MAX_INFO_SWITCH_STORAGE_SERVER),
        ("byRes", BYTE * 324),
    ]


LPNET_DVR_STORAGE_SERVER_SWITCH_CFG = POINTER(NET_DVR_STORAGE_SERVER_SWITCH_CFG)


*LPNET_DVR_STORAGE_SERVER_SWITCH_CFG;
# 强制停止取证
class NET_DVR_FORCESTOP_FORENSICS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FORCESTOP_FORENSICS_CFG = POINTER(NET_DVR_FORCESTOP_FORENSICS_CFG)


class NET_DVR_DEC_VCA_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDisplayNo", DWORD), # 产生智能报警的显示通道号
        ("bySubWinNo", BYTE), # 产生智能报警的子窗口号
        ("byRes1", BYTE * 3),
        ("struTime", NET_DVR_TIME_V30), # 产生报警时间
        ("struSourceInfo", NET_DVR_PU_STREAM_CFG_V41), # 码流源信息
        ("*byAlarmPic", BYTE), # 报警图片缓冲区
        ("dwAlarmPicSize", DWORD), # 报警图片大小，单位：字节
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_DEC_VCA_ALARM = POINTER(NET_DVR_DEC_VCA_ALARM)


class NET_DVR_DEC_VCA_ALARM_LOGO(Structure):
    _fields_ = [
        ("byEnableLogo", BYTE), # 是否叠加智能报警logo，0-不叠加，非0-叠加
        ("byFlash", BYTE), # 是否闪烁，0-不闪烁，非0-闪烁
        ("wFlashTime", WORD), # 闪烁时间，单位：秒，取值范围从解码器能力集获取
        ("dwLogoX", DWORD), # logo X坐标，解码窗口总大小：1920*1920
        ("dwLogoY", DWORD), # logo Y坐标
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DEC_VCA_ALARM_LOGO = POINTER(NET_DVR_DEC_VCA_ALARM_LOGO)


class NET_DVR_DEC_VCA_ALARM_PIC(Structure):
    _fields_ = [
        ("byUploadPic", BYTE), # 智能报警时是否上传报警图片，0-不上传，非0-上传
        ("byOverlayTargetInfo", BYTE), # 报警图片是否叠加目标信息，0-不叠加，非0-叠加
        ("byOverlayRuleInfo", BYTE), # 报警图片是否叠加智能规则信息，0-不叠加，非0-叠加
        ("byPicQuality", BYTE), # 图片质量系数 0-最好 1-较好 2-一般
        # 图片大小 可以通过能力集获取
        # 0-CIF，           1-QCIF，           2-D1，         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)，
        # 6-VGA，           7-XVGA，           8-HD900p，     9-HD1080，     10-2560*1920，
        # 11-1600*304，     12-2048*1536，     13-2448*2048,  14-2448*1200， 15-2448*800，
        # 16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576，
        # 21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
        # 26-1280*1280,     27-1600*600,       28-2048*768,   0xff-Auto(使用当前码流分辨率)
        ("byPicSize", BYTE),
        ("byRes", BYTE * 27),
    ]


LPNET_DVR_DEC_VCA_ALARM_PIC = POINTER(NET_DVR_DEC_VCA_ALARM_PIC)


class NET_DVR_VCA_ALARM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAlarmLogo", NET_DVR_DEC_VCA_ALARM_LOGO), # 智能报警logo叠加参数
        ("struAlarmPic", NET_DVR_DEC_VCA_ALARM_PIC), # 智能报警图片参数
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_VCA_ALARM_CFG = POINTER(NET_DVR_VCA_ALARM_CFG)


MAX_OSD_LEN = 64 # 输出口OSD长度
class NET_DVR_OUTPUT_PIC_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sPicName", BYTE * NAME_LEN), # 图片名称
        ("byUsed", BYTE), # 是否已存在，0-不存在，1-存在
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_OUTPUT_PIC_INFO = POINTER(NET_DVR_OUTPUT_PIC_INFO)


class NET_DVR_OUTPUT_PIC_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwOutputPicNo", DWORD), # 图片序号
        ("byEnable", BYTE), # logo是否显示，1-显示，0-隐藏
        ("byRes1", BYTE * 3),
        ("struRect", NET_DVR_RECTCFG_EX), # logo位置，输出口范围总大小为1920*1920
        ("byFlash", BYTE), # 是否闪烁1-闪烁，0-不闪烁
        ("byTranslucent", BYTE), # 是否半透明1-半透明，0-不半透明
        ("byRes2", BYTE * 2), # 保留
        ("dwOutputPicWinNo", DWORD), # 输出口图片窗口号（1字节设备号+1字节输出口号+2字节输出口图片窗口号）,获取全部时有效
        ("byRes3", BYTE * 28),
    ]


LPNET_DVR_OUTPUT_PIC_CFG = POINTER(NET_DVR_OUTPUT_PIC_CFG)


class NET_DVR_OUTPUT_OSD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # OSD是否显示，0-不显示，1-显示
        ("byFontSize", BYTE), # 字体大小，1-大，2-中，3-小
        ("byOSDColor", BYTE), # OSD颜色配置，0-默认， 1-黑，2-白，3-红，4-绿，5-蓝
        ("byRes1", BYTE * 1),
        ("byOsdContent", BYTE * MAX_OSD_LEN), # OSD内容
        ("struRect", NET_DVR_RECTCFG_EX), # OSD位置，输出口范围总大小为1920*1920
        ("dwOsdWinNo", DWORD), # 输出口OSD窗口号（1字节设备号+1字节输出口号+2字节OSD窗口号），获取所有时有效
        ("byRes2", BYTE * 32), # 保留
    ]


LPNET_DVR_OUTPUT_OSD_CFG = POINTER(NET_DVR_OUTPUT_OSD_CFG)


class NET_DVR_CHAN_RELATION_RESOURCE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDisplayChan", DWORD), # 显示通道号（1字节设备号+1字节保留+2字节显示通道号）
        ("byRelateAudio", BYTE), # 是否关联子窗口音频
        ("byRes1", BYTE * 3),
        ("dwSubWinNo", DWORD), # 关联音频的子窗口号（1字节电视墙号+1字节子窗口号+2字节窗口号）
        ("dwChannel", DWORD), # 编码通道号，获取全部时有效
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_CHAN_RELATION_RESOURCE = POINTER(NET_DVR_CHAN_RELATION_RESOURCE)


class NET_DVR_ALARM_CHAN_ABLITITY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySensorChan", BYTE * 64), # 模拟量通道 下标表示通道号 0-表示不支持，1-表示支持
        ("byAlarmInChan", BYTE * 64), # 报警输入通道 下标表示通道号 0-表示不支持，1-表示支持
        ("byAlarmOutChan", BYTE * 64), # 报警输出通道 下标表示通道号 0-表示不支持，1-表示支持
        ("by485Chan", BYTE * 64), # 485通道 下标表示通道号 0-表示不支持，1-表示支持
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ALARM_CHAN_ABLITITY = POINTER(NET_DVR_ALARM_CHAN_ABLITITY)


class NET_DVR_OUT_SCALE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byOutScale", BYTE * 8), # 下标表示主辅口号，0-表示不支持，1-表示12V，2-表示24V
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_OUT_SCALE_CFG = POINTER(NET_DVR_OUT_SCALE_CFG)


class NET_DVR_MONITOR_LOCATION_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD),
        #
        # 0 表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
        # 1 表示关联 抓拍 HVT 模式（混卡IPC使用）
        #
        ("byRelateType", BYTE),
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_MONITOR_LOCATION_COND = POINTER(NET_DVR_MONITOR_LOCATION_COND)


class NET_DVR_MONITOR_LOCATION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMonitoringSiteID", BYTE * MAX_ID_LEN), # 监测点编号
        ("byDeviceID", BYTE * MAX_ID_LEN), # 设备编号
        ("byDirectionNo", BYTE), # 监测方向编号,0-无,1-上行,2-下行,3-双向,4-由东向西,5-由南向北,6-由西向东,7-由北向南,8-其他
        ("byRes1", BYTE * 3), # 保留
        ("byMonitorInfo", BYTE * MONITORSITE_ID_LEN), # 监测点信息描述
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_MONITOR_LOCATION_CFG = POINTER(NET_DVR_MONITOR_LOCATION_CFG)


class NET_DVR_REMOTECONTROL_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_REMOTECONTROL_COND = POINTER(NET_DVR_REMOTECONTROL_COND)


class NET_DVR_REMOTECONTROL_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("byAlarmStatus", BYTE), # 布防状态，0-保留,1-撤防,2-布防
        ("byRes", BYTE * 3),
        ("wAlarmDealyTime", WORD), # 布防延迟时间，单位s
        ("wDisAlarmDealyTime", WORD), # 撤防延迟时间，单位s
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_REMOTECONTROL_STATUS = POINTER(NET_DVR_REMOTECONTROL_STATUS)


class NET_DVR_SECURITY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCommuMode", BYTE), # 私有协议通信模式，0-兼容模式，1-安全模式
        ("byRes1", BYTE * 2),
        ("byWebAuthentication", BYTE), # web认证配置 0-digest、1-basic、2-digest/basic默认basic认证
        ("byRtspAuthentication", BYTE), # rtsp认证配置 0-disable、1-basic、2-digest、3-digest/basic默认basic认证
        ("byTelnetServer", BYTE), # telnet设置 0～禁用，1～启用
        ("bySSHServer", BYTE), # SSH设置 0～禁用(默认)，1～启用
        ("byIllegalLoginLock", BYTE), # 开启登陆锁定, 0-启用（默认），1-禁用
        ("byStreamEncryption", BYTE), # 码流加密 0-不加密，1-加密
        ("byAntiAttack", BYTE), # 是否开启防攻击功能，0- 不启用，1-启用(socket延时5s关闭)
        ("byRes", BYTE * 26),
    ]


LPNET_DVR_SECURITY_CFG = POINTER(NET_DVR_SECURITY_CFG)


class NET_DVR_PASSWORD_MANAGE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 3),
        ("byLockCount", BYTE), # 对应用户名或IP被几次连续的错误密码登录后，对该用户进行锁定，0-不锁定，其他值为锁定的次数。 默认为0，例如1表示错误登录1次以后就锁定该用户名。
        ("dwLockTime", DWORD), # 锁定时间，表示错误后锁定的时间，单位：秒。不能为0，byLockCount不为0时，dwLockTime才有效
        ("byRes1", BYTE * 128), # 4字节对齐
    ]


LPNET_DVR_PASSWORD_MANAGE_CFG = POINTER(NET_DVR_PASSWORD_MANAGE_CFG)


class NET_DVR_UNLOCK_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byUnlockType", BYTE), # 0-无效， 1-按IP解锁，2-解锁所有IP
        ("byIPVersion", BYTE), # 1-IPV4，2-IPV6，当byUnlockType为1时，该参数有效
        ("byRes1", BYTE * 2),
        ("struIPAddr", NET_DVR_IPADDR), # IP地址
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_UNLOCK_INFO = POINTER(NET_DVR_UNLOCK_INFO)


class NET_DVR_LOCKED_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIPType", BYTE), # IP类型 0-无效，1-IPV4，2-IPV6
        ("byRes1", BYTE * 3),
        ("struIPAddress", NET_DVR_IPADDR),
        ("byRes", BYTE * 20),
    ]


LPNET_DVR_LOCKED_INFO = POINTER(NET_DVR_LOCKED_INFO)


class NET_DVR_VEHICLE_PARA(Structure):
    _fields_ = [
        ("sLicense", BYTE * MAX_LICENSE_LEN),
        # 国家索引值
        # 0-算法库不支持牌识国家，1-捷克共和国(CZ - Czech Republic)，2-法国(FRA - France)，
        # 3-德国(DE - Germany),4-西班牙(E - Spain), 5-意大利(IT - Italy)，6-荷兰(NL - Netherlands)，7-波兰(PL - Poland)，8-斯洛伐克(SVK - Slovakia), 9-白俄罗斯(BY - Belorussia), 10-摩尔多瓦(MDA - Moldova)，11-俄罗斯(RU - Russia)，12-乌克兰(UA - Ukraine),
        # 169-加拿大(Canada), 172-美国(US), 227-澳大利亚(Australia), 0xfe-无法识别
        #
        ("byCountry", BYTE), #  国家索引值
        #
        ("byRes", BYTE * 239),
    ]


LPNET_DVR_VEHICLE_PARA = POINTER(NET_DVR_VEHICLE_PARA)


class NET_DVR_FACE_PIC_DATA_INFO(Structure):
    _fields_ = [
        ("dwImageLen", DWORD), # 图片大小
        ("struVcaRect", NET_VCA_RECT), # 子图在大图中的坐标位置，归一化坐标
        ("dwFaceScore", DWORD), # 相似度，取值范围0-100
        ("byVcaRectOnly", BYTE), # 是否只上传坐标：0-否；1-是
        ("byRes1", BYTE * 3),
        ("dwPID", DWORD), # 图片ID
        ("dwFaceSearchNum", DWORD), #  搜索人脸区域个数
        ("struMultiVcaRect", NET_VCA_RECT * NET_DVR_MAX_FACE_SEARCH_NUM), # （多个）子图在大图中的坐标位置，归一化坐标, byVcaRectOnly=1时启用，紧凑排列
        ("byRes", BYTE * 136),
        ("*pImage", BYTE), # 其中图片要求为jpg格式
    ]


LPNET_DVR_FACE_PIC_DATA_INFO = POINTER(NET_DVR_FACE_PIC_DATA_INFO)


class NET_DVR_BEHAVIOUR_COND(Structure):
    _fields_ = [
        ("dwSearchType", DWORD), # 搜索类型
        # &0x1 - 穿越警戒线
        # &0x2 - 区域入侵
        # &0x4 - 物品遗留
        # &0x8 - 物品拿取
        # &0x10 - 进入区域
        # &0x20 - 离开区域
        # &0x40 - 非法停车
        # &0x80 - 徘徊
        # &0x100 -人员聚集
        # &0x200 - 快速移动
        # &0x400 - 离岗检测
        # &0x800 - 人数变化
        # &0x1000 - 剧烈运动
        # &0x2000 - 人员奔跑
        # &0x4000 - 人员倒地
        # &0x8000 - 人员滞留
        # &0x10000 –态势分析
        # &0x20000 – 玩手机
        ("byHumanMisinfo", BYTE), #  只获取人体误报信息 0-否，1-是
        ("byRes", BYTE * 251), # 保留
    ]


LPNET_DVR_BEHAVIOUR_COND = POINTER(NET_DVR_BEHAVIOUR_COND)


class NET_DVR_SMARTSEARCH_PIC_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 256), # 联合体长度
        ("struVehiclePara", NET_DVR_VEHICLE_PARA), # 车辆检测信息
        ("struHumaFeature", NET_VCA_HUMAN_FEATURE), # 人脸属性
        ("struHumaPic", NET_DVR_FACE_PIC_DATA_INFO), # 根据人脸子图信息查询（用于远程图片的以图索图功能）
        ("struBehaviourCond", NET_DVR_BEHAVIOUR_COND), # 行为分析搜索条件
    ]


LPNET_DVR_SMARTSEARCH_PIC_UNION = POINTER(NET_DVR_SMARTSEARCH_PIC_UNION)


class NET_DVR_SMART_SEARCH_PIC_PARA(Structure):
    _fields_ = [
        ("dwChanNo", DWORD), # 通道号
        ("byStreamID", DWORD * STREAM_ID_LEN), # 流ID信息，与dwChanNo相比，优先级较高，即当byStreamID不为空时，则使用流ID，为空的情况下使用dwChanNo字段
        ("struStartTime", NET_DVR_TIME_EX), # 录像开始的时间
        ("struEndTime", NET_DVR_TIME_EX), # 录像停止的时间
        ("wSearchType", WORD), # 智能查找类型  0-车辆检索 ，1-人脸属性， 2-以图索图 ，3-行为分析
        ("byRes1", BYTE * 2),
        ("uSmartSearchCond", NET_DVR_SMARTSEARCH_PIC_UNION), # 智能查找条件
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cStartTimeDifferenceH", CHAR), # 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cStartTimeDifferenceM", CHAR), # 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("cStopTimeDifferenceH", CHAR), # 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
        ("cStopTimeDifferenceM", CHAR), # 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("byRes", BYTE * 59),
    ]


LPNET_DVR_SMART_SEARCH_PIC_PARA = POINTER(NET_DVR_SMART_SEARCH_PIC_PARA)


# 人体特征识别结果
class NET_DVR_FACE_SUB_PIC_INFO(Structure):
    _fields_ = [
        ("dwSimilarity", DWORD), # 相似度 0-100
        ("struVcaRect", NET_VCA_RECT), # 人脸区域，归一化坐标
        ("byRes2", BYTE * 236), # 保留
    ]


LPNET_DVR_FACE_SUB_PIC_INFO = POINTER(NET_DVR_FACE_SUB_PIC_INFO)


class NET_DVR_BEHAVIOR_INFO(Structure):
    _fields_ = [
        ("struVcaRect", NET_VCA_RECT),
        ("wPeopleNum", WORD), # 区域人数，仅图片类型（NET_DVR_SMART_SEARCH_PIC_RET 中wPicType）为态势分析时有效
        ("byRes2", BYTE * 238), # 保留
    ]


LPNET_DVR_BEHAVIOR_INFO = POINTER(NET_DVR_BEHAVIOR_INFO)


class NET_DVR_PIC_FEATURE_UNION(Union):
    _fields_ = [
        ("byLen", BYTE * 256), # 联合体长度
        ("struPlateInfo", NET_DVR_PLATE_INFO), # 车辆检索信息
        ("struFaceSubInfo", NET_DVR_FACE_SUB_PIC_INFO), # 人脸子图信息
        ("struBehavior", NET_DVR_BEHAVIOR_INFO), # 行为分析对应的子图信息
    ]


LPNET_DVR_PIC_FEATURE_UNION = POINTER(NET_DVR_PIC_FEATURE_UNION)


class NET_DVR_SMART_SEARCH_PIC_RET(Structure):
    _fields_ = [
        ("sFileName", CHAR * PICTURE_NAME_LEN), # 文件名
        ("struTime", NET_DVR_TIME_EX), # 图片的抓图时间
        ("dwFileSize", DWORD), # 文件的大小
        ("wPicType", WORD), # 图片类型  0-车辆检索 ，1-人脸属性， 2-以图索图 ，3-穿越警戒线，4-区域入侵， 5-物品遗留， 6-物品拿取， 7-进入区域， 8-离开区域， 9-非法停车，10-徘徊，11-人员聚集，12-快速移动,13-人员奔跑，14-剧烈运动，15-人员倒地，16-人数异常，17-离岗检测，18-人员滞留，19-态势分析  20-玩手机
        ("byRes1", BYTE * 2), # 保留
        ("uPicFeature", NET_DVR_PIC_FEATURE_UNION), # 图片属性
        ("byISO8601", BYTE), # 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14， 正数表示东时区
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
        ("byRes", BYTE * 29),
    ]


LPNET_DVR_SMART_SEARCH_PIC_RET = POINTER(NET_DVR_SMART_SEARCH_PIC_RET)


class NET_DVR_T1TEST_SEND_DATA_BUZZER(Structure):
    _fields_ = [
        ("byHearSound", BYTE), # 是否听到声音 0-未听到，1-听到
        ("byRes", BYTE * 31), # 保留
    ]


LPNET_DVR_T1TEST_SEND_DATA_BUZZER = POINTER(NET_DVR_T1TEST_SEND_DATA_BUZZER)


class NET_DVR_T1TEST_SEND_DATA(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byDataType", BYTE), # 数据类型 0-蜂鸣器，1-pc本地时间
        ("byRes1", BYTE * 3),
        ("uSendData", NET_DVR_T1TEST_DATA_UNION), # 发送的数据内容
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_T1TEST_SEND_DATA = POINTER(NET_DVR_T1TEST_SEND_DATA)


class NET_DVR_PIC_MODEL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_PIC_MODEL_CFG = POINTER(NET_DVR_PIC_MODEL_CFG)


class NET_DVR_MOUSE_EVENT_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byMouseEvent", BYTE), # 鼠标事件类型， 0-鼠标左键单击，1-鼠标左键双击，2-鼠标右键，3-滚轮上滚，4-滚轮下滚
        ("byRes1", BYTE * 3), # 保留
        ("struPoint", NET_VCA_POINT), # 鼠标点位置坐标，归一化处理
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_MOUSE_EVENT_PARAM = POINTER(NET_DVR_MOUSE_EVENT_PARAM)


class NET_DVR_AUTO_LIMIT_WAVE_CFG(Structure):
    _fields_ = [
        ("byFBCEnable", BYTE), # FBC开关 0-不开启，1-开启
        ("byMode", BYTE), # 模式, 0-快速, 1-普通,2-慢速
        ("byFilterQValue", BYTE), # 自适应滤波器Q值，单位Oct, 0-1/40,1-1/10, 默认值为1/40 Oct
        ("byStaticFilterNum", BYTE), # 静态滤波器数量，取值范围0-12
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_AUTO_LIMIT_WAVE_CFG = POINTER(NET_DVR_AUTO_LIMIT_WAVE_CFG)


class NET_DVR_MIX_AUDIOIN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwHighPassFilter", DWORD), # 高通滤波器 取值范围 0-127, 具体索引代表含义以能力集为准
        ("dwNoiseMargin", DWORD), # 噪声门限，取值范围 0-127, 具体索引代表含义以能力集为准
        ("struLimitWave", NET_DVR_AUTO_LIMIT_WAVE_CFG), # 自动限波控制参数，当音频输入源为macIn时有效
        ("struDSPParameter", NET_DVR_DSP_PARAMETER_CFG), # 数字信号处理芯片参数
        ("byRes", BYTE * 40),
    ]


LPNET_DVR_MIX_AUDIOIN_CFG = POINTER(NET_DVR_MIX_AUDIOIN_CFG)


class NET_DVR_MIX_AUDIOOUT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byModulatorEnbale", BYTE), # 是否启用相位调制器
        ("byPostFilter", BYTE), # Post Filter开关，0-关闭，1-开启，默认开启
        ("byLimitPressure", BYTE), # 输出压限开关 0-关闭，1-开启，默认开启
        ("byRes1", BYTE), # 保留
        ("wModulatorValue", WORD), # 相位调制量 取值范围 0-127, 具体索引代表含义以能力集为准，默认10
        ("wTriggerTime", WORD), # 压限触发时间，取值范围 0-127, 具体索引代表含义以能力集为准
        ("wFreeTime", WORD), # 压限释放时间，取值范围 0-127, 具体索引代表含义以能力集为准
        ("byCompressThreshold", BYTE), # 压缩门限 0-1X,1-2X,2-4X,3-8X  X表示倍，比如2X表示2倍
        ("byCompressMode", BYTE), # 压缩方式，0-硬压缩，1-软压缩，默认为硬压缩
        ("byCompressRate", BYTE), # 压缩率
        ("byRecoveryGain", BYTE), # 回复增益 0-1X,1-2X,2-4X,3-8X
        ("byOutputGain", BYTE), # 输出增益 0 ~100（负值）
        ("byOutputMute", BYTE), # 输出静音，0-关闭，1-开启
        ("iOutputGainEx", int), # 输出增益扩展，返回正值为放大，负值为缩小
        ("bySoundQualityHanding", BYTE), # 音质处理，0-关闭，1-开启
        ("byRes", BYTE * 55),
    ]


LPNET_DVR_MIX_AUDIOOUT_CFG = POINTER(NET_DVR_MIX_AUDIOOUT_CFG)


MAX_AUDIOOUT_PRO_TYPE = 8 # 音频输出处理方式
class NET_DVR_VOLUME_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("wVolume", WORD * MAX_AUDIOOUT_PRO_TYPE), # 音量大小 取值范围 0-127, 具体索引代表含义以能力集为准
        ("byPhantomPowerSupply", BYTE), # 是否使用幻象电源供电(音频输入通道为MIC时有效)，0-无意义，1-不供电，2-供电
        ("byEnableAEC", BYTE), # 是否启用全局的回声消除,0-不启用，1-启用
        ("wTalkVolume", WORD), # 支持对讲的设备，对讲时音量大小
        ("byEnableFBC", BYTE * MAX_AUDIOOUT_PRO_TYPE), # 是否启用FBC(啸叫抑制),0-不启用，1-启用
        ("wVolumeEx", WORD * MAX_AUDIOOUT_PRO_TYPE), # 音量大小扩展 取值范围 0-127, 具体索引代表含义以能力集为准
        ("byRes", BYTE * 4), # 保留
    ]


LPNET_DVR_VOLUME_CFG = POINTER(NET_DVR_VOLUME_CFG)


class NET_DVR_VIDEOOUT_RESOLUTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byResolution", BYTE), # 分辨率 0-1024x768, 1-1280x720,  2-1280x1024,  3-1680x1050, 4-1920x1080, 5-3840*2160
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_VIDEOOUT_RESOLUTION_CFG = POINTER(NET_DVR_VIDEOOUT_RESOLUTION_CFG)


class NET_DVR_ADDR_DOMAIN_INFO(Structure):
    _fields_ = [
        ("szDomainAddr", BYTE * MAX_DOMAIN_NAME), #  主机IP地址或者域名,需要设备解析,解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
        ("wPort", WORD),
        ("byRes", BYTE * 2),
    ]


LPNET_DVR_ADDR_DOMAIN_INFO = POINTER(NET_DVR_ADDR_DOMAIN_INFO)


MAX_CENTERNUM_V40 = 6 # 报警中心地址个数
# 报警中心网络配置
class NET_DVR_ALARMCENTER_NETCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAuxiliaryAlarmAddr", BYTE * MAX_DOMAIN_NAME), #  辅报警主机IP地址或者域名,需要设备解析,解析方式为有字母存在且有’.’则认为是域名,否则为IP地址
        ("wAuxiliaryAlarmPort", WORD), #  辅报警主机端口号
        ("struHostAddr", NET_DVR_ADDR_DOMAIN_INFO * MAX_CENTERNUM_V40), # 报警中心地址信息
        ("byRes", BYTE * 172),
    ]


LPNET_DVR_ALARMCENTER_NETCFG = POINTER(NET_DVR_ALARMCENTER_NETCFG)


# 报警联动参数结构
class NET_DVR_ALARM_LINKAGE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wChanRec", WORD), # 联动录像的NVR通道，按位表示，例如最低位表示通道1，最高位表示通道16，二进制位的值：0-不录像，1-录像
        ("byRes1", BYTE * 2),
        ("wRecTime", WORD * MAX_LINKAGE_CHAN_NUM), # 录像的时间，按字节表示，例如byRecTime[0]表示通道1的录像时间，byRecTime[15]表示通道16的录像时间
        ("wChanPic", WORD), # 联动抓图的NVR通道，按位表示，例如最低位表示通道1，最高位表示通道16，二进制位的值：0-不抓图，1-抓图
        ("byRes2", BYTE * 2),
        ("byPicNum", BYTE * MAX_LINKAGE_CHAN_NUM), # 抓图的个数，按字节表示，例如byPicNum[0]表示通道1的抓图个数，byPicNum[15]表示通道16的抓图个数
        ("byTriggerEnabled", BYTE * ALARMHOST_ALARMOUT_NUM), # 变量联动触发器，0-不联动，1-联动
        ("bySensorJointAlarmOut", BYTE * ALARMHOST_ALARMOUT_NUM), # 遥信值按类型联动触发器，该值为byTriggerEnabled的扩充。数组下标表示触发器号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：1bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
        ("byRes3", BYTE * 128), # 保留
    ]


LPNET_DVR_ALARM_LINKAGE_PARAM = POINTER(NET_DVR_ALARM_LINKAGE_PARAM)


# 雷达调试报警上传 抓拍机4.0新增
class NET_DVR_ALARM_RADARINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRadarTriggerTimeSecond", DWORD), # 雷达触发时间，秒
        ("dwRadarTriggerTimeMSecond", DWORD), # 雷达触发时间，毫秒
        ("dwVedioTriggerTimeSecond", DWORD), # 视频触发时间，秒
        ("dwVedioTriggerTimeMSecond", DWORD), # 视频触发时间，毫秒
        ("dwVedioRadarDiffTimeMSecond", DWORD), # 雷达视频触发时间差，毫秒
        ("dwRadarSpeed", DWORD), # 雷达速度
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_ALARM_RADARINFO = POINTER(NET_DVR_ALARM_RADARINFO)


MAX_FINGER_PRINT_LEN = 768 # 最大指纹长度
class NET_DVR_FINGER_PRINT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("dwFingerPrintLen", DWORD), # 指纹数据长度
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 需要下发指纹的读卡器，按数组表示，0-不下发该读卡器，1-下发到该读卡器
        ("byFingerPrintID", BYTE), # 手指编号，有效值范围为1-10
        ("byFingerType", BYTE), # 指纹类型  0-普通指纹，1-胁迫指纹
        ("byRes1", BYTE * 30),
        ("byFingerData", BYTE * MAX_FINGER_PRINT_LEN), # 指纹数据内容
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FINGER_PRINT_CFG = POINTER(NET_DVR_FINGER_PRINT_CFG)


class NET_DVR_FINGER_PRINT_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("byCardReaderRecvStatus", BYTE * MAX_CARD_READER_NUM_512), # 指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置
        ("byFingerPrintID", BYTE), # 手指编号，有效值范围为1-10
        ("byFingerType", BYTE), # 指纹类型  0-普通指纹，1-胁迫指纹
        ("byTotalStatus", BYTE), # 下发总的状态，0-当前指纹未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
        ("byRes1", BYTE),
        ("byErrorMsg", BYTE * ERROR_MSG_LEN), # 下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
        ("dwCardReaderNo", DWORD), # 非0表示错误信息byErrMsg有效，其值代表byErrMsg对应的读卡器编号（具体什么错误查看byCardReaderRecvStatus对应编号的值）。0时表示无错误信息
        ("byRes", BYTE * 24),
    ]


LPNET_DVR_FINGER_PRINT_STATUS = POINTER(NET_DVR_FINGER_PRINT_STATUS)


class NET_DVR_FINGER_PRINT_INFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 指纹的读卡器信息，按数组表示
        ("dwFingerPrintNum", DWORD), # 设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
        ("byFingerPrintID", BYTE), # 手指编号，有效值范围为-10   0xff表示该卡所有指纹
        ("byCallbackMode", BYTE), # 设备回调方式，0-设备所有读卡器下完了范围，1-在时间段内下了部分也返回
        ("byRes1", BYTE * 26), # 保留
    ]


LPNET_DVR_FINGER_PRINT_INFO_COND = POINTER(NET_DVR_FINGER_PRINT_INFO_COND)


class NET_DVR_FINGER_PRINT_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("dwFingerPrintLen", DWORD), # 指纹数据长度
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 需要下发指纹的读卡器，按数组表示，从低位到高位表示，0-不下发该读卡器，1-下发到该读卡器
        ("byFingerPrintID", BYTE), # 手指编号，有效值范围为1-10
        ("byFingerType", BYTE), # 指纹类型  0-普通指纹，1-胁迫指纹，2-巡更指纹，3-超级指纹，4-解除指纹
        ("byRes1", BYTE * 30),
        ("byFingerData", BYTE * MAX_FINGER_PRINT_LEN), # 指纹数据内容
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
        ("byLeaderFP", BYTE * MAX_DOOR_NUM_256), # 对门是否有首次认证功能（按字节表示）：0-无首次认证功能，1-有首次认证功能
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_FINGER_PRINT_CFG_V50 = POINTER(NET_DVR_FINGER_PRINT_CFG_V50)


class NET_DVR_FINGER_PRINT_STATUS_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("byCardReaderRecvStatus", BYTE * MAX_CARD_READER_NUM_512), # 指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置，10-指纹读卡器版本过低（无法支持工号）
        ("byFingerPrintID", BYTE), # 手指编号，有效值范围为1-10
        ("byFingerType", BYTE), # 指纹类型  0-普通指纹，1-胁迫指纹，2-巡更指纹，3-超级指纹，4-解除指纹
        ("byTotalStatus", BYTE), # 下发总的状态，0-当前指纹未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
        ("byRecvStatus", BYTE), # 主机错误状态：0-成功，1-手指编号错误，2-指纹类型错误，3-卡号错误（卡号规格不符合设备要求），4-指纹未关联工号或卡号（工号或卡号字段为空），5-工号不存在，6-指纹数据长度为0，7-读卡器编号错误，8-工号错误
        ("byErrorMsg", BYTE * ERROR_MSG_LEN), # 下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
        ("dwCardReaderNo", DWORD), # 当byCardReaderRecvStatus为5时，表示已存在指纹对应的指纹读卡器编号，可用于下发错误返回。0时表示无错误信息
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
        ("byErrorEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的工号（人员ID）
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_FINGER_PRINT_STATUS_V50 = POINTER(NET_DVR_FINGER_PRINT_STATUS_V50)


class NET_DVR_FINGER_PRINT_INFO_COND_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号（该字段获取时有效，设置时无效）
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 指纹的读卡器是否有效，0-无效，1-有效
        ("dwFingerPrintNum", DWORD), # 设置或获指纹数量，获取时置为0xffffffff表示获取所有指纹信息
        ("byFingerPrintID", BYTE), # 手指编号，有效值范围为1-10   0xff表示该卡所有指纹
        ("byCallbackMode", BYTE), # 设备回调方式，0-设备所有读卡器下完了返回，1-在时间段内下了部分也返回
        ("byRes2", BYTE * 2), # 保留
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
        ("byRes1", BYTE * 128), # 保留
    ]


LPNET_DVR_FINGER_PRINT_INFO_COND_V50 = POINTER(NET_DVR_FINGER_PRINT_INFO_COND_V50)


class NET_DVR_FINGER_PRINT_BYCARD(Structure):
    _fields_ = [
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 指纹的读卡器信息，按数组表示
        ("byFingerPrintID", BYTE * MAX_FINGER_PRINT_NUM), # 需要获取的指纹信息，按数组下标，值表示0-不删除，1-删除该指纹
        ("byRes1", BYTE * 34), # 保留
    ]


LPNET_DVR_FINGER_PRINT_BYCARD = POINTER(NET_DVR_FINGER_PRINT_BYCARD)


class NET_DVR_FINGER_PRINT_BYREADER(Structure):
    _fields_ = [
        ("dwCardReaderNo", DWORD), # 按值表示，指纹读卡器编号
        ("byClearAllCard", BYTE), # 是否删除所有卡的指纹信息，0-按卡号删除指纹信息，1-删除所有卡的指纹信息
        ("byRes1", BYTE * 3), # 保留
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("byRes", BYTE * 548), # 保留
    ]


LPNET_DVR_FINGER_PRINT_BYREADER = POINTER(NET_DVR_FINGER_PRINT_BYREADER)


class NET_DVR_DEL_FINGER_PRINT_MODE(Union):
    _fields_ = [
        ("uLen", BYTE * 588), # 联合体长度
        ("struByCard", NET_DVR_FINGER_PRINT_BYCARD), # 按卡号的方式删除
        ("struByReader", NET_DVR_FINGER_PRINT_BYREADER), # 按读卡器的方式删除
    ]


LPNET_DVR_DEL_FINGER_PRINT_MODE = POINTER(NET_DVR_DEL_FINGER_PRINT_MODE)


class NET_DVR_FINGER_PRINT_INFO_CTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMode", BYTE), # 删除方式，0-按卡号方式删除，1-按读卡器删除
        ("byRes1", BYTE * 3), # 保留
        ("struProcessMode", NET_DVR_DEL_FINGER_PRINT_MODE), # 处理方式
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_FINGER_PRINT_INFO_CTRL = POINTER(NET_DVR_FINGER_PRINT_INFO_CTRL)


class NET_DVR_FINGER_PRINT_BYCARD_V50(Structure):
    _fields_ = [
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("byEnableCardReader", BYTE * MAX_CARD_READER_NUM_512), # 指纹的读卡器信息，按位表示
        ("byFingerPrintID", BYTE * MAX_FINGER_PRINT_NUM), # 需要删除的手指编号，按数组下标，值表示0-不删除，1-删除该指纹
        ("byRes1", BYTE * 2),
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
    ]


LPNET_DVR_FINGER_PRINT_BYCARD_V50 = POINTER(NET_DVR_FINGER_PRINT_BYCARD_V50)


class NET_DVR_FINGER_PRINT_BYREADER_V50(Structure):
    _fields_ = [
        ("dwCardReaderNo", DWORD), # 按值表示，指纹读卡器编号
        ("byClearAllCard", BYTE), # 是否删除所有卡的指纹信息，0-按卡号（人员ID）删除指纹信息，1-删除所有卡（人员ID）的指纹信息
        ("byRes1", BYTE * 3), # 保留
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 指纹关联的卡号
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
        ("byRes", BYTE * 516), # 保留
    ]


LPNET_DVR_FINGER_PRINT_BYREADER_V50 = POINTER(NET_DVR_FINGER_PRINT_BYREADER_V50)


class NET_DVR_DEL_FINGER_PRINT_MODE_V50(Union):
    _fields_ = [
        ("uLen", BYTE * 588), # 联合体长度
        ("struByCard", NET_DVR_FINGER_PRINT_BYCARD_V50), # 按卡号（人员ID）的方式删除
        ("struByReader", NET_DVR_FINGER_PRINT_BYREADER_V50), # 按读卡器的方式删除
    ]


LPNET_DVR_DEL_FINGER_PRINT_MODE_V50 = POINTER(NET_DVR_DEL_FINGER_PRINT_MODE_V50)


class NET_DVR_FINGER_PRINT_INFO_CTRL_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMode", BYTE), # 删除方式，0-按卡号（人员ID）方式删除，1-按读卡器删除
        ("byRes1", BYTE * 3), # 保留
        ("struProcessMode", NET_DVR_DEL_FINGER_PRINT_MODE_V50), # 处理方式
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_FINGER_PRINT_INFO_CTRL_V50 = POINTER(NET_DVR_FINGER_PRINT_INFO_CTRL_V50)


class NET_DVR_FINGER_PRINT_INFO_STATUS_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCardReaderNo", DWORD), # 按值表示，指纹读卡器编号
        ("byStatus", BYTE), # 状态：0-无效，1-处理中，2-删除失败，3-成功
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_FINGER_PRINT_INFO_STATUS_V50 = POINTER(NET_DVR_FINGER_PRINT_INFO_STATUS_V50)


EVENT_ACS_HOST_ANTI_DISMANTLE = 0
EVENT_ACS_OFFLINE_ECENT_NEARLY_FULL = 1
EVENT_ACS_NET_BROKEN = 2
EVENT_ACS_NET_RESUME  = 3
EVENT_ACS_LOW_BATTERY = 4
EVENT_ACS_BATTERY_RESUME = 5
EVENT_ACS_AC_OFF = 6
EVENT_ACS_AC_RESUME = 7
EVENT_ACS_SD_CARD_FULL = 8
EVENT_ACS_LINKAGE_CAPTURE_PIC = 9
EVENT_ACS_IMAGE_QUALITY_LOW = 10
EVENT_ACS_FINGER_PRINT_QUALITY_LOW = 11
EVENT_ACS_BATTERY_ELECTRIC_LOW = 12
EVENT_ACS_BATTERY_ELECTRIC_RESUME = 13
EVENT_ACS_FIRE_IMPORT_SHORT_CIRCUIT = 14
EVENT_ACS_FIRE_IMPORT_BROKEN_CIRCUIT = 15
EVENT_ACS_FIRE_IMPORT_RESUME = 16
EVENT_ACS_MASTER_RS485_LOOPNODE_BROKEN = 17
EVENT_ACS_MASTER_RS485_LOOPNODE_RESUME = 18
EVENT_ACS_LOCAL_CONTROL_OFFLINE = 19
EVENT_ACS_LOCAL_CONTROL_RESUME = 20
EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN = 21
EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME = 22
EVENT_ACS_DISTRACT_CONTROLLER_ONLINE = 23
EVENT_ACS_DISTRACT_CONTROLLER_OFFLINE = 24
EVENT_ACS_FIRE_BUTTON_TRIGGER = 25
EVENT_ACS_FIRE_BUTTON_RESUME = 26
EVENT_ACS_MAINTENANCE_BUTTON_TRIGGER = 27
EVENT_ACS_MAINTENANCE_BUTTON_RESUME = 28
EVENT_ACS_EMERGENCY_BUTTON_TRIGGER = 29
EVENT_ACS_EMERGENCY_BUTTON_RESUME = 30
EVENT_ACS_RES = 31
EVENT_ACS_SUBMARINEBACK_COMM_BREAK = 32
EVENT_ACS_SUBMARINEBACK_COMM_RESUME = 33
EVENT_ACS_REMOTE_ACTUAL_GUARD = 34
EVENT_ACS_REMOTE_ACTUAL_UNGUARD = 35
EVENT_ACS_MOTOR_SENSOR_EXCEPTION = 36
EVENT_ACS_CAN_BUS_EXCEPTION = 37
EVENT_ACS_CAN_BUS_RESUME = 38
EVENT_ACS_GATE_TEMPERATURE_OVERRUN = 39
EVENT_ACS_IR_EMITTER_EXCEPTION = 40
EVENT_ACS_IR_EMITTER_RESUME = 41
EVENT_ACS_LAMP_BOARD_COMM_EXCEPTION = 42
EVENT_ACS_LAMP_BOARD_COMM_RESUME = 43
EVENT_ACS_IR_ADAPTOR_BOARD_COMM_EXCEPTION = 44
EVENT_ACS_IR_ADAPTOR_BOARD_COMM_RESUME = 45
EVENT_ACS_CHANNEL_CONTROLLER_DESMANTLE_ALARM = 46
EVENT_ACS_CHANNEL_CONTROLLER_DESMANTLE_RESUME = 47
EVENT_ACS_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM = 48
EVENT_ACS_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME = 49
EVENT_ACS_STAY_EVENT = 50
EVENT_ACS_LEGAL_EVENT_NEARLY_FULL = 51


EVENT_ACS_ALARMIN_SHORT_CIRCUIT = 0
EVENT_ACS_ALARMIN_BROKEN_CIRCUIT = 1
EVENT_ACS_ALARMIN_EXCEPTION = 2
EVENT_ACS_ALARMIN_RESUME = 3
EVENT_ACS_CASE_SENSOR_ALARM = 4
EVENT_ACS_CASE_SENSOR_RESUME = 5


EVENT_ACS_LEADER_CARD_OPEN_BEGIN = 0
EVENT_ACS_LEADER_CARD_OPEN_END = 1
EVENT_ACS_ALWAYS_OPEN_BEGIN  = 2
EVENT_ACS_ALWAYS_OPEN_END = 3
EVENT_ACS_ALWAYS_CLOSE_BEGIN = 4
EVENT_ACS_ALWAYS_CLOSE_END = 5
EVENT_ACS_LOCK_OPEN = 6
EVENT_ACS_LOCK_CLOSE = 7
EVENT_ACS_DOOR_BUTTON_PRESS = 8
EVENT_ACS_DOOR_BUTTON_RELEASE = 9
EVENT_ACS_DOOR_OPEN_NORMAL = 10
EVENT_ACS_DOOR_CLOSE_NORMAL  = 11
EVENT_ACS_DOOR_OPEN_ABNORMAL = 12
EVENT_ACS_DOOR_OPEN_TIMEOUT = 13
EVENT_ACS_REMOTE_OPEN_DOOR = 14
EVENT_ACS_REMOTE_CLOSE_DOOR = 15
EVENT_ACS_REMOTE_ALWAYS_OPEN = 16
EVENT_ACS_REMOTE_ALWAYS_CLOSE = 17
EVENT_ACS_NOT_BELONG_MULTI_GROUP = 18
EVENT_ACS_INVALID_MULTI_VERIFY_PERIOD = 19
EVENT_ACS_MULTI_VERIFY_SUPER_RIGHT_FAIL = 20
EVENT_ACS_MULTI_VERIFY_REMOTE_RIGHT_FAIL = 21
EVENT_ACS_MULTI_VERIFY_SUCCESS = 22
EVENT_ACS_MULTI_VERIFY_NEED_REMOTE_OPEN = 23
EVENT_ACS_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS = 24
EVENT_ACS_MULTI_VERIFY_REPEAT_VERIFY_FAIL = 25
EVENT_ACS_MULTI_VERIFY_TIMEOUT = 26
EVENT_ACS_REMOTE_CAPTURE_PIC = 27
EVENT_ACS_DOORBELL_RINGING = 28
EVENT_ACS_SECURITY_MODULE_DESMANTLE_ALARM = 29
EVENT_ACS_CALL_CENTER = 30
EVENT_ACS_FIRSTCARD_AUTHORIZE_BEGIN = 31
EVENT_ACS_FIRSTCARD_AUTHORIZE_END = 32
EVENT_ACS_DOORLOCK_INPUT_SHORT_CIRCUIT = 33
EVENT_ACS_DOORLOCK_INPUT_BROKEN_CIRCUIT = 34
EVENT_ACS_DOORLOCK_INPUT_EXCEPTION = 35
EVENT_ACS_DOORCONTACT_INPUT_SHORT_CIRCUIT = 36
EVENT_ACS_DOORCONTACT_INPUT_BROKEN_CIRCUIT = 37
EVENT_ACS_DOORCONTACT_INPUT_EXCEPTION = 38
EVENT_ACS_OPENBUTTON_INPUT_SHORT_CIRCUIT = 39
EVENT_ACS_OPENBUTTON_INPUT_BROKEN_CIRCUIT = 40
EVENT_ACS_OPENBUTTON_INPUT_EXCEPTION = 41
EVENT_ACS_DOORLOCK_OPEN_EXCEPTION = 42
EVENT_ACS_DOORLOCK_OPEN_TIMEOUT = 43
EVENT_ACS_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE = 44
EVENT_ACS_CALL_LADDER_RELAY_BREAK = 45
EVENT_ACS_CALL_LADDER_RELAY_CLOSE = 46
EVENT_ACS_AUTO_KEY_RELAY_BREAK = 47
EVENT_ACS_AUTO_KEY_RELAY_CLOSE = 48
EVENT_ACS_KEY_CONTROL_RELAY_BREAK = 49
EVENT_ACS_KEY_CONTROL_RELAY_CLOSE = 50
EVENT_ACS_REMOTE_VISITOR_CALL_LADDER = 51
EVENT_ACS_REMOTE_HOUSEHOLD_CALL_LADDER = 52
EVENT_ACS_LEGAL_MESSAGE = 53
EVENT_ACS_ILLEGAL_MESSAGE = 54
EVENT_ACS_TRAILING = 55
EVENT_ACS_REVERSE_ACCESS = 56
EVENT_ACS_FORCE_ACCESS = 57
EVENT_ACS_CLIMBING_OVER_GATE = 58
EVENT_ACS_PASSING_TIMEOUT = 59
EVENT_ACS_INTRUSION_ALARM = 60
EVENT_ACS_FREE_GATE_PASS_NOT_AUTH = 61
EVENT_ACS_DROP_ARM_BLOCK = 62
EVENT_ACS_DROP_ARM_BLOCK_RESUME = 63
EVENT_ACS_REMOTE_CONTROL_CLOSE_DOOR = 64
EVENT_ACS_REMOTE_CONTROL_OPEN_DOOR = 65
EVENT_ACS_REMOTE_CONTROL_ALWAYS_OPEN_DOOR = 66


EVENT_ACS_STRESS_ALARM = 0
EVENT_ACS_CARD_READER_DESMANTLE_ALARM = 1
EVENT_ACS_LEGAL_CARD_PASS = 2
EVENT_ACS_CARD_AND_PSW_PASS = 3
EVENT_ACS_CARD_AND_PSW_FAIL = 4
EVENT_ACS_CARD_AND_PSW_TIMEOUT = 5
EVENT_ACS_CARD_MAX_AUTHENTICATE_FAIL = 6
EVENT_ACS_CARD_NO_RIGHT = 7
EVENT_ACS_CARD_INVALID_PERIOD = 8
EVENT_ACS_CARD_OUT_OF_DATE = 9
EVENT_ACS_INVALID_CARD = 10
EVENT_ACS_ANTI_SNEAK_FAIL = 11
EVENT_ACS_INTERLOCK_DOOR_NOT_CLOSE = 12
EVENT_ACS_FINGERPRINT_COMPARE_PASS = 13
EVENT_ACS_FINGERPRINT_COMPARE_FAIL = 14
EVENT_ACS_CARD_FINGERPRINT_VERIFY_PASS = 15
EVENT_ACS_CARD_FINGERPRINT_VERIFY_FAIL = 16
EVENT_ACS_CARD_FINGERPRINT_VERIFY_TIMEOUT = 17
EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_PASS = 18
EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL = 19
EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT = 20
EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_PASS = 21
EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_FAIL = 22
EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_TIMEOUT = 23
EVENT_ACS_FINGERPRINT_INEXISTENCE = 24
EVENT_ACS_FACE_VERIFY_PASS = 25
EVENT_ACS_FACE_VERIFY_FAIL = 26
EVENT_ACS_FACE_AND_FP_VERIFY_PASS = 27
EVENT_ACS_FACE_AND_FP_VERIFY_FAIL = 28
EVENT_ACS_FACE_AND_FP_VERIFY_TIMEOUT = 29
EVENT_ACS_FACE_AND_PW_VERIFY_PASS = 30
EVENT_ACS_FACE_AND_PW_VERIFY_FAIL = 31
EVENT_ACS_FACE_AND_PW_VERIFY_TIMEOUT = 32
EVENT_ACS_FACE_AND_CARD_VERIFY_PASS = 33
EVENT_ACS_FACE_AND_CARD_VERIFY_FAIL = 34
EVENT_ACS_FACE_AND_CARD_VERIFY_TIMEOUT = 35
EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_PASS = 36
EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_FAIL = 37
EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT = 38
EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_PASS = 39
EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_FAIL = 40
EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_TIMEOUT = 41
EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_PASS = 42
EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_FAIL = 43
EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT = 44
EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS = 45
EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL = 46
EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT = 47
EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_PASS = 48
EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_FAIL = 49
EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT = 50
EVENT_ACS_FACE_RECOGNIZE_FAIL = 51
EVENT_ACS_EMPLOYEENO_AND_PW_PASS = 52
EVENT_ACS_EMPLOYEENO_AND_PW_FAIL = 53
EVENT_ACS_EMPLOYEENO_AND_PW_TIMEOUT = 54
EVENT_ACS_HUMAN_DETECT_FAIL = 55
EVENT_ACS_PEOPLE_AND_ID_CARD_COMPARE_PASS = 56
EVENT_ACS_PEOPLE_AND_ID_CARD_COMPARE_FAIL = 57
EVENT_ACS_DOOR_OPEN_OR_DORMANT_FAIL = 58
EVENT_ACS_AUTH_PLAN_DORMANT_FAIL = 59
EVENT_ACS_CARD_ENCRYPT_VERIFY_FAIL = 60
EVENT_ACS_SUBMARINEBACK_REPLY_FAIL = 61
EVENT_ACS_PASSWORD_MISMATCH = 62
EVENT_ACS_EMPLOYEE_NO_NOT_EXIST = 63
EVENT_ACS_COMBINED_VERIFY_PASS = 64
EVENT_ACS_COMBINED_VERIFY_TIMEOUT = 65
EVENT_ACS_VERIFY_MODE_MISMATCH = 66
EVENT_ACS_PSW_ERROR_OVER_TIMES = 67
EVENT_ACS_PSW_VERIFY_PASS = 68
EVENT_ACS_PSW_VERIFY_FAIL = 69
EVENT_ACS_ORCODE_VERIFY_PASS = 70
EVENT_ACS_ORCODE_VERIFY_FAIL = 71
EVENT_ACS_HOUSEHOLDER_AUTHORIZE_PASS = 72
EVENT_ACS_BLUETOOTH_VERIFY_PASS = 73
EVENT_ACS_BLUETOOTH_VERIFY_FAIL = 74
EVENT_ACS_INFORMAL_MIFARE_CARD_VERIFY_FAIL = 75
EVENT_ACS_CPU_CARD_ENCRYPT_VERIFY_FAIL = 76
EVENT_ACS_NFC_DISABLE_VERIFY_FAIL = 77
EVENT_ACS_EM_CARD_RECOGNIZE_NOT_ENABLED = 78
EVENT_ACS_M1_CARD_RECOGNIZE_NOT_ENABLED = 79
EVENT_ACS_CPU_CARD_RECOGNIZE_NOT_ENABLED = 80
EVENT_ACS_ID_CARD_RECOGNIZE_NOT_ENABLED = 81
EVENT_ACS_CARD_SET_SECRET_KEY_FAIL = 82


class NET_DVR_EVENT_LINKAGE_INFO(Structure):
    _fields_ = [
        ("wMainEventType", WORD), # 事件主类型，0-设备事件，1-报警输入事件，2-门事件，3-读卡器事件
        ("wSubEventType", WORD), # 事件次类型
        ("byRes", BYTE * 28),
    ]


LPNET_DVR_EVENT_LINKAGE_INFO = POINTER(NET_DVR_EVENT_LINKAGE_INFO)


class NET_DVR_EVETN_CARD_LINKAGE_UNION(Union):
    _fields_ = [
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("struEventLinkage", NET_DVR_EVENT_LINKAGE_INFO), # 事件联动时参数
        ("byMACAddr", BYTE * MACADDR_LEN), # 物理MAC地址
        ("byEmployeeNo", BYTE * NET_SDK_EMPLOYEE_NO_LEN), # 工号（人员ID）
    ]


LPNET_DVR_EVETN_CARD_LINKAGE_UNION = POINTER(NET_DVR_EVETN_CARD_LINKAGE_UNION)


class NET_DVR_EVENT_CARD_LINKAGE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byProMode", BYTE), # 联动方式，0-事件，1-卡号
        ("byRes1", BYTE * 3),
        ("dwEventSourceID", DWORD), # 事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号当主类型为读卡器事件时，为读卡器ID当为报警输入事件时为防区报警输入ID或事件报警输入ID
        ("uLinkageInfo", NET_DVR_EVETN_CARD_LINKAGE_UNION), # 联动方式参数
        ("byAlarmout", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 关联的报警输出号，按数组表示，为0表示不关联，为1表示关联
        ("byRes2", BYTE * 32), # 保留
        ("byOpenDoor", BYTE * MAX_DOOR_NUM_256), # 按数组表示,是否联动开门，0-不联动，1-联动
        ("byCloseDoor", BYTE * MAX_DOOR_NUM_256), # 按数组表示,是否联动关门，0-不联动，1-联动
        ("byNormalOpen", BYTE * MAX_DOOR_NUM_256), # 按数组表示,是否联动常开，0-不联动，1-联动
        ("byNormalClose", BYTE * MAX_DOOR_NUM_256), # 按数组表示,是否联动常关，0-不联动，1-联动
        ("byMainDevBuzzer", BYTE), # 主机蜂鸣器   0-不联动，1-联动输出
        ("byCapturePic", BYTE), # 是否联动抓拍，0-不联动抓拍，1-联动抓拍
        ("byRecordVideo", BYTE), # 是否联动录像，0-不联动录像，1-联动录像
        ("byRes3", BYTE * 29), # 保留
        ("byReaderBuzzer", BYTE * MAX_CARD_READER_NUM_512), # 联动读卡器蜂鸣器，按数组表示，0-不联动，1-联动
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_EVENT_CARD_LINKAGE_CFG = POINTER(NET_DVR_EVENT_CARD_LINKAGE_CFG)


class NET_DVR_EVENT_CARD_LINKAGE_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byProMode", BYTE), # 联动方式，0-事件，1-卡号, 2-MAC地址
        ("byRes1", BYTE * 3),
        ("dwEventSourceID", DWORD), # 事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号当主类型为读卡器事件时，为读卡器ID当为报警输入事件时为防区报警输入ID或事件报警输入ID。0xffffffff表示联动全部
        ("uLinkageInfo", NET_DVR_EVETN_CARD_LINKAGE_UNION), # 联动方式参数
        ("byAlarmout", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 关联的报警输出号，按位表示，为0表示不关联，为1表示关联
        ("byRes2", BYTE * 32), # 保留
        ("byOpenDoor", BYTE * MAX_DOOR_NUM_256), # 按位表示,是否联动开门，0-不联动，1-联动
        ("byCloseDoor", BYTE * MAX_DOOR_NUM_256), # 按位表示,是否联动关门，0-不联动，1-联动
        ("byNormalOpen", BYTE * MAX_DOOR_NUM_256), # 按位表示,是否联动常开，0-不联动，1-联动
        ("byNormalClose", BYTE * MAX_DOOR_NUM_256), # 按位表示,是否联动常关，0-不联动，1-联动
        ("byMainDevBuzzer", BYTE), # 主机蜂鸣器   0-不联动，1-联动输出
        ("byCapturePic", BYTE), # 是否联动抓拍，0-不联动抓拍，1-联动抓拍
        ("byRecordVideo", BYTE), # 是否联动录像，0-不联动录像，1-联动录像
        ("byRes3", BYTE * 29), # 保留
        ("byReaderBuzzer", BYTE * MAX_CARD_READER_NUM_512), # 联动读卡器蜂鸣器，按位表示，0-不联动，1-联动
        ("byAlarmOutClose", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 关联报警输出关闭，按字节表示，为0表示不关联，为1表示关联
        ("byAlarmInSetup", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 关联防区布防，按字节表示，为0表示不关联，为1表示关联
        ("byAlarmInClose", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 关联防区撤防，按字节表示，为0表示不关联，为1表示关联
        ("byRes", BYTE * 500), # 保留
    ]


LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V50 = POINTER(NET_DVR_EVENT_CARD_LINKAGE_CFG_V50)


class NET_DVR_EVENT_CARD_LINKAGE_CFG_V51(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byProMode", BYTE), # 联动方式，0-事件，1-卡号，2-MAC地址，3-工号（人员ID）
        ("byRes1", BYTE * 3),
        ("dwEventSourceID", DWORD), # 事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号当主类型为读卡器事件时，为读卡器ID当为报警输入事件时为防区报警输入ID或事件报警输入ID。0xffffffff表示联动全部
        ("uLinkageInfo", NET_DVR_EVETN_CARD_LINKAGE_UNION), # 联动方式参数
        ("byAlarmout", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 关联的报警输出号，按位表示，为0表示不关联，为1表示关联
        ("byRes2", BYTE * 32), # 保留
        ("byOpenDoor", BYTE * MAX_DOOR_NUM_256), # 按位表示,是否联动开门，0-不联动，1-联动
        ("byCloseDoor", BYTE * MAX_DOOR_NUM_256), # 按位表示,是否联动关门，0-不联动，1-联动
        ("byNormalOpen", BYTE * MAX_DOOR_NUM_256), # 按位表示,是否联动常开，0-不联动，1-联动
        ("byNormalClose", BYTE * MAX_DOOR_NUM_256), # 按位表示,是否联动常关，0-不联动，1-联动
        ("byMainDevBuzzer", BYTE), # 主机蜂鸣器   0-不联动，1-联动输出
        ("byCapturePic", BYTE), # 是否联动抓拍，0-不联动抓拍，1-联动抓拍
        ("byRecordVideo", BYTE), # 是否联动录像，0-不联动录像，1-联动录像
        ("byMainDevStopBuzzer", BYTE), # 主机停止蜂鸣   0-不联动，1-联动输出
        ("wAudioDisplayID", WORD), # 联动语音播放ID：0-不联动，目前范围1-32
        ("byAudioDisplayMode", BYTE), # 联动语音播放模式：0-关闭，1-单次播放，2-循环播放
        ("byRes3", BYTE * 25), # 保留
        ("byReaderBuzzer", BYTE * MAX_CARD_READER_NUM_512), # 联动读卡器蜂鸣器，按位表示，0-不联动，1-联动
        ("byAlarmOutClose", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 关联报警输出关闭，按字节表示，为0表示不关联，为1表示关联
        ("byAlarmInSetup", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 关联防区布防，按字节表示，为0表示不关联，为1表示关联
        ("byAlarmInClose", BYTE * MAX_ALARMHOST_ALARMIN_NUM), # 关联防区撤防，按字节表示，为0表示不关联，为1表示关联
        ("byReaderStopBuzzer", BYTE * MAX_CARD_READER_NUM_512), # 联动读卡器停止蜂鸣，按字节表示，0-不联动，1-联动
        ("byRes", BYTE * 512), # 保留
    ]


LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V51 = POINTER(NET_DVR_EVENT_CARD_LINKAGE_CFG_V51)


class NET_DVR_EVENT_CARD_LINKAGE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEventID", DWORD), # 事件ID
        ("wLocalControllerID", WORD), # 就地控制器序号[1,64]
        ("byRes", BYTE * 106),
    ]


LPNET_DVR_EVENT_CARD_LINKAGE_COND = POINTER(NET_DVR_EVENT_CARD_LINKAGE_COND)


class NET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileSize", DWORD), # 文件大小，单位：字节（上传音频文件时有效，下载音频文件时无效）
        ("dwAudioID", DWORD), # 音频ID（0xffffffff代表上传/下载全部音频文件，目前设备仅支持全量上传/下载，不支持单个音频ID上传/下载）
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM = POINTER(NET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM)


# 客户标定文件结构体
class NET_DVR_CLIENT_CALIBFILE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileLen", DWORD), # 文件大小
        ("byChannel", BYTE), # 通道号
        ("byRes", BYTE * 23),
    ]


LPNET_DVR_CLIENT_CALIBFILE_PARAM = POINTER(NET_DVR_CLIENT_CALIBFILE_PARAM)


# 3200W矫正表结构体
class NET_DVR_CORRECT_TABLE_3200W_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileLen", DWORD), # 文件大小
        ("byChannel", BYTE), # 通道号
        ("byRes", BYTE * 23),
    ]


LPNET_DVR_CORRECT_TABLE_3200W_PARAM = POINTER(NET_DVR_CORRECT_TABLE_3200W_PARAM)


# 四通道抓图文件结构体
class NET_DVR_FOUR_CAMERAS_PICTURES(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileLen", DWORD), # 文件大小
        ("byChannel", BYTE), # 通道号
        ("byRes", BYTE * 23),
    ]


LPNET_DVR_FOUR_CAMERAS_PICTURES = POINTER(NET_DVR_FOUR_CAMERAS_PICTURES)


class NET_DVR_ANTI_SNEAK_HOST_INFO(Structure):
    _fields_ = [
        ("struDVRIP", NET_DVR_ADDRESS), # 主机IP地址
        ("byIsStartAddr", BYTE), # 是否为开始地址，0-否，1-是
        ("byHostNo", BYTE), # 主机编号，1-8，主要用于读卡器顺序设置
        ("byRes", BYTE * 34), # 保留
    ]


LPNET_DVR_ANTI_SNEAK_HOST_INFO = POINTER(NET_DVR_ANTI_SNEAK_HOST_INFO)


class NET_DVR_ANTI_SNEAK_HOST_READER_INFO(Structure):
    _fields_ = [
        ("byAntiSnealHostNo", BYTE), # 反潜回主机编号
        ("byRes", BYTE * 5), # 保留
        ("wFollowUpCardReader", WORD), # 该反潜回主机下的读卡器编号
    ]


LPNET_DVR_ANTI_SNEAK_HOST_READER_INFO = POINTER(NET_DVR_ANTI_SNEAK_HOST_READER_INFO)


class NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否加入反潜回路径，1-加入，0-不加入
        ("byRes1", BYTE * 3),
        ("struSneakHost", NET_DVR_ANTI_SNEAK_HOST_INFO * MAX_SNEAK_PATH_NODE), # 后续主机地址信息
        ("struStartReader", NET_DVR_ANTI_SNEAK_HOST_READER_INFO), # 起始读卡器编号 当该内容全为0时，表示不关注从哪个读卡器开始
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG = POINTER(NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG)


class NET_DVR_ANTI_SNEAK_READER_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 是否加入反潜回路径，1-加入，0-不加入
        ("byAntiSnealHostNo", BYTE), # 反潜回主机编号
        ("wReaderID", WORD), # 读卡器ID
        ("struSneakReaderInfo", NET_DVR_ANTI_SNEAK_HOST_READER_INFO * MAX_SNEAK_PATH_NODE), # 后续主机读卡器编号
        ("byRes2", BYTE * 8),
    ]


LPNET_DVR_ANTI_SNEAK_READER_CFG = POINTER(NET_DVR_ANTI_SNEAK_READER_CFG)


class NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struReaderCfg", NET_DVR_ANTI_SNEAK_READER_CFG * MAX_READER_ROUTE_NUM), # 读卡器信息
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG = POINTER(NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG)


class NET_DVR_ACS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byRS485Backup", BYTE), # 是否启用下行RS485通信备份功能，0-不启用，1-启用
        ("byShowCapPic", BYTE), # 是否显示抓拍图片， 0-不显示，1-显示
        ("byShowCardNo", BYTE), # 是否显示卡号，0-不显示，1-显示
        ("byShowUserInfo", BYTE), # 是否显示用户信息，0-不显示，1-显示
        ("byOverlayUserInfo", BYTE), # 是否叠加用户信息，0-不叠加，1-叠加
        ("byVoicePrompt", BYTE), # 是否启用语音提示，0-不启用，1-启用
        ("byUploadCapPic", BYTE), # 联动抓拍是否上传图片，0-不上传，1-上传
        ("bySaveCapPic", BYTE), # 是否保存抓拍图片，0-不保存，1-保存
        ("byInputCardNo", BYTE), # 是否是否允许按键输入卡号，0-不允许，1-允许
        ("byEnableWifiDetect", BYTE), # 是否启动wifi探针，0-不启动，1-启动
        ("byEnable3G4G", BYTE), # 3G4G使能，0-不使能，1-使能
        ("byProtocol", BYTE), # 读卡器通信协议类型，0-私有协议（默认），1-OSDP协议
        ("byRes", BYTE * 500),
    ]


LPNET_DVR_ACS_CFG = POINTER(NET_DVR_ACS_CFG)


class NET_DVR_PLATFORM_VERIFY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDoorNo", DWORD), # 门编号
        ("byResultType", BYTE), # 认证结果类型，0：非法，1：合法
        ("byRes1", BYTE * 3),
        ("byScreenDisplay", BYTE * MAX_SCREEN_DISPLAY_LEN), # LED屏幕显示，用于显示认证相关信息
        ("byRes", BYTE * 300), #  保留字节
    ]


LPNET_DVR_PLATFORM_VERIFY_CFG = POINTER(NET_DVR_PLATFORM_VERIFY_CFG)


class NET_DVR_PERSON_STATISTICS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableStatistics", BYTE), # 是否开启人数统计，0：不开启；1：开启；
        ("byEnableOfflineStatistics", BYTE), # 是否开启离线人数统计，0：不开启；1：开启；
        ("byCountSignalStatisticalStandard", BYTE), # 计数信号统计标准，0：无效；1：红外检测通行统计；2：认证数量统计
        ("byRes", BYTE * 605),
    ]


LPNET_DVR_PERSON_STATISTICS_CFG = POINTER(NET_DVR_PERSON_STATISTICS_CFG)


class NET_DVR_ACS_SCREEN_DISPLAY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFontSize", DWORD), # 字体大小，[1,10]；
        ("dwRowSpacing", DWORD), # 行间距，单位：像素点；
        ("dwColumnSpacing", DWORD), # 列间距，单位：像素点；
        ("dwFirstRowPosition", DWORD), # 起始行位置在屏幕哪一个分块，0：0、 1：1/8:、 2：2/8、 3：3/8、 4：4/8、 5：5/8、 6：6/8:、 7：7/8；
        ("byDegree", BYTE), # 字符显示方向角度，0-0度（正常），1-90度（侧着）；
        ("byScreenType", BYTE), # 屏幕类型，0-DC48270RS043_01T，1-DC80480B070_03T；
        ("byRes", BYTE * 306),
    ]


LPNET_DVR_ACS_SCREEN_DISPLAY_CFG = POINTER(NET_DVR_ACS_SCREEN_DISPLAY_CFG)


class NET_DVR_GATE_TIME_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwHoldOnALarmTime", DWORD), # 延续报警器蜂鸣时间，单位ms
        ("dwHoldOnGateOpenTime", DWORD), # 闸门收到关闭命令前继续保持打开状态时间，单位ms
        ("dwPostponeIntrusionAlarmTime", DWORD), # 推迟触发闯入欺骗行为报警时间，单位ms
        ("dwNoLaneAccessTimeLimitTime", DWORD), # 通道收到有效通行认证信号，但无人通行超时报警时间，单位s
        ("dwSafetyZoneStayTime", DWORD), # 通道收到有效通行认证信号，乘客到达安全区后滞留通道超时报警时间，单位s
        ("byIRTriggerTimeoutTime", BYTE), # 红外触发超时时间，单位：秒（0-255）
        ("byRes", BYTE * 299),
    ]


LPNET_DVR_GATE_TIME_CFG = POINTER(NET_DVR_GATE_TIME_CFG)


class NET_DVR_CARD_PASSWD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("byCardPassword", BYTE * CARD_PASSWORD_LEN), # 卡密码
        ("dwErrorCode", DWORD), # 获取卡密码开门使能配置返回的错误码，成功为0，失败返回错误码
        ("byCardValid", BYTE), # 卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
        ("byRes2", BYTE * 23),
    ]


LPNET_DVR_CARD_PASSWD_CFG = POINTER(NET_DVR_CARD_PASSWD_CFG)


class NET_DVR_CARD_PASSWD_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("dwErrorCode", DWORD), # 发送卡密码开门使能配置返回的错误码，成功为0，失败返回错误码
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_CARD_PASSWD_STATUS = POINTER(NET_DVR_CARD_PASSWD_STATUS)


# 条件结构
class NET_DVR_VEHICLE_RECOG_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_VEHICLE_RECOG_COND = POINTER(NET_DVR_VEHICLE_RECOG_COND)


# 参数结构
class NET_DVR_VEHICLE_RECOG_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 数据流水号 和（上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段sDataIndex对应）
        ("sDataIndex", CHAR * DATA_INDEX_LEN),
        # 任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应)
        ("wTaskNo", WORD),
        ("byRes1", BYTE * 2),
        ("struPlateRect", NET_VCA_RECT), # 车牌位置
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        #
        # 车辆图片二次识别操作
        # bit0-车牌识别：0-不启用识别，1-启用识别；
        # bit1-车辆类型识别：0-不启用识别，1-启用识别；
        # bit2-车身颜色识别：0-不启用识别，1-启用识别；
        # bit3-车辆品牌识别：0-不启用识别，1-启用识别；
        # bit4-遮挡板识别(主驾驶)：0-不启用识别，1-启用识别；
        # bit5-安全带识别(主驾驶)：0-不启用识别，1-启用识别；
        # bit6-遮挡板识别(副驾驶)：0-不启用识别，1-启用识别；
        # bit7-安全带识别(副驾驶)：0-不启用识别，1-启用识别；
        # bit8-车辆图片叠加使能：0-不启用识别，1-启用识别；
        # bit9-上传车辆图片使能(通过SDK)：0-不启用识别，1-启用识别；
        # bit10-上传车辆图片使能(通过URL)：0-不启用识别，1-启用识别；
        # bit11-黄标车：0-不启用识别，1-启用识别；
        # bit12-打手机：0-不启用识别，1-启用识别；
        # bit13-挂件：0-不启用识别，1-启用识别；
        # bit14-危险品车: 0-不启用识别，1-启用识别；
        # bit15-车辆天窗站人检测: 0-不启用识别，1-启用识别；
        #
        ("dwRecogOperate", DWORD),
        #
        # 车辆图片数据上传
        # bit0-车牌图片：0-不上传，1-上传；
        # bit1-车辆图片：0-不上传，1-上传；
        # bit2-人脸子图(主驾驶)：0-不上传，1-上传；
        # bit3-人脸子图(副驾驶)：0-不上传，1-上传；
        # bit4-安全带子图(主驾驶)：0-不上传，1-上传；
        # bit5-安全带子图(副驾驶)：0-不上传，1-上传；
        #
        ("dwDataUploadType", DWORD),
        ("dwPostID", DWORD), # 卡口ID。
        ("struPostTime", NET_DVR_TIME_V30), # 过车时间
        ("dwJsonLen", DWORD), # Json透传数据长度
        ("*pJsonBuffer", BYTE), # Json数据指针,参考4.2.4Json数据格式
        ("byRes", BYTE * 107),
        ("byPicDataType", BYTE), # 图片数据类型，0-图片数据，1-URL
        # 图片数据
        # 当byPicDataType == 0的时候，该字段内的数据无效，图片数据在结构体后面
        # 当byPicDataType == 1的时候，是指定的图片的URL信息
        ("sPicDataPath", CHAR * 256),
    ]


LPNET_DVR_VEHICLE_RECOG_CFG = POINTER(NET_DVR_VEHICLE_RECOG_CFG)


class NET_DVR_VEHICLERECOG_TASK_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 设备数据流水号,每次提交任务，设备会自行生成唯一的流水号返回给上层。
        ("sDevDataIndex", CHAR * MAX_DEV_DATAINDEX_LEN),
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_VEHICLERECOG_TASK_RESULT = POINTER(NET_DVR_VEHICLERECOG_TASK_RESULT)


# 条件结构
class NET_DVR_VEHICLE_RECOG_TASK_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("sDataIndex", CHAR * DATA_INDEX_LEN), # 数据流水号    全0的时候表示获取全部
        ("wTaskNo", WORD), # 任务处理号         值为0的时候表示全部任务
        #
        # 任务状态
        # bit0-完成状态的任务：0-不查询，1-查询；
        # bit1-执行中的任务：0-不查询，1-查询；
        # bit2-等待中的任务：0-不查询，1-查询；
        #
        ("byTask", BYTE),
        ("byRes1", BYTE),
        # 设备数据流水号查询,每次提交任务，设备会自行生成唯一的流水号。
        ("sDevDataIndex", CHAR * MAX_DEV_DATAINDEX_LEN),
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_VEHICLE_RECOG_TASK_COND = POINTER(NET_DVR_VEHICLE_RECOG_TASK_COND)


# 参数结构
class NET_DVR_VEHICLE_RECOG_TASK_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("sDataIndex", CHAR * DATA_INDEX_LEN), # 数据流水号
        ("wTaskNo", WORD), # 任务处理号
        ("wTaskProgress", WORD), # 任务执行进度（实际进度*1000）
        ("byTaskState", BYTE), # 任务状态，0-等待中，1-执行中，2-完成
        ("byRes1", BYTE * 3),
        #
        # 车辆图片二次识别操作
        # bit0-车牌识别：0-不启用识别，1-启用识别；
        # bit1-车辆类型识别：0-不启用识别，1-启用识别；
        # bit2-车身颜色识别：0-不启用识别，1-启用识别；
        # bit3-车辆品牌识别：0-不启用识别，1-启用识别；
        # bit4-遮挡板识别(主驾驶)：0-不启用识别，1-启用识别；
        # bit5-安全带识别(主驾驶)：0-不启用识别，1-启用识别；
        # bit6-遮挡板识别(副驾驶)：0-不启用识别，1-启用识别；
        # bit7-安全带识别(副驾驶)：0-不启用识别，1-启用识别；
        # bit8-车辆图片叠加使能：0-不启用识别，1-启用识别；
        # bit9-上传车辆图片使能(通过SDK)：0-不启用识别，1-启用识别；
        # bit10-上传车辆图片使能(通过URL)：0-不启用识别，1-启用识别；
        # bit11-黄标车：0-不启用识别，1-启用识别；
        # bit12-打手机：0-不启用识别，1-启用识别；
        # bit13-挂件：0-不启用识别，1-启用识别；
        # bit14-危险品车: 0-不启用识别，1-启用识别；
        # bit15-车辆天窗站人检测: 0-不启用识别，1-启用识别；
        #
        ("dwRecogOperate", DWORD),
        ("dwPostID", DWORD), # 卡口ID。
        ("struPostTime", NET_DVR_TIME_V30), # 过车时间
        ("dwJsonLen", DWORD), # Json透传数据长度（预留，JSON内容暂不实现）
        ("*pJsonBuffer", BYTE), # Json数据指针, （预留，JSON内容暂不实现）
        ("byRes", BYTE * 104),
    ]


LPNET_DVR_VEHICLE_RECOG_TASK_INFO = POINTER(NET_DVR_VEHICLE_RECOG_TASK_INFO)


class NET_DVR_VEHICLE_RECOG_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构
        # 数据流水号 和（任务提交NET_DVR_VEHICLE_RECOG_CFG中的字段sDataIndex对应）
        ("sDataIndex", CHAR * DATA_INDEX_LEN),
        # 任务处理号 和 (任务提交NET_DVR_VEHICLE_RECOG_CFG中的字段wTaskNo对应)
        ("wTaskNo", WORD),
        ("byRes", BYTE * 2),
        ("struPlateRect", NET_VCA_RECT), # 车牌位置
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("byVehicleType", BYTE), # 车辆类型，参考VTR_RESULT
        ("byColorDepth", BYTE), # 车身颜色深浅，参考 0-深色，1-浅色
        ("byColor", BYTE), # 车身颜色,  参考VCR_CLR_CLASS
        ("byVehicleLogoRecog", BYTE), # 车辆主品牌
        ("byVehicleSubLogoRecog", BYTE), # 车辆子品牌
        ("byPilotSafebelt", BYTE), # 0-表示未知,1-不系安全带,2-系安全带
        ("byCopilotSafebelt", BYTE), # 0-表示未知,1-不系安全带,2-系安全带
        ("byPilotSunVisor", BYTE), # 0-表示未知,1-不打开遮阳板,2-打开遮阳板
        ("byCopilotSunVisor", BYTE), # 0-表示未知, 1-不打开遮阳板,2-打开遮阳板
        ("byVehicleModel", BYTE), #  参考文档  车辆子品牌年款
        ("wVehicleLogoRecog", WORD), # 车辆主品牌，参考"车辆主品牌.xlsx"
        ("byRes1", BYTE * 251),
        # 0-数据直接上传; 1-云存储服务器URL原先的图片数据变成URL数据，图片长度变成URL长度
        ("byDataType", BYTE),
        #
        # 上传图片类型信息:
        # bit0-车辆图：0-不上传，1-上传；
        # bit1-车牌图：0-不上传，1-上传；
        # bit2-人脸子图(主驾驶)：0-不上传，1-上传；
        # bit3-人脸子图(副驾驶)：0-不上传，1-上传；
        # bit4-安全带识别(主驾驶)：0-不上传，1-上传；
        # bit5-安全带识别(副驾驶)：0-不上传，1-上传；
        #
        ("dwPicType", DWORD), # 0:无图片信息: 车辆图:车牌图
        ("*pVehicleBuffer", BYTE), # 车辆图片数据指针
        ("dwVehicleBufferLen", DWORD), #  车辆图片数据长度
        ("*pPlateBuffer", BYTE), # 车牌图片数据指针
        ("dwPlateBufferLen", DWORD), #  车牌图片数据长度
        ("*pPilotFaceBuffer", BYTE), # 人脸子图(主驾驶)图片数据指针
        ("dwPilotFaceBufferLen", DWORD), #  人脸子图(主驾驶)图片数据长度
        ("*pCopilotFaceBuffer", BYTE), # 人脸子图(副驾驶)图片数据指针
        ("dwCopilotFaceBufferLen", DWORD), #  人脸子图(副驾驶)图片数据长度
        ("*pPilotSafebeltBuffer", BYTE), # 安全带识别(主驾驶)图片数据指针
        ("dwPilotSafebeltBufferLen", DWORD), #  安全带识别(主驾驶)图片数据长度
        ("*pCopilotSafebeltBuffer", BYTE), #  安全带识别(副驾驶)图片数据指针
        ("dwCopilotSafebeltBufferLen", DWORD), #  安全带识别(副驾驶)图片数据长度
        ("struVehicleRect", NET_VCA_RECT), # 车身矩形坐标
        ("struPilotRect", NET_VCA_RECT), # 主驾驶矩形坐标
        ("struCopilotRect", NET_VCA_RECT), # 副驾驶矩形坐标
        ("*pJsonBuffer", BYTE), # Json数据指针,参考JSON数据格式
        ("dwJsonBufferLen", DWORD), #  Json数据长度
        ("dwPostID", DWORD), # 卡口ID
        ("struPostTime", NET_DVR_TIME_V30), # 过车时间
        ("Res2", BYTE * 56),
    ]


LPNET_DVR_VEHICLE_RECOG_RESULT = POINTER(NET_DVR_VEHICLE_RECOG_RESULT)


MAX_ZONE_LINKAGE_CHAN_NUM = 4 #  防区关联最大通道数


class NET_DVR_ZONE_CHANNEL_LINKAGE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struLinkChannels", NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG * MAX_ZONE_LINKAGE_CHAN_NUM), #  每个防区可以关联四个视频通道
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_ZONE_CHANNEL_LINKAGE_CFG = POINTER(NET_DVR_ZONE_CHANNEL_LINKAGE_CFG)


class NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG(Structure):
    _fields_ = [
        ("byDevSerialNo", BYTE * SERIALNO_LEN), # 设备序列号
        ("dwChannel", DWORD), # 联动通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SINGLE_ASSOCIATED_CHAN_CFG = POINTER(NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG)


class NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG(Structure):
    _fields_ = [
        ("wZoneNo", WORD),
        ("byRes1", BYTE * 2),
        ("struSingleChanCfg", NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG * MAX_ZONE_LINKAGE_CHAN_NUM),
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG = POINTER(NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG)


class NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAssociatedChanCfg", NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG * MAX_MAX_ALARMIN_NUM),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST = POINTER(NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST)


class NET_DVR_LCD_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwScreenID", DWORD), # 屏幕索引号
        ("byOnOffLine", BYTE), # 屏幕是否在线，0-离线，1-在线，当屏幕离线时，本结构后续参数无效
        ("byTempState", BYTE), # 板卡温度状态，0-正常，1-异常
        ("byFanState", BYTE), # 风扇状态，0-关，1-开
        ("byFanException", BYTE), # 风扇异常状态，0-不支持 1-正常，2-异常
        ("byTemperature", BYTE), # 屏幕板卡温度，单位：摄氏度
        ("byRes", BYTE * 27),
    ]


LPNET_DVR_LCD_ALARM = POINTER(NET_DVR_LCD_ALARM)


# 传感器上传信息
class NET_DVR_SENSOR_INFO_UPLOAD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTime", NET_DVR_TIME_V30),
        ("szSensorName", CHAR * MAX_SENSORNAME_LEN), # 传感器名称
        ("szSensorChan", CHAR * MAX_SENSORCHAN_LEN), # 传感器通道
        ("byReboot", BYTE), # 之前是否重启过（一般是重启的后的第一条数据带有这个标志）0-表示没有重启，1-有过重启
        ("byPowerSupply", BYTE), # 是否正常供电 0-不在供电，1-正在供电
        ("byStatusType", BYTE), # 设备状态:0:正常、1：异常、2、报警
        ("bySensorType", BYTE), # 参考传感器枚举类型SENSOR_TYPE
        ("fVoltageValue", float), # 电压值； 精确到0.001
        ("fCurrentValue", float), # 电流值；精确到0.001
        ("fActualValue", float), # 模拟信号转换后的数值；精确到0.001
        ("szDescription", CHAR * MAX_DESCRIPTION_LEN), # 描述信息当设备状态（byStatusType）为非0时生效。
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_SENSOR_INFO_UPLOAD = POINTER(NET_DVR_SENSOR_INFO_UPLOAD)


# 抓拍图片上传
class NET_DVR_CAPTURE_UPLOAD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTime", NET_DVR_TIME_V30),
        ("dwChannel", DWORD), # 通道号
        ("szDevName", CHAR * MAX_DEVNAME_LEN_EX),
        ("dwPicLen", DWORD), # 图片长度
        ("*pBuffer", BYTE), # 图片数据指针
        ("byRes", BYTE * 124),
    ]


LPNET_DVR_CAPTURE_UPLOAD = POINTER(NET_DVR_CAPTURE_UPLOAD)


# 全景联动到位上传
class NET_DVR_PANORAMIC_LINKAGE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byType", BYTE), # 图片类型，0-无意义，1-全景联动到位图片
        ("byRes1", BYTE * 3),
        ("byMACAddr", BYTE * MACADDR_LEN), # mac地址
        ("byRes2", BYTE * 2),
        ("struDevIP", NET_DVR_IPADDR), # 设备IP地址
        ("dwPicLen", DWORD), # 全景联动到位抓拍图片长度
        ("*pPicBuff", CHAR), # 全景联动到位抓拍图片指针
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PANORAMIC_LINKAGE = POINTER(NET_DVR_PANORAMIC_LINKAGE)


MAX_MASK_AREA_NUM = 8 # 马赛克区域个数
class NET_DVR_AREA_MASK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用马赛克   0-否，1-是
        ("byMaskThick", BYTE), # 马赛克厚度 0-薄码，1-中码，2-厚码，薄码的区块大小为8*8，中码16*16，厚码32*32。默认为中码
        ("byAutoMask", BYTE), # 是否启用自动马赛克   0-否，1-是
        ("byRes1", BYTE),
        ("struRegion", NET_VCA_RECT * MAX_MASK_AREA_NUM), # 马赛克区域范围
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_AREA_MASK_CFG = POINTER(NET_DVR_AREA_MASK_CFG)


class NET_DVR_AUDIO_DIACRITICAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用变音 0-不启用，1-启用
        ("byBassValue", CHAR), # 高低音值，范围为-12-12 值越大声音越细，反之越小，0-表示不变音
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_AUDIO_DIACRITICAL_CFG = POINTER(NET_DVR_AUDIO_DIACRITICAL_CFG)


class NET_DVR_RESOLUTION_SWITCH(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byResolutionType", BYTE), # 0-all,1-20:9,2-20:6,3-原始码流模式
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_RESOLUTION_SWITCH = POINTER(NET_DVR_RESOLUTION_SWITCH)


class NET_DVR_WIFI_DHCP_ADDR_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartAddr", NET_DVR_IPADDR), # 开始IP地址
        ("struEndAddr", NET_DVR_IPADDR), # 结束IP地址
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_WIFI_DHCP_ADDR_CFG = POINTER(NET_DVR_WIFI_DHCP_ADDR_CFG)


class NET_DVR_WIFI_CLIENT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAddress", NET_DVR_IPADDR), # IP地址
        ("byMACAddr", BYTE),
        ("wConnSpeed", WORD), # 连接速度 单位KB
        ("byRSSIValue", BYTE), # 接收到的信号强度，取值为负值，传输时不带赋值，范围为0~-110dbm,值越大，代表信号越强
        ("byRes1", BYTE), # 保留
        ("wBandwidth", WORD), # 网络带宽  单位KB
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_WIFI_CLIENT_INFO = POINTER(NET_DVR_WIFI_CLIENT_INFO)


class NET_DVR_MULTISTREAM_RELATION_CHAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD), # 关联的编码通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_MULTISTREAM_RELATION_CHAN_CFG = POINTER(NET_DVR_MULTISTREAM_RELATION_CHAN_CFG)


class NET_DVR_RING_PORT_PROPERTY(Structure):
    _fields_ = [
        ("byPort", BYTE), # 端口
        ("byMasterSlaveProperty", BYTE), # 端口主从属性  1-主  2-从
        ("byPortEthernetType", BYTE), # 端口类型，1-百兆端口，2-千兆端口
        ("byRes", BYTE * 9),
    ]


LPNET_DVR_RING_PORT_PROPERTY = POINTER(NET_DVR_RING_PORT_PROPERTY)


class NET_DVR_NS_RING_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用， 0-不启用， !0-启用
        ("byProtoType", BYTE), # 协议类型， 1-光端机组网协议(私有)，2-综合平台组网协议（私有），3-G8032协议（公有）
        ("byBandWidth", BYTE), # 环网带宽类型，1-百兆，2-千兆
        ("byRes1", BYTE), # 保留字段
        ("struRingPort", NET_DVR_RING_PORT_PROPERTY * PER_RING_PORT_NUM), # 环网端口
        ("byRes2", BYTE * 60), # 保留字段
    ]


LPNET_DVR_NS_RING_CFG = POINTER(NET_DVR_NS_RING_CFG)


# 火点检测报警
class NET_DVR_FIREDETECTION_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("wPanPos", WORD),
        ("wTiltPos", WORD),
        ("wZoomPos", WORD),
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("byRes1", BYTE),
        ("dwPicDataLen", DWORD), # 报警抓拍图片长度
        ("*pBuffer", BYTE), # 数据指针
        ("struRect", NET_VCA_RECT), # 火点框
        ("struPoint", NET_VCA_POINT), # 火点框内最高温度点坐标
        ("wFireMaxTemperature", WORD), # 火点最高温度[300℃~4000℃]
        ("wTargetDistance", WORD), # 目标距离[100m ~ 10000m]
        ("byStrategyType", BYTE), # 策略类型；0~任意报警，1~协同报警，2~多系统报警，3~指定火点报警，4~指定烟雾报警
        ("byAlarmSubType", BYTE), # 报警子类型。0~火点检测报警，1~烟雾检测报警，2~烟火报警
        # 是否启用PTZ坐标扩展，
        # 0~不启用，PTZ坐标值以wPanPos、wTiltPos、wZoomPos为准。
        # 1~启用，PTZ坐标值以struPtzPosEx为准。但是新老PTZ都需返回。struPtzPosEx的值需转化为wPanPos、wTiltPos、wZoomPos值。
        #
        ("byPTZPosExEnable", BYTE),
        ("byRes2", BYTE),
        ("struPtzPosEx", NET_PTZ_INFO), #  ptz坐标扩展(支持高精度PTZ值，精确到小数点后三位)
        ("dwVisiblePicLen", DWORD), # 可见光图片长度
        ("*pVisiblePicBuf", BYTE), # 可见光图片数据指针
        # pSmokeBuf参数当byAlarmSubType报警子类型为1（烟雾检测报警）、2（烟火报警）时生效。
        ("*pSmokeBuf", BYTE), # 烟雾检测报警数据指针，指向一个NET_DVR_SMOKEDETECTION_ALARM结构体
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byRes3", BYTE),
        ("byFireScanWaitMode", BYTE), # 火点扫描等待模式 0-自动   1-手动
        ("dwVisibleChannel", DWORD), # 可见光通道通道号
        ("byTimeDiffFlag", BYTE), # 时差字段是否有效  0-时差无效， 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
        ("byRes", BYTE * 49),
    ]


LPNET_DVR_FIREDETECTION_ALARM = POINTER(NET_DVR_FIREDETECTION_ALARM)


# 火点检测配置
class NET_DVR_SMOKEDETECTION_CFG(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 使能
        ("bySensitivity", BYTE), # 检测灵敏度: 1~100默认50
        ("byPatrolSensitivity", BYTE), # 巡航检测灵敏度: 1~100默认50
        ("byDoubleCheckSensitivity", BYTE), # 二次过滤灵敏度: 1~100默认50
        ("byRes", BYTE * 56),
    ]


LPNET_DVR_SMOKEDETECTION_CFG = POINTER(NET_DVR_SMOKEDETECTION_CFG)


class NET_DVR_ALARMSTRATEGY_PARAM(Structure):
    _fields_ = [
        ("byStrategyType", BYTE), # 策略类型；0~任意报警，1~协同报警，2~多系统报警, 3~指定火点报警，4~指定烟雾报警
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_ALARMSTRATEGY_PARAM = POINTER(NET_DVR_ALARMSTRATEGY_PARAM)


class NET_DVR_FIREDETECTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("bySensitivity", BYTE), # 检测灵敏度: 1~100默认5s
        ("byFireComfirmTime", BYTE), # 发现火点等待时间: 0-120秒 默认5s
        ("byFireRegionOverlay", BYTE), # 码流叠加火点框: 0- 否，1- 是
        ("byDetectionMode", BYTE), #  火点检测模式：0~二次判别，1~单帧检测。
        ("byFireFocusMode", BYTE), # 火点聚焦模式：0~自动模式,1~ 巡航模式。
        ("byFireZoomMode", BYTE), # 火点光学变倍模式：0~为自动模式，1~为手动模式。
        ("byFirezoomLevel", BYTE), # 火点光学变倍倍率，1~100。当光学变倍模式为手动模式时生效
        ("bySmokeFireEnabled", BYTE), # 烟火检测总使能：0—不启用，1-启用
        #
        # 火点手动等待使能，为1时代表开启。开启后，火点等待时间参数byFireComfirmTime无效。
        # 开启后，当设备发现火点时，云台一直停留在发现火点位置，可通过继续火点扫描命令解除该等待模式，继续火点扫描。
        # 当火点手动等待使能为0时，设备为自动等待模式，该模式下可根据byFireComfirmTime字段所配置的等待时间进行火点等待，超过该等待时间后设备自动进行火点扫描。
        #
        ("byFireManualWaitEnabled", BYTE), #  火点手动等待使能，0~为自动等待模式，1~手动等待模式
        ("byCancelRepeatedAlarmEnabled", BYTE), #  取消重复报警使能 0-关闭 1-开启
        ("byApplicationSceneMode", BYTE), # 应用场景模式：0-保留，1-森林防火, 2-秸秆燃烧,3-城市制高点, 4-室内或周界
        ("dwInstallationHeight", DWORD), #  安装高度
        ("byFireSourceDetection", BYTE), #  火点搜索模式 0-动态火点 1-吸烟模式
        ("bySmokeAuxiliaryDetectionEnabled", BYTE), #  烟雾辅助判断启用使能,检测模式是二次判别时生效 0-否 1-是
        ("byverificationSensitivity", BYTE), # 二次确认灵敏度，范围1~100s，默认50s
        ("byFireAlgorithmMode", BYTE), # 火点算法模式，0：无效，1：模式识别-patternRecognition,:2：机器学习-machineLearning
        ("byAgriculturalMachineryFilterEnabled", BYTE), # 农机过滤模块使能，0：不启用，1：启用
        ("byWaterReflectionEnabled", BYTE), # 水面阳光反射模块使能, 0：不启用，1：启用
        ("byPatrolSensitivity", BYTE), # 巡航检测灵敏度 （针对火点检测）, 范围1~100s，默认50s
        ("byRes", BYTE * 33),
        ("struAlarmStrategy", NET_DVR_ALARMSTRATEGY_PARAM), # 报警策略
        ("struSmokeCfg", NET_DVR_SMOKEDETECTION_CFG), # 烟雾检测配置
    ]


LPNET_DVR_FIREDETECTION_CFG = POINTER(NET_DVR_FIREDETECTION_CFG)


class NET_DVR_THERMALPOWER_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byPowerSwitch", BYTE), # 开关使能，1为开启，0为关闭
        ("byRes", BYTE * 123),
    ]


LPNET_DVR_THERMALPOWER_PARAM = POINTER(NET_DVR_THERMALPOWER_PARAM)


class NET_DVR_PTZABSOLUTEEX_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struPTZCtrl", NET_PTZ_INFO), # 设备PTZF信息
        ("dwFocalLen", DWORD), # 焦距范围：0-100000MM
        ("fHorizontalSpeed", float), # 水平转动速度：0.01-1000.00度/S
        ("fVerticalSpeed", float), # 垂直转动速度：0.01-1000.00度/S
        # 镜头变倍配置类型；absoluteZoom:通过变倍参数进行配置，选择为该类型时struPTZCtrl中的fZoom参数生效。focalLen:通过焦距参数进行配置，选择为该类型时，dwFocalLen参数生效。
        ("byZoomType", BYTE), #  镜头变倍配置类型0~ absoluteZoom，1~ focalLen
        ("byRes", BYTE * 123),
    ]


LPNET_DVR_PTZABSOLUTEEX_CFG = POINTER(NET_DVR_PTZABSOLUTEEX_CFG)


MAX_PLAYLIST_NUM = 50 # 最大播放列表数目
MAX_PLAYPLAN_NUM = 50 # 最大播放计划数目
MAX_LEN_256 = 256
MAX_GROUP_RECORD_NUM = 10 # 最大记录个数
class NET_DVR_AREA_MONITOR_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwAreaID", DWORD), # 区域ID
        ("dwMonitorID", DWORD), # 当前开始获取的监控点编号，从1开始
        ("byIsNeedGroup", BYTE), # 是否查询关联分组信息
        ("byRes", BYTE),
    ]


LPNET_DVR_AREA_MONITOR_COND = POINTER(NET_DVR_AREA_MONITOR_COND)


class NET_DVR_DEL_MONITOR_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDelType", BYTE), # 删除类型，0-删除指定区域的所有监控点，1-删除指定区域的指定监控点
        ("dwAreaID", DWORD), # 区域ID
        ("dwMonitorID", DWORD), # 监控点ID（当byDelType为0时无效，当byDelType为1时有效），从1开始
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_DEL_MONITOR_COND = POINTER(NET_DVR_DEL_MONITOR_COND)


class NET_DVR_BLACKLIST_ALARM_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byType", BYTE), # 黑白名单标志：- 全部，- 白名单，- 黑名单
        ("byRes1", BYTE * 3), # 保留
        ("dwFaceID", DWORD), # 人脸名单ID
        ("dwMaxSnapNum", DWORD), # 最大抓拍张数，0-表示不限制
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_BLACKLIST_ALARM_COND = POINTER(NET_DVR_BLACKLIST_ALARM_COND)


class NET_DVR_STORAGE_RESOURCE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwStorageID", DWORD), # 从当前编号开始获取剩余资源，从1开始
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_STORAGE_RESOURCE_COND = POINTER(NET_DVR_STORAGE_RESOURCE_COND)


class NET_DVR_BLACKLIST_ALARM_RECORD(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwSnapFacePicID", DWORD), # 抓拍人脸ID
        ("dwRegisterID", DWORD), # 名单注册ID号（只读）
        ("dwGroupNo", DWORD), # 分组号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_BLACKLIST_ALARM_RECORD = POINTER(NET_DVR_BLACKLIST_ALARM_RECORD)


class NET_DVR_BLACKLIST_GROUP_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwGroupID", DWORD), # 分组编号（获取时有效，添加时无效），从1开始
        ("dwGroupNo", DWORD), # 名单分组号
        ("byGroupType", BYTE), # 分组类型，0-黑名单分组，1-白名单分组
        ("byRes1", BYTE),
        ("wThreshold", WORD), # 报警阈值，取值范围为0-1000
        ("dwListNum", DWORD), # 分组名单数
        ("szGroupName", BYTE * NAME_LEN), # 分组名称
        ("szRemark", BYTE * MAX_LEN_256),
        ("byStorageAddr", BYTE * MAX_DOMAIN_NAME), # 存储IP地址信息
        ("wStoragePort", WORD), # 存储IP对应的端口号
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_BLACKLIST_GROUP_INFO = POINTER(NET_DVR_BLACKLIST_GROUP_INFO)


class NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwGroupRecordID", DWORD), # 分组记录ID，修改和查询时有效，增加时无效，从1开始
        ("dwGroupNo", DWORD), # 名单分组号
        ("dwFaceDBID", DWORD), # 人脸库ID
        ("dwFaceRecordID", DWORD), # 人脸记录ID
        ("byAlarmLevel", BYTE), # 报警等级，0-high,1-medium,2-low
        ("byRes1", BYTE * 3), # 保留
        ("struStorageAddr", NET_DVR_ADDR_DOMAIN_INFO), # 存储IP地址信息
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD = POINTER(NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD)


class NET_DVR_BLACKLIST_GROUP_RECORD_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwRecordID", DWORD), # 从当前编号开始获取，从1开始
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_BLACKLIST_GROUP_RECORD_COND = POINTER(NET_DVR_BLACKLIST_GROUP_RECORD_COND)


class NET_DVR_BLACKLIST_GROUP_RECORD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwRecordNum", DWORD), # 记录总个数
        ("struRecord", NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD * MAX_GROUP_RECORD_NUM), # 记录参数
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_BLACKLIST_GROUP_RECORD_CFG = POINTER(NET_DVR_BLACKLIST_GROUP_RECORD_CFG)


class NET_DVR_BLACKLIST_GROUP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwGroupNum", DWORD), # 分组总个数
        ("struGroup", NET_DVR_BLACKLIST_GROUP_INFO * MAX_GROUP_RECORD_NUM), # 记录参数
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_BLACKLIST_GROUP_CFG = POINTER(NET_DVR_BLACKLIST_GROUP_CFG)


class NET_DVR_BLACKLIST_GROUP_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwGroupID", DWORD), # 从当前编号开始获取，从1开始
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_BLACKLIST_GROUP_COND = POINTER(NET_DVR_BLACKLIST_GROUP_COND)


class NET_DVR_SENSOR_VALUE(Structure):
    _fields_ = [
        ("fMinValue", float), # 最小值；精确到0.001，若为0xfffffffff表示查询所有
        ("fMaxValue", float), # 最大值；精确到0.001，若为0xfffffffff表示查询所有
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_SENSOR_VALUE = POINTER(NET_DVR_SENSOR_VALUE)


class NET_DVR_HISTORICAL_QUERY_PARAM(Structure):
    _fields_ = [
        ("struStartTime", NET_DVR_TIME_V30), # 开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 结束时间
        ("struVoltageValue", NET_DVR_SENSOR_VALUE), # 电压参数 单位伏特
        ("struCurrentValue", NET_DVR_SENSOR_VALUE), # 电流参数 单位毫安
        ("struTemperatureValue", NET_DVR_SENSOR_VALUE), # 温度参数，单位摄氏度
        ("struHumidityValue", NET_DVR_SENSOR_VALUE), # 湿度参数
        ("bySwitchStatus", BYTE), # 通电状态， 0~未通电，1~通电，0xff查询所有
        ("bySensorStatus", BYTE), # 传感器状态； 0-正常、1-异常、2-报警；0xff查询所有
        ("byRes", BYTE * 66),
    ]


LPNET_DVR_HISTORICAL_QUERY_PARAM = POINTER(NET_DVR_HISTORICAL_QUERY_PARAM)


class NET_DVR_SENSOR_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byQueryType", BYTE), # 查询方式；0~实时数据查询，1~历史数据查询
        ("byDeviceType", BYTE), # 设备类型0~未知,1~模拟量传感器, 2~上电端子,3~上电插座，0xff表示查询所有
        ("byDeviceID", BYTE), # 设备ID；Analog(模拟量传感器)范围：1-8、Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2，0xff表示查询所有
        ("byRes1", BYTE),
        # INTER_HISTORICAL_QUERY_PARAM子结构，在byQueryType为1时生效
        ("struHistoricalQueryParam", NET_DVR_HISTORICAL_QUERY_PARAM), # 历史数据查询参数
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SENSOR_COND = POINTER(NET_DVR_SENSOR_COND)


class NET_DVR_SENSOR_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 当前查询的传感器是否使能，0-不使能，1-使能；
        ("byDeviceType", BYTE), # 设备类型0~未知,1~模拟量传感器, 2~上电端子,3~上电插座
        ("byDeviceID", BYTE), # 设备ID；Analog(模拟量传感器)范围：1-8、Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2
        ("byRes1", BYTE),
        ("struTime", NET_DVR_TIME_V30), # 时间
        ("byIsFirst", BYTE), # 是否是启动后第一条数据(检测是否有重启)，0-否, 1-是；
        ("byIsSwitchOn", BYTE), # 是否通电，0-否, 1-是；
        ("bySensorStatus", BYTE), # 传感器状态； 0-正常、1-异常、2-报警；
        ("bySensorType", BYTE), # 传感器类型；参照 SENSOR_TYPE
        ("fVoltage", float), # 电压；单位伏特，精确到0.001。若为0xff表示无效值
        ("fCurrent", float), # 电流；单位毫安，精确到0.001。若为0xff表示无效值
        ("fTemperatureValue", float), # 温度值；单位摄氏度，精确到0.001。若为0xff表示无效值
        ("fHumidityValue", float), # 湿度值，精确到0.001。若为0xff表示无效值
        ("bySensorName", BYTE * SENSORNAME_LEN), # 传感器名称
        ("byDescription", BYTE * MAX_SENSORDESCR_LEN), # 传感器数据的描述信息，statusType为正常时，description可以为空
        ("fActualValue", float), # 模拟信号转换后的数值；精确到0.0001
        ("byUnit", BYTE * SENSORUNIT_LEN), # 单位字符串
        ("byRes", BYTE * 220),
    ]


LPNET_DVR_SENSOR_CFG = POINTER(NET_DVR_SENSOR_CFG)


class NET_DVR_SENSOR_SWITCH_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byDeviceType", BYTE), # 设备类型0~未知, 1~上电端子Terminal,2~上电插座Socket
        ("byDeviceID", BYTE), # 设备ID；Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2
        ("bySwitch", BYTE), # 开关，0-断电, 1-上电，2-重启
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_SENSOR_SWITCH_COND = POINTER(NET_DVR_SENSOR_SWITCH_COND)


class NET_DVR_GB28181_SERVICE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byServerID", BYTE * DEV_ID_LEN), # SIP服务器ID；
        ("wPort", WORD), # SIP服务器端口号
        ("byRes1", BYTE * 2), # 保留
        ("byAuthPasswd", BYTE * PASSWD_LEN),
        ("dwRegisterValid", DWORD), # 存活期周期，单位：秒，默认：3600
        ("byMaxHeartbeatTimeOut", BYTE), # 最大心跳超时次数，默认：3次
        ("byAutoAddIpc", BYTE), # 是否启用自动添加ipc,0-不启用，1-启用
        ("byAuthPasswdEx", BYTE * MAX_PASSWD_LEN_EX), # 密码扩展为64位，设置时，byAuthPasswdEx为非空，此参数有效，byAuthPasswd无效，获取时，byAuthPasswdEx和byAuthPasswd都返回
        ("byRes", BYTE * 190), # 保留
    ]


LPNET_DVR_GB28181_SERVICE_CFG = POINTER(NET_DVR_GB28181_SERVICE_CFG)


class NET_DVR_ACTIVATECFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sPassword", BYTE * PASSWD_LEN), # 初始密码
        ("byRes", BYTE * 108),
    ]


LPNET_DVR_ACTIVATECFG = POINTER(NET_DVR_ACTIVATECFG)


class NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDigitalChanPasswordStatus", BYTE * MAX_CHANNUM_V30*4), # 0-保留,1-IPC未激活，2-风险密码，3-密码强度弱，4-密码强度中，5-密码强度强byDigitalChanPasswordStatus[0]表示第一个数字通道
        ("byRes", BYTE * 1140),
    ]


LPNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS = POINTER(NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS)


class NET_DVR_CAMERACHAN_SERIALCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwBaudRate", DWORD), # 波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k
        ("byDataBit", BYTE), # 数据有几位：0-5位，1-6位，2-7位，3-8位
        ("byStopBit", BYTE), # 停止位：0-1位，1-2位
        ("byParity", BYTE), # 是否校验：0-无校验，1-奇校验，2-偶校验
        ("byFlowcontrol", BYTE), #  是否流控：0-无，1-软流控,2-硬流控
        ("wPTZProtocol", WORD), # 控球协议类型，索引值
        ("byRes1", BYTE * 6),
        ("dwSerialPort", DWORD), # 串口号,最高位为0，表示前面板串口，最高位为1，表示后面板串口
        ("bySerialAddress", BYTE), # 串口地址0~255
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_CAMERACHAN_SERIALCFG = POINTER(NET_DVR_CAMERACHAN_SERIALCFG)


MAX_MATRIX_SUBBOARD_NUM = 16 # 综合平台最大子板数
MAX_MATRIX_SUBBOARD_NUM_V51 = 32 # 综合平台最大子板数
MAX_BOARD_SUBSYSTEM_NUM = 12 # 每个子板最大系统数
class NET_DVR_SUBSYSTEM_STATUS(Structure):
    _fields_ = [
        # 子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-Fpga解码子系统，9-Fpga子系统，10-转码子系统，
        # 11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板， 14- X86业务服务板 ，15-多相机拼接子系统，16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，19-音频子系统，0-NULL
        ("bySubSystemType", BYTE),
        ("bySubSystemNo", BYTE), # 子系统号，即所在子板上的编号
        ("byOnlineStatus", BYTE), # 网络连接状态， 1-在线 2-不在线
        ("byRes", BYTE * 49),
    ]


LPNET_DVR_SUBSYSTEM_STATUS = POINTER(NET_DVR_SUBSYSTEM_STATUS)


class NET_DVR_MATRIX_SUBBOARD(Structure):
    _fields_ = [
        ("byBoardNo", BYTE), # 子板号
        ("byPcieConnectStatus", BYTE), # pcie连接状态， 1-连接 2-断开
        ("byRes", BYTE * 2),
        ("dwHardwareVersion", DWORD), # 子板硬件版本
        ("dwPcieBandwidth", DWORD), # pcie Link 带宽
        ("dwTemperature", DWORD), # 子板温度  单位：摄氏度
        ("struSubsystemStatus", NET_DVR_SUBSYSTEM_STATUS * MAX_BOARD_SUBSYSTEM_NUM), # 子系统状态
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_MATRIX_SUBBOARD = POINTER(NET_DVR_MATRIX_SUBBOARD)


class NET_DVR_MATRIX_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMainFrameType", BYTE), # 机箱类型  1-18U机箱(V1.0) 2-18U机箱 3-14U机箱 4-11U机箱 5-8U机箱 6-7U机箱  7-5U机箱
        ("bySoltNum", BYTE), # 槽位数
        ("byBoardNum", BYTE), # 子板数
        ("byRes", BYTE),
        ("struMatrixSubboard", NET_DVR_MATRIX_SUBBOARD * MAX_MATRIX_SUBBOARD_NUM),
        ("byRes2", BYTE * 48),
    ]


LPNET_DVR_MATRIX_STATUS = POINTER(NET_DVR_MATRIX_STATUS)


class NET_DVR_MATRIX_SUBBOARD_V50(Structure):
    _fields_ = [
        ("byBoardNo", BYTE), # 子板号
        ("byPcieConnectStatus", BYTE), # pcie连接状态， 1-连接 2-断开
        ("byRes", BYTE),
        ("byTemperatureAlarm", BYTE), # 温度报警，0-此字段无效，1-温度正常，2-温度超上限报警，3-温度超下限报警
        ("dwHardwareVersion", DWORD), # 子板硬件版本
        ("dwPcieBandwidth", DWORD), # pcie Link 带宽
        ("dwTemperature", DWORD), # 子板温度  单位：摄氏度
        ("struSubsystemStatus", NET_DVR_SUBSYSTEM_STATUS * MAX_BOARD_SUBSYSTEM_NUM), # 子系统状态
        ("bySubboardModel", BYTE * 32), # 子板型号
        ("byRes1", BYTE * 32),
    ]


LPNET_DVR_MATRIX_SUBBOARD_V50 = POINTER(NET_DVR_MATRIX_SUBBOARD_V50)


class NET_DVR_MATRIX_STATUS_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMainFrameType", BYTE), # 机箱类型  1-18U机箱(V1.0) 2-18U机箱 3-14U机箱 4-11U机箱 5-8U机箱 6-7U机箱  7-5U机箱
        ("bySoltNum", BYTE), # 槽位数
        ("byBoardNum", BYTE), # 子板数
        ("byLCDPanelStatus", BYTE), # 液晶面板连接状态，1-正常，2-异常
        ("struMatrixSubboard", NET_DVR_MATRIX_SUBBOARD_V50 * MAX_MATRIX_SUBBOARD_NUM),
        ("dwFanSequence", DWORD), # 风扇编号，按位表示，最低位不使用，例如0xffffff04表示编号为1的风扇，当对应风扇被置位时，dwFanConnectStatus和dwFanOperationStatus的对应位才有效，否则认为无此编号的风扇
        ("dwFanConnectStatus", DWORD), # 风扇连接状态，按位表示，最低位不使用，例如0xffffff00表示编号为1的风扇连接正常，0xffffff04表示编号为1的风扇连接异常
        ("dwFanOperationStatus", DWORD), # 风扇运行状态，按位表示，最低位不使用，例如0xffffff00表示编号为1的风扇运行状态正常，0xffffff04表示编号为1的风扇运行异常
        ("byDeviceModel", BYTE * 32), # 设备型号
        ("byPowerNums", BYTE), # 电源数量
        ("byMainBoardNums", BYTE), # 主控数量
        ("byHotStandbyMode", BYTE), #  byMainBoardNums为2时，0-工作在M1槽位，1-工作在M2槽位
        ("byRes", BYTE * 29),
    ]


LPNET_DVR_MATRIX_STATUS_V50 = POINTER(NET_DVR_MATRIX_STATUS_V50)


class NET_DVR_MATRIX_SUBBOARD_V51(Structure):
    _fields_ = [
        ("byBoardNo", BYTE), # 子板号
        ("byPcieConnectStatus", BYTE), # pcie连接状态，1-连接，2-断开
        ("byRes1", BYTE),
        ("byTemperatureAlarm", BYTE), # 温度报警，0-此字段无效，1-温度正常，2-温度超上限报警，3-温度超下限报警
        ("dwHardwareVersion", DWORD), # 子板硬件版本
        ("dwPcieBandwidth", DWORD), # pcie Link带宽
        ("dwTemperature", DWORD), # 子板温度，单位：摄氏度
        ("struSubsystemStatus", NET_DVR_SUBSYSTEM_STATUS * MAX_BOARD_SUBSYSTEM_NUM), # 子系统状态
        ("bySubboardModel", BYTE * 32), # 子板型号
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_MATRIX_SUBBOARD_V51 = POINTER(NET_DVR_MATRIX_SUBBOARD_V51)


class NET_DVR_MATRIX_STATUS_V51(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMainFrameType", BYTE), # 机箱类型 1-18U机箱（V1.0），2-18U机箱，3-14U机箱，4-11U机箱，5-8U机箱，6-7U机箱
        ("bySoltNum", BYTE), # 槽位数
        ("byBoardNum", BYTE), # 子板数
        ("byLCDPanelStatus", BYTE), # 液晶面板连接状态，1-正常，2-异常
        ("struMatrixSubboard", NET_DVR_MATRIX_SUBBOARD_V51 * MAX_MATRIX_SUBBOARD_NUM_V51),
        ("dwFanSequence", DWORD), # 风扇编号，按位表示，例如0x00000001表示设备只有一个风扇，编号为1，0x00000101表示设备有两个风扇，编号分别为1和9，当对应风扇编号被置位时，dwFanConnectStatus和dwFanOperationStatus的对应位才有效，否则认为无此编号的风扇
        ("dwFanConnectStatus", DWORD), # 风扇连接状态，按位表示，例如0x00000001表示编号为1的风扇连接状态异常，0x00000101表示编号为1和9的风扇连接状态均异常
        ("dwFanOperationStatus", DWORD), # 风扇运行状态，按位表示，例如0x00000001表示编号为1的风扇运行状态异常，0x00000101表示编号为1和9的风扇运行状态均异常
        ("byDeviceModel", BYTE * 32), # 设备型号
        ("byFanSpeed", BYTE * 32), # 风扇转速，按字节表示，例如byFanSpeed[0]表示编号为1的风扇的转速，转速等级范围为[1,3]
        ("byMainMemUsed", BYTE), # 主控内存使用率，单位：百分比
        ("byMainCpuUsed", BYTE), # 主控CPU使用率，单位：百分比
        ("byNetwordUsed", BYTE), # 交换板网络使用率，单位：百分比
        ("byRes1", BYTE),
        ("dwMainSoftwareVer", DWORD), # 主控软件版本
        ("byPowerNums", BYTE), # 电源数量
        ("byMainBoardNums", BYTE), # 主控数量
        ("byHotStandbyMode", BYTE), #  byMainBoardNums为2时，0-工作在M1槽位，1-工作在M2槽位
        ("byRes2", BYTE * 125),
    ]


LPNET_DVR_MATRIX_STATUS_V51 = POINTER(NET_DVR_MATRIX_STATUS_V51)


class NET_DVR_FUSION_SCALE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wWidth", WORD), # 图像融合宽(横向图像数目)
        ("wHeight", WORD), # 图像融合高(纵向图像数目)
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_FUSION_SCALE = POINTER(NET_DVR_FUSION_SCALE)


class NET_DVR_FUSION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFusion", BYTE), # 是否融合，0-未融合或取消融合，非0-融合
        ("byUseHistoryMap", BYTE), # 是否使用历史融合映射表，0-不使用，非0-使用
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_FUSION_CFG = POINTER(NET_DVR_FUSION_CFG)


class NET_DVR_MULTIFUNCTION_SERIALCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byVariable", BYTE), # 串口是否可变，1-不可变  2-可变 （只获取）
        ("bySerialWorkMode", BYTE), # 工作模式，1-RS485, 2-RS232（只在可变情况下，修改工作模式）
        ("byFunType", BYTE), # 串口功能， 1-键盘控制，2-屏幕控制，3-透明通道模式 4-PTZ控制  5-矩阵控制 6-控制台
        ("byDataBit", BYTE), #  数据位 0－5位，1－6位，2－7位，3－8位
        ("byStopBit", BYTE), #  停止位 0－1位，1－2位
        ("byParity", BYTE), #  校验 0－无校验，1－奇校验，2－偶校验
        ("byFlowcontrol", BYTE), #  0－无，1－软流控,2-硬流控
        ("byRes1", BYTE),
        ("dwBaudRate", DWORD), # 波特率0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k
        ("wProtocol", WORD), # 串口协议  不同串口功能对应串口协议不一样
        ("byRes", BYTE * 34),
    ]


LPNET_DVR_MULTIFUNCTION_SERIALCFG = POINTER(NET_DVR_MULTIFUNCTION_SERIALCFG)


class NET_DVR_PTZ_3D_SPEED_CONTROL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byPSpeed", BYTE), #  X轴控制速度  （取值1－64）
        ("byTSpeed", BYTE), #  Y轴控制速度   （取值1－64）
        ("byZSpeed", BYTE), #  Z速度
        ("byPDirect", BYTE), #  P方向， 1-左， 2-右
        ("byTDirect", BYTE), #  T方向， 1-上， 2-下
        ("byZDirect", BYTE), # Z方向，  1-ZOOM+,  2-ZOOM-
        ("byRes", BYTE * 18), # 保留字节
    ]


LPNET_DVR_PTZ_3D_SPEED_CONTROL = POINTER(NET_DVR_PTZ_3D_SPEED_CONTROL)


# Sensor信息
class NET_DVR_SENSOR_PARAM(Structure):
    _fields_ = [
        ("bySensorType", BYTE), # SensorType:0-CCD,1-CMOS
        ("byRes", BYTE * 31),
        ("fHorWidth", float), # 水平宽度 精确到小数点后两位 *10000
        ("fVerWidth", float), # 垂直宽度 精确到小数点后两位 *10000
        ("fFold", float), # zoom=1没变时的焦距 精确到小数点后两位 *100
    ]


LPNET_DVR_SENSOR_PARAM = POINTER(NET_DVR_SENSOR_PARAM)


class NET_DVR_LLI_PARAM(Structure):
    _fields_ = [
        ("fSec", float), # 秒[0.000000,60.000000]
        ("byDegree", BYTE), # 度:纬度[0,90] 经度[0,180]
        ("byMinute", BYTE), # 分[0,59]
        ("byRes", BYTE * 6),
    ]


LPNET_DVR_LLI_PARAM = POINTER(NET_DVR_LLI_PARAM)


class NET_DVR_LLPOS_PARAM(Structure):
    _fields_ = [
        ("byLatitudeType", BYTE), # 纬度类型，0-北纬，1-南纬
        ("byLongitudeType", BYTE), # 经度类型，0-东经，1-西经
        ("byRes1", BYTE * 2),
        ("struLatitude", NET_DVR_LLI_PARAM), # 纬度
        ("struLongitude", NET_DVR_LLI_PARAM), # 经度
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_LLPOS_PARAM = POINTER(NET_DVR_LLPOS_PARAM)


# 转向流量信息
class NET_DVR_TURN_DIRECTION_PARAM(Structure):
    _fields_ = [
        ("byLine", BYTE), # 转向线编号
        ("byStatus", BYTE), # 转向线状态，0-未知，1-进入，2-离开
        ("byRes", BYTE * 38),
    ]


LPNET_DVR_TURN_DIRECTION_PARAM = POINTER(NET_DVR_TURN_DIRECTION_PARAM)


# 停止线信息
class NET_DVR_STOP_LINE_PARAM(Structure):
    _fields_ = [
        ("byStatus", BYTE), # 停止线状态，0-未知，1-进入，2-离开
        ("byRes", BYTE * 39),
    ]


LPNET_DVR_STOP_LINE_PARAM = POINTER(NET_DVR_STOP_LINE_PARAM)


# TPS附加信息
class NET_DVR_TPS_ADDINFO(Structure):
    _fields_ = [
        ("struFirstLLPos", NET_DVR_LLPOS_PARAM), # 车流量第一辆车的经纬度位置信息(byLaneState=3且byQueueLen>0时才返回)
        ("struLastLLPos", NET_DVR_LLPOS_PARAM), # 车流量最后一辆车的经纬度位置信息(byLaneState=3且byQueueLen>0时才返回)
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌号
        ("struTurnDirection", NET_DVR_TURN_DIRECTION_PARAM), # 转向流量信息
        ("struStopLine", NET_DVR_STOP_LINE_PARAM), # 停止线信息
        ("byRes", BYTE * 884),
    ]


LPNET_DVR_TPS_ADDINFO = POINTER(NET_DVR_TPS_ADDINFO)


# 车辆附加信息
class NET_DVR_VEHICLE_ADDINFO(Structure):
    _fields_ = [
        ("struLLPos", NET_DVR_LLPOS_PARAM), # 车辆当前经纬度位置信息
        ("sVehicleNo", CHAR * LEN_64), # 上传的车辆唯一标识,最大长度为64
        ("byVehicleMonitorTaskID", BYTE * 64), # 车辆智能布控任务ID,64位字符串,创建任务时由上层下发给设备,上层确保ID唯一性
        ("byUUID", BYTE * LEN_64), # 通用唯一识别码,64位字符串,设备确保唯一性，用于跨服务器关联同一次抓拍,vehicleMonitor，manualVehicleMonitor，dailyVehicleMonitor报警中的linkageANPRUUID有关
        ("byRes", BYTE * 832),
    ]


LPNET_DVR_VEHICLE_ADDINFO = POINTER(NET_DVR_VEHICLE_ADDINFO)


# 烟雾报警
class NET_DVR_SMOKEDETECTION_ALARM(Structure):
    _fields_ = [
        ("struPTZPos", NET_PTZ_INFO), # 可见光设备PTZF位置
        ("struThermalPTZPos", NET_PTZ_INFO), # 热成像设备PTZF位置
        ("struLLPos", NET_DVR_LLPOS_PARAM), # 设备经纬度位置
        ("struSmokePos", NET_VCA_RECT), # 画面中烟雾区域位置
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_SMOKEDETECTION_ALARM = POINTER(NET_DVR_SMOKEDETECTION_ALARM)


# 球机位置信息
class NET_DVR_PTZPOS_PARAM(Structure):
    _fields_ = [
        ("fPanPos", float), # 水平参数，精确到小数点后1位
        ("fTiltPos", float), # 垂直参数，精确到小数点后1位
        ("fZoomPos", float), # 变倍参数，精确到小数点后1位
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_PTZPOS_PARAM = POINTER(NET_DVR_PTZPOS_PARAM)


# GIS信息上传
class NET_DVR_GIS_UPLOADINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备
        ("fAzimuth", float), # 电子罗盘的方位信息；方位角[0.00°,360.00°)
        ("byLatitudeType", BYTE), # 纬度类型，0-北纬，1-南纬
        ("byLongitudeType", BYTE), #  经度类型，0-东度，1-西度
        ("byRes1", BYTE * 2),
        ("struLatitude", NET_DVR_LLI_PARAM), # 纬度
        ("struLongitude", NET_DVR_LLI_PARAM), # 经度
        ("fHorizontalValue", float), # 水平视场角，精确到小数点后面两位
        ("fVerticalValue", float), # 垂直视场角，精确到小数点后面两位
        ("fVisibleRadius", float), # 当前可视半径，精确到小数点后面两位
        ("fMaxViewRadius", float), # 最大可视半径，精确到小数点后面0位（预留处理）
        ("struSensorParam", NET_DVR_SENSOR_PARAM), # Sensor信息
        ("struPtzPos", NET_DVR_PTZPOS_PARAM), # ptz坐标
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_GIS_UPLOADINFO = POINTER(NET_DVR_GIS_UPLOADINFO)


# 防破坏报警信息上传
class NET_DVR_VANDALPROOF_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_VANDALPROOF_ALARM = POINTER(NET_DVR_VANDALPROOF_ALARM)


# 集中布控参数配置
class NET_DVR_CENTRALIZEDCTRL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 0-结束，1-开始
        ("byLatitudeType", BYTE), # 纬度类型，0-北纬，1-南纬
        ("byLongitudeType", BYTE), #  经度类型，0-东经，1-西经
        ("byRes1", BYTE),
        ("struLatitude", NET_DVR_LLI_PARAM), # 纬度
        ("struLongitude", NET_DVR_LLI_PARAM), # 经度
        ("dwTimeOut", DWORD), # 超时时间 [60s, 6*60*60s]
        ("byControlType", BYTE), # 集中布控方式 0-强制布控，1-非强制布控
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_CENTRALIZEDCTRL_CFG = POINTER(NET_DVR_CENTRALIZEDCTRL_CFG)


# 球机的GIS信息数据
class NET_DVR_GIS_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("fAzimuth", float), # 电子罗盘的方位信息；方位角[0.00°,360.00°)
        ("fHorizontalValue", float), # 水平视场角，精确到小数点后面两位
        ("fVerticalValue", float), # 垂直视场角，精确到小数点后面两位
        ("fVisibleRadius", float), # 当前可视半径，精确到小数点后面两位
        ("fMaxViewRadius", float), # 最大可视半径，精确到小数点后面0位（预留处理）
        ("byLatitudeType", BYTE), # 纬度类型，0-北纬，1-南纬
        ("byLongitudeType", BYTE), #  经度类型，0-东经，1-西经
        ("byPTZPosExEnable", BYTE), # 是否启用PTZ坐标扩展，0~不启用，PTZ坐标值以struPtzPos 为准。1~启用，PTZ坐标值以struPtzPosEx为准。
        ("byRes1", BYTE),
        ("struLatitude", NET_DVR_LLI_PARAM), # 纬度
        ("struLongitude", NET_DVR_LLI_PARAM), # 经度
        ("struPtzPos", NET_DVR_PTZPOS_PARAM), # ptz坐标
        ("struSensorParam", NET_DVR_SENSOR_PARAM), # Sensor信息
        ("struPtzPosEx", NET_PTZ_INFO), #  ptz坐标扩展(支持高精度PTZ值，精确到小数点后三位)
        ("fMinHorizontalValue", float), # 最小水平视场角，精确到小数点后面两位；0.0-360.00
        ("fMaxHorizontalValue", float), # 最大水平视场角，精确到小数点后面两位；0.0-360.00
        ("fMinVerticalValue", float), # 最小垂直视场角，精确到小数点后面两位；0.0-360.00
        ("fMaxVerticalValue", float), # 最大垂直视场角，精确到小数点后面两位；0.0-360.00
        ("byRes", BYTE * 220),
    ]


LPNET_DVR_GIS_INFO = POINTER(NET_DVR_GIS_INFO)


# 设备巡航模式
class NET_DVR_CRUISE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byCruiseMode", BYTE), #  巡航模式，0~连续，1~预置点
        ("byRes", BYTE * 123),
    ]


LPNET_DVR_CRUISE_PARAM = POINTER(NET_DVR_CRUISE_PARAM)


# 获取设备环境温湿度信息结构体
class NET_DVR_TEMP_HUMI_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struCurrentTime", NET_DVR_TIME_V30), #  当前时间
        ("fTemperature", float), # 设备环境温度，精确到小数点后两位，（-273 – 1000摄氏度）
        ("fHumidity", float), #  设备环境湿度，精确到小数点后两位。单位为：%
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_TEMP_HUMI_INFO = POINTER(NET_DVR_TEMP_HUMI_INFO)


class NET_SDK_POINT_THERMOMETRY(Structure):
    _fields_ = [
        ("fPointTemperature", float), # 点测温当前温度, 当标定为0-点时生效。精确到小数点后一位(-40-1000),（浮点数+100）*10
        ("struPoint", NET_VCA_POINT), # 点测温坐标（当规则标定类型为“点”的时候生效）
        ("byRes", BYTE * 20),
    ]


LPNET_SDK_POINT_THERMOMETRY = POINTER(NET_SDK_POINT_THERMOMETRY)


class NET_SDK_REGION_THERMOMETRY(Structure):
    _fields_ = [
        ("fMaxTemperature", float), # 最高温度,精确到小数点后一位(-40-1000),（浮点数+100）*10
        ("fMinTemperature", float), # 最低温度,精确到小数点后一位(-40-1000),（浮点数+100）*10
        ("fAverageTemperature", float), # 平均温度,精确到小数点后一位(-40-1000),（浮点数+100）*10
        ("fTemperatureDiff", float), # 温差,精确到小数点后一位(-40-1000),（浮点数+100）*10
        ("struRegion", NET_VCA_POLYGON), # 区域、线（当规则标定类型为“框”或者“线”的时候生效）
        ("byRes", BYTE * 20),
    ]


LPNET_SDK_REGION_THERMOMETRY = POINTER(NET_SDK_REGION_THERMOMETRY)


class NET_SDK_MANUALTHERM_RULE(Structure):
    _fields_ = [
        ("byRuleID", BYTE), # 规则ID 0-表示无效，从1开始 （list内部判断数据有效性）
        ("byEnable", BYTE), # 是否启用
        ("byRes1", BYTE * 2),
        ("szRuleName", CHAR * NAME_LEN), # 规则名称
        ("byRuleCalibType", BYTE), # 规则标定类型 0-点，1-框，2-线
        ("byRes2", BYTE * 3),
        ("struPointTherm", NET_SDK_POINT_THERMOMETRY), # 点测温，当标定为0-点时生效
        ("struRegionTherm", NET_SDK_REGION_THERMOMETRY), # 区域测温，当标定为1-框、2-线时生效。
        ("byRes", BYTE * 512),
    ]


LPNET_SDK_MANUALTHERM_RULE = POINTER(NET_SDK_MANUALTHERM_RULE)


class NET_SDK_MANUAL_THERMOMETRY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD), # 通道号
        ("dwRelativeTime", DWORD), #  相对时标（只读）
        ("dwAbsTime", DWORD), #  绝对时标（只读）
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
        ("byDataType", BYTE), # 数据状态类型:0-检测中，1-开始，2-结束（只读）
        ("byRes1", BYTE * 6),
        ("struRuleInfo", NET_SDK_MANUALTHERM_RULE),
        ("byRes", BYTE * 512),
    ]


LPNET_SDK_MANUAL_THERMOMETRY = POINTER(NET_SDK_MANUAL_THERMOMETRY)


class NET_SDK_MANUALTHERM_BASICPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wDistance", WORD), # 距离(m)[0, 10000]
        ("byDistanceUnit", BYTE), # 距离单位: 0-米（m），1-英尺（feet）,2-厘米(centimeter)
        ("byRes1", BYTE * 1), # 保留
        ("fEmissivity", float), # 发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_SDK_MANUALTHERM_BASICPARAM = POINTER(NET_SDK_MANUALTHERM_BASICPARAM)


class NET_SDK_FIRESHIELDMASK_REGION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMaskID", BYTE), # 区域ID，1~24
        ("byEnabled", BYTE), #  单个火点屏蔽区域使能，0~不启用，1~启用
        ("byShieldZoom", BYTE), # 屏蔽倍率，0~32倍。屏蔽大于等于该值的光学变倍。
        ("byMaskType", BYTE), # 屏蔽区域颜色类型，0-灰色，1-红色，2-黄色，3-蓝色，4-橙色，5-绿色，6-透明，7-半透明，8-马赛克
        ("byRegionType", BYTE), # 区域类型（预留）0-四边形
        ("byShowEnabled", BYTE), # 区域显示使能，该参数为只读，若该使能为false则上层不显示该区域相关信息。True为显示该区域相关信息
        ("byRes1", BYTE * 2), # 保留
        ("szMaskName", CHAR * NAME_LEN), # 屏蔽标题
        ("struRegion", NET_VCA_POLYGON), # 屏蔽区域
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_SDK_FIRESHIELDMASK_REGION = POINTER(NET_SDK_FIRESHIELDMASK_REGION)


MAX_FIRESHIELDMASK_REGION = 24
class NET_SDK_FIRESHIELDMASK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnabled", BYTE), #  火点区域屏蔽使能，0~不启用，1~启用
        ("byShieldAreaTransparency", BYTE), # 屏蔽区域透明度 0-不透明 1-透明 2-半透明
        ("byDisplayShieldAreaEnabled", BYTE), # 码流叠加屏蔽区域使能
        ("byRes1", BYTE * 1), # 保留
        ("struMaskRegion", NET_SDK_FIRESHIELDMASK_REGION * MAX_FIRESHIELDMASK_REGION), # 火点屏蔽区域
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_SDK_FIRESHIELDMASK_CFG = POINTER(NET_SDK_FIRESHIELDMASK_CFG)


class NET_SDK_SMOKESHIELDMASK_REGION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byMaskID", BYTE), # 区域ID，1~24
        ("byEnabled", BYTE), #  单个烟雾屏蔽区域使能，0~不启用，1~启用
        ("byShieldZoom", BYTE), # 屏蔽倍率，0~32倍。屏蔽大于等于该值的光学变倍。
        ("byMaskType", BYTE), # 屏蔽区域颜色类型，0-灰色，1-红色，2-黄色，3-蓝色，4-橙色，5-绿色，6-透明，7-半透明，8-马赛克
        ("byRegionType", BYTE), # 区域类型（预留）0-四边形
        ("byShowEnabled", BYTE), #  区域显示使能，该参数为只读，若该使能为false则上层不显示该区域相关信息。True为显示该区域相关信息
        ("byRes1", BYTE * 2), # 保留
        ("szMaskName", CHAR * NAME_LEN), # 屏蔽标题
        ("struRegion", NET_VCA_POLYGON), # 屏蔽区域
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_SDK_SMOKESHIELDMASK_REGION = POINTER(NET_SDK_SMOKESHIELDMASK_REGION)


MAX_SMOKESHIELDMASK_REGION = 24
class NET_SDK_SMOKESHIELDMASK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnabled", BYTE), #  烟雾区域屏蔽使能，0~不启用，1~启用
        ("byShieldAreaTransparency", BYTE), # 屏蔽区域透明度 0-不透明 1-透明 2-半透明
        ("byDisplayShieldAreaEnabled", BYTE), # 码流叠加屏蔽区域使能
        ("byRes1", BYTE * 1), # 保留
        ("struMaskRegion", NET_SDK_SMOKESHIELDMASK_REGION * MAX_SMOKESHIELDMASK_REGION), # 烟雾屏蔽区域
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_SDK_SMOKESHIELDMASK_CFG = POINTER(NET_SDK_SMOKESHIELDMASK_CFG)


class NET_SDK_AREASCAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byScanState", BYTE), # 区域扫描当前设置状态，0为未设置，1为已设置（该参数为只读）
        ("byRes", BYTE * 259), # 保留
    ]


LPNET_SDK_AREASCAN_CFG = POINTER(NET_SDK_AREASCAN_CFG)


class NET_SDK_FIRESHIELDMASK_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRegionID", BYTE), # 区域ID，1~24.
        ("byRes", BYTE * 127), # 保留
    ]


LPNET_SDK_FIRESHIELDMASK_COND = POINTER(NET_SDK_FIRESHIELDMASK_COND)


class NET_SDK_SMOKESHIELDMASK_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRegionID", BYTE), # 区域ID，1~24.
        ("byRes", BYTE * 127), # 保留
    ]


LPNET_SDK_SMOKESHIELDMASK_COND = POINTER(NET_SDK_SMOKESHIELDMASK_COND)


# 子罗盘关联防破坏参数
class NET_DVR_VANDALPROOFALARM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("bySensitivity", BYTE), # 灵敏度[1,100] (支持灵敏度配置，灵敏度值大，越容易触发，值越小，越难触发)
        ("byUploadEnabled", BYTE), # 启用防破坏报警上传使能 0-不启用，1-启用
        ("byVoiceWarningEnabled", BYTE), # 启用防破坏报警语音提示使能 0-不启用，1-启用
        ("byEnable", BYTE), #  启用检测防破坏报警 0-关闭，1-开始
        ("byRes", BYTE * 124),
    ]


LPNET_DVR_VANDALPROOFALARM_CFG = POINTER(NET_DVR_VANDALPROOFALARM_CFG)


class NET_DVR_AZIMUTHINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("fDegree", float), # 方位角度数(精确到小数点后两位)
        ("byAzimuth", BYTE), # 方位角信息 0-东北,1-西北,2-东南,3-西南,4-东,5-西,6-南,7-北
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_AZIMUTHINFO = POINTER(NET_DVR_AZIMUTHINFO)


# 电子罗盘矫正、指向正北控制条件结构
class NET_DVR_COMPASS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_COMPASS_COND = POINTER(NET_DVR_COMPASS_COND)


class NET_DVR_POSITION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("bySoftWorkMode", BYTE), # 工作模式 0-自动，1-手动
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_POSITION_CFG = POINTER(NET_DVR_POSITION_CFG)


class NET_DVR_STREAMING_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD), # 通道号
        ("byStreamType", BYTE), # 码流类型0-主码流，1-子码流，2-码流3
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_STREAMING_COND = POINTER(NET_DVR_STREAMING_COND)


# 卫星定位参数配置
class NET_DVR_SATELLITETIME_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 卫星定位校时使能 0-不开启，1-开启
        ("byRes", BYTE),
        ("wTimeInterval", WORD), # 校时时间间隔(s)
        ("byRes1", BYTE * 124),
    ]


LPNET_DVR_SATELLITETIME_CFG = POINTER(NET_DVR_SATELLITETIME_CFG)


MAX_SIGNAL_JOINT_NUM = 64 # 最大的拼接规模
class NET_DVR_SIGNAL_JOINT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sCamName", BYTE * NAME_LEN), # 拼接后信号源名称
        ("byEnable", BYTE), # 使能，0-不使能  !0-使能
        ("byCamMode", BYTE), # 拼接后信号源类型，NET_DVR_CAM_JOINT
        ("byRows", BYTE), # 拼接行数
        ("byColumns", BYTE), # 拼接列数
        ("dwSignalNo", DWORD * MAX_SIGNAL_JOINT_NUM), # 信号源号,前byRows* byColumns项有效
        ("dwJointNo", DWORD), # 拼接编号（获取有效）
        ("dwSignalNoJoint", DWORD), # 拼接后的信号源号（获取有效）
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SIGNAL_JOINT_CFG = POINTER(NET_DVR_SIGNAL_JOINT_CFG)


class NET_DVR_SIGNAL_CUTPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSignalNo", DWORD), # 信号源号
        ("dwCutTop", DWORD), # 上方裁剪像素值,0代表还原
        ("dwCutBottom", DWORD), # 下方裁剪像素值,0代表还原
        ("dwCutLeft", DWORD), # 左边裁剪像素值,0代表还原
        ("dwCutRight", DWORD), # 右边裁剪像素值,0代表还原
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_SIGNAL_CUTPARAM = POINTER(NET_DVR_SIGNAL_CUTPARAM)


class NET_DVR_WALL_RELATION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 关联， 0-不关联 !0-关联
        ("byRealWallNo", BYTE), # 物理墙号
        ("byRes", BYTE * 14),
    ]


LPNET_DVR_WALL_RELATION_CFG = POINTER(NET_DVR_WALL_RELATION_CFG)


class NET_DVR_INPUTSTREAMCFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE),
        ("byCamMode", BYTE), # 见NET_DVR_CAM_MODE
        ("wInputNo", WORD), # 信号源序号
        ("sCamName", BYTE * NAME_LEN),
        ("struVideoEffect", NET_DVR_VIDEOEFFECT), # 视频参数
        ("struPuStream", NET_DVR_PU_STREAM_CFG), # ip输入时使用
        ("wBoardNum", WORD), # 信号源所在的板卡号，只能获取
        ("wInputIdxOnBoard", WORD), # 信号源在板卡上的位置，只能获取
        ("dwResolution", DWORD), # 分辨率
        ("byVideoFormat", BYTE), # 视频制式，见VIDEO_STANDARD
        ("byStatus", BYTE), # 信号源状态，0-字段无效 1-有信号 2-无信号 3-异常
        ("sGroupName", BYTE * NAME_LEN), # 网络信号源分组 组名
        ("byJointMatrix", BYTE), # 关联矩阵，0-不关联  1-关联，当输入信号源为NET_DVR_CAM_BNC，NET_DVR_CAM_VGA，NET_DVR_CAM_DVI，NET_DVR_CAM_HDMI,中的一种时，该参数有效。
        ("byJointNo", BYTE), # 拼接信号源的拼接编号(只能获取)
        ("byColorMode", BYTE), # 色彩模式， 0-自定义 1-锐利 2-普通 3-柔和，当为自定义时，使用struVideoEffect设置
        ("byScreenServer", BYTE), # 关联屏幕服务器，0-不联，1-关联
        ("byDevNo", BYTE), # 设备号
        ("byRes1", BYTE),
        ("dwInputSignalNo", DWORD), # 输入信号源编号（新）
        ("byVideoEnctype", BYTE), # 视频编码类型，0-默认，1-Smart264
        ("byAudioEnctype", BYTE), # 音频编码类，0-默认，1-AUDIO_G711_A，2-AUDIO_G711_U，3- AUDIO_G722_1
        ("byWallStatus", BYTE), # 信号源上墙状态，0-无效 1-有上墙 2- 无上墙
        ("byRes", BYTE * 117),
    ]


LPNET_DVR_INPUTSTREAMCFG_V40 = POINTER(NET_DVR_INPUTSTREAMCFG_V40)


class NET_DVR_AUDIO_CONTROL_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMonId", DWORD), # 监视器全局编号
        ("bySubWindowNum", BYTE), # 监视器对应子窗口号
        ("byWallNo", BYTE), # 墙号
        ("byEnable", BYTE), # 音频开关，0-关，1-开
        ("byRes", BYTE * 13),
    ]


LPNET_DVR_AUDIO_CONTROL_INFO = POINTER(NET_DVR_AUDIO_CONTROL_INFO)


class NET_DVR_INPUTSTREAM_PTZCFG_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wPTZProtocol", WORD), # 控球协议类型，索引值
        ("byRes", BYTE * 34),
    ]


LPNET_DVR_INPUTSTREAM_PTZCFG_PARAM = POINTER(NET_DVR_INPUTSTREAM_PTZCFG_PARAM)


# 公路货车轴型定义 参照《2016治超分类1133.xlsx》
AXLE_TYPE_UNKNOWN = 0x0000
#2轴
AXLE_TYPE_2AXLE_12 = 0x0200
#3轴
AXLE_TYPE_3AXLE_122_1 = 0x0300
AXLE_TYPE_3AXLE_122_2 = 769
AXLE_TYPE_3AXLE_15 = 770
AXLE_TYPE_3AXLE_112 = 771
#4轴
AXLE_TYPE_4AXLE_125_1 = 0x0400
AXLE_TYPE_4AXLE_152 = 1025
AXLE_TYPE_4AXLE_125_2 = 1026
AXLE_TYPE_4AXLE_1222 = 1027
AXLE_TYPE_4AXLE_115 = 1028
#5轴
AXLE_TYPE_5AXLE_155_1 = 0x0500
AXLE_TYPE_5AXLE_1125_1 = 1281
AXLE_TYPE_5AXLE_155_2 = 1282
AXLE_TYPE_5AXLE_1125_2 = 1283
AXLE_TYPE_5AXLE_129 = 1284
AXLE_TYPE_5AXLE_1522 = 1285
AXLE_TYPE_5AXLE_11222 = 1286
#6轴
AXLE_TYPE_6AXLE_159_1 = 0x0600
AXLE_TYPE_6AXLE_159_2 = 1537
AXLE_TYPE_6AXLE_1155_1 = 1538
AXLE_TYPE_6AXLE_1155_2 = 1539
AXLE_TYPE_6AXLE_159_3 = 1540
AXLE_TYPE_6AXLE_159_4 = 1541
AXLE_TYPE_6AXLE_1129 = 1542
AXLE_TYPE_6AXLE_11522_1 = 1543
AXLE_TYPE_6AXLE_11522_2 = 1544


# 车辆称重
class NET_DVR_VEHICLE_WEIGHT_RESULT(Structure):
    _fields_ = [
        ("byIsOverWeight", BYTE), # 是否超限
        ("byAxleNum", BYTE), # 轴数
        ("wAxleModel", WORD), # 参考 enum TRUCK_AXLE_MODEL,可以根据类型解析出轴的个数
        ("fOverWeight", float), # 超限重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
        ("fWeight", float), # 车身重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
        ("fLimitWeight", float), # 限制重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
        ("fAxleLen", float), # 轴距(米)，实际值扩大100倍传输（实际值精确到小数点后两位）
        ("sDevDescInfo", CHAR * MAX_DEVDESC_LEN), # 设备描述信息
        ("wAxleWeight", WORD * MAX_TRUCK_AXLE_NUM), # 车轴重量，单位千克（kg）第i个元素表示第i个轴重
        ("wAxleDistance", WORD * MAX_TRUCK_AXLE_NUM), # 车轴间距，单位毫米(mm).第i个元素表示第i轴和第i+1轴的间距
        ("byRes2", BYTE * 24), # 预留
    ]


LPNET_DVR_VEHICLE_WEIGHT_RESULT = POINTER(NET_DVR_VEHICLE_WEIGHT_RESULT)


#  车牌检测结果
class NET_DVR_PLATE_RESULT_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwMatchNo", DWORD), # 匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
        ("byGroupNum", BYTE), # 图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
        ("byPicNo", BYTE), # 连拍的图片序号（接收到图片组数量后，表示接收完成接收超时不足图片组数量时，根据需要保留或删除）
        ("bySecondCam", BYTE), # 是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
        ("byFeaturePicNo", BYTE), # 闯红灯电警，取第几张图作为特写图,0xff-表示不取
        ("byDriveChan", BYTE), # 触发车道号
        ("byVehicleType", BYTE), # 车辆类型，参考VTR_RESULT
        ("byDetSceneID", BYTE), # 检测场景号[1,4], IPC默认是0
        # 车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
        # 该节点已不再使用,使用下面的byYellowLabelCar和byDangerousVehicles判断是否黄标车和危险品车
        ("byVehicleAttribute", BYTE),
        ("wIllegalType", WORD), # 违章类型采用国标定义
        ("byIllegalSubType", BYTE * 8), # 违章子类型
        ("byPostPicNo", BYTE), # 违章时取第几张图片作为卡口图,0xff-表示不取
        ("byChanIndex", BYTE), # 通道号（保留）
        ("wSpeedLimit", WORD), # 限速上限（超速时有效）
        ("byChanIndexEx", BYTE), # byChanIndexEx*256+byChanIndex表示真实通道号。
        ("byVehiclePositionControl", BYTE), # 车辆位置布控标志,0~为普通车牌识别报警,1~为车辆位置布控触发报警
        # (即通过PUT /ISAPI/Traffic/channels/<ID>/vehiclePositionControl?format=json触发)
        ("struPlateInfo", NET_DVR_PLATE_INFO), # 车牌信息结构
        ("struVehicleInfo", NET_DVR_VEHICLE_INFO), # 车辆信息
        ("byMonitoringSiteID", BYTE * 48), # 监测点编号
        ("byDeviceID", BYTE * 48), # 设备编号
        ("byDir", BYTE), # 监测方向，1-上行（反向），2-下行(正向)，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
        ("byDetectType", BYTE), # 检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
        # 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
        # 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
        ("byRelaLaneDirectionType", BYTE),
        ("byCarDirectionType", BYTE), # 车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
        # 当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
        ("dwCustomIllegalType", DWORD), # 违章类型定义(用户自定义)
        # 为0~数字格式时，为老的违章类型，wIllegalType、dwCustomIllegalType参数生效，赋值国标违法代码。
        # 为1~字符格式时，pIllegalInfoBuf参数生效。老的违章类型，wIllegalType、dwCustomIllegalType参数依然赋值国标违法代码
        ("pIllegalInfoBuf", BYTE*), # 违法代码字符信息结构体指针；指向NET_ITS_ILLEGAL_INFO
        ("byIllegalFromatType", BYTE), # 违章信息格式类型； 0~数字格式， 1~字符格式
        ("byPendant", BYTE), #  0-表示未知,1-车窗有悬挂物，2-车窗无悬挂物
        ("byDataAnalysis", BYTE), # 0-数据未分析, 1-数据已分析
        ("byYellowLabelCar", BYTE), # 0-表示未知, 1-非黄标车,2-黄标车
        ("byDangerousVehicles", BYTE), # 0-表示未知, 1-非危险品车,2-危险品车
        # 以下字段包含Pilot字符均为主驾驶，含Copilot字符均为副驾驶
        ("byPilotSafebelt", BYTE), # 0-表示未知,1-系安全带,2-不系安全带
        ("byCopilotSafebelt", BYTE), # 0-表示未知,1-系安全带,2-不系安全带
        ("byPilotSunVisor", BYTE), # 0-表示未知,1-不打开遮阳板,2-打开遮阳板
        ("byCopilotSunVisor", BYTE), # 0-表示未知, 1-不打开遮阳板,2-打开遮阳板
        ("byPilotCall", BYTE), #  0-表示未知, 1-不打电话,2-打电话
        # 0-开闸，1-未开闸 (专用于历史数据中相机根据黑白名单匹配后，是否开闸成功的标志)
        ("byBarrierGateCtrlType", BYTE),
        ("byAlarmDataType", BYTE), # 0-实时数据，1-历史数据
        ("struSnapFirstPicTime", NET_DVR_TIME_V30), # 端点时间(ms)（抓拍第一张图片的时间）
        ("dwIllegalTime", DWORD), # 违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
        ("dwPicNum", DWORD), # 图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
        ("struPicInfo", NET_ITS_PICTURE_INFO * 6), # 图片信息,单张回调，最多6张图，由序号区分
        ("struWeightResult", NET_DVR_VEHICLE_WEIGHT_RESULT), # 车辆称重
        ("byRes", BYTE * 256), # 预留
    ]


LPNET_DVR_PLATE_RESULT_V50 = POINTER(NET_DVR_PLATE_RESULT_V50)


class NET_DVR_SUBSYSTEM_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNormalSchedtime", NET_DVR_NORMAL_SCHEDTIME * MAX_DAYS),
        # 日常计划布防时间段
        ("byNormalSchedTimeOn", BYTE), # 日常计划是否启用
        ("byMandatoryAlarm", BYTE), # 0-非强制布防，1-强制布防 指当防区有问题是是否为旁路布防
        ("byRes", BYTE * 254),
    ]


LPNET_DVR_SUBSYSTEM_ALARM = POINTER(NET_DVR_SUBSYSTEM_ALARM)


MAX_WHITELIST_PHONE_NUM = 16
class NET_DVR_MODULE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byModuleType", BYTE), # 外接触发器类型，1-键盘，2-触发器，3-防区 ，4-网络模块
        ("byKeyBoardType", BYTE), # 1-LCD,2-LED
        ("byTriggerType", BYTE), #  1-本地触发器， 2-4路触发器，3-8路触发器，4-单防区触发器，5-32路触发器
        ("byZoneType", BYTE), # 防区类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器
        ("wModuleAddress", WORD), # 外接触发器地址，扩展模块从0~255，0xFFFF表示无效
        ("byRes2", BYTE * 2), # 保留
        ("sModelInfo", CHAR * 32), # 模块信息
        ("sDeviceVersionInfo", CHAR * 32), # 版本信息
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_MODULE_INFO = POINTER(NET_DVR_MODULE_INFO)


class NET_DVR_ALARMHOST_DETECTOR_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDetectorSerialNo", BYTE * 16), # 探测器序列号
        ("dwAlarmIn", DWORD), # 防区号
        ("wDetectorType", WORD), #  探测器类型，DETECTOR_TYPE
        ("byRes", BYTE * 126), # 保留
    ]


LPNET_DVR_ALARMHOST_DETECTOR_INFO = POINTER(NET_DVR_ALARMHOST_DETECTOR_INFO)


class NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40(Structure):
    _fields_ = [
        ("byEnable", BYTE), #  0- 否，1- 是
        ("byRes1", BYTE * 3),
        ("struDate", NET_DVR_SCHEDDATE),
        ("struOutputSchedule", NET_DVR_OUTPUT_SCHEDULE * MAX_TIMESEGMENT_V30),
        ("byTriggerIndex", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 下标表示触发器号，值0-不启用，1-启用
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 = POINTER(NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40)


# 时控输出规则参数
class NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struOutputRule", NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 * MAX_RULE_NUM), # 最多支持8个日期区段的规则配置，对于定时开/关触发器只需要使用一个日期区段就可以了
        ("byRes", BYTE * 64), # 保留
    ]


LPNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40 = POINTER(NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40)


# 单个时控输出规则配置
class NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struOutputRule", NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40),
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40 = POINTER(NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40)


class NET_DVR_ALARM_CAPTRUE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byBeforeAlarmPic", BYTE), # 对应分辨率下可设置报警前图片最大数4CIF：10张，2CIF：20张，CIF：40张，QCIF：80张；WD1:10张,XVGA:10张,720P:10张,1080P:10张
        ("byAfterAlarmPic", BYTE), # 对应分辨率下可设置报警后图片最大数 4CIF：10张，2CIF：20张，CIF：40张，QCIF：80张；WD1:10张,XVGA:10张,720P:10张,1080P:10张
        ("wInterval", WORD), # 间隔时间 单位s
        ("byResolution", BYTE), # 图片分辨率1-CIF，2-2CIF，3-4CIF，4-QCIF，5-WD1，6-VGA,7-XVGA，8-720P，9-1080P
        ("byRes", BYTE * 63), #  保留字节
    ]


LPNET_DVR_ALARM_CAPTRUE_CFG = POINTER(NET_DVR_ALARM_CAPTRUE_CFG)


PRIOR_SCHEDTIME = 30
class NET_DVR_TAMPER_ALARMIN_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byTamperType", BYTE), #  0-无,1-常开，2-常闭
        ("byUploadAlarmRecoveryReport", BYTE), # 是否上传防区报警恢复报告，0-不上传，1-上传
        ("byRes1", BYTE * 2),
        ("byAssociateAlarmOut", BYTE * MAX_ALARMHOST_ALARMOUT_NUM), # 防区关联触发器    BYTE            byAssociateSirenOut[8]        警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
        ("byAssociateSirenOut", BYTE * 8), # 警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
        ("byTamperResistor", BYTE), # 防拆电阻，单位千欧 ， 0-无效 1-2.2 ，2--3.3, 3-4.7 ，4-5.6 ， 5-8.2 ，0xff-自定义
        ("byRes2", BYTE * 3),
        ("fTamperResistorManual", float), # 防拆手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byTamperResistor为0xff时有效
        ("byRes3", BYTE * 36), #  保留字节
    ]


LPNET_DVR_TAMPER_ALARMIN_PARAM = POINTER(NET_DVR_TAMPER_ALARMIN_PARAM)


class NET_DVR_REMOTECONTROLLER_PERMISSION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE),
        ("byRes1", BYTE),
        ("wRemoteCtrllerID", WORD), # 遥控器号 从1开始
        ("sDevSn", BYTE * 16), # 产品序列号
        ("byArmRight", BYTE), # 0-无布防权限，1-有布防权限
        ("byDisArmRight", BYTE), # 0-无撤防权限，1-有撤防权限
        ("byArmReportRight", BYTE), # 0-无传布防报告权限，1-有传布防报告权限
        ("byDisArmReportRight", BYTE), # 0-无上传撤防报告权限，1-有上传撤防报告权限
        ("byClearAlarmRight", BYTE), # 0-无消警权限，1-有消警权限
        ("bySubSystemID", BYTE), #  设备(遥控器)子系统号,1~8
        ("byKeyboardAddr", BYTE), #  接收键盘的地址,在配对时设置
        ("byEnableDel", BYTE), # 删除遥控器用户，0-禁用删除，1-启用删除
        ("byAlwaysOpenRight", BYTE), # 是否允许常开：0-无效，1-不允许，2-允许
        ("byOpeningDirection", BYTE), # 开门方向：0-无效，1-进门方向，2-出门方向
        ("byRes3", BYTE * 2),
        ("byName", BYTE * NAME_LEN), # 遥控器名称
        ("byRes2", BYTE * 28),
    ]


LPNET_DVR_REMOTECONTROLLER_PERMISSION_CFG = POINTER(NET_DVR_REMOTECONTROLLER_PERMISSION_CFG)


class NET_DVR_KEYBOARD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableLock", BYTE), # 是否启用键盘锁定,0--不启用, 1--启用
        ("byErrorTimes", BYTE), # 输入键盘用户密码错误次数（锁定键盘）
        ("wLockTime", WORD), # 锁定键盘时间，单位秒
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_KEYBOARD_CFG = POINTER(NET_DVR_KEYBOARD_CFG)


class NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCommOperatorNum", BYTE * NAME_LEN), # 通信运营商号码
        ("byQueryCode", BYTE * 16), # 业务查询代码
        ("byBusinessType", BYTE), # 业务类型 0-话费，1-流量
        ("byRes", BYTE * 35),
    ]


LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND = POINTER(NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND)


class NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("by3GBusiness", BYTE * 1024), # 3G业务通过短信查询
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO = POINTER(NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO)


class NET_DVR_PREVIEW_DELAY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wdelayTime", WORD), # 延迟预览时间，单位：秒
        ("byRes", BYTE * 130),
    ]


LPNET_DVR_PREVIEW_DELAY_CFG = POINTER(NET_DVR_PREVIEW_DELAY_CFG)


class NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDevNo", DWORD), # 设备号
        ("byDevType", BYTE), # 升级设备类型 0-键盘,1-机芯,2-网络模块,3-路由器 ，4-防区，5-RS485无线扩展模块，6-温控模块，7-电锁模块,8-网口供电模块
        ("byRes", BYTE * 131),
    ]


LPNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM = POINTER(NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM)


class NET_DVR_CALL_ROOM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("nFloorNumber", SHORT), # 层号
        ("wRoomNumber", WORD), # 房间号
        ("byManageCenter", BYTE), # 是否呼叫管理中心
        ("byRes1", BYTE * 3),
        ("byCalledName", BYTE * 64), # 标准sip模式下有效，被叫用户名, 支持数字、字母、“@”和“.”
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_CALL_ROOM_CFG = POINTER(NET_DVR_CALL_ROOM_CFG)


class NET_DVR_VIDEO_CALL_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_VIDEO_CALL_COND = POINTER(NET_DVR_VIDEO_CALL_COND)


# 审讯案件信息
class NET_DVR_INQUEST_CASE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sCaseNo", BYTE * INQUEST_CASE_NO_LEN), # 案件编号
        ("sCaseName", BYTE * INQUEST_CASE_NAME_LEN), # 案件名称；
        ("sCustomInfo1", BYTE * CUSTOM_INFO_LEN), # 自定义信息1；
        ("sCustomInfo2", BYTE * CUSTOM_INFO_LEN), # 自定义信息2；
        ("sCustomInfo3", BYTE * CUSTOM_INFO_LEN), # 自定义信息3
        ("byShowCaseInfoTime", BYTE), #  案件信息显示时间,单位秒, 取值范围1~60秒
        ("byShowCaseInfo", BYTE), # 案件开始是否显示案件信息，0-不显示，1-显示
        ("byPosition", BYTE), # 案件显示位置，0-左上，1-左下
        ("byRes1", BYTE), # 保留
        ("byCustomInfo4", BYTE * CUSTOM_INFO_LEN), # 自定义信息4，案件编号有内容时该字段无效
        ("byCustomInfo5", BYTE * CUSTOM_INFO_LEN), # 自定义信息5，案件名称有内容时该字段无效
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_INQUEST_CASE_INFO = POINTER(NET_DVR_INQUEST_CASE_INFO)


class NET_DVR_CASE_INFO_CTRL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 审讯通道号
        ("byShowCaseInfoTime", BYTE), # 显示持续时间
        ("byRes", BYTE * 131),
    ]


LPNET_DVR_CASE_INFO_CTRL_PARAM = POINTER(NET_DVR_CASE_INFO_CTRL_PARAM)


class NET_DVR_INQUEST_USER_RIGHT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # 数组0: 审讯记录删除权限
        ("byLocalRight", BYTE * MAX_RIGHT), #  本地权限
        # 数组0: 远程音频预览权限
        ("byRemoteRight", BYTE * MAX_RIGHT), #  远程权限
        ("byNetAudioRight", BYTE * MAX_CHANNUM_V40), #  远程音频预览权限，数组下标表示通道，值表示有无权限，0-无权限，1-有权限
        ("byRes", BYTE * 512*9), # 保留9种权限可扩展
    ]


LPNET_DVR_INQUEST_USER_RIGHT_CFG = POINTER(NET_DVR_INQUEST_USER_RIGHT_CFG)


class NET_DVR_INQUEST_MIX_AUDIOIN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用混音，0-不启用，1-启用
        ("byRes1", BYTE * 3), # 保留
        ("dwMixCnt", DWORD), # 混音的通道数
        ("bySrcChan", BYTE * MAX_MIX_CHAN_NUM), # 数组下标表示混音通道号（模拟通道、IP通道）,数值0表示不混，数值1表示混入
        ("byLineIn", BYTE * MAX_LINE_IN_CHAN_NUM), # 数组下标表示混入Line In通道号,数值0表示不混，数值1表示混入
        ("byMic", BYTE * MAX_MIC_CHAN_NUM), # 数组下标表示混入Mic通道号,数值0表示不混，数值1表示混入
        ("byMixAudioDelay", BYTE), # 混音延迟，单位：帧，范围0-63
        ("byRes2", BYTE * 127), # 保留
    ]


LPNET_DVR_INQUEST_MIX_AUDIOIN_CFG = POINTER(NET_DVR_INQUEST_MIX_AUDIOIN_CFG)


class NET_DVR_FACECAPTURE_STATISTICS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("struStartTime", NET_DVR_TIME_EX), # 开始时间
        ("byReportType", BYTE), # 统计报表类型：1-日报表，2-周报表，3-月报表，4-年报表
        ("byStatType", BYTE), # 数据类型统计：Bit0-年龄段，Bit1-性别，Bit2-人数
        ("byEnableProgramStatistics", BYTE), # 是否按节目统计，0-否，1-是
        ("byRes1", BYTE),
        ("dwPlayScheduleNo", DWORD), # 按节目统计时关联的日程号
        ("byRes", BYTE * 120),
    ]


LPNET_DVR_FACECAPTURE_STATISTICS_COND = POINTER(NET_DVR_FACECAPTURE_STATISTICS_COND)


class NET_DVR_AGEGROUP_PARAM(Structure):
    _fields_ = [
        ("dwTeenage", DWORD), # 少年（人数）
        ("dwYouth", DWORD), # 青年（人数）
        ("dwMidLife", DWORD), # 中年（人数）
        ("dwElderly", DWORD), # 老年（人数）
        ("dwChild", DWORD), # 儿童（人数）
        ("dwAdolescent", DWORD), # 青少年（人数）
        ("dwPrime", DWORD), # 壮年（人数）
        ("dwMidage", DWORD), # 中老年（人数）
        ("byRes", BYTE * 48),
    ]


LPNET_DVR_AGEGROUP_PARAM = POINTER(NET_DVR_AGEGROUP_PARAM)


class NET_DVR_FILECOND_MEDICAL(Structure):
    _fields_ = [
        ("lChannel", LONG), # 通道号
        ("dwFileType", DWORD), # 录象文件类型
        # 不带卡号，0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
        # 带卡号，0xff－全部，0－定时录像，1-移动侦测，2－接近报警，3－出钞报警，4－进钞报警，5-命令触发，6－手动录像，7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
        ("dwIsLocked", DWORD), # 是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
        ("dwUseCardNo", DWORD), # 是否使用卡号
        ("sCardNumber", BYTE * 32), # 卡号
        ("struStartTime", NET_DVR_TIME_SEARCH_COND), # 开始时间
        ("struStopTime", NET_DVR_TIME_SEARCH_COND), # 结束时间
        ("szPatientID", CHAR * 64),
        ("dwBigFileType", DWORD), #  0为普通片段搜索，1为大文件搜索
        ("byRes", BYTE * 252),
    ]


LPNET_DVR_FILECOND_MEDICAL = POINTER(NET_DVR_FILECOND_MEDICAL)


class NET_DVR_FIND_PICTURE_MEDICAL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), #  结构体大小
        ("lChannel", LONG), #  通道号
        # 查找的图片类型:0定时抓图1 移动侦测抓图 2 报警抓图，
        # 3 报警 | 移动侦测抓图 4 报警 & 移动侦测抓图 6 手动抓图 ,
        # 9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,
        # 0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，
        # 0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测,
        # 0x13-进入区域侦测,0x14-离开区域侦测,0x15-徘徊侦测,
        # 0x16-人员聚集侦测,0x17-快速运动侦测,0x18-停车侦测,
        # 0x19-物品遗留侦测,0x1a-物品拿取侦测, 0x1b-车牌侦测,
        # 0x1c-混行检测,0x1d-取证事件,0x1e-火点检测,0x1f-防破坏检测,
        # 0x20-船只检测，0x21-测温预警，0x22-测温报警, 0x23测差报警, 0x24违停检测,0x25-人脸抓拍,0x26-离线测温报警,0x2a-起身检测,0x2b-折线攀高,0x2c-如厕超时,0x2d-安全帽检测,0x2e-周界抓拍,0x2f-人体目标抓拍,0x30-人脸抓拍建模, 0x31-混合目标检测,0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询,0x35-非法摆摊,0xff- 全部类型
        ("byFileType", BYTE),
        ("byNeedCard", BYTE), #  是否需要卡号
        #
        # 0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，
        # 8-贵，9-琼，10-冀，11-豫，12-黑，13-鄂，14-湘，
        # 15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，
        # 22-鲁，23-晋，24-陕，25-沪，26-川，27-台，28-津，
        # 29-藏，30-港，31-新，32-云，33-浙，34-皖，0xff-全部
        #
        ("byProvince", BYTE), # 省份索引值
        ("byRes1", BYTE), # 查找结果中是否要求返回人脸坐标信息，0-不返回，1-返回
        ("struStartTime", NET_DVR_TIME), # 查找图片的开始时间
        ("struStopTime", NET_DVR_TIME), #  查找图片的结束时间
        ("szPatientID", CHAR * 64),
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_FIND_PICTURE_MEDICAL_PARAM = POINTER(NET_DVR_FIND_PICTURE_MEDICAL_PARAM)


class NET_DVR_SEXGROUP_PARAM(Structure):
    _fields_ = [
        ("dwMale", DWORD), # 男（人数）
        ("dwFemale", DWORD), # 女（人数）
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SEXGROUP_PARAM = POINTER(NET_DVR_SEXGROUP_PARAM)


class NET_DVR_FACECAPTURE_STATISTICS_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartTime", NET_DVR_TIME_EX), # 间隔开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 间隔结束时间
        ("byStatType", BYTE), # 数据类型统计：Bit0-年龄段有效，Bit1-性别有效，Bit2-人数有效
        ("byRes", BYTE * 7),
        ("dwPeopleNum", DWORD), # 人数统计
        ("struAgeGroupParam", NET_DVR_AGEGROUP_PARAM), # 年龄段人数统计
        ("struSexGroupParam", NET_DVR_SEXGROUP_PARAM), # 性别人数统计
        ("struProgramInfo", NET_DVR_PROGRAM_INFO), # 节目信息
        ("byRes1", BYTE * 76),
    ]


LPNET_DVR_FACECAPTURE_STATISTICS_RESULT = POINTER(NET_DVR_FACECAPTURE_STATISTICS_RESULT)


# 获取交通数据条件结构
class NET_DVR_TRAFFIC_DATA_QUERY_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        #
        # Bit0-通道有效
        # Bit1-时间有效
        # Bit2-车牌号有效
        # Bit3-车牌类型有效
        # Bit4-车牌颜色有效
        # Bit5-车身颜色有效
        # Bit6-车辆类型有效
        # Bit7-车辆品牌有效
        # Bit8-车道号有效
        # Bit9-监测方向有效
        # Bit10-最低速度有效
        # Bit11-最高速度有效
        # Bit12-数据类型有效
        # Bit13-布控方式类型有效
        # Bit14-违法取证有效
        # Bit15-事件类型有效
        # Bit16-取证类型有效
        #
        ("dwQueryCond", DWORD), # 查询条件 0表示无效，1表示有效
        ("dwChannel", DWORD), # 默认是1（[1~32]，bit0表示通道1，依次类推bit31表示通道32）
        ("struStartTime", NET_DVR_TIME_V30), # 开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 结束时间
        ("sLicense", CHAR * MAX_LICENSE_LEN), # (设备支持模糊查询, GB2312编码)
        #
        # Bit0-未知（其他）
        # Bit1-标准民用车与军车
        # Bit2-02式民用车牌
        # Bit3-武警车
        # Bit4-警车
        # Bit5-民用车双行尾牌
        # Bit6-使馆车牌
        # Bit7-农用车
        # Bit8-摩托车
        #
        ("dwPlateType", DWORD), # 车牌类型（支持按位表示，可以复选）
        #
        # Bit0-未知（其他）
        # Bit1-黄色
        # Bit2-白色
        # Bit3-黑色
        # Bit4-绿色
        # Bit5-蓝色
        #
        ("dwPlateColor", DWORD), # 车牌颜色（支持按位表示，可以复选）
        #
        # Bit0-未知（其他）
        # Bit1-白色
        # Bit2-银色
        # Bit3-灰色
        # Bit4-黑色
        # Bit5-红色
        # Bit6-深蓝色
        # Bit7-蓝色
        # Bit8-黄色
        # Bit9-绿色
        # Bit10-棕色
        # Bit11-粉色
        # Bit12-紫色
        # Bit13-深灰色
        #
        ("dwVehicleColor", DWORD), # 车身颜色（支持按位表示，可以复选）
        #
        # Bit0-未知（其他）
        # Bit1-客车
        # Bit2-大货车
        # Bit3-轿车
        # Bit4-面包车
        # Bit5-小货车
        # Bit6-行人
        # Bit7-二轮车
        # Bit8-三轮车
        # Bit9-SUV/MPV
        # Bit10-中型客车
        #
        ("dwVehicleType", DWORD), # 车辆类型（支持按位表示，可以复选）
        # *
        # Bit0-其他（保留）
        # Bit1-低速
        # Bit2-超速
        # Bit3-逆行
        # Bit4-闯红灯
        # Bit5-压车道线
        # Bit6-不按导向
        # Bit7-路口滞留
        # Bit8-机占非
        # Bit9-违法变道
        # Bit10-不按车道
        # Bit11-违反禁令
        # Bit12-路口停车
        # Bit13-绿灯停车
        # Bit14-未礼让行人
        # Bit15-违章停车
        # Bit16-违章掉头
        # Bit17-占用应急车道
        # Bit18-未系安全带
        #
        ("dwIllegalType", DWORD),
        # *
        # Bit0-其他（保留）
        # Bit1-拥堵
        # Bit2-停车
        # Bit3-逆行
        # Bit4-行人
        # Bit5-抛洒物
        # Bit6-烟雾
        # Bit7-压线
        # Bit8-黑名单
        # Bit9-超速
        # Bit10-变道
        # Bit11-掉头
        # Bit12-机占非
        # Bit13-加塞
        #
        ("dwEventType", DWORD),
        # *
        # Bit0-其他（保留）
        # Bit1-城市公路违法停车
        # Bit2-高速公路违法停车
        # Bit3-压线
        # Bit4-逆行
        # Bit5-违法变道
        # Bit6-机占非
        #
        ("dwForensiceType", DWORD),
        ("wVehicleLogoRecog", WORD), # 车辆主品牌，参考"车辆主品牌.xlsx" （仅单选）
        ("byLaneNo", BYTE), # 车道号（0~255,0号车道 表示 车道号未知）
        ("byDirection", BYTE), # 监测方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南
        ("wMinSpeed", WORD), # 最低速度（0~999）单位km/h
        ("wMaxSpeed", WORD), # 最高速度（0~999）单位km/h
        ("byDataType", BYTE), # 数据类型 0-卡口数据，1-违法数据，2-交通事件，3-取证数据 （仅单选）
        ("byExecuteCtrl", BYTE), # 布控 0-白名单，1-黑名单，0xff-其他
        ("byRes", BYTE * 254),
    ]


LPNET_DVR_TRAFFIC_DATA_QUERY_COND = POINTER(NET_DVR_TRAFFIC_DATA_QUERY_COND)


# 交通图片参数子结构
class NET_DVR_TRAFFIC_PICTURE_PARAM(Structure):
    _fields_ = [
        ("struRelativeTime", NET_DVR_TIME_V30), # 抓拍相对时标
        ("struAbsTime", NET_DVR_TIME_V30), # 抓拍绝对时标
        ("szPicName", CHAR * PICTURE_NAME_LEN),
        ("byPicType", BYTE), # 图片类型 0-车牌图，1-抓拍原图，2-合成图，3-特写图
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_TRAFFIC_PICTURE_PARAM = POINTER(NET_DVR_TRAFFIC_PICTURE_PARAM)


# 交通数据结构体
class NET_DVR_TRAFFIC_DATA_QUERY_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 默认是1（[1~32]）
        ("sLicense", CHAR * MAX_LICENSE_LEN),
        #
        # Bit0-未知（其他）
        # Bit1-标准民用车与军车
        # Bit2-02式民用车牌
        # Bit3-武警车
        # Bit4-警车
        # Bit5-民用车双行尾牌
        # Bit6-使馆车牌
        # Bit7-农用车
        # Bit8-摩托车
        #
        ("dwPlateType", DWORD), # 车牌类型
        #
        # Bit0-未知（其他）
        # Bit1-黄色
        # Bit2-白色
        # Bit3-黑色
        # Bit4-绿色
        # Bit5-蓝色
        #
        ("dwPlateColor", DWORD), # 车牌颜色
        #
        # Bit0-未知（其他）
        # Bit1-白色
        # Bit2-银色
        # Bit3-灰色
        # Bit4-黑色
        # Bit5-红色
        # Bit6-深蓝色
        # Bit7-蓝色
        # Bit8-黄色
        # Bit9-绿色
        # Bit10-棕色
        # Bit11-粉色
        # Bit12-紫色
        # Bit13-深灰色
        #
        ("dwVehicleColor", DWORD), # 车身颜色
        #
        # Bit0-未知（其他）
        # Bit1-客车
        # Bit2-大货车
        # Bit3-轿车
        # Bit4-面包车
        # Bit5-小货车
        # Bit6-行人
        # Bit7-二轮车
        # Bit8-三轮车
        # Bit9-SUV/MPV
        # Bit10-中型客车
        # Bit11-机动车
        # Bit12-非机动车
        # Bit13-小型轿车
        # Bit14-微型轿车
        # Bit15-皮卡车
        # Bit16-集装箱卡车
        # Bit17-微卡，栏板卡
        # Bit18-渣土车
        # Bit19-吊车，工程车
        # Bit20-油罐车
        # Bit21-混凝土搅拌车
        # Bit22-平板拖车
        # Bit23-两厢轿车
        # Bit24-三厢轿车
        # Bit25-轿跑
        # Bit26-小型客车
        #
        ("dwVehicleType", DWORD), # 车辆类型
        # *
        # Bit0-其他（保留）
        # Bit1-低速
        # Bit2-超速
        # Bit3-逆行
        # Bit4-闯红灯
        # Bit5-压车道线
        # Bit6-不按导向
        # Bit7-路口滞留
        # Bit8-机占非
        # Bit9-违法变道
        # Bit10-不按车道
        # Bit11-违反禁令
        # Bit12-路口停车
        # Bit13-绿灯停车
        # Bit14-未礼让行人
        # Bit15-违章停车
        # Bit16-违章掉头
        # Bit17-占用应急车道
        # Bit18-未系安全带
        #
        ("dwIllegalType", DWORD),
        # *
        # Bit0-其他（保留）
        # Bit1-拥堵
        # Bit2-停车
        # Bit3-逆行
        # Bit4-行人
        # Bit5-抛洒物
        # Bit6-烟雾
        # Bit7-压线
        # Bit8-黑名单
        # Bit9-超速
        # Bit10-变道
        # Bit11-掉头
        # Bit12-机占非
        # Bit13-加塞
        #
        ("dwEventType", DWORD),
        # *
        # Bit0-其他（保留）
        # Bit1-城市公路违法停车
        # Bit2-高速公路违法停车
        # Bit3-压线
        # Bit4-逆行
        # Bit5-违法变道
        # Bit6-机占非
        #
        ("dwForensiceType", DWORD),
        ("wVehicleLogoRecog", WORD), # 车辆主品牌，参考"车辆主品牌.xlsx"
        ("byLaneNo", BYTE), # 车道号（0~255,0号车道 表示 车道号未知）
        ("byDirection", BYTE), # 监测方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南
        ("wSpeed", WORD), # 速度（0~999）单位km/h
        ("byDataType", BYTE), # 数据类型: 0-卡口 1-违法 2-事件 3-取证
        ("byRes", BYTE * 253),
        ("struTrafficPic", NET_DVR_TRAFFIC_PICTURE_PARAM * MAX_TRAFFIC_PICTURE_NUM),
    ]


LPNET_DVR_TRAFFIC_DATA_QUERY_RESULT = POINTER(NET_DVR_TRAFFIC_DATA_QUERY_RESULT)


# 长连接获取交通流量条件结构
class NET_DVR_TRAFFIC_FLOW_QUERY_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        # *
        # Bit0-通道有效
        # Bit1-时间有效
        # Bit2-车道号有效
        #
        ("dwQueryCond", DWORD), # 查询条件 0-无条件
        ("dwChannel", DWORD), # 默认是1（[1~32]，bit0表示通道1，依次类推bit31表示通道32）
        ("dwResChan", DWORD * 10), # 预留可扩展的通道号
        ("struStartTime", NET_DVR_TIME_V30), # 开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 结束时间
        ("byLaneNo", BYTE), # 车道号（0~255,0号车道 表示 车道号未知）
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_TRAFFIC_FLOW_QUERY_COND = POINTER(NET_DVR_TRAFFIC_FLOW_QUERY_COND)


# 长连接获取交通流量结构
class NET_DVR_TRAFFIC_FLOW_QUERY_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartTime", NET_DVR_TIME_V30), # 开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 结束时间
        ("dwChannel", DWORD), # 默认是1（[1~32]）
        ("dwFlow", DWORD), # 车流量
        ("byLaneNo", BYTE), # 车道号（0~255,0号车道 表示 车道号未知）
        ("byRes", BYTE * 511),
    ]


LPNET_DVR_TRAFFIC_FLOW_QUERY_RESULT = POINTER(NET_DVR_TRAFFIC_FLOW_QUERY_RESULT)


# 图片参数
class NET_DVR_PIC_INFO(Structure):
    _fields_ = [
        ("byPicType", BYTE), # 图片类型，0-jpg
        ("byRes1", BYTE * 3), # 保留
        ("dwPicWidth", DWORD), # 图片宽度
        ("dwPicHeight", DWORD), # 图片高度
        ("dwPicDataLen", DWORD), # 图片数据大小
        ("byPicDataBuff", CHARP), # 图片数据缓冲区
        ("byRes2", BYTE * 32), # 保留
    ]


LPNET_DVR_PIC_INFO = POINTER(NET_DVR_PIC_INFO)


class NET_DVR_VCA_RULE_COLOR_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 规则是否启用， 0-不启用，1-启用
        ("byRuleID", BYTE), # 关联的规则ID
        ("byColorBlockNo", BYTE), # 颜色块序号，从1开始
        ("byRes1", BYTE), # 保留
        ("struPicInfo", NET_DVR_PIC_INFO), # 图片颜色信息
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_VCA_RULE_COLOR_CFG = POINTER(NET_DVR_VCA_RULE_COLOR_CFG)


class NET_DVR_VCA_RULE_COLOR_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD), # 通道号
        ("byRuleID", BYTE), # 关联的规则ID  0表示不关联
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_VCA_RULE_COLOR_COND = POINTER(NET_DVR_VCA_RULE_COLOR_COND)


# LLDP参数
class NET_DVR_LLDP_PORT_CFG(Structure):
    _fields_ = [
        ("byCardNo", BYTE), # 卡号
        ("byPortNo", BYTE), # 端口号
        ("byEnabledTx", BYTE), # 使能发送lldp包，0-不使能，1-使能
        ("byEnabledRx", BYTE), # 使能接收lldp包，0-不使能，1-使能
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_LLDP_PORT_CFG = POINTER(NET_DVR_LLDP_PORT_CFG)


class NET_DVR_LLDP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnabled", BYTE), # 使能LLDP功能，0-不使能，1-使能
        ("byRes1", BYTE * 3),
        ("dwHoldTime", DWORD), # 保持时间，单位：秒
        ("dwReiniTime", DWORD), # 重新初始化时间，单位：秒
        ("dwPacketTime", DWORD), # 打包时间，单位：秒
        ("struLLDPPortCfg", NET_DVR_LLDP_PORT_CFG * MAX_PORT_NUM), # 各端口LLDP参数
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_LLDP_CFG = POINTER(NET_DVR_LLDP_CFG)


# 光纤收发器基本信息
class NET_DVR_CARD_PORT_INFO(Structure):
    _fields_ = [
        ("dwPortNo", DWORD), # 端口号，0-无效
        ("byPortName", BYTE * NAME_LEN), # 端口名
        ("byWorkMode", BYTE), # 工作模式，1-ACCESS，2-TRUNK，3-HYPRID
        ("byBandWidth", BYTE), # 带宽，1-100M，2-1G，3-10G
        ("byPortType", BYTE), # 端口类型，1-电口，2-光口，3-光电复用口
        ("byRes", BYTE * 13),
    ]


LPNET_DVR_CARD_PORT_INFO = POINTER(NET_DVR_CARD_PORT_INFO)


class NET_DVR_NETMGR_CARD_INFO(Structure):
    _fields_ = [
        ("byTypeName", BYTE * NAME_LEN), # 型号名称
        ("bySerialNo", BYTE * SERIALNO_LEN), # 序列号
        ("bySoftwareVersion", BYTE * VERSION_LEN), # 软件版本
        ("struIPAddr", NET_DVR_IPADDR), # IP地址
        ("dwSlotNo", DWORD), # 网管卡槽位号（主槽位）
        ("byStructureType", BYTE), # 结构类型，1-2U，2-4U
        ("byRes1", BYTE * 3),
        ("struNetPortInfo", NET_DVR_CARD_PORT_INFO * MAX_SINGLE_CARD_PORT_NO), # 各网口信息
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_NETMGR_CARD_INFO = POINTER(NET_DVR_NETMGR_CARD_INFO)


class NET_DVR_FUNC_CARD_INFO(Structure):
    _fields_ = [
        ("dwCardNo", DWORD), # 卡号，从1开始
        ("byTypeName", BYTE * NAME_LEN), # 型号名称
        ("bySerialNo", BYTE * SERIALNO_LEN), # 序列号
        ("bySoftwareVersion", BYTE * VERSION_LEN), # 软件版本
        ("dwMainSlot", DWORD), # 主槽位，从1开始
        ("byStructureType", BYTE), # 结构类型，1-2U，2-4U
        ("byRes1", BYTE * 3),
        ("struFuncPortInfo", NET_DVR_CARD_PORT_INFO * MAX_SINGLE_CARD_PORT_NO), # 各端口参数
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_FUNC_CARD_INFO = POINTER(NET_DVR_FUNC_CARD_INFO)


class NET_DVR_FIBER_CONVERT_BASIC(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPowerType", BYTE), # 电源类型，1-单电源，2-双电源
        ("byRes1", BYTE * 3),
        ("dwSlotNum", DWORD), # 网管卡槽位号（主槽位）
        ("struNetCardInfo", NET_DVR_NETMGR_CARD_INFO), # 网管卡信息
        ("struFuncCardInfo", NET_DVR_FUNC_CARD_INFO * MAX_FUNC_CARD_NUM), # 功能卡信息
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_FIBER_CONVERT_BASIC = POINTER(NET_DVR_FIBER_CONVERT_BASIC)


# 光纤收发器工作状态信息
class NET_DVR_CARD_PORT_STATE(Structure):
    _fields_ = [
        ("byValid", BYTE), # 是否有效，0-无效，1-有效
        ("byPortType", BYTE), # 端口类型，1-电口，2-光口，3-光电复用口
        ("byLinkState", BYTE), # 连接状态，0-未连接，1-已连接
        ("byRes1", BYTE),
        ("dwSendBytes", DWORD), # 发送的字节数
        ("dwRecvBytes", DWORD), # 接收数据包数
        ("dwRecvLostPackets", DWORD), # 接收丢包数
        ("dwRecvCrcErrPackets", DWORD), # 接收CRC校验错误包数
        ("dwRecvFragmentPackets", DWORD), # 接收碎片、冲突及过短字节包数（包长度均小于64字节）
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_CARD_PORT_STATE = POINTER(NET_DVR_CARD_PORT_STATE)


class NET_DVR_NET_CARD_STATE(Structure):
    _fields_ = [
        ("struNetPortState", NET_DVR_CARD_PORT_STATE * MAX_SINGLE_CARD_PORT_NO), # 各端口状态
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_NET_CARD_STATE = POINTER(NET_DVR_NET_CARD_STATE)


class NET_DVR_FUNC_CARD_STATE(Structure):
    _fields_ = [
        ("byEnabled", BYTE), # 此结构是否有效，0-无效，1-有效
        ("byRes1", BYTE * 3),
        ("dwCardNo", DWORD), # 卡号
        ("struFuncCardPortState", NET_DVR_CARD_PORT_STATE * MAX_SINGLE_CARD_PORT_NO),
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_FUNC_CARD_STATE = POINTER(NET_DVR_FUNC_CARD_STATE)


class NET_DVR_FIBER_CONVERT_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNetCardState", NET_DVR_NET_CARD_STATE), # 网管卡状态
        ("struFuncCardState", NET_DVR_FUNC_CARD_STATE * MAX_FUNC_CARD_NUM), # 功能卡状态
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_FIBER_CONVERT_STATE = POINTER(NET_DVR_FIBER_CONVERT_STATE)


# 远端网管收发器1.0 基本信息
class NET_DVR_NETMGR_CARD_INFO_V50(Structure):
    _fields_ = [
        ("byMainSlotNo", BYTE), # 网管卡槽位号（主槽位）
        ("byRes1", BYTE * 3),
        ("byTypeName", BYTE * NAME_LEN), # 型号名称
        ("bySerialNo", BYTE * SERIALNO_LEN), # 序列号
        ("bySoftwareVersion", BYTE * VERSION_LEN), # 软件版本
        ("byHardwareVersion", BYTE * VERSION_LEN), # 硬件版本
        ("struIPAddr", NET_DVR_IPADDR), # IP地址
        ("struMask", NET_DVR_IPADDR), # 子网掩码
        ("struGateway", NET_DVR_IPADDR), # 默认网关
        ("byMacAddr", BYTE * 6), # MAC地址
        ("bySlotNums", BYTE), # 槽位数
        ("byStructureType", BYTE), # 结构类型，1-2U，2-4U
        ("struPortInfo", NET_DVR_CARD_PORT_INFO * MAX_SINGLE_CARD_PORT_NO), # 各端口信息
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_NETMGR_CARD_INFO_V50 = POINTER(NET_DVR_NETMGR_CARD_INFO_V50)


class NET_DVR_FUNC_CARD_INFO_V50(Structure):
    _fields_ = [
        ("byCardNo", BYTE), # 接收卡卡号
        ("byMainSlotNo", BYTE), # 接收卡槽位号（主槽位）
        ("byRes1", BYTE * 2),
        ("byTypeName", BYTE * NAME_LEN), # 型号名称
        ("bySerialNo", BYTE * SERIALNO_LEN), # 序列号
        ("bySoftwareVersion", BYTE * VERSION_LEN), # 软件版本
        ("byIsVerMismatch", BYTE), # 软件版本与网管卡中本地存储的软件版本是否一致，0-匹配，!0-不匹配
        ("byRes2", BYTE * 3),
        ("byNewestSoftwareVersion", BYTE * VERSION_LEN), # 最新的软件版本，版本不匹配时有效
        ("byHardwareVersion", BYTE * VERSION_LEN), # 硬件版本
        ("bySlotNums", BYTE), # 槽位数
        ("byStructureType", BYTE), # 结构类型，1-2U，2-4U
        ("byRes3", BYTE * 2),
        ("struPortInfo", NET_DVR_CARD_PORT_INFO * MAX_SINGLE_CARD_PORT_NO), # 各端口信息
        ("byRes4", BYTE * 64),
    ]


LPNET_DVR_FUNC_CARD_INFO_V50 = POINTER(NET_DVR_FUNC_CARD_INFO_V50)


class NET_DVR_REMOTE_SEND_CARD_INFO_V50(Structure):
    _fields_ = [
        ("byCardNo", BYTE), # 卡号，发送机连接的接收卡的卡号
        ("byMainSlotNo", BYTE), # 槽位号，发送机连接的接收卡的主槽位号
        ("byRes1", BYTE * 2),
        ("byTypeName", BYTE * NAME_LEN), # 型号名称
        ("bySoftwareVersion", BYTE * VERSION_LEN), # 软件版本
        ("byIsVerMismatch", BYTE), # 软件版本与网管卡中本地存储的软件版本是否一致，0-匹配，!0-不匹配
        ("byRes2", BYTE * 3),
        ("byNewestSoftwareVersion", BYTE * VERSION_LEN), # 最新的软件版本，版本不匹配时有效
        ("byHardwareVersion", BYTE * VERSION_LEN), # 硬件版本
        ("struPortInfo", NET_DVR_CARD_PORT_INFO * MAX_SINGLE_CARD_PORT_NO), # 各端口信息
        ("byRes3", BYTE * 64),
    ]


LPNET_DVR_REMOTE_SEND_CARD_INFO_V50 = POINTER(NET_DVR_REMOTE_SEND_CARD_INFO_V50)


class NET_DVR_FIBER_CONVERT_BASIC_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPowerType", BYTE), # 电源类型，1-单电源，2-双电源
        ("byRes1", BYTE * 3),
        ("dwSlotNum", DWORD), # 机箱总槽位数
        ("struNetCardInfo", NET_DVR_NETMGR_CARD_INFO_V50), # 网管卡信息
        ("struFuncCardInfo", NET_DVR_FUNC_CARD_INFO_V50 * MAX_FUNC_CARD_NUM), # 接收卡信息
        ("struRemoteSendCardInfo", NET_DVR_REMOTE_SEND_CARD_INFO_V50 * MAX_FUNC_CARD_NUM), # 发送机信息
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_FIBER_CONVERT_BASIC_V50 = POINTER(NET_DVR_FIBER_CONVERT_BASIC_V50)


# 远端网管收发器1.0 状态信息
class NET_DVR_CARD_PORT_STATE_V50(Structure):
    _fields_ = [
        ("byPortNo", BYTE), # 端口号，从1开始
        ("byPortType", BYTE), # 端口类型，1-电口，2-光口，3-光电复用口
        ("byLinkState", BYTE), # 连接状态，0-未连接，1-已连接
        ("byPortSpeed", BYTE), # 带宽，0-无效，1-自动，2-100M，3-1000M，4-10G
        ("byPortDuplexMode", BYTE), # 端口双工模式，0-无效，1-自动，2-全双工，3-半双工
        ("byRes1", BYTE * 3),
        ("byPortName", BYTE * NAME_LEN), # 端口名称
        ("dwSendBytes", DWORD), # 发送的字节数
        ("dwSendByteSpeed", DWORD), # 发送字节速率，单位：bps
        ("dwSendPackets", DWORD), # 发送的字节数
        ("dwSendPacketSpeed", DWORD), # 发包速率，单位：个/秒
        ("dwRecvBytes", DWORD), # 接收的字节数
        ("dwRecvByteSpeed", DWORD), # 接收字节速率，单位：bps
        ("dwRecvPackets", DWORD), # 接收的包数
        ("dwRecvPacketSpeed", DWORD), # 收包速率，单位：个/秒
        ("dwRecvLostPackets", DWORD), # 接收丢包数
        ("dwRecvCrcErrPackets", DWORD), # 接收CRC校验错误包数
        ("dwRecvFragmentPackets", DWORD), # 接收碎片、冲突及过短字节包数（包长度均小于64字节）
        ("byRes2", BYTE * 48),
    ]


LPNET_DVR_CARD_PORT_STATE_V50 = POINTER(NET_DVR_CARD_PORT_STATE_V50)


class NET_DVR_NET_CARD_STATE_V50(Structure):
    _fields_ = [
        ("byMainSlotNo", BYTE), # 网管卡主槽位号
        ("byRes1", BYTE * 3),
        ("struPortState", NET_DVR_CARD_PORT_STATE_V50 * MAX_SINGLE_CARD_PORT_NO), # 网管卡端口状态
        ("byRes2", BYTE * 344),
    ]


LPNET_DVR_NET_CARD_STATE_V50 = POINTER(NET_DVR_NET_CARD_STATE_V50)


class NET_DVR_FUNC_CARD_STATE_V50(Structure):
    _fields_ = [
        ("byCardNo", BYTE), # 接收卡卡号
        ("byMainSlotNo", BYTE), # 接收卡主槽位号
        ("byRes1", BYTE * 2),
        ("struPortState", NET_DVR_CARD_PORT_STATE_V50 * MAX_SINGLE_CARD_PORT_NO), # 接收卡端口状态
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_FUNC_CARD_STATE_V50 = POINTER(NET_DVR_FUNC_CARD_STATE_V50)


class NET_DVR_REMOTE_SEND_CARD_STATE_V50(Structure):
    _fields_ = [
        ("byCardNo", BYTE), # 发送机连接的接收卡的卡号
        ("byMainSlotNo", BYTE), # 发送机连接的接收卡的主槽位号
        ("byRes1", BYTE * 2),
        ("struPortState", NET_DVR_CARD_PORT_STATE_V50 * MAX_SINGLE_CARD_PORT_NO), # 接收卡端口状态
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_REMOTE_SEND_CARD_STATE_V50 = POINTER(NET_DVR_REMOTE_SEND_CARD_STATE_V50)


class NET_DVR_FIBER_CONVERT_STATE_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struNetCardState", NET_DVR_NET_CARD_STATE_V50), # 网管卡状态
        ("struFuncCardState", NET_DVR_FUNC_CARD_STATE_V50 * MAX_FUNC_CARD_NUM), # 接收卡状态
        ("struRemoteSendCardState", NET_DVR_REMOTE_SEND_CARD_STATE_V50 * MAX_FUNC_CARD_NUM), # 发送机状态
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FIBER_CONVERT_STATE_V50 = POINTER(NET_DVR_FIBER_CONVERT_STATE_V50)


# 光纤收发器拓扑信息
class NET_DVR_FC_PORT_TOPOLOGY(Structure):
    _fields_ = [
        ("dwPortNo", DWORD), # 端口号，0-无效，非0为功能卡端口号
        ("byPortType", BYTE), # 端口类型，1-电口，2-光口，3-光电复用口
        ("byLocalWorkMode", BYTE), # 本地工作模式，1-ACCESS，2-TRUNK，3-HYPRID
        ("byLocalBandWidth", BYTE), # 本地带宽，1-100M，2-1G，3-10G
        ("byRes1", BYTE * 1),
        ("byPeerTypeName", BYTE * NAME_LEN), # 对端设备类型名称
        ("byPeerMac", BYTE * MACADDR_LEN), # 对端MAC地址
        ("dwPeerPortNo", DWORD), # 对端端口号
        ("byPeerWorkMode", BYTE), # 对端工作模式，1-ACCESS，2-TRUNK，3-HYPRID
        ("byPeerBandWidth", BYTE), # 对端带宽，1-100M，2-1G，3-10G
        ("byRes2", BYTE * 30),
    ]


LPNET_DVR_FC_PORT_TOPOLOGY = POINTER(NET_DVR_FC_PORT_TOPOLOGY)


class NET_DVR_FC_CARD_TOPOLOGY(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 此结构体是否有效，0-无效，非0-有效
        ("byRes1", BYTE * 3),
        ("dwCardNo", DWORD), # 卡号，0-网管卡，大于0-功能卡
        ("dwSlotNum", DWORD), # 卡占用的槽位数
        ("byTypeName", BYTE * NAME_LEN), # 卡类型名称
        ("byLocalMac", BYTE * MACADDR_LEN), # 本地MAC地址
        ("struFCPortTopology", NET_DVR_FC_PORT_TOPOLOGY * MAX_SINGLE_CARD_PORT_NO), # 各端口拓扑信息
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_FC_CARD_TOPOLOGY = POINTER(NET_DVR_FC_CARD_TOPOLOGY)


class NET_DVR_FIBER_CONVERT_TOPOLOGY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struFCCardTopology", NET_DVR_FC_CARD_TOPOLOGY * MAX_FC_CARD_NUM), # 各卡拓扑信息
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FIBER_CONVERT_TOPOLOGY = POINTER(NET_DVR_FIBER_CONVERT_TOPOLOGY)


# 光纤收发器端口注释信息
class NET_DVR_FC_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSlotNo", DWORD), # 槽位号
        ("dwPortNo", DWORD), # 端口号
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_FC_COND = POINTER(NET_DVR_FC_COND)


class NET_DVR_FC_PORT_REMARKS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLocalRemarks", BYTE * MAX_REMARKS_LEN), # 本地端口注释信息
        ("byPeerRemarks", BYTE * MAX_REMARKS_LEN), # 对端端口注释信息
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_FC_PORT_REMARKS = POINTER(NET_DVR_FC_PORT_REMARKS)


FC_OPTICAL_PORT_LOST = 1
FC_ELECTRICAL_PORT_LOST = 2
FC_FUNC_CARD_LOST = 3
FC_CARD_DISCONNECTED = 4
FC_MAX_TEMP_LIMITED = 5
FC_MIN_TEMP_LIMITED = 6
FC_MAX_VOLTAGE_LIMITED = 7
FC_MIN_VOLTAGE_LIMITED = 8


FC_OPTICAL_PORT_CONNECTED = 1
FC_ELECTRICAL_PORT_CONNECTED = 2
FC_FUNC_CARD_INSERT = 3
FC_CARD_CONNECTED = 4
FC_TEMP_RECOVERY = 5
FC_VOLTAGE_RECOVERY = 6


class NET_DVR_FIBER_CONVERT_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEventType", DWORD), # 事件类型，1-告警，2-通知
        ("dwEvent", DWORD), # 具体事件，告警时参考枚举FIBER_CONVERT_ALARM，通知时参考枚举FIBER_CONVERT_NOTIFICATION
        ("bySlotNum", BYTE), # 槽位号，当卡类型为发送机时，槽位号为该发送机连接的接收卡的槽位号，机箱告警及通知时无效
        ("byCardType", BYTE), # 卡类型，0-无效，1-网管卡，2-接收卡，3-发送机，4-机箱
        ("byPortNo", BYTE), # 端口号，从1开始，机箱告警及通知时无效
        ("byCurTemperature", BYTE), # 触发事件的温度，温度告警及通知时有效，单位：摄氏度
        ("wCurVoltage", WORD), # 触发事件的电压（实际电压*10），电压告警及通知时有效，单位：伏特
        ("byRes1", BYTE * 30),
    ]


LPNET_DVR_FIBER_CONVERT_ALARM = POINTER(NET_DVR_FIBER_CONVERT_ALARM)


# 交换机告警事件上传
SC_OPTICAL_PORT_LOST = 1
SC_NETWORK_PORT_LOST = 2
SC_WIRELESS_SPEED_UP_EXCEPTION = 3
SC_WIRELESS_SHUTDOWN = 4
SC_DEVICE_POE_MAX = 5
SC_PORT_POE_POWER_OFF = 6


SC_OPTICAL_PORT_CONNECTED = 1
SC_NETWORK_PORT_CONNECTED = 2
SC_DEVICE_POE_MAX_RECOVERY = 3
SC_PORT_POE_POWER_ON = 4
SC_WIRELESS_CONNECTED = 5


class NET_DVR_SWITCH_CONVERT_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPortNo", BYTE), # 接口索引，从1开始
        ("byRes1", BYTE * 3),
        ("dwEventType", DWORD), # 事件类型，1-告警，2-通知
        ("dwEvent", DWORD), # 具体事件，告警时参考枚举EN_SWITCH_CONVERT_ALARM，通知时参考枚举EN_SWITCH_CONVERT_NOTIFICATION
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_SWITCH_CONVERT_ALARM = POINTER(NET_DVR_SWITCH_CONVERT_ALARM)


class NET_DVR_SWITCH_LAMP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 规则是否启用， 0-不启用，1-启用
        ("byTriggerMode", BYTE), #  1-持续触发，2-单次触发
        ("byUploadPic", BYTE), # 0-不上传图片，1-上传图片
        ("byRes1", BYTE), # 保留
        ("dwTimeInterval", DWORD), # 持续触发报警时间间隔，范围[0,3600]，单位：秒
        ("struHandleType", NET_DVR_HANDLEEXCEPTION_V30), # 处理方式
        ("byRelRecordChan", BYTE * MAX_IVMS_IP_CHANNEL), # 报警触发的录象通道：1表示触发该通道；0表示不触发
        ("struAlarmTime", NET_DVR_SCHEDTIME * MAX_DAYS), # 检测时间
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_SWITCH_LAMP_CFG = POINTER(NET_DVR_SWITCH_LAMP_CFG)


class NET_DVR_SWITCH_LAMP_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struDevInfo", NET_VCA_DEV_INFO), # 设备信息
        ("struTime", NET_DVR_TIME_EX), # 报警时间
        ("byLampStatus", BYTE), # 开关灯状态，0-已关闭  1-已打开
        ("byRes1", BYTE * 3), # 保留
        ("dwPicDataLen", DWORD), # 图片数据长度，非0表示有图片上传
        ("pPicData", CHARP), # 图片数据
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SWITCH_LAMP_ALARM = POINTER(NET_DVR_SWITCH_LAMP_ALARM)


# 防护舱级联配置
class NET_DVR_RS485_CASCADE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDevAddr", BYTE), # 设备地址，0-主机，1-15为从机
        ("byRes", BYTE * 131),
    ]


LPNET_DVR_RS485_CASCADE_CFG = POINTER(NET_DVR_RS485_CASCADE_CFG)


# 私有关键信息上传配置
class NET_DVR_PRIVATE_PROTOCOL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIP", NET_DVR_IPADDR), # 消息上传的IP地址
        ("wPort", WORD), # 消息上传的端口号
        ("byEnable", BYTE), # 使能,  0-保留，1-不启用，2-启用
        ("byRes", BYTE),
        ("dwInterval", DWORD), # 消息上传间隔(0-无时间间隔限制，以设备为准 >=0,以秒为单位的时间间隔)
        ("byServerType", BYTE), # 服务类型 0-无，1-公安
        ("byEcryptedSMSEnable", BYTE), # 0-不加密，1-加密
        ("byAlgorithm", BYTE), # 加密算法，0-无，1-RSA
        ("byAcauisitionMode", BYTE), # 采集模式，0-基本信息，1-虚拟身份信息，2-基本信息+虚拟身份信息
        ("dwDistanceLimit", DWORD), # 距离限制，单位：m
        ("byPKModeEnable", BYTE), # PK模式使能,  0-保留，1-不启用，2-启用
        ("byMACAddrReductionEnable", BYTE), # MAC地址还原使能,  0-保留，1-不启用，2-启用
        ("byRes1", BYTE * 214),
        ("szIndexCode", CHAR * MAX_INDEX_CODE_LEN),
        ("dwSecretKeyLen", DWORD), # 秘钥长度
        ("szSecretKey", CHAR * MAX_SECRETKEY_LEN), # 秘钥
    ]


LPNET_DVR_PRIVATE_PROTOCOL_CFG = POINTER(NET_DVR_PRIVATE_PROTOCOL_CFG)


# 调试命令
class NET_DVR_DEBUG_CMD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szDebugCMD", CHAR * MAX_DEBUGCMD_LEN),
        ("byRes", BYTE * 400),
    ]


LPNET_DVR_DEBUG_CMD = POINTER(NET_DVR_DEBUG_CMD)


# 调试信息
class NET_DVR_DEBUG_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szDebugInfo", CHAR * MAX_DEBUGINFO_LEN),
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DEBUG_INFO = POINTER(NET_DVR_DEBUG_INFO)


MAX_SSID_LEN = 32 # SSID号长度
MAX_WS_PASSWD_LEN = 64 # 密码长度
class NET_DVR_WIRELESSSERVER(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byWLanShare", BYTE), # WLan热点使能 0-关闭，1-使能
        ("byBroadcastSSID", BYTE), # SSID广播使能 0-关闭，1-使能
        ("bySecurityMode", BYTE), # 安全模式 0- not-encrypted，1-WPA，2-WPA2(暂时只支持2)
        ("byAlgorithmType", BYTE), # 加密模式 1-TKIP，2-AES
        ("szSSID", CHAR * MAX_SSID_LEN), # SSID号信息
        ("szPassWord", CHAR * MAX_WS_PASSWD_LEN),
        ("byDefaultPassword", BYTE), # 是否是默认密码 0-否，1-是
        ("byWifiApModeType", BYTE), # 启用WlanAP热点模式，0-关闭，1-开启，2-自动
        ("byRes", BYTE * 254),
    ]


LPNET_DVR_WIRELESSSERVER = POINTER(NET_DVR_WIRELESSSERVER)


class NET_DVR_CONNECTDEV_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CONNECTDEV_COND = POINTER(NET_DVR_CONNECTDEV_COND)


class NET_DVR_CONNECTDEV_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byID", BYTE), # 序列号
        ("byRes", BYTE * 1),
        ("byMACAddr", BYTE * MACADDR_LEN), #  物理地址
        ("struDVRIP", NET_DVR_IPADDR), # 设备IP
        ("struConnectTime", NET_DVR_TIME), # 接入时间
        ("byRes1", BYTE * 256),
    ]


LPNET_DVR_CONNECTDEV_CFG = POINTER(NET_DVR_CONNECTDEV_CFG)


class NET_DVR_GIS_SERVER_INFO(Structure):
    _fields_ = [
        ("byUserName", BYTE * NAME_LEN),
        ("byPassword", BYTE * PASSWD_LEN),
        ("struServerIP", NET_DVR_IPADDR), # GIS服务器IP地址
        ("wPort", WORD), # GIS服务器端口
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_GIS_SERVER_INFO = POINTER(NET_DVR_GIS_SERVER_INFO)


class NET_DVR_BASEMAP_CONTROL_CFG_V40(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否显示，1-显示，0-隐藏
        ("byBaseMapType", BYTE), # 底图类型，1-图片底图，2-超高清输入底图，3-GIS底图
        ("byRes1", BYTE * 2),
        ("dwBaseMapNo", DWORD), # 底图号；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入口号（1字节矩阵号+1字节子板号+1字节输入口号+1字节保留）
        ("struGisServer", NET_DVR_GIS_SERVER_INFO), # GIS服务器信息,当底图类型为GIS底图时有效
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_BASEMAP_CONTROL_CFG_V40 = POINTER(NET_DVR_BASEMAP_CONTROL_CFG_V40)


class NET_DVR_VIDEO_IMG_DB_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # NET_DVR_VIDEO_IMG_DB_CFG结构体大小
        ("i64Capacity", INT64), # 视图库总容量，低位，单位：MB
        ("i64UsedSpace", INT64), # 只读，已用空间，低位，单位：MB
        ("i64AvailableSpace", INT64), # 只读，可用空间，低位，单位：MB
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_VIDEO_IMG_DB_CFG = POINTER(NET_DVR_VIDEO_IMG_DB_CFG)


class NET_DVR_FILE_QUERY_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # NET_DVR_FILE_QUERY_INFO结构体大小
        ("i64FileLen", INT64), # 文件大小
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_FILE_QUERY_INFO = POINTER(NET_DVR_FILE_QUERY_INFO)


class NET_DVR_FILE_INFO_IN(Structure):
    _fields_ = [
        ("szFileID", CHAR * MAX_FILE_ID_LEN), # 上传之后，设备分配的文件ID
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_FILE_INFO_IN = POINTER(NET_DVR_FILE_INFO_IN)


class NET_DOWNLOAD_CB_INFO(Structure):
    _fields_ = [
        ("dwType", DWORD), # 类型, 0-数据信息,1-单个图片信息(云存储批量下载),2-图片总体信息(云存储批量下载)
        ("*pData", BYTE), # 数据指针
        ("dwDataLen", DWORD), # 数据长度
        ("pFileInfo", VOIDP), # 文件信息结构体(云存储批量下载时有效)
        ("dwFileInfoLen", DWORD), # 文件信息结构体长度(云存储批量下载时有效)
        ("byRes", BYTE * 120), # 保留
    ]


LPNET_DOWNLOAD_CB_INFO = POINTER(NET_DOWNLOAD_CB_INFO)


class NET_DVR_DOWNLOAD_CB_PARAM(Structure):
    _fields_ = [
        ("fnDownloadDataCB", DOWNLOAD_DATA_CB), # 下载数据回调函数
        ("*pUserData", void), # 用户参数, 在fnPreviewDataCB回调出来
        ("i64Offset", INT64), # 下载文件的偏移量，用于断点续传
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_DOWNLOAD_CB_PARAM = POINTER(NET_DVR_DOWNLOAD_CB_PARAM)


class NET_DVR_UPLOAD_DB_IN(Structure):
    _fields_ = [
        ("i64FileLen", INT64), # 上传新文件，需要给出文件长度，文件续传可以不给
        ("byContinueUpload", BYTE), # 0-新文件上传，1-老文件续传，文件名必须给出
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_UPLOAD_DB_IN = POINTER(NET_DVR_UPLOAD_DB_IN)


class NET_DVR_UPLOAD_DB_OUT(Structure):
    _fields_ = [
        ("szFileID", CHAR * MAX_FILE_ID_LEN), # 上传之后，设备分配的文件ID
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_UPLOAD_DB_OUT = POINTER(NET_DVR_UPLOAD_DB_OUT)


class NET_DVR_SEND_PARAM_IN(Structure):
    _fields_ = [
        ("*pSendData", BYTE), # 发送的缓冲区,PicURL == 1 的时候，内存中存储的是 URL 字符串,byUploadModeling == 1 的时候，内存中存储的是 建模base64加密数据
        ("dwSendDataLen", DWORD), # 发送数据长度,PicURL == 1 的时候，表示的 URL 字符串的长度,byUploadModeling == 1 的时候，表示为建模数据base64后的加密长度
        ("struTime", NET_DVR_TIME_V30), # 图片时间
        ("byPicType", BYTE), # 图片格式,1-jpg,2-bmp,3-png,4-SWF,5-GIF
        ("byPicURL", BYTE), # 图片数据采用URL方式 0-二进制图片数据，1-图片数据走URL方式
        # 是否上传建模数据；
        # 0-	二进制图片数据方式(pSendData指向二进制图片数据, dwPicDataLen为图片二进制数据长度)，
        # 1-	直接上传建模数据(pSendData指向建模base64加密数据, dwPicDataLen为建模数据base64后的加密长度)。
        # 注：建模数据采用base64加密方式,选择为建模数据上传后，byPicURL 无需。
        # 当”/ISAPI/Intelligent/channels/<ID>/faceContrast/capabilities”能力中返回isSupportUploadModeling能力节点时，支持上传建模数据.
        ("byUploadModeling", BYTE),
        ("byRes1", BYTE),
        ("dwPicMangeNo", DWORD), # 图片管理号
        ("sPicName", BYTE * NAME_LEN), # 图片名称
        ("dwPicDisplayTime", DWORD), # 图片播放时长，单位秒
        ("*pSendAppendData", BYTE), # 发送图片的附加信息缓冲区，对应FaceAppendData 的XML描述；
        ("dwSendAppendDataLen", DWORD), # 发送图片的附加信息数据长度  FaceAppendData  XML的长度；
        ("byRes", BYTE * 192),
    ]


LPNET_DVR_SEND_PARAM_IN = POINTER(NET_DVR_SEND_PARAM_IN)


class NET_DVR_DOWNLOAD_QOS(Structure):
    _fields_ = [
        ("dwMaxSpeed", DWORD), # 流控最大速度，单位kbps
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_DOWNLOAD_QOS = POINTER(NET_DVR_DOWNLOAD_QOS)


NET_SDK_MAX_FILE_NAME = 100 # 最大文件名称
class NET_DVR_UPLOAD_FILEVOLUME_PRARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFileType", BYTE), # 文件类型 0-录像，1-音频
        ("byFileVolnumeID", BYTE), # 文件卷ID（可以通过NET_DVR_GET_HDVOLUME_CFG 获取）
        ("byArchive", BYTE), # 0-不归档，1-归档
        ("byRes1", BYTE),
        ("dwFileSize", DWORD), # 文件大小
        ("szFileName", CHAR * NET_SDK_MAX_FILE_NAME), # 文件名称
        ("byRes", BYTE * 300),
    ]


LPNET_DVR_UPLOAD_FILEVOLUME_PRARAM = POINTER(NET_DVR_UPLOAD_FILEVOLUME_PRARAM)


class NET_DVR_DOWNLOAD_FILEVOLUME_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sUrl", BYTE * MAX_UPLOADFILE_URL_LEN), # url
        ("byRes", BYTE * 248),
        ("fnDownloadDataCB", DOWNLOAD_DATA_CB), # 下载数据回调函数
        ("*pUserData", void), # 用户参数, 在fnPreviewDataCB回调出来
    ]


LPNET_DVR_DOWNLOAD_FILEVOLUME_PARAM = POINTER(NET_DVR_DOWNLOAD_FILEVOLUME_PARAM)


# 电影模式参数
class NET_DVR_FILM_MODE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byScreenType", BYTE), # 画面类型，0-单画面，1-两画面，2-画中画
        ("byRes", BYTE * 255), # 保留
    ]


LPNET_DVR_FILM_MODE_CFG = POINTER(NET_DVR_FILM_MODE_CFG)


# 导播策略配置
class NET_DVR_DIRECTED_STRATEGY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byDirectedStrategyType", BYTE), # 导播策略类型，0-常态导播策略，1-精品导播策略,2-精品导播1替2,3-精品导播策略1替3
        ("byRes", BYTE * 255), # 保留
    ]


LPNET_DVR_DIRECTED_STRATEGY_CFG = POINTER(NET_DVR_DIRECTED_STRATEGY_CFG)


# 边框子结构
# 配置画面边框
class NET_DVR_FRAME_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struTopFrame", NET_DVR_FRAME), # 上边框
        ("struBottomFrame", NET_DVR_FRAME), # 下边框
        ("struLeftFrame", NET_DVR_FRAME), # 左边框
        ("struRightFrame", NET_DVR_FRAME), # 右边框
        ("byFrameEnable", BYTE), # 叠加边框0-不叠加1-叠加边框
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_FRAME_CFG = POINTER(NET_DVR_FRAME_CFG)


# 配置画面边框条件
class NET_DVR_FRAME_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPicNo", DWORD), # 画面编号
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_FRAME_COND = POINTER(NET_DVR_FRAME_COND)


# 音频优化参数
class NET_DVR_AUDIO_EFFECTIVE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwCheckDelay", DWORD), # 检测时延，单位s，0表示不自动优化
        ("byThreshold", BYTE), # 阈值[0,100]
        ("byVolumePercent", BYTE), # 音量 [0,100]
        ("byPriority", BYTE), # 等级，[0，100]
        ("byRes", BYTE * 301),
    ]


LPNET_DVR_AUDIO_EFFECTIVE_CFG = POINTER(NET_DVR_AUDIO_EFFECTIVE_CFG)


# 录制视频参数
class NET_DVR_RECORD_VIDEO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byExportType", BYTE), # 阈值0-MP4 1-AVI
        ("byRes", BYTE * 255), # 保留字节
    ]


LPNET_DVR_RECORD_VIDEO_CFG = POINTER(NET_DVR_RECORD_VIDEO_CFG)


# RTMP Cond
class NET_DVR_RTMP_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byStreamType", BYTE), # 码流类型，1-主码流，2-子码流，3-码流三
        ("byRes", BYTE * 303),
    ]


LPNET_DVR_RTMP_COND = POINTER(NET_DVR_RTMP_COND)


# RTMP Cfg
class NET_DVR_RTMP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用RTMP，0-不启用，1-启用
        ("byRes1", BYTE * 3),
        ("dwPacketLen", DWORD), # RTMP包长
        ("szURL", CHAR * RTMP_URL_LEN), # RTMP URL
        ("byRes", BYTE * 256), # 保留字节
    ]


LPNET_DVR_RTMP_CFG = POINTER(NET_DVR_RTMP_CFG)


# 文件发布
class NET_DVR_RECORDING_PUBLISH_FILE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byFileID", BYTE * MAX_ID_LEN_128), # 发布文件ID
        ("struStartTime", NET_DVR_TIME_EX), # 课程开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 课程结束时间
        ("byCmdType", BYTE), # 发布命令类型  1--开始发布 2--取消发布
        ("byFileType", BYTE), # 发布文件类型  0—保留 1—定时课程 2—手动课程
        ("byRes", BYTE * 254),
    ]


LPNET_DVR_RECORDING_PUBLISH_FILE_CFG = POINTER(NET_DVR_RECORDING_PUBLISH_FILE_CFG)


# 文件发布进度条件
class NET_DVR_PUBLISH_PROGRESS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byFileID", BYTE * MAX_ID_LEN_128), # 发布文件ID
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_PUBLISH_PROGRESS_COND = POINTER(NET_DVR_PUBLISH_PROGRESS_COND)


# 文件发布进度参数
class NET_DVR_PUBLISH_PROGRESS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byPublishPercent", BYTE), # 发布百分比 0-100
        ("byPublishStatus", BYTE), # 发布状态  0-发布成功 1--正在发布 2--等待发布 3-连不上FTP  4--没有找到此文件 5--发布失败（其他错误）
        ("byRes", BYTE * 302),
    ]


LPNET_DVR_PUBLISH_PROGRESS_CFG = POINTER(NET_DVR_PUBLISH_PROGRESS_CFG)


# 删除视图库中的文件
class NET_DVR_BACKGROUND_PIC_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szFileID", CHAR * MAX_ID_LEN_128), # 上传之后，设备分配的文件ID, 指背景图片名
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_BACKGROUND_PIC_COND = POINTER(NET_DVR_BACKGROUND_PIC_COND)


# 查询背景图片文件
class NET_DVR_BACKGROUND_PIC_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwPicSize", DWORD), # 背景图片大小
        ("dwPicType", DWORD), # 图片类型，YUV:0 JPEG:1
        ("wPicWidth", WORD), # 图片宽
        ("wPicHeight", WORD), # 图片高
        ("byPicName", BYTE * MAX_PIC_NAME_LEN), # 图片名称
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_BACKGROUND_PIC_CFG = POINTER(NET_DVR_BACKGROUND_PIC_CFG)


class NET_DVR_BACKGROUND_PIC_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用背景图片叠加，0-否，1-是
        ("byRes1", BYTE * 3),
        ("byPicID", BYTE * MAX_ID_LEN_128),
        ("byRes", BYTE * 300), # 保留
    ]


LPNET_DVR_BACKGROUND_PIC_INFO = POINTER(NET_DVR_BACKGROUND_PIC_INFO)


# 上传背景图片文件
class NET_DVR_BACKGROUND_PIC_PRARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 导播通道
        ("dwPicSize", DWORD), # 背景图片大小
        ("wPicWidth", WORD), # 图片宽
        ("wPicHeight", WORD), # 图片高
        ("szPicName", CHAR * MAX_PIC_NAME_LEN), # 图片名称
        ("byPicType", BYTE), # 图片类型，YUV:0 JPEG:1
        ("byRes", BYTE * 303),
    ]


LPNET_DVR_BACKGROUND_PIC_PRARAM = POINTER(NET_DVR_BACKGROUND_PIC_PRARAM)


# 低功耗配置
class NET_DVR_LOWPOWER(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byMode", BYTE), # 补光灯模式 0-手动，1-定时
        ("byEnabled", BYTE), # 手动模式下的使能开关 0-关闭，1-开启
        ("byRes", BYTE * 6),
        ("struSchedTime", NET_DVR_SCHEDULE_DAYTIME), # 定时时间段
        ("byRes1", BYTE * 256),
    ]


LPNET_DVR_LOWPOWER = POINTER(NET_DVR_LOWPOWER)


class NET_DVR_POINT(Structure):
    _fields_ = [
        ("dwX", DWORD), # X轴坐标
        ("dwY", DWORD), # Y坐标
    ]


LPNET_DVR_POINT = POINTER(NET_DVR_POINT)


# 变倍联动配置
class NET_DVR_ZOOMLINKAGE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 使能 0-关，1-开
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_ZOOMLINKAGE = POINTER(NET_DVR_ZOOMLINKAGE)


class NET_DVR_ONLINEUPGRADE_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byUpgradeStatus", BYTE), # 0-未开始升级,1-正在升级,2-升级成功,3-包语言不匹配,4-写falsh失败,5-包类型不匹配,6-包版本不匹配,7-网络不可达,8-升级服务器出错,
        # 9-读取升级包文件出错,10-没有找到升级文件,11-升级文件有错,12-设备内存不足,0xff-未知错误
        ("byProgress", BYTE), # 升级进度,0~100
        ("byRes", BYTE * 250),
    ]


LPNET_DVR_ONLINEUPGRADE_STATUS = POINTER(NET_DVR_ONLINEUPGRADE_STATUS)


class NET_DVR_FIRMWARECODE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwStartIndex", DWORD), # 起始索引号
        ("dwMaxNum", DWORD), # 单次最大个数，32
        ("byRes", BYTE * 52),
    ]


LPNET_DVR_FIRMWARECODE_COND = POINTER(NET_DVR_FIRMWARECODE_COND)


class NET_DVR_FIRMWARECODE(Structure):
    _fields_ = [
        ("wIndex", WORD),
        ("wCodeLen", WORD), # 识别码长度，上层应用开发的时候做一个判断，如果本字段大于128，请报错，提示用户更新工具/客户端版本
        ("byCode", BYTE * MAX_IDCODE_LEN), # 识别码
        ("byVersion", BYTE * MAX_VERSIIN_LEN), # 版本
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_FIRMWARECODE = POINTER(NET_DVR_FIRMWARECODE)


class NET_DVR_FIRMWARECODE_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwValidCodeNum", DWORD), # 有效个数
        ("struCode", NET_DVR_FIRMWARECODE * MAX_IDCODE_NUM),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FIRMWARECODE_LIST = POINTER(NET_DVR_FIRMWARECODE_LIST)


class NET_DVR_ONLINEUPGRADE_SERVER(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byConnectStatus", BYTE), # 0-未连接,1-已连接
        ("byRes", BYTE * 1019),
    ]


LPNET_DVR_ONLINEUPGRADE_SERVER = POINTER(NET_DVR_ONLINEUPGRADE_SERVER)


class NET_DVR_ONLINEUPGRADE_VERSION_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCheckFromSvr", BYTE), # 是否需要从服务器检测，0-不需要，仅返回设备周期性检查的结果1-需要，设备会即时连接服务器检测是否有新版本
        ("byRes", BYTE * 59),
    ]


LPNET_DVR_ONLINEUPGRADE_VERSION_COND = POINTER(NET_DVR_ONLINEUPGRADE_VERSION_COND)


class NET_DVR_ONLINEUPGRADE_VERSION_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byNewVersionAvailable", BYTE), # 是否有新版本,0-否,1-是
        ("byNewVersion", BYTE * MAX_VERSIIN_LEN), # 新版本的版本号
        ("byChangeLog", BYTE * SDK_LEN_2048), # 新版本更新的内容
        ("byRes", BYTE * 971),
    ]


LPNET_DVR_ONLINEUPGRADE_VERSION_RET = POINTER(NET_DVR_ONLINEUPGRADE_VERSION_RET)


class NET_DVR_RECOMMEN_VERSION_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFirmwareCode", BYTE * MAX_IDCODE_LEN),
        ("byFirmwareVersion", BYTE * MAX_VERSIIN_LEN),
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_RECOMMEN_VERSION_COND = POINTER(NET_DVR_RECOMMEN_VERSION_COND)


class NET_DVR_RECOMMEN_VERSION_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRecommenUpgrade", BYTE), # 推荐升级,0-否,1-是
        ("byRes", BYTE * 123),
    ]


LPNET_DVR_RECOMMEN_VERSION_RET = POINTER(NET_DVR_RECOMMEN_VERSION_RET)


# 温湿度配置
class NET_DVR_THSCREEN(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 启用定时使能
        ("byTHOSDDisplay", BYTE), # 温湿度显示OSD显示是否启用,  0-否，1-是
        ("byRes", BYTE * 2), #  保留字节
        ("struTHOSDPoint", NET_VCA_POINT), # 温湿度显示OSD显示左上角坐标
        ("byTimingMode", BYTE), # 校时模式 0-手动，1-自动
        ("byRes1", BYTE),
        ("wInterval", WORD), # 校时定时模式下，间隔时间设置[1,10080]m
        ("byRes2", BYTE * 254),
    ]


LPNET_DVR_THSCREEN = POINTER(NET_DVR_THSCREEN)


class NET_DVR_SENSOR_ADJUSTMENT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byType", BYTE), # 调整模式：0-上下，1-左右，2-旋转，3-图像视场角，4-RGB调整, 5-亮度, 6-RGB_Ex调整
        ("bySensorNo", BYTE), # Sensor 号[1,8]
        ("byRes", BYTE * 2),
        ("iAdjustMentRange", int), # 调整幅度 [-100,100] 旋转的时候[-30,30] 图像视场角[-10,10]
        ("byR", BYTE), # RGB参数，R（红色），范围0-100
        ("byG", BYTE), # RGB参数，G（绿色），范围0-100
        ("byB", BYTE), # RGB参数，B（蓝色），范围0-100
        ("byRgbType", BYTE), # RGB类型，0-保留，1-产线模式，2-手动模式
        ("byBrightness", BYTE), # 亮度，范围0-100,默认值50
        ("byRes1", BYTE * 3),
        ("wRex", WORD), # RGB参数(扩展)，R（红色），范围0-2048
        ("wGex", WORD), # RGB参数(扩展)，G（绿色），范围0-2048
        ("wBex", WORD), # RGB参数(扩展)，B（蓝色），范围0-2048
        ("byRes2", BYTE * 114),
    ]


LPNET_DVR_SENSOR_ADJUSTMENT = POINTER(NET_DVR_SENSOR_ADJUSTMENT)


class NET_DVR_SENSOR_ADJUSTMENT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("iPan", int), # 左右值
        ("iTilt", int), # 上下值
        ("iRotation", int), # 旋转值
        ("iFieldAngle", int), # 图像视场角值
        ("byR", BYTE), # RGB参数，R（红色），范围0-100
        ("byG", BYTE), # RGB参数，G（绿色），范围0-100
        ("byB", BYTE), # RGB参数，B（蓝色），范围0-100
        ("byRgbType", BYTE), # RGB类型，0-保留，1-产线模式，2-手动模式
        ("byBrightness", BYTE), # 亮度，范围0-100,默认值50
        ("byRes", BYTE * 3),
        ("wRex", WORD), # RGB参数(扩展)，R（红色），范围0-2048
        ("wGex", WORD), # RGB参数(扩展)，G（绿色），范围0-2048
        ("wBex", WORD), # RGB参数(扩展)，B（蓝色），范围0-2048
        ("byRes1", BYTE * 114),
    ]


LPNET_DVR_SENSOR_ADJUSTMENT_INFO = POINTER(NET_DVR_SENSOR_ADJUSTMENT_INFO)


class NET_DVR_SENSOR_RESET(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("bySensorNo", BYTE), # Sensor号[1,8]当Sensor No为0的时候，表示全部清除；其他情况下表示单个清除
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_SENSOR_RESET = POINTER(NET_DVR_SENSOR_RESET)


class NET_DVR_PANORAMAIMAGE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byFusionMode", BYTE), # 模式：0-原始图像，1-全景图像
        ("byPreviewMode", BYTE), # 模式：1-目标跟踪，2-固定显示
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_PANORAMAIMAGE = POINTER(NET_DVR_PANORAMAIMAGE)


class NET_DVR_RELOCATE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byTakeOverAddr", BYTE * MAX_DOMAIN_NAME), # 接管设备的地址
        ("wPort", WORD), # 设备端口号
        ("byRes", BYTE * 254), # 保留
    ]


LPNET_DVR_RELOCATE_INFO = POINTER(NET_DVR_RELOCATE_INFO)


class NET_DVR_CONFERENCE_REGION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnabled", BYTE), # 是否启用会议区域，0-否，1-是
        ("byRes1", BYTE * 3),
        ("struRegion", NET_DVR_POINT * RECT_POINT_NUM), # 会议区域，矩形，起始点为左下角，顺时针方向
        ("dwOutputWidth", DWORD), # 单输出口基准宽，只能获取
        ("dwOutputHeight", DWORD), # 单输出口基准高，只能获取
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_CONFERENCE_REGION = POINTER(NET_DVR_CONFERENCE_REGION)


class NET_DVR_TERMINAL_CALL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAnswerType", BYTE), # 会议呼叫响应方式，1-自动接听，2-自动拒接，3-手动接听
        ("byProtocolType", BYTE), # 使用的协议类型，1-SIP，2-H232
        ("byTransmissionProtocol", BYTE), # 传输协议类型，0-无效，1-TCP，2-UDP
        ("byRes", BYTE * 29),
    ]


LPNET_DVR_TERMINAL_CALL_CFG = POINTER(NET_DVR_TERMINAL_CALL_CFG)


class NET_DVR_TERMINAL_CALL_INFO(Structure):
    _fields_ = [
        ("byTermianlURL", BYTE * MAX_URL_LEN),
        ("dwCallRate", DWORD), # 呼叫速率，范围为：32~6144，单位Kbps  (连接速率)
        ("byRes", BYTE * 124),
    ]


LPNET_DVR_TERMINAL_CALL_INFO = POINTER(NET_DVR_TERMINAL_CALL_INFO)


class NET_DVR_TERMINAL_AUDIO_CTRL(Structure):
    _fields_ = [
        ("byMute", BYTE), # 是否静音，0-否，1-是
        ("byVolume", BYTE), # 音量，非静音时有效，1-100
        ("byAudioInputDisabled", BYTE), # 禁止音频输入，0-允许音频输入，1-禁止音频输入
        ("byAudioInputVolume", BYTE), # 音频输入音量，允许音频输入时有效，1-100
        ("byRes", BYTE * 636),
    ]


LPNET_DVR_TERMINAL_AUDIO_CTRL = POINTER(NET_DVR_TERMINAL_AUDIO_CTRL)


class NET_DVR_HOWLING_SUPPRESSION(Structure):
    _fields_ = [
        ("byEnabled", BYTE), # 是否使能啸叫抑制
        ("byHsSensibility", BYTE), # 啸叫抑制灵敏度
        ("byHsMode", BYTE), # 啸叫抑制模式，0-默认，1-慢速，2-快速
        ("byRes1", BYTE),
        ("dwHsTime", DWORD), # 啸叫抑制时间，单位：ms
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_HOWLING_SUPPRESSION = POINTER(NET_DVR_HOWLING_SUPPRESSION)


class NET_DVR_TERMINAL_INPUT_AUDIO(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号
        ("byGainType", BYTE), # 增益类型，1-数字增益，2-模拟增益,3-两者
        ("byEnableSimulate", BYTE), # 是否启用模拟增益，0-否，1-是
        ("byVolumeSimulate", BYTE), # 模拟音量，启用时有效，1-100
        ("byEnableDigital", BYTE), # 是否启用数字增益，0-否，1-是
        ("byVolumeDigital", BYTE), # 数字音量，启用时有效，1-100
        ("byRes1", BYTE * 3),
        ("struHsParam", NET_DVR_HOWLING_SUPPRESSION), # 啸叫抑制参数
        ("byRes", BYTE * 604),
    ]


LPNET_DVR_TERMINAL_INPUT_AUDIO = POINTER(NET_DVR_TERMINAL_INPUT_AUDIO)


class NET_DVR_TERMINAL_DETAIL_CTRL_PARAM(Union):
    _fields_ = [
        ("byRes", BYTE * 640),
        ("struCallInfo", NET_DVR_TERMINAL_CALL_INFO),
        ("struAudioCtrl", NET_DVR_TERMINAL_AUDIO_CTRL),
        ("struInputAudio", NET_DVR_TERMINAL_INPUT_AUDIO),
    ]


LPNET_DVR_TERMINAL_DETAIL_CTRL_PARAM = POINTER(NET_DVR_TERMINAL_DETAIL_CTRL_PARAM)


class NET_DVR_TERMINAL_CTRL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byOperateType", BYTE), # 操作类型，1-接听，2-拒接，3-呼叫，4-音频调节，5-挂断，6-双流开，7-双流关
        ("byRes1", BYTE * 3),
        ("struCtrlParam", NET_DVR_TERMINAL_DETAIL_CTRL_PARAM), # 具体控制参数
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_TERMINAL_CTRL_PARAM = POINTER(NET_DVR_TERMINAL_CTRL_PARAM)


class NET_DVR_POS_INFO_OVERLAY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPosInfoOverlayEnable", BYTE), #  Pos信息码流叠加控制，0-不叠加，1-叠加
        ("byOverlayType", BYTE), # 0-叠加进入和离开，1-叠加进入、离开、PASS、ID、高度
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_POS_INFO_OVERLAY = POINTER(NET_DVR_POS_INFO_OVERLAY)


class NET_DVR_CAMERA_WORK_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byWorkMode", BYTE), # 工作模式，0-正常模式，1-工厂标定模式
        ("byPreviewImageMode", BYTE), # 预览图像模式，0-左眼图像，1-右眼图像，2-左右叠加图像
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_CAMERA_WORK_MODE = POINTER(NET_DVR_CAMERA_WORK_MODE)


class NET_DVR_VCA_VERSION_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("struVcaVersion", NET_DVR_VCA_VERSION * NET_SDK_VERSION_LIST_LEN), # 算法库版本信息
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_VCA_VERSION_LIST = POINTER(NET_DVR_VCA_VERSION_LIST)


class NET_DVR_SETUP_CALIB_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCalibrateType", BYTE), # 标定类型，0-未进行标定，1-自动标定，2-手动标定,3-智能标定
        ("byRes1", BYTE * 3),
        ("fTiltAngle", float), # 俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,当byCalibrateType为2时有效
        ("fHeelAngle", float), # 倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,当byCalibrateType为2时有效
        ("fHeight", float), # 高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时有效
        ("struAutoCalibPolygon", NET_VCA_POLYGON), # 自动标定区域，当byCalibrateType为1时有效
        ("byIntelligentType", BYTE), # 标定的智能类型，0-保留， 1-客流，2-人体属性，3-行为分析；只有在标定客流时NET_DVR_SETUP_CALIB_RESULT返回的数据才有效
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_SETUP_CALIB_COND = POINTER(NET_DVR_SETUP_CALIB_COND)


class NET_DVR_SETUP_CALIB_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCalibrateType", BYTE), # 标定类型，0-未进行标定，1-自动标定，2-手动标定,3-智能标定
        ("byRes1", BYTE * 3),
        ("fTiltAngle", float), # 俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,当byCalibrateType为2时有效
        ("fHeelAngle", float), # 倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,当byCalibrateType为2时有效
        ("fHeight", float), # 高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时有效
        ("struCountPolygon", NET_VCA_POLYGON), # 计数区域
        ("struEnterDirection", NET_DVR_PDC_ENTER_DIRECTION), #  流量进入方向
        ("struLine", NET_VCA_LINE), # 检测线
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_SETUP_CALIB_RESULT = POINTER(NET_DVR_SETUP_CALIB_RESULT)


class NET_DVR_CALL_QUERY_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySearchID", BYTE * MAX_SEARCH_ID_LEN), # 搜索标识符
        ("struStartTime", NET_DVR_TIME), # 搜索起始时间
        ("struEndTime", NET_DVR_TIME), # 搜索结束时间
        ("byCallType", BYTE), # 呼叫类型，1-已接，2-未接，3-已拨，4-所有类型
        ("byRes1", BYTE * 3),
        ("dwMaxResults", DWORD), # 本次查找最多返回个数
        ("dwSearchPos", DWORD), # 查找起始索引
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_CALL_QUERY_COND = POINTER(NET_DVR_CALL_QUERY_COND)


class NET_DVR_CALL_QUERY_SINGLE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCallType", BYTE), # 呼叫类型，1-已接，2-未接，3-已拨
        ("byRes1", BYTE * 3),
        ("byTerminalName", BYTE * TERMINAL_NAME_LEN), # 终端名
        ("byAddressURL", BYTE * MAX_URL_LEN), # 对端URL地址
        ("struStartTime", NET_DVR_TIME), # 呼叫开始时间
        ("struEndTime", NET_DVR_TIME), # 呼叫结束时间
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_CALL_QUERY_SINGLE = POINTER(NET_DVR_CALL_QUERY_SINGLE)


CALL_QUERY_RESULT_OK = 0
CALL_QUERY_RESULT_FAIL = 1
CALL_QUERY_RESULT_MORE = 2
CALL_QUERY_RESULT_NOMATCH = 3
CALL_QUERY_RESULT_PARAMERROR = 4
CALL_QUERY_RESULT_INVALIDTIME = 5
CALL_QUERY_RESULT_TIMEOUT = 6


class NET_DVR_CALL_QUERY_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySearchID", BYTE * MAX_SEARCH_ID_LEN), # 搜索标识符
        ("byStatus", BYTE), # 查询状态  参考CALL_QUERY_RESULT_STATUS结构体
        ("byRes", BYTE * 3), # 保留
        ("dwCount", DWORD), # 实际查询到的结果个数
        ("*pResults", BYTE), # 结果内容，dwCount个NET_DVR_CALL_QUERY_SINGLE,需要调用者预先分屏好内存
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_CALL_QUERY_RESULT = POINTER(NET_DVR_CALL_QUERY_RESULT)


class NET_DVR_CONFERENCE_CALL_INFO(Structure):
    _fields_ = [
        ("byConferenceID", BYTE * MAX_ID_LEN), # 会议ID
        ("byConferenceName", BYTE * NAME_LEN), # 会议名称
        ("struStartTime", NET_DVR_TIME), # 会议开始时间
        ("struEndTime", NET_DVR_TIME), # 会议结束时间
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_CONFERENCE_CALL_INFO = POINTER(NET_DVR_CONFERENCE_CALL_INFO)


class NET_DVR_CALL_INFO(Union):
    _fields_ = [
        ("byRes", BYTE * 640),
        ("struTerminalCallInfo", NET_DVR_TERMINAL_CALL_INFO), # 终端点对点呼叫信息
        ("struConferenceCallInfo", NET_DVR_CONFERENCE_CALL_INFO), # 会议呼叫信息
    ]


LPNET_DVR_CALL_INFO = POINTER(NET_DVR_CALL_INFO)


class NET_DVR_CONFERENCE_CALL_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byAlarmType", BYTE), # 报警类型，1-会议呼叫， 2-呼叫状态切换，3-终端提问
        ("byCallType", BYTE), # 呼叫类型，报警类型为1时有效，1-终端点对点呼叫，2-会议呼叫
        ("byAutoAnswer", BYTE), # 是否已自动接听，0-否，1-是
        ("byCallStatusSwitch", BYTE), # 呼叫状态切换类型，当报警类型为2时有效，1-开始呼叫，2-呼叫成功，3-呼叫结束，4-对端挂断
        ("struCallInfo", NET_DVR_CALL_INFO), # 呼叫信息
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_CONFERENCE_CALL_ALARM = POINTER(NET_DVR_CONFERENCE_CALL_ALARM)


class NET_DVR_TERMINAL_INPUT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwInputNo", DWORD), # 作为视频会议输入的输入口编号
        ("byStreamType", BYTE), # 码流类型：0-主码流，1-子码流，2-三码流
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_TERMINAL_INPUT_CFG = POINTER(NET_DVR_TERMINAL_INPUT_CFG)


class NET_DVR_AUDIO_STATUS(Structure):
    _fields_ = [
        ("byMute", BYTE), # 是否静音，0-否，1-是
        ("byVolume", BYTE), # 会议音量，1-100，非静音时有效
        ("byAudioInputDisabled", BYTE), # 禁用音频输入，0-否，1-是
        ("byAudioInputVolume", BYTE), # 音频输入音量，1-100，允许音频输入时有效
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_AUDIO_STATUS = POINTER(NET_DVR_AUDIO_STATUS)


class NET_DVR_TERMINAL_CONFERENCE_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byConferenceState", BYTE), # 会议状态，0-空闲，1-忙碌（会议中），2-呼叫中，3-被呼叫中
        ("byConferenceType", BYTE), # 会议类型，1-点对点，2-MCU发起会议
        ("byDualStreamEnabled", BYTE), # 是否开启双流，0-未开启，1-开启
        ("byMicPowerEnabled", BYTE), # 麦克风电源是否开启，0-未开启，1-开启
        ("dwInputNo", DWORD), # 使用的音频输入口号
        ("struCallInfo", NET_DVR_CALL_INFO), # 会议信息
        ("struAudioStatus", NET_DVR_AUDIO_STATUS), # 音频相关状态
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_TERMINAL_CONFERENCE_STATUS = POINTER(NET_DVR_TERMINAL_CONFERENCE_STATUS)


# 终端注册GK信息
class NET_DVR_TERMINAL_GK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用
        ("byRegisterState", BYTE), # 注册状态，0-未注册，1-已注册，只读
        ("byRes1", BYTE * 2),
        ("struGKIP", NET_DVR_IPADDR), # GK IP
        ("wGKPort", WORD), # GK端口号
        ("byRes2", BYTE * 2),
        ("byRegisterName", BYTE * REGISTER_NAME_LEN), # 终端注册到GK的名字
        ("byPassword", BYTE * PASSWD_LEN), # 终端注册到GK的密码
        ("byRes3", BYTE * 16),
    ]


LPNET_DVR_TERMINAL_GK_CFG = POINTER(NET_DVR_TERMINAL_GK_CFG)


# 解码器漫游开关参数
class NET_DVR_WIN_ROAM_SWITCH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableRoam", BYTE), # 是否允许窗口漫游，0-否，非0-是
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_WIN_ROAM_SWITCH_CFG = POINTER(NET_DVR_WIN_ROAM_SWITCH_CFG)


class NET_DVR_LED_OUTPUT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableZoom", BYTE), # 是否缩放，0-否，1-是
        ("byAutoCutBlackEdge", BYTE), # 是否自动裁剪黑边，0-否，1-是
        ("byRes1", BYTE * 2),
        ("wLEDWidth", WORD), # 分辨率宽
        ("wLEDHeight", WORD), # 分辨率高
        ("dwRefreshRate", DWORD), # 刷新频率
        ("dwInputNO", DWORD), # 关联的输入通道号
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_LED_OUTPUT_CFG = POINTER(NET_DVR_LED_OUTPUT_CFG)


class NET_DVR_LED_OUTPUT_PORT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnabled", BYTE), # 是否使能，0-否，1-是
        ("byRes1", BYTE * 3),
        ("dwPortNum", DWORD), # 包含的端口个数
        ("dwPortNo", DWORD * MAX_OUTPUT_PORT_NUM), # 包含的端口号
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_LED_OUTPUT_PORT_CFG = POINTER(NET_DVR_LED_OUTPUT_PORT_CFG)


class NET_DVR_LINE_COLUMN_INFO(Structure):
    _fields_ = [
        ("wLine", WORD), # 行号
        ("wColumn", WORD), # 列号
    ]


LPNET_DVR_LINE_COLUMN_INFO = POINTER(NET_DVR_LINE_COLUMN_INFO)


class NET_DVR_LED_DISPLAY_AREA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struLCInfo", NET_DVR_LINE_COLUMN_INFO), # 显示区域的起始位置(接收卡行列号)
        ("wWidth", WORD), # 横向接收卡数
        ("wHeight", WORD), # 竖向接收卡数
        ("wRecvCardWidth", WORD), # 接收卡宽度大小，为0则使用端口参数中接收卡大小参数
        ("wRecvCardHeigt", WORD), # 接收卡高度大小，为0则使用端口参数中接收卡大小参数
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LED_DISPLAY_AREA = POINTER(NET_DVR_LED_DISPLAY_AREA)


class NET_DVR_LED_RECV_CARD_INFO(Structure):
    _fields_ = [
        ("struPos", NET_DVR_LINE_COLUMN_INFO), # 接收卡位置
        ("wRecvCardWidth", WORD), # 接收卡宽度大小
        ("wRecvCardHeigt", WORD), # 接收卡高度大小
    ]


LPNET_DVR_LED_RECV_CARD_INFO = POINTER(NET_DVR_LED_RECV_CARD_INFO)


class NET_DVR_LED_PORT_BACKUP(Structure):
    _fields_ = [
        ("byEnabled", BYTE), # 是否启用端口备份，0-否，1-是
        ("byPortMode", BYTE), # 端口模式，1-主口，2-备份口
        ("byRes1", BYTE * 2),
        ("dwPairPort", DWORD), # 配对端口号，当端口为主口时，此参数为备份口端口号，当端口为备份口时，此参数为主口端口号
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_LED_PORT_BACKUP = POINTER(NET_DVR_LED_PORT_BACKUP)


class NET_DVR_LED_PORT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnabled", BYTE), # 是否启用该端口，0-否，1-是
        ("byRes1", BYTE * 3),
        ("struLedPortBackup", NET_DVR_LED_PORT_BACKUP), # 端口备份参数
        ("dwRecvCardNum", DWORD), # 本端口连接的接收卡数
        ("struRecvCard", NET_DVR_LED_RECV_CARD_INFO * MAX_SINGLE_PORT_RECVCARD_NUM), # 各接收卡的信息
        ("dwPortNo", DWORD), # 端口号，获取所有端口参数时有效
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_LED_PORT_CFG = POINTER(NET_DVR_LED_PORT_CFG)


class NET_DVR_LED_DISPLAY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struColorTemp", NET_DVR_COLOR_TEMPERATURE_CFG), # 色温参数
        ("struVoutCfg", NET_DVR_VIDEO_OUT_CFG), # 显示效果参数
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LED_DISPLAY_CFG = POINTER(NET_DVR_LED_DISPLAY_CFG)


class NET_DVR_LED_TEST_SIGNAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnabled", BYTE), # 是否启用测试信号，0-不启用，1-启用
        ("bySignalType", BYTE), # 测试信号类型，1-彩条，2-波纹，3-格状彩条，4-方格，5-水平和垂直灰阶联合体，6-棋盘，0xff-自定义颜色
        ("byRes1", BYTE * 2),
        ("struSignalColor", NET_DVR_RGB_COLOR), # 测试信号颜色，测试信号类型为0xff时有效
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LED_TEST_SIGNAL_CFG = POINTER(NET_DVR_LED_TEST_SIGNAL_CFG)


class NET_DVR_LED_NOSIGNAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byNoSignalMode", BYTE), # 无信号显示模式，1-黑屏，2-显示厂家LOGO，3-显示自定义图片
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_LED_NOSIGNAL_CFG = POINTER(NET_DVR_LED_NOSIGNAL_CFG)


class NET_DVR_LED_INPUT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwResolutionWidth", DWORD), # 输入分辨率宽，只读
        ("dwResolutionHeight", DWORD), # 输入分辨率高，只读
        ("dwRefreshRate", DWORD), # 输入信号刷新频率，只读
        ("struVgaCfg", NET_DVR_SCREEN_VGA_CFG), # VGA信号调整参数，VGA输入时可调
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LED_INPUT_CFG = POINTER(NET_DVR_LED_INPUT_CFG)


class NET_DVR_LED_RECV_CARD_CFG_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwOutputNo", DWORD), # 输出编号
        ("struPosStart", NET_DVR_LINE_COLUMN_INFO), # 接收卡起始位置
        ("struPosEnd", NET_DVR_LINE_COLUMN_INFO), # 接收卡结束位置
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LED_RECV_CARD_CFG_COND = POINTER(NET_DVR_LED_RECV_CARD_CFG_COND)


class NET_DVR_LED_GAMMA_CFG_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwOutputNo", DWORD), # 输出编号
        ("struPosStart", NET_DVR_LINE_COLUMN_INFO), # 接收卡起始位置
        ("struPosEnd", NET_DVR_LINE_COLUMN_INFO), # 接收卡结束位置
        ("byGammaType", BYTE), # Gamma表类型，Gamma表配置时有效，0-RGB混合Gamma表，1-红色Gamma表，2-绿色Gamma表，3-蓝色Gamma表
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_LED_GAMMA_CFG_COND = POINTER(NET_DVR_LED_GAMMA_CFG_COND)


class NET_DVR_LED_GAMMA_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wGammaValue", WORD * MAX_GAMMA_X_VALUE), # GAMMA表Y取值，每个元素取值0-65535，自定义模式时有效
        ("byGammaModel", BYTE), # GAMMA表模式，0-自定义模式，1-夜模式1，2-夜模式2，3-正常模式，4-日照模式1，5-日照模式2
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_LED_GAMMA_CFG = POINTER(NET_DVR_LED_GAMMA_CFG)


class NET_DVR_LED_CLOCK_CFG(Structure):
    _fields_ = [
        ("dwDclkRate", DWORD), # 传输时钟dclk频率，实际值乘10，单位：MHz，实际值范围1.0-31.3
        ("dwGclkRate", DWORD), # 刷新时钟gclk频率，实际值乘10，单位：MHz，实际值范围1.0-31.3
        ("dwGclkCountNum", DWORD), # 300ns gclk计数值
        ("byDclkDutyRatio", BYTE), # dclk时钟占空比，取值：25，50，75
        ("byDclkPhase", BYTE), # dclk相位，取值：0,1,2,3
        ("byGclkNum", BYTE), # 刷新1行需要的有效gclk个数，0-255
        ("byRes", BYTE * 17),
    ]


LPNET_DVR_LED_CLOCK_CFG = POINTER(NET_DVR_LED_CLOCK_CFG)


class NET_DVR_LED_RECV_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struClockCfg", NET_DVR_LED_CLOCK_CFG), # 时钟相关参数
        ("byGrayLevel", BYTE), # 灰度等级，取值13，14
        ("byRefreshRate", BYTE), # 刷新倍率，取值1-6
        ("byLineScanNum", BYTE), # 行扫数，0-255
        ("byRefreshCompleteGrayNum", BYTE), # 刷新完整灰阶数，0-255
        ("dwHBlank", DWORD), # 行消隐时间，单位：gclk时钟个数，取值1-65535
        ("dwAfterglowCtrl", DWORD), # 余晖控制结束时间，单位：gclk时钟个数，取值1-65535
        ("dwLineFeedTime", DWORD), # 换行时间，单位：gclk时钟个数，取值1-65535
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_LED_RECV_CFG = POINTER(NET_DVR_LED_RECV_CFG)


class NET_DVR_LED_REGISTOR_VALUE(Structure):
    _fields_ = [
        ("byChip1High", BYTE), # 芯片1高字节
        ("byChip1Low", BYTE), # 芯片1低字节
        ("byChip2High", BYTE), # 芯片2高字节
        ("byChip2Low", BYTE), # 芯片2低字节
        ("byChip3High", BYTE), # 芯片3高字节
        ("byChip3Low", BYTE), # 芯片3低字节
        ("byChip4High", BYTE), # 芯片4高字节
        ("byChip4Low", BYTE), # 芯片4低字节
        ("byChip5High", BYTE), # 芯片5高字节
        ("byChip5Low", BYTE), # 芯片5低字节
        ("byChip6High", BYTE), # 芯片6高字节
        ("byChip6Low", BYTE), # 芯片6低字节
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_LED_REGISTOR_VALUE = POINTER(NET_DVR_LED_REGISTOR_VALUE)


class NET_DVR_LED_RECV_REGISTOR(Structure):
    _fields_ = [
        ("byEliminateGhostShadowLevel", BYTE), # 下鬼影消除等级，0-5
        ("byEliminateShadowy", BYTE), # 第一扫偏暗消除等级，0-15
        ("byGrayEqualize1", BYTE), # 低灰偏色补偿1，0-3
        ("byGrayEqualize2", BYTE), # 低灰偏色补偿2，0-15
        ("byEnableGrayUniformity", BYTE), # 低灰均匀性提升是否开启，0-关，1-开
        ("byDisableHGrayStripes", BYTE), # 低灰横条纹消除是否开启，0-关，1-开
        ("byGhostShadowEnhancedMode1", BYTE), # 下鬼影消除增强模式1是否开启，0-关，1-开
        ("byGhostShadowEnhancedMode2", BYTE), # 下鬼影消除增强模式2是否开启，0-关，1-开
        ("byClearBadPoint", BYTE), # 去除坏点使能，0-非使能，1-使能
        ("byEnableSelfDefineRegistor", BYTE), # 是否启用自定义寄存器值，0-否，1-是
        ("byRes1", BYTE * 2),
        ("struRegistorValue", NET_DVR_LED_REGISTOR_VALUE), # 自定义寄存器参数
        ("byEnabledExGradientOptimition", BYTE), # 渐变过度优化开关，0-关闭，!0-开启
        ("byDummyGClockCycle", BYTE), # Dummy GClock周期，开启渐变过度优化时有效，单位：个gclk
        ("byDummyGClockHighTime", BYTE), # Dummy GClock高电平时间，开启渐变过度优化时有效，单位：8ns
        ("byFirstGClockExtendedTime", BYTE), # 第一个GClock展宽时间，开启渐变过度优化时有效，单位：8ns
        ("byRes", BYTE * 28),
    ]


LPNET_DVR_LED_RECV_REGISTOR = POINTER(NET_DVR_LED_RECV_REGISTOR)


class NET_DVR_LED_RECV_ADVANCED_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struFirstRegistor", NET_DVR_LED_RECV_REGISTOR), # 第一组接收卡高级参数，自定义寄存器值为红芯片寄存器值
        ("struSecondRegistor", NET_DVR_LED_RECV_REGISTOR), # 第二组接收卡高级参数，自定义寄存器值为绿芯片寄存器值
        ("struThirdRegistor", NET_DVR_LED_RECV_REGISTOR), # 第三组接收卡高级参数，自定义寄存器值为蓝芯片寄存器值
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_LED_RECV_ADVANCED_CFG = POINTER(NET_DVR_LED_RECV_ADVANCED_CFG)


class NET_DVR_LED_CHECK_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwOutputNo", DWORD), # 输入编号
        ("struPosStart", NET_DVR_LINE_COLUMN_INFO), # 接收卡起始位置
        ("byStartPosType", BYTE), # 起始位置类型，0-使用接收卡起始位置，1-使用坐标位置
        ("byRes1", BYTE * 3),
        ("dwXCoordinate", DWORD), # 矩形左上角起始点X坐标
        ("dwYCoordinate", DWORD), # 矩形左上角Y坐标
        ("dwWidth", DWORD), # 区域宽度
        ("dwHeight", DWORD), # 区域高度
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_LED_CHECK_COND = POINTER(NET_DVR_LED_CHECK_COND)


# 查询方式
QUERYSVR_BY_COUNTRYID = 0
QUERYSVR_BY_SERVERTYPE = 1
QUERYDEV_BY_NICKNAME_DDNS = 2
QUERYDEV_BY_SERIAL_DDNS = 3
CHECKDEV_BY_NICKNAME_DDNS = 4
CHECKDEV_BY_SERIAL_DDNS = 5
QUERYDEV_BY_NICKNAME_IPSERVER = 6
QUERYDEV_BY_SERIAL_IPSERVER = 7


CLIENT_VERSION_LEN = 64
# 按国家编号查询的条件结构体
class NET_DVR_QUERY_COUNTRYID_COND(Structure):
    _fields_ = [
        ("wCountryID", WORD), # 国家编号,取值详见附件一
        ("szSvrAddr", CHAR * MAX_DOMAIN_NAME), # 服务器地址,表示去哪个服务器上查询目标服务器的信息
        ("szClientVersion", CHAR * CLIENT_VERSION_LEN), # 客户端版本信息,例如:iVMS4500 V4.0.0.0 build20150112
        ("byRes", BYTE * 382),
    ]


LPNET_DVR_QUERY_COUNTRYID_COND = POINTER(NET_DVR_QUERY_COUNTRYID_COND)


# 按国家编号查询的返回结构体
class NET_DVR_QUERY_COUNTRYID_RET(Structure):
    _fields_ = [
        ("szResolveSvrAddr", CHAR * MAX_DOMAIN_NAME), # 解析服务器地址(即设备注册服务器)
        ("szAlarmSvrAddr", CHAR * MAX_DOMAIN_NAME), # 报警服务器地址
        ("byRes", BYTE * 1024),
    ]


LPNET_DVR_QUERY_COUNTRYID_RET = POINTER(NET_DVR_QUERY_COUNTRYID_RET)


# 按服务器类型查询的条件结构体
class NET_DVR_QUERY_SERVERTYPE_COND(Structure):
    _fields_ = [
        ("wSvrType", WORD), # 服务器类型, 6-手机推送服务器
        ("szSvrAddr", CHAR * MAX_DOMAIN_NAME), # 服务器地址,表示去哪个服务器上查询目标服务器的信息
        ("szClientVersion", CHAR * CLIENT_VERSION_LEN), # 客户端版本信息
        ("byRes", BYTE * 382),
    ]


LPNET_DVR_QUERY_SERVERTYPE_COND = POINTER(NET_DVR_QUERY_SERVERTYPE_COND)


# 按服务器类型查询的返回结构体
class NET_DVR_QUERY_SERVERTYPE_RET(Structure):
    _fields_ = [
        ("szSvrAddr", CHAR * MAX_DOMAIN_NAME), # 服务器地址
        ("wSvrPort", WORD), # 服务器端口
        ("byRes", BYTE * 446),
    ]


LPNET_DVR_QUERY_SERVERTYPE_RET = POINTER(NET_DVR_QUERY_SERVERTYPE_RET)


# 从hiDDNS上查询或诊断的条件结构体
class NET_DVR_QUERY_DDNS_COND(Structure):
    _fields_ = [
        ("szResolveSvrAddr", CHAR * MAX_DOMAIN_NAME), # 解析服务器地址
        ("szDevNickName", CHAR * MAX_DOMAIN_NAME), # 设备在解析服务器上的别名
        ("szDevSerial", CHAR * SERIALNO_LEN), # 设备序列号
        ("szClientVersion", CHAR * CLIENT_VERSION_LEN), # 客户端版本信息,例如:iVMS4500 V4.0.0.0 build20150112
        ("byRes", BYTE * 272), # 保留
    ]


LPNET_DVR_QUERY_DDNS_COND = POINTER(NET_DVR_QUERY_DDNS_COND)


# 从hiDDNS上查询返回的结构体
class NET_DVR_QUERY_DDNS_RET(Structure):
    _fields_ = [
        ("szDevIP", CHAR * SDK_MAX_IP_LEN), # 设备IP地址
        ("wCmdPort", WORD), # 控制端口（SDK连接端口）
        ("wHttpPort", WORD), # http端口
        ("byRes", BYTE * 460),
    ]


LPNET_DVR_QUERY_DDNS_RET = POINTER(NET_DVR_QUERY_DDNS_RET)


# 从hiDDNS上诊断返回的结构体
class NET_DVR_CHECK_DDNS_RET(Structure):
    _fields_ = [
        ("byDevStatus", BYTE), # 设备状态,0-正常,1-找不到,2-设备不在线,3-设备不在当前区域
        ("byRes1", BYTE),
        ("struQueryRet", NET_DVR_QUERY_DDNS_RET), # 地址信息
        ("wRegionID", WORD), # 当前设备注册区域编号[1美国,2南美,3亚太,4中国,5欧洲,6其它]
        ("byRes2", BYTE * 508),
    ]


LPNET_DVR_CHECK_DDNS_RET = POINTER(NET_DVR_CHECK_DDNS_RET)


# 从IPServer上查询的条件结构体
class NET_DVR_QUERY_IPSERVER_COND(Structure):
    _fields_ = [
        ("szResolveSvrAddr", CHAR * MAX_DOMAIN_NAME), # 解析服务器地址
        ("wResolveSvrPort", WORD), # 解析服务器端口
        ("szDevNickName", CHAR * MAX_DOMAIN_NAME), # 设备在解析服务器上的别名
        ("szDevSerial", CHAR * SERIALNO_LEN), # 设备序列号
        ("byRes", BYTE * 334), # 保留
    ]


LPNET_DVR_QUERY_IPSERVER_COND = POINTER(NET_DVR_QUERY_IPSERVER_COND)


# 从IPServer上查询返回的结构体
class NET_DVR_QUERY_IPSERVER_RET(Structure):
    _fields_ = [
        ("szDevIP", CHAR * SDK_MAX_IP_LEN), # 设备IP地址
        ("wCmdPort", WORD), # 控制端口（SDK连接端口）
        ("byRes", BYTE * 462),
    ]


LPNET_DVR_QUERY_IPSERVER_RET = POINTER(NET_DVR_QUERY_IPSERVER_RET)


class NET_DVR_CURRENT_VALID_PORT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wHTTPPort", WORD),
        ("byRes", BYTE * 122),
    ]


LPNET_DVR_CURRENT_VALID_PORT = POINTER(NET_DVR_CURRENT_VALID_PORT)


class NET_DVR_AUDIO_CHANNEL(Structure):
    _fields_ = [
        ("dwChannelNum", DWORD), # 通道号
        ("byres", BYTE * 32), # 保留
    ]


LPNET_DVR_AUDIO_CHANNEL = POINTER(NET_DVR_AUDIO_CHANNEL)


# 码流加密条件结构
class NET_DVR_STREAMENCRYPTION_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChan", DWORD), # 预览通道号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_STREAMENCRYPTION_COND = POINTER(NET_DVR_STREAMENCRYPTION_COND)


# 码流加密信息结构
class NET_DVR_STREAMENCRYPTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 启用码流加密，0~关闭，1~开启
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_STREAMENCRYPTION_CFG = POINTER(NET_DVR_STREAMENCRYPTION_CFG)


# 校准的GPS经纬度参数
class NET_DVR_REVISE_GPS_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byLatitudeType", BYTE), # 纬度类型，0-北纬，1-南纬
        ("byLongitudeType", BYTE), #  经度类型，0-东度，1-西度
        ("byMode", BYTE), # 模式 0-默认，1-自动，2-手动
        ("byRes", BYTE),
        ("struLatitude", NET_DVR_LLI_PARAM), # 纬度
        ("struLongitude", NET_DVR_LLI_PARAM), # 经度
        ("byRes1", BYTE * 300),
    ]


LPNET_DVR_REVISE_GPS_CFG = POINTER(NET_DVR_REVISE_GPS_CFG)


class NET_DVR_PDC_RECOMMEND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wWidth", WORD), # 推荐宽度值[0, 1000]
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_PDC_RECOMMEND = POINTER(NET_DVR_PDC_RECOMMEND)


class NET_DVR_FLASHSTORAGE_REMOVE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byPDCRemoveEnable", BYTE), # 清除客流数据使能 0-不清除，1-清除
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_FLASHSTORAGE_REMOVE = POINTER(NET_DVR_FLASHSTORAGE_REMOVE)


# *******************************DS-TME4XX控制机开发 Begin***************************
class NET_DVR_PARKING_CARD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 默认是1（后续兼容多通道设备）
        ("szCardNo", CHAR * MAX_CARDNO_LEN), # 卡号
        ("byCardType", BYTE), # 卡片类型 0-临时卡，1-固定卡
        ("byCardStatus", BYTE), # 卡片状态 0-正常，1-挂失，2-注销
        ("byChargeRuleID", BYTE), # 收费规则ID
        ("byDelete", BYTE), # 是否删除 0-不删除，1-删除
        ("struStartTime", NET_DVR_TIME_V30), # 有效开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 有效结束时间
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PARKING_CARD = POINTER(NET_DVR_PARKING_CARD)


# 出入口卡片信息上传
class NET_DVR_GATE_CARDINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDevInfo", NET_VCA_DEV_INFO),
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("szCardNo", CHAR * MAX_CARDNO_LEN), # 卡号
        ("szPassVehicleID", CHAR * MAX_VEHICLE_ID_LEN), # 唯一标识
        ("szInVehicleID", CHAR * MAX_VEHICLE_ID_LEN), # 出口时的入口唯一标识
        ("struSwipeTime", NET_DVR_TIME_V30), # 刷卡时间
        ("struCardTime", NET_DVR_TIME_V30), # 卡片存的时间，即入场时写入的时间，只对出口票箱有用，0表示无入场时间
        ("byLetPass", BYTE), # 出入口放行方式 0-不放行(当CardType == 纸票)需要收费，1-放行，2-中心收费放行
        ("byCardType", BYTE), # 卡类型 0-固定卡，1-临时卡，2-纸票
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_GATE_CARDINFO = POINTER(NET_DVR_GATE_CARDINFO)


# 月台作业数据上传
# 出入口付费信息上传(COMM_GATE_CHARGEINFO_UPLOAD)
class NET_DVR_GATE_CHARGEINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDevInfo", NET_VCA_DEV_INFO),
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("sLicense", CHAR * MAX_LICENSE_LEN), # 车牌
        ("szCardNo", CHAR * 48),
        ("struEntranceTime", NET_DVR_TIME_V30),
        ("struDepartureTime", NET_DVR_TIME_V30),
        ("szDepartureID", CHAR * 32), # 出场唯一过车标示
        ("szEntranceID", CHAR * 32), # 入场唯一过车标示
        ("dwTotalCost", DWORD), # 实际收费金额*100
        ("szOperateName", CHAR * 32), # 脱机下为"offline"
        ("byChargeRuleId", BYTE), # 收费规则centerId
        ("byVehicleType", BYTE), # 车辆类型，0-其他车辆，1-小型车，2-大型车
        ("byRes", BYTE * 127), # 预留
    ]


LPNET_DVR_GATE_CHARGEINFO = POINTER(NET_DVR_GATE_CHARGEINFO)


# 停车场停车卡控制结构体
class NET_DVR_PARKING_CARD_CTRL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byCardType", BYTE), # 卡片类型 0-临时卡
        ("byDeleteALL", BYTE), # 是否全部删除 0-不删除，1-删除
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_PARKING_CARD_CTRL_PARAM = POINTER(NET_DVR_PARKING_CARD_CTRL_PARAM)


# TME车辆抓图上传
class NET_DVR_TME_VEHICLE_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wLaneid", WORD), # 车道号1～32（索引车道号，可以跳跃）
        ("byCamLaneId", BYTE), # 对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
        ("byRes1", BYTE), # 保留
        ("dwChanIndex", DWORD), # 通道号
        ("struPlateInfo", NET_DVR_PLATE_INFO), # 车牌信息结构
        ("struVehicleInfo", NET_DVR_VEHICLE_INFO), # 车辆信息
        ("byMonitoringSiteID", BYTE * 48), # 监测点编号
        ("byDeviceID", BYTE * 48), # 设备编号
        ("byDir", BYTE), # 监测方向，0-其它 1 入场，2 出场
        ("byRes2", BYTE),
        ("wBackList", WORD), # 标记为是否报警数据 0 表示为正常过车数据  1 表示黑名单
        ("dwPicNum", DWORD), # 图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
        ("struPicInfo", NET_ITS_PICTURE_INFO * 4), # 图片信息,暂定最多4张图
        ("byPassVehicleID", BYTE * 32), # 车辆唯一ID
        ("byCardNo", BYTE * 48), #  卡号
        ("bySwipeTime", BYTE * 32), # 增加刷卡时间  时间格式为yyyymmddhh24missfff
        ("dwCharge", DWORD), # 收费金额 （分）
        ("byHistory", BYTE), # 是否是历史数据  0-否  1-是
        ("byLetPass", BYTE), # 是否已放行，0-未放行，1-放行  2-未知
        ("byRes3", BYTE * 186),
    ]


LPNET_DVR_TME_VEHICLE_RESULT = POINTER(NET_DVR_TME_VEHICLE_RESULT)


# 地磁管理器注册消息
class NET_DVR_MVMRegisterInfo(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sDetectorID", CHAR * 16), # 检测器ID
        ("sManagerID", CHAR * 16), # 管理器ID
        ("sSim", CHAR * 20), # 卡号信息
        ("dwLocalIP", DWORD), # 本地IPv4地址，例如dwLocalIP=0x01020304,则IP地址为1.2.3.4
        ("dwLocalIPMask", DWORD), # 本地网络子网掩码，格式同dwLocalIP
        ("dwLocalGateway", DWORD), # 本地网关，格式同dwLocalIP
        ("dwDstIP", DWORD), # 目标IP，格式同dwLocalIP
        ("byMACAddr", BYTE * 6), # 本地mac地址
        ("wLocalPort", WORD), # 本地端口
        ("wFirmwareYear", WORD), # 软件版本年份
        ("byFirmwareMonth", BYTE), # 软件版本月份
        ("byFirmwareDay", BYTE), # 软件版本日
        ("byMajorVersion", BYTE), # 版本小数点前
        ("byMinorVersion", BYTE), # 版本小数点后
        ("byRes", BYTE * 170),
    ]


LPNET_DVR_MVMRegisterInfo = POINTER(NET_DVR_MVMRegisterInfo)


# 地磁状态信息
class NET_DVR_SingleMagneticStatus(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sDetectorID", CHAR * 16), # 检测器ID
        ("sManagerID", CHAR * 16), # 管理器ID
        ("sParkNum", CHAR * 16), # 车位编号
        ("struDetectorTime", NET_DVR_TIME_V30), # 检测时间
        ("dwRssi", DWORD), # 接收信号强度，实际值范围-137~0dbm，此处没有符号，为实际值的绝对值
        ("byParkinglotState", BYTE), # 车位状态，0-无车，1-有车
        ("byBatteryState", BYTE), # 电池状态，0-100%，1-75%，2-50%，3-25%，4-小于5%
        ("byDeviceState", BYTE), # 设备状态0-正常，1-故障
        ("byCMD", BYTE), # 0-车位变化报警，1-检测器心跳报警
        ("byRes", BYTE * 184),
    ]


LPNET_DVR_SingleMagneticStatus = POINTER(NET_DVR_SingleMagneticStatus)


# 车辆信息同步
class NET_DVR_PARKING_VEHICLE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 默认是1（后续兼容多通道设备）
        ("szLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("szRelateCardNo", CHAR * MAX_CARDNO_LEN), # 关联卡号
        ("struStartTime", NET_DVR_TIME_V30), # 有效开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 有效结束时间
        ("byVehicleType", BYTE), # 车辆类型：0-其他车辆，1-小型车，2-大型车
        ("byPlateColor", BYTE), # 车牌颜色，参考 VCA_PLATE_COLOR
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_PARKING_VEHICLE = POINTER(NET_DVR_PARKING_VEHICLE)


# 缴费金额信息
class NET_DVR_CHARGEACCOUNT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("fAccount", float), # 实际收费金额
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CHARGEACCOUNT_CFG = POINTER(NET_DVR_CHARGEACCOUNT_CFG)


# 停车场票箱从属设备多角度参数配置
class NET_DVR_PXMULTICTRL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwMultiChansWaitTime", DWORD), # 多角度抓拍匹配时间（1~300s）
        ("byMultiChansCapEnabled", BYTE), # 是否启用多角度抓拍 0-否，1-是
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_PXMULTICTRL_CFG = POINTER(NET_DVR_PXMULTICTRL_CFG)


# 停车场票箱脱机下参数配置
class NET_DVR_PXOFFLINE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否启用票箱脱机模式：0-不启用 1-启用
        ("byChargeEnabled", BYTE), # 是否脱机收费 0-否，1-是
        ("byAlarmEnabled", BYTE), # 是否启用脱机报警 0-否，1-是
        ("byRecordSource", BYTE), # 记录产生依据 0-牌识 1-读卡
        ("dwTimeWait", DWORD), # 票箱进入脱机模式前的等待时间（1-300秒）
        # *
        # realeaseMode&(0x1<<0) 固定车放行
        # realeaseMode&(0x1<<1) 固定卡放行
        # realeaseMode&(0x1<<2) 临时车放行
        # realeaseMode&(0x1<<3) 临时卡放行
        # realeaseMode&(0x1<<4) 无车牌放行
        # realeaseMode&(0x1<<5) 固定车若免费则自动放行
        # realeaseMode&(0x1<<6) 临时车若免费则自动放行
        #
        ("dwRealeaseMode", DWORD), # 放行方式，按位表示
        ("byVehCardmatch", BYTE), # 车卡一致  0-否，1-是
        ("bySingleInSingleOut", BYTE), # 单进单出 0-否，1-是
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_PXOFFLINE_CFG = POINTER(NET_DVR_PXOFFLINE_CFG)


class NET_DVR_PARKINGSAPCE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwTotalParkingLot", DWORD), # 总停车位数
        ("dwCurrParkingLot", DWORD), # 当前剩余停车位数
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PARKINGSAPCE_CFG = POINTER(NET_DVR_PARKINGSAPCE_CFG)


class NET_DVR_PAPERCHARGEINFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("szBarCode", CHAR * LEN_16), # 条形码（16位字符串）
        ("szLicense", CHAR * MAX_LICENSE_LEN), # 车牌号码
        ("szVehicleInTime", CHAR * LEN_32), # 入场时间（32位字符串 YYYY-MM-DD HH:MM:SS）
        ("szPaymentTime", CHAR * LEN_32), # 缴费时间（32位字符串 YYYY-MM-DD HH:MM:SS）
        ("fPaymentAmount", float), # 缴费金额
        ("dwPaymentOutFailureTime", DWORD), # 缴费出场失效时间（DWORD）
        ("byVehicleOutEnabled", BYTE), # 是否出场: 0- 否，1- 是
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PAPERCHARGEINFO_CFG = POINTER(NET_DVR_PAPERCHARGEINFO_CFG)


# 停车场票箱参数
class NET_DVR_ILLEGALCARDFILTERING_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sLEDDefaultInfo", CHAR * MAX_LED_INFO_LEN), #  LED默认显示内容
        ("byillegalCardFilteringEnabled", BYTE), # 启用非法卡过滤,0~不启用，1~启用
        ("bySendCardSensingCoilEnabled", BYTE), # 发卡机是否关联地感线圈
        ("byWiegendSensingCoilEnabled", BYTE), # 远距离卡是否关联地感线圈
        ("byGateSwitchEnabled", BYTE), # 是否有道闸开关信息
        ("byVerifyKeyWriteCardEnabled", BYTE), # 是否验证密钥和写卡
        ("byNoplateTakeCardEnabled", BYTE), #  是否启用无车牌取凭据放行
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_ILLEGALCARDFILTERING_CFG = POINTER(NET_DVR_ILLEGALCARDFILTERING_CFG)


# 停车场出入口车卡收费规则规则条件结构
class NET_DVR_TME_CHARGERULE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("szCardNo", CHAR * 32), # 卡号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_TME_CHARGERULE_COND = POINTER(NET_DVR_TME_CHARGERULE_COND)


# LED屏幕显示参数
class NET_DVR_LEDDISPLAY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sDisplayInfo", CHAR * MAX_LED_INFO_LEN), #  LED显示内容
        ("byDisplayMode", BYTE), # 显示方式:0~左移,1~右移,2~立即显示
        ("bySpeedType", BYTE), # 速度类型:0~快,1~中,2~慢
        ("byShowPlateEnable", BYTE), # 显示车牌使能，0~关闭，1~启用
        ("byRes1", BYTE),
        ("dwShowTime", DWORD), # 显示时长，1~60秒
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_LEDDISPLAY_CFG = POINTER(NET_DVR_LEDDISPLAY_CFG)


# 语音播报控制参数
class NET_DVR_VOICEBROADCAST_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sInfo", CHAR * MAX_VOICE_INFO_LEN), # 语音播报内容
        ("byBroadcastNum", BYTE), #  语音播报次数， 1~10次
        ("byIntervalTime", BYTE), #  语音播报间隔时间,1~5s
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_VOICEBROADCAST_CFG = POINTER(NET_DVR_VOICEBROADCAST_CFG)


# 纸票打印格式参数
class NET_DVR_PAPERPRINTFORMAT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sTitleInfo", CHAR * MAX_LITLE_INFO_LEN), # 纸票标题内容
        ("sCustomInfo", CHAR * MAX_CUSTOM_INFO_LEN), # 纸票自定义信息内容
        ("sPhoneNum", CHAR * MAX_PHONE_NUM_LEN), # 联系电话
        ("byPrintInTimeEnabled", BYTE), # 是否打印入场时间
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_PAPERPRINTFORMAT_CFG = POINTER(NET_DVR_PAPERPRINTFORMAT_CFG)


# 智能锁闸时间段
class NET_DVR_LOCKGATE_TIME_CFG(Structure):
    _fields_ = [
        ("sBeginTime", CHAR * LEN_32), # 开始时间（32位字符串 HH:MM:SS）
        ("sEndTime", CHAR * LEN_32), # 结束时间（32位字符串 HH:MM:SS）
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_LOCKGATE_TIME_CFG = POINTER(NET_DVR_LOCKGATE_TIME_CFG)


# 智能锁闸参数
class NET_DVR_LOCKGATE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struTime", NET_DVR_LOCKGATE_TIME_CFG * LOCKGATE_TIME_NUM), # 智能锁闸时间段
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_LOCKGATE_CFG = POINTER(NET_DVR_LOCKGATE_CFG)


# 数据同步状态
# 联动EPTZ参数
class NET_DVR_EPTZ_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnableEPTZ", BYTE), # 是否启用EPTZ, 0-不启用，1 -启用
        ("byRes", BYTE * 503),
    ]


LPNET_DVR_EPTZ_CFG = POINTER(NET_DVR_EPTZ_CFG)


# 中心点参数
class NET_DVR_CENTER_POINT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_CENTER_POINT_CFG = POINTER(NET_DVR_CENTER_POINT_CFG)


# *******************************DS-TME4XX控制机开发 End***************************
# *******************************IPC FF车牌 Start***************************
class NET_DVR_FTPUPLOAD_PARAM(Structure):
    _fields_ = [
        ("szRuleTypeItem", CHAR * MAX_SINGLE_FTPPICNAME_LEN),
        ("szCameraName", CHAR * MAX_CAMNAME_LEN),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_FTPUPLOAD_PARAM = POINTER(NET_DVR_FTPUPLOAD_PARAM)


# char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN# 20];
# 里面内容是固定字符串  capture_time,plate_No,alarm_type,camera_name
# 数组下标表示先后顺序
# char szCameraName[MAX_CAMNAME_LEN# 32];
# 依赖于szRuleTypeItem中字段表示内容为 camera_name 的情况
class NET_DVR_FTPUPLOADCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEventType", BYTE), # 事件类型，0-默认，1-车辆检测
        ("byMode", BYTE), # 图片命名模式，0-默认，1-自定义
        ("byRes", BYTE * 62),
        ("struCustomVehicle", NET_DVR_FTPUPLOAD_PARAM * MAX_FTPNAME_NUM),
        ("byRes1", BYTE * 1024),
    ]


LPNET_DVR_FTPUPLOADCFG = POINTER(NET_DVR_FTPUPLOADCFG)


# *******************************IPC FF车牌 End***************************
# 信息发布终端升级
class NET_DVR_PUBLISH_UPGRADE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwUpgradeType", DWORD), # 升级类型，1-按终端升级，2-按终端组升级
        ("dwTerminalNum", DWORD), # 升级的终端格式，按终端升级时有效
        ("*pTerminalNo", DWORD), # 需要升级的终端号，按终端升级时有效
        ("dwGroupNo", DWORD), # 终端组号，按终端组升级时有效
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_PUBLISH_UPGRADE_COND = POINTER(NET_DVR_PUBLISH_UPGRADE_COND)


# WEP加密密钥
class NET_DVR_WEP_KEY_CFG(Structure):
    _fields_ = [
        ("csWEPKey", CHAR * WEP_KEY_MAX_SIZE), # 加密密钥，
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_WEP_KEY_CFG = POINTER(NET_DVR_WEP_KEY_CFG)


class NET_DVR_SUB_UPGRADE_PROGRESS(Structure):
    _fields_ = [
        ("dwTerminalNo", DWORD), # 终端号
        ("dwProgress", DWORD), # 终端升级进度，0-100，101表示此终端升级出现异常,,102-终端解压失败，103-升级包版本不匹配，104-非升级文件，105-非法签名升级包
    ]


LPNET_DVR_SUB_UPGRADE_PROGRESS = POINTER(NET_DVR_SUB_UPGRADE_PROGRESS)


class NET_DVR_UPGRADE_PROGRESS_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMainProgress", DWORD), # 主进度，0-100
        ("dwSubProgressNum", DWORD), # 子进度个数
        ("lpStruSubProgress", LPNET_DVR_SUB_UPGRADE_PROGRESS), # 各终端升级的子进度，dwSubProgressNum个NET_DVR_SUB_UPGRADE_PROGRESS内容
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_UPGRADE_PROGRESS_RESULT = POINTER(NET_DVR_UPGRADE_PROGRESS_RESULT)


# 信息发布服务器日程发布进度
class NET_DVR_SCHEDULE_PROGRESS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwScheduleNo", DWORD), # 日程号
        ("byProgressType", BYTE), # 获取的进度类型，1-按组获取进度，2-按终端获取进度，3-按组织获取进度
        ("byRes1", BYTE * 3),
        ("dwGroupNo", DWORD), # 终端组号或组织，进度类型为1，3时有效
        ("dwTerminalNo", DWORD), # 终端号，进度类型为2时有效
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_SCHEDULE_PROGRESS_COND = POINTER(NET_DVR_SCHEDULE_PROGRESS_COND)


class NET_DVR_SUB_SCHEDULE_PROGRESS(Structure):
    _fields_ = [
        ("dwTerminalNo", DWORD), # 终端号
        ("dwProgress", DWORD), # 终端日程发布进度，0-100，101表示此终端日程发布出现异常,102表示此终端存储空间不足,103-终端不在线，104-终端拒绝，105-服务器和终端网络中断
    ]


LPNET_DVR_SUB_SCHEDULE_PROGRESS = POINTER(NET_DVR_SUB_SCHEDULE_PROGRESS)


class NET_DVR_SCHEDULE_PROGRESS_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMainProgress", DWORD), # 主进度，0-100，按组获取进度时为整组日程发布进度，按终端获取进度时为单个终端日程发布进度
        ("dwSubProgressNum", DWORD), # 子进度个数，按组获取时有效，表示组下各终端进度个数
        ("lpStruSubProgress", LPNET_DVR_SUB_SCHEDULE_PROGRESS), # 各终端日程发布的子进度，按组获取时有效，dwSubProgressNum个NET_DVR_SUB_SCHEDULE_PROGRESS内容
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_SCHEDULE_PROGRESS_RESULT = POINTER(NET_DVR_SCHEDULE_PROGRESS_RESULT)


# 信息发布插播进度
class NET_DVR_INSERTPLAY_PROGRESS_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byInsertType", BYTE), # 插播类型，1-素材，2-节目
        ("byRes3", BYTE * 3),
        ("dwInsertNo", DWORD), # 如果插播类型是素材，为素材编号，如果插播类型是节目，为节目编号
        ("byProgressType", BYTE), # 获取的进度类型，1-按组获取进度，2-按终端获取进度
        ("byRes1", BYTE * 3),
        ("dwGroupNo", DWORD), # 终端组号，进度类型为1时有效
        ("dwTerminalNo", DWORD), # 终端号，进度类型为2时有效
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_INSERTPLAY_PROGRESS_COND = POINTER(NET_DVR_INSERTPLAY_PROGRESS_COND)


class NET_DVR_SUB_INSERTPLAY_PROGRESS(Structure):
    _fields_ = [
        ("dwTerminalNo", DWORD), # 终端号
        ("dwProgress", DWORD), # 终端插播进度，0-100，101表示此终端插播出现异常,102表示此终端存储空间不足,103表示取消插播,104插播素材被替换
    ]


LPNET_DVR_SUB_INSERTPLAY_PROGRESS = POINTER(NET_DVR_SUB_INSERTPLAY_PROGRESS)


class NET_DVR_INSERTPLAY_PROGRESS_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwMainProgress", DWORD), # 主进度，0-100，按组获取进度时为整组插播进度，按终端获取进度时为单个终端插播进度
        ("dwSubProgressNum", DWORD), # 子进度个数，按组获取时有效，表示组下各终端进度个数
        ("lpStruSubProgress", LPNET_DVR_SUB_INSERTPLAY_PROGRESS), # 各终端插播的子进度，按组获取时有效，dwSubProgressNum个NET_DVR_SUB_INSERTPLAY_PROGRESS内容
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_INSERTPLAY_PROGRESS_RESULT = POINTER(NET_DVR_INSERTPLAY_PROGRESS_RESULT)


# WEP参数
class NET_DVR_WEP_CFG(Structure):
    _fields_ = [
        ("byAuthenticationType", BYTE), # 身份验证类型；0~开启验证；1~共享密钥；2~自动验证
        ("byDefaultTransmitKeyIndex", BYTE), # 默认传输密钥个数，1~4个。对应到struEncryptionKeyCfg加密密钥的个数。
        #
        # 当为64位密钥时，ASCII码密钥字符长度为5个。
        # 当为128位密钥时，ASCII码密钥字符长度为13个。
        #
        ("byWepKeyLenType", BYTE), # 密钥类型；0~   64位密钥，1~  128位密钥。
        ("byKeyType", BYTE), #  密钥类型；0~   ASCII码，1~  16进制。
        ("struWEPKeyCfg", NET_DVR_WEP_KEY_CFG * WEP_KEY_MAX_NUM), #  WEP加密密钥，最大支持4个。
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_WEP_CFG = POINTER(NET_DVR_WEP_CFG)


# WPA参数
class NET_DVR_WPA_CFG(Structure):
    _fields_ = [
        ("byAlgorithmType", BYTE), # 算法类型；0~TKIP, 1~AES, 2~TKIP/AES
        ("byWPAKeyLen", BYTE), #  WPA共享密钥长度，区间为8~63，对应到csSharedKey参数的字符长度
        ("byDefaultPassword", BYTE), # 是否启用默认WPA密钥
        ("byRes1", BYTE),
        ("csSharedKey", CHAR * WPA_KEY_MAX_SIZE), # WPA共享密钥,为8-63个ASCII字符
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_WPA_CFG = POINTER(NET_DVR_WPA_CFG)


class NET_DVR_WIRELESS_SECURITY_CFG(Structure):
    _fields_ = [
        ("bySecurityMode", BYTE), # 安全模式；0~禁用,1~WEP,2~WPA-personal, 3~WPA2-personal
        ("struWEPCfg", NET_DVR_WEP_CFG), # 当安全模式选择为WEP时生效。
        ("struWPACfg", NET_DVR_WPA_CFG), # 当安全模式选择为WPA-personal、WPA2-personal时生效。
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_WIRELESS_SECURITY_CFG = POINTER(NET_DVR_WIRELESS_SECURITY_CFG)


# wifi热点参数配置(完整版)
class NET_DVR_WIRELESSSERVER_FULLVERSION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byWifiAPEnabled", BYTE), # 是否启用无线AP：0-否，1- 是
        ("byBroadcastEnabled", BYTE), #  是否启用广播，0-否，1-是
        ("byWlanShareEnabled", BYTE), # 是否启用共享，0-否，1-是
        ("byDHCPEnabled", BYTE), # 是否启用DHCP，0-否，1-是
        ("bySSID", BYTE * IW_ESSID_MAX_SIZE), # SSID
        ("byRes1", BYTE * 11),
        ("byIPType", BYTE), # IP地址类型，0-IPv4,1-IPv6
        ("struIPAddr", NET_DVR_IPADDR), # IP地址
        ("struIPMask", NET_DVR_IPADDR), # 掩码地址
        ("struGatewayIPMask", NET_DVR_IPADDR), # 网关地址
        ("struStartIPAddrPool", NET_DVR_IPADDR), # IP段起始地址
        ("struEndIPAddrPool", NET_DVR_IPADDR), #  IP段结束地址
        ("struDNSServerIpAddr", NET_DVR_IPADDR * MAX_DNS_SERVER_NUM), # DNS地址
        ("struWirelessSecurityCfg", NET_DVR_WIRELESS_SECURITY_CFG), # 无线安全加密参数
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_WIRELESSSERVER_FULLVERSION_CFG = POINTER(NET_DVR_WIRELESSSERVER_FULLVERSION_CFG)


class NET_DVR_OPTICAL_DEV_CHAN_INFO(Structure):
    _fields_ = [
        ("dwChannel", DWORD), # 通道号，0为无效
        ("byChannelName", BYTE * NAME_LEN),
        ("bySignal", BYTE), # 是否有信号，0-无，1-有，只读
        ("bySignalType", BYTE), # 信号源类型，1-标清，2-高清，有信号时有效，只读
        ("byRes", BYTE * 10),
    ]


LPNET_DVR_OPTICAL_DEV_CHAN_INFO = POINTER(NET_DVR_OPTICAL_DEV_CHAN_INFO)


class NET_DVR_OPTICAL_DEV_NODE(Structure):
    _fields_ = [
        ("byValid", BYTE), # 是否有效，0-无效，1-有效
        ("byRes1", BYTE * 3),
        ("dwDevNo", DWORD), # 光端机号
        ("byDevName", BYTE * NAME_LEN), # 节点光端机名称
        ("byDevID", BYTE * MAX_ID_LEN), # 光端机物理ID，设备唯一标识，只读
        ("struChannel", NET_DVR_OPTICAL_DEV_CHAN_INFO * MAX_CHANNUM),
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_OPTICAL_DEV_NODE = POINTER(NET_DVR_OPTICAL_DEV_NODE)


MAX_OPTICAL_DEV_NODE = 32 # 最多节点光端机数
class NET_DVR_OPTICAL_PORT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byValid", BYTE), # 是否有信号接入，0-无，1-有，只读
        ("byLinkType", BYTE), # 链路类型，1-环网，2-链网，只读
        ("byPortWorkMode", BYTE), # 端口工作模式，0-无效，1-主口，2-辅口，当链路类型为环网时有效，只读
        ("byRes1", BYTE * 1),
        ("dwPairPort", DWORD), # 配对光口号，链路类型为环网时有效，主口时此参数为辅口号，辅口时，此参数为主口号
        ("struDevInfo", NET_DVR_OPTICAL_DEV_NODE * MAX_OPTICAL_DEV_NODE), # 节点光端机设备信息
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_OPTICAL_PORT_INFO = POINTER(NET_DVR_OPTICAL_PORT_INFO)


class NET_DVR_OPTICAL_CHAN_RELATE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否关联光端机输入，0-否，非0-是
        ("byRes1", BYTE * 3),
        ("dwDevNo", DWORD), # 光端机号
        ("dwOpticalPort", DWORD), # 光口号
        ("byDevID", BYTE * MAX_ID_LEN), # 光端机物理ID
        ("dwInputChanNo", DWORD), # 光端机输入通道号
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_OPTICAL_CHAN_RELATE_CFG = POINTER(NET_DVR_OPTICAL_CHAN_RELATE_CFG)


class NET_DVR_START_FILE_TO_CLOUD_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("aCameraID", BYTE * MAX_CAMERAID_LEN), # 编码器ID
        ("dwPoolID", DWORD), # 存储池ID
        ("dwRepPoolID", DWORD), # 冗余池ID
        ("wReplication", WORD), # 冗余份数
        ("byRes", BYTE),
    ]


LPNET_DVR_START_FILE_TO_CLOUD_COND = POINTER(NET_DVR_START_FILE_TO_CLOUD_COND)


class NET_DVR_START_PICTURE_FROM_CLOUD_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileCount", DWORD), # 文件数量
        ("byRes", BYTE * 120),
    ]


LPNET_DVR_START_PICTURE_FROM_CLOUD_RET = POINTER(NET_DVR_START_PICTURE_FROM_CLOUD_RET)


class NET_DVR_PICTURE_FROM_CLOUD_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTime", NET_DVR_TIME_V30), # 图片时间
        ("dwPicLen", DWORD), # 图片长度
        ("byPicType", BYTE), # 图片格式,1-jpg,2-bmp,3-png
        ("byRes", BYTE * 107),
    ]


LPNET_DVR_PICTURE_FROM_CLOUD_RET = POINTER(NET_DVR_PICTURE_FROM_CLOUD_RET)


class NET_DVR_ACS_EXTERNAL_DEV_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIDCardUpMode", BYTE), # 身份证信息上报，0：上传18位身份证号；1：上传全部信息
        ("byRes1", BYTE),
        ("byCardVerifyMode", BYTE), # 刷卡认证模式，0：远程中心认证；1：客户端平台认证；2：刷卡开门
        ("byACSDevType", BYTE), # 设备型号，1：身份证读卡器，2：IC读卡器，3：二维码读卡器，4：指纹读卡器，5：字符屏+二维码读卡器，6：收卡器，7：字符屏，8：指纹头，9：语音模块；10：人证设备
        ("byDoorMode", BYTE), # 门出入类型，0：进门，1：出门；
        ("byRes2", BYTE),
        ("wDevDetailType", WORD), # 外设的具体设备型号，0-iDR210，1-IDM10，2-海康身份证阅读器
        ("byRes", BYTE * 300),
    ]


LPNET_DVR_ACS_EXTERNAL_DEV_CFG = POINTER(NET_DVR_ACS_EXTERNAL_DEV_CFG)


class NET_DVR_PERSONNEL_CHANNEL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byInMode", BYTE), # 进门模式，0受控；1禁止；2自由；
        ("byOutMode", BYTE), # 出门模式，0受控；1禁止；2自由；
        ("byWorkMode", BYTE), # 工作模式，0紧急；1维护；2常闭；3常开；
        ("byRes", BYTE * 301),
    ]


LPNET_DVR_PERSONNEL_CHANNEL_CFG = POINTER(NET_DVR_PERSONNEL_CHANNEL_CFG)


MAX_ID_NUM_LEN = 32 # 最大身份证号长度
MAX_ID_NAME_LEN = 128 # 最大姓名长度
MAX_ID_ADDR_LEN = 280 # 最大住址长度
MAX_ID_ISSUING_AUTHORITY_LEN = 128 # 最大签发机关长度
# 身份证信息
class NET_DVR_ID_CARD_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byName", BYTE * MAX_ID_NAME_LEN), # 姓名
        ("struBirth", NET_DVR_DATE), # 出生日期
        ("byAddr", BYTE * MAX_ID_ADDR_LEN), # 住址
        ("byIDNum", BYTE * MAX_ID_NUM_LEN), # 身份证号码
        ("byIssuingAuthority", BYTE * MAX_ID_ISSUING_AUTHORITY_LEN), # 签发机关
        ("struStartDate", NET_DVR_DATE), # 有效开始日期
        ("struEndDate", NET_DVR_DATE), # 有效截止日期
        ("byTermOfValidity", BYTE), # 是否长期有效， 0-否，1-是（有效截止日期无效）
        ("bySex", BYTE), # 性别，1-男，2-女
        ("byNation", BYTE),
        ("byRes", BYTE * 101),
    ]


LPNET_DVR_ID_CARD_INFO = POINTER(NET_DVR_ID_CARD_INFO)


# 身份证信息报警
class NET_DVR_ID_CARD_INFO_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("struIDCardCfg", NET_DVR_ID_CARD_INFO), # 身份证信息
        ("dwMajor", DWORD), # 报警主类型，参考宏定义
        ("dwMinor", DWORD), # 报警次类型，参考宏定义
        ("struSwipeTime", NET_DVR_TIME_V30), # 时间
        ("byNetUser", BYTE * MAX_NAMELEN), # 网络操作的用户名
        ("struRemoteHostAddr", NET_DVR_IPADDR), # 远程主机地址
        ("dwCardReaderNo", DWORD), # 读卡器编号，为0无效
        ("dwDoorNo", DWORD), # 门编号，为0无效
        ("dwPicDataLen", DWORD), # 图片数据大小，不为0是表示后面带数据
        ("*pPicData", CHAR),
        ("byCardType", BYTE), # 卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
        ("byDeviceNo", BYTE), #  设备编号，为0时无效（有效范围1-255）
        ("byRes2", BYTE * 2),
        ("dwFingerPrintDataLen", DWORD), #  指纹数据大小，不为0是表示后面带数据
        ("*pFingerPrintData", CHAR),
        ("dwCapturePicDataLen", DWORD), #  抓拍图片数据大小，不为0是表示后面带数据
        ("*pCapturePicData", CHAR),
        ("dwCertificatePicDataLen", DWORD), # 证件抓拍图片数据大小，不为0是表示后面带数据
        ("*pCertificatePicData", CHAR),
        ("byCardReaderKind", BYTE), # 读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
        ("byRes", BYTE * 179),
    ]


LPNET_DVR_ID_CARD_INFO_ALARM = POINTER(NET_DVR_ID_CARD_INFO_ALARM)


# 身份证信息黑名单条件结构
class NET_DVR_ID_CARD_BLACK_LIST_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_ID_CARD_BLACK_LIST_COND = POINTER(NET_DVR_ID_CARD_BLACK_LIST_COND)


# 身份证信息黑名单参数
class NET_DVR_ID_CARD_BLACK_LIST_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIDCardCfg", NET_DVR_ID_CARD_INFO), #  身份证信息
        ("dwFingerPrintDataLen", DWORD), #  身份证指纹数据大小，不为0是表示后面带数据
        ("*pFingerPrintData", CHAR),
        ("dwPicDataLen", DWORD), #  身份证图片数据大小，不为0是表示后面带数据
        ("*pPicData", CHAR),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ID_CARD_BLACK_LIST_CFG = POINTER(NET_DVR_ID_CARD_BLACK_LIST_CFG)


# A =字母字符 [a..z, A..Z]，N = 数字字符 [0..9]，S = 特殊字符 [‘<’]，B=二进制数据
class NET_DVR_PASSPORT_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("byOCR", BYTE), # 0-电子护照数据，1- OCR识别数据，
        ("byRes1", BYTE * 3), # 保留
        ("byType", BYTE * MAX_PASSPORT_TYPE_LEN), # 证件类型，数据类型A，S
        ("byCountryIssue", BYTE * MAX_PASSPORT_INFO_LEN), # 签发国或签发机构，数据类型A，S
        ("byName", BYTE * MAX_PASSPORT_NAME_LEN), # 姓名，数据类型A，S
        ("byPassportNo", BYTE * MAX_PASSPORT_NUM_LEN), # 证件号码，数据类型A，N，S
        ("byNationality", BYTE * MAX_NATIONALITY_LEN), # 国籍 ，数据类型A，S
        ("struBirth", NET_DVR_DATE), # 出生日期
        ("struExpireDate", NET_DVR_DATE), # 有效截止日期
        ("bySex", BYTE), # 性别，1-男，2-女
        ("byRes2", BYTE * 35), # 保留
        ("byLocalName", BYTE * MAX_PASSPORT_INFO_LEN), # 本国姓名，数据类型B
        ("byNumber", BYTE * MAX_PASSPORT_INFO_LEN), # 个人号码，数据类型A，N，S
        ("byPlaceOfBirth", BYTE * MAX_PASSPORT_INFO_LEN), # 出生地，数据类型B
        ("byAddr", BYTE * MAX_PASSPORT_INFO_LEN), # 地址，数据类型A，N，S，B
        ("byPhone", BYTE * MAX_PASSPORT_INFO_LEN), # 电话，数据类型N，S
        ("byJob", BYTE * MAX_PASSPORT_INFO_LEN), # 职业，数据类型B
        ("byTitle", BYTE * MAX_PASSPORT_INFO_LEN), # 职衔，数据类型B
        ("byResume", BYTE * MAX_PASSPORT_INFO_LEN), # 简历，数据类型B
        ("byOtherNumber", BYTE * MAX_PASSPORT_INFO_LEN), # 其他旅行证件号码，数据类型A，N，S，B
        ("byMonitoring", BYTE * MAX_PASSPORT_MONITOR_LEN), # 监护信息，数据类型B
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PASSPORT_INFO = POINTER(NET_DVR_PASSPORT_INFO)


# 护照信息上传
class NET_DVR_PASSPORT_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwMajor", DWORD), # 报警主类型，参考宏定义
        ("dwMinor", DWORD), # 报警次类型，参考宏定义
        ("struSwipeTime", NET_DVR_TIME_V30), # 时间
        ("byNetUser", BYTE * MAX_NAMELEN), # 网络操作的用户名
        ("struRemoteHostAddr", NET_DVR_IPADDR), # 远程主机地址
        ("dwCardReaderNo", DWORD), # 读卡器编号，为0无效
        ("byCardType", BYTE), # 卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
        ("byRes2", BYTE * 11),
        ("struPassportInfo", NET_DVR_PASSPORT_INFO), # 护照信息
        ("dwFaceDataLen", DWORD), # 人脸数据大小，不为0是表示后面带数据
        ("*pFaceData", CHAR),
        ("dwPicDataLen", DWORD), # 公民证件图片数据大小，不为0是表示后面带数据
        ("*pPicData", CHAR), # 按照 [ISO/IEC 10918-1] 格式化的公民证件图像
        ("dwCapturePicDataLen", DWORD), # 抓拍图片数据大小，不为0是表示后面带数据
        ("*pCapturePicData", CHAR),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_PASSPORT_ALARM = POINTER(NET_DVR_PASSPORT_ALARM)


class NET_DVR_PASSNUM_INFO_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwAccessChannel", DWORD), # 人员通道号
        ("struSwipeTime", NET_DVR_TIME_V30), # 时间
        ("byNetUser", BYTE * MAX_NAMELEN), # 网络操作的用户名
        ("struRemoteHostAddr", NET_DVR_IPADDR), # 远程主机地址
        ("dwEntryTimes", DWORD), # 人员入次数；
        ("dwExitTimes", DWORD), # 人员出次数；
        ("dwTotalTimes", DWORD), # 人员出入总次数；
        ("byRes", BYTE * 300),
    ]


LPNET_DVR_PASSNUM_INFO_ALARM = POINTER(NET_DVR_PASSNUM_INFO_ALARM)


class NET_DVR_UPLOAD_VIDEO_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwVideoMangeNo", DWORD), # 视频管理号
        ("byVideoType", BYTE), # 视频格式 0-AVI 1-WMV 2-MP4 3-FLV 3-VOD 4-MKV 5-RMVB
        ("byRes1", BYTE * 3), # 保留
        ("sVideoName", BYTE * NAME_LEN), # 视频名称
        ("struTime", NET_DVR_TIME_V30), # 图片上传时间
        ("byRes", BYTE * 132),
    ]


LPNET_DVR_UPLOAD_VIDEO_INFO = POINTER(NET_DVR_UPLOAD_VIDEO_INFO)


class NET_DVR_DEVICE_FILE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sFileName", BYTE * NAME_LEN), # 文件名称
        ("dwManageNo", DWORD), # (只能获取)
        ("struTime", NET_DVR_TIME_EX), # 文档上传时间
        ("byUsed", BYTE), # 是否已存在，0-不存在，1-存在 （只能获取）
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_DEVICE_FILE_INFO = POINTER(NET_DVR_DEVICE_FILE_INFO)


class NET_DVR_PLAY_ITEM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byItemType", BYTE), # 播放项类型，1-图片 2-视频 3-播放列表
        ("byRes", BYTE * 3), # 保留
        ("dwPlayManageNo", DWORD), # 播放管理号
        ("dwPlayPicTime", DWORD), # 播放图片时间，单位秒, (类型为图片有效)
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_PLAY_ITEM = POINTER(NET_DVR_PLAY_ITEM)


class NET_DVR_DEVICE_PLAYLIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否有效， 0-无效  !0-有效
        ("byPlayType", BYTE), # 播放模式，1-循环播放
        ("byVaildItemNum", BYTE), # 有效播放项数量
        ("byRes", BYTE * 1),
        ("struPlayItem", NET_DVR_PLAY_ITEM * PLAYLIST_ITEM_NUM), # 播放项，前byVaildItemNum有效
        ("byPlaylistName", BYTE * PLAYLIST_NAME_LEN), # 播放列表名称
        ("dwPlaylistNo", DWORD), # 播放列表号（获取有效）
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_DEVICE_PLAYLIST = POINTER(NET_DVR_DEVICE_PLAYLIST)


class NET_DVR_PLAYLIST_ITEM_CTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCtrlType", BYTE), # 操作类型， 1-添加播放项  2-删除播放项  3-移动播放项位置
        ("byPlayIndex", BYTE), # 播放序号， 从1开始
        ("struPlayItem", NET_DVR_PLAY_ITEM), # 播放项
        ("byNewPlayIndex", BYTE), # 新播放序号，0无效
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_PLAYLIST_ITEM_CTRL = POINTER(NET_DVR_PLAYLIST_ITEM_CTRL)


class NET_DVR_PLAN_ITEM(Structure):
    _fields_ = [
        ("struPlanPlayItem", NET_DVR_PLAY_ITEM), # 播放项
        ("struTimeSegment", NET_DVR_TIME_SEGMENT), # 时间段参数
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_PLAN_ITEM = POINTER(NET_DVR_PLAN_ITEM)


class NET_DVR_PLAYPLAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否使能,  0-不使能 !0-使能
        ("byPlanMode", BYTE), # 计划模式，1-周计划  2-日计划
        ("byRes", BYTE * 2),
        ("struPlanItem", NET_DVR_PLAN_ITEM * MAX_DAYS),
        ("dwPlayPlanNo", DWORD), # 播放计划号（获取时有效）
        ("byPlayPlanName", BYTE * NAME_LEN), # 播放计划名称
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_PLAYPLAN_CFG = POINTER(NET_DVR_PLAYPLAN_CFG)


class NET_DVR_WINDOW_PLAYPLAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用播放计划， 0-不启用 !0-启用
        ("byRes", BYTE * 3),
        ("dwPlayPlanNo", DWORD), # 播放计划号
        ("byRes2", BYTE * 32),
    ]


LPNET_DVR_WINDOW_PLAYPLAN_CFG = POINTER(NET_DVR_WINDOW_PLAYPLAN_CFG)


class NET_DVR_DEV_PLAYCTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byControlType", BYTE), # 控制类型，1-音频开，2-音频关，3-停止播放，4-暂停播放，恢复播放
        ("byRes", BYTE * 131),
    ]


LPNET_DVR_DEV_PLAYCTRL = POINTER(NET_DVR_DEV_PLAYCTRL)


class NET_DVR_PLAYING_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byPlayWay", BYTE), # 播放方式， 1-单项播放  2-播放列表  3-播放计划 4-动态解码 5-紧急插播
        ("byCurPlayType", BYTE), # 正在播放素材类型， 1-图片 2-视频，动态解码和紧急插播时无效
        ("byPlayState", BYTE), # 播放状态，1-正在播放，2-播放停止，3-播放暂停
        ("byAudioState", BYTE), # 音频开关状态，0-关，1-开
        ("struPlayItemInfo", NET_DVR_PLAYITEM_INFO), # 播放项信息
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_PLAYING_INFO = POINTER(NET_DVR_PLAYING_INFO)


class NET_DVR_ONLINEUSER_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号（前端默认是1）
        ("byRes", BYTE),
    ]


LPNET_DVR_ONLINEUSER_COND = POINTER(NET_DVR_ONLINEUSER_COND)


class NET_DVR_ONLINEUSER_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byID", BYTE), # 用户序列号
        ("byUserType", BYTE), # 用户类型 0-普通用户，1-操作员，2-超级用户
        ("byDataType", BYTE), # 数据状态类型:0-检测中，1-开始，2-结束
        ("byRes", BYTE),
        ("struIpAddr", NET_DVR_IPADDR), # IP地址
        ("struLoginTime", NET_DVR_TIME_V30), # 登陆时间
        ("szUserName", CHAR * NAME_LEN), # 用户名
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_ONLINEUSER_CFG = POINTER(NET_DVR_ONLINEUSER_CFG)


# 存储健康状态
class NET_DVR_STORAGE_DETECTION(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byHealthState", BYTE), # 健康状态0-良好，1-差，2-损坏，3-未知
        ("bySDCardState", BYTE), # SDcard状态 0-掉线，1-上线,2-未知,3-已锁定
        ("wAbnormalPowerLoss", WORD), # 异常掉电数
        ("wBadBlocks", WORD), # 坏块数
        ("byRemainingLife", BYTE), # SD卡剩余寿命 0~100%
        ("byRes", BYTE * 125),
    ]


LPNET_DVR_STORAGE_DETECTION = POINTER(NET_DVR_STORAGE_DETECTION)


# 存储智能检测报警上传
class NET_DVR_STORAGE_DETECTION_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("dwCardID", DWORD), # 卡ID
        ("wAbnormalPowerLoss", WORD), # 异常掉电数
        ("wBadBlocks", WORD), # 坏块数
        ("byHealthState", BYTE), # 健康状态0-良好，1-差，2-损坏，3-未知
        ("byRes1", BYTE * 3),
        ("fResidualLife", float), # SD卡 预计剩余寿命
        ("byRes", BYTE * 118),
    ]


LPNET_DVR_STORAGE_DETECTION_ALARM = POINTER(NET_DVR_STORAGE_DETECTION_ALARM)


# 存储侦测的读写锁配置
class NET_DVR_STORAGE_RWLOCK(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 使能 0-关闭，1-开启
        ("byRes", BYTE * 3),
        ("szPassWD", CHAR * PASSWD_LEN), # 读写锁新密码
        ("szOriginalPassWD", CHAR * PASSWD_LEN), # 原始密码
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_STORAGE_RWLOCK = POINTER(NET_DVR_STORAGE_RWLOCK)


# 存储侦测的解锁配置
class NET_DVR_STORAGE_UNLOCK(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("szPassWD", CHAR * PASSWD_LEN), # 密码
        ("byRes1", BYTE * 128),
    ]


LPNET_DVR_STORAGE_UNLOCK = POINTER(NET_DVR_STORAGE_UNLOCK)


class NET_DVR_PTZTRACKSTATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byID", BYTE), # 联动设备的ID (字段byLinkageType非0的时候生效)
        ("byLinkageType", BYTE), # 联动动作0-不联动，1-联动球机设备跟踪
        ("byRes", BYTE * 254),
    ]


LPNET_DVR_PTZTRACKSTATUS = POINTER(NET_DVR_PTZTRACKSTATUS)


MAX_PROXY_COUNT = 32
class NET_DVR_SOCKS_PROXY_PARA(Structure):
    _fields_ = [
        ("byIP", BYTE * 129), # 代理服务器地址
        ("byAuthType", BYTE), # 认证方式，暂时先不使用该字段
        ("wPort", WORD), # 代理服务器端口
        ("byRes2", BYTE * 64), # 如果要使用认证方式，必然需要一些保留字节，先留一些
    ]


LPNET_DVR_SOCKS_PROXY_PARA = POINTER(NET_DVR_SOCKS_PROXY_PARA)


class NET_DVR_SOCKS_PROXYS(Structure):
    _fields_ = [
        ("struProxy", NET_DVR_SOCKS_PROXY_PARA * MAX_PROXY_COUNT),
    ]


LPNET_DVR_SOCKS_PROXYS = POINTER(NET_DVR_SOCKS_PROXYS)


class NET_DVR_GET_FIGURE_COND(Structure):
    _fields_ = [
        ("dwLength", DWORD), # 结构长度
        ("dwChannel", DWORD), # 通道
        ("struTimePoint", NET_DVR_TIME_V30), # 时间点
        ("byID", BYTE * STREAM_ID_LEN), # ID数据
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_GET_FIGURE_COND = POINTER(NET_DVR_GET_FIGURE_COND)


class NET_DVR_FIGURE_INFO(Structure):
    _fields_ = [
        ("dwPicLen", DWORD), # 图片长度
        ("*pPicBuf", CHAR), # 图片数据
    ]


LPNET_DVR_FIGURE_INFO = POINTER(NET_DVR_FIGURE_INFO)


# 手动测距参数
class NET_DVR_MANUALRANGING_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否开启手动测距：0- 否，1- 是
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_MANUALRANGING_CFG = POINTER(NET_DVR_MANUALRANGING_CFG)


class NET_DVR_VIDEO_INTERCOM_ALARM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byDoorNotCloseAlarm", BYTE), # 是否上传门未关报警，0-不上传，1-上传
        ("byRes", BYTE * 603), # 保留
    ]


LPNET_DVR_VIDEO_INTERCOM_ALARM_CFG = POINTER(NET_DVR_VIDEO_INTERCOM_ALARM_CFG)


class NET_DVR_PACKET_INFO_EX(Structure):
    _fields_ = [
        ("wWidth", WORD), # width
        ("wHeight", WORD), # height
        ("dwTimeStamp", DWORD), # lower time stamp
        ("dwTimeStampHigh", DWORD), # higher time stamp
        ("dwYear", DWORD), # year
        ("dwMonth", DWORD), # month
        ("dwDay", DWORD), # day
        ("dwHour", DWORD), # hour
        ("dwMinute", DWORD), # minute
        ("dwSecond", DWORD), # second
        ("dwMillisecond", DWORD), # millisecond
        ("dwFrameNum", DWORD), # frame num
        ("dwFrameRate", DWORD), # frame rate,当帧率小于0时，0x80000002:表示1/2帧率，同理可推0x80000010为1/16帧率
        ("dwFlag", DWORD), # flag E帧标记
        ("dwFilePos", DWORD), # file pos
        ("dwPacketType", DWORD), # Packet type:0 -file head，1 -video I frame，2- video B frame， 3- video P frame， 10- audio packet， 11- private packet
        ("dwPacketSize", DWORD), # packet size
        ("char*", unsigned), # packet buffer
        ("byRes1", BYTE * 4),
        ("dwPacketMode", DWORD), # 打包方式:0-保留，1-FU_A打包方式
        ("byRes2", BYTE * 16),
        ("dwReserved", DWORD * 6), # reserved[0] 表示私有数据类型
        # reserved[1] 表示私有裸数据地址高位
        # reserved[2] 表示私有裸数据地址低位
        # reserved[3] 表示私有裸数据长度
        # reserved[4] 私有帧/包的时间间隔\时间戳
        # reserved[5].一bit位标记是否为深P帧，深P：1，不为深P：0;     lizhonghu 20150203
    ]


LPNET_DVR_PACKET_INFO_EX = POINTER(NET_DVR_PACKET_INFO_EX)


class NET_DVR_CHECK_DEV_STATE(Structure):
    _fields_ = [
        ("dwTimeout", DWORD), # 定时检测设备工作状态，单位ms，为0时，表示使用默认值(30000)。最小值为1000
        ("fnStateCB", DEV_WORK_STATE_CB),
        ("pUserData", VOIDP),
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_CHECK_DEV_STATE = POINTER(NET_DVR_CHECK_DEV_STATE)


COURSE_NAME_LEN_128 = 128 # 课程名称
INSTRUCTOR_NAME_LEN_64 = 64 # 授课教师
MAX_UUID_LEN = 64 # 手动课程UUID
# 获取条件结构体
class NET_DVR_COURSE_LIST_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartTime", NET_DVR_TIME_V30), # 课程开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 课程结束时间
        ("byCourseName", BYTE * COURSE_NAME_LEN_128), # 课程名称
        ("byInstructorName", BYTE * INSTRUCTOR_NAME_LEN_64), # 授课老师
        ("byCourseType", BYTE), # 课表类型，0-全部，1-手动
        ("byRes", BYTE * 603),
    ]


LPNET_DVR_COURSE_LIST_COND = POINTER(NET_DVR_COURSE_LIST_COND)


class NET_DVR_COURSE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartTime", NET_DVR_TIME_V30), # 课程开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 课程开始时间
        ("byCourseName", BYTE * COURSE_NAME_LEN_128),
        ("byInstructorName", BYTE * INSTRUCTOR_NAME_LEN_64),
        ("byCourseDescription", BYTE * COURSE_DESCRIPTION_LEN),
        ("byRecUUID", BYTE * MAX_UUID_LEN), # 手动课表UUID
        ("byCourseType", BYTE), # 课表类型，0-全部，1-手动课表
        ("byRes", BYTE * 303),
    ]


LPNET_DVR_COURSE_CFG = POINTER(NET_DVR_COURSE_CFG)


class NET_DVR_RECORD_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byRecUUID", BYTE * MAX_UUID_LEN), # 手动课表UUID
        ("byRecordStatus", BYTE), # 录播状态，0-暂停，1-屏蔽,2-正在录像，3-空闲
        ("byRes1", BYTE * 3), # 保留字节
        ("dwRecordingTime", DWORD), # 已录制时长，单位：秒，最大为12*60*60
        ("byRes", BYTE * 596), # 保留字节
    ]


LPNET_DVR_RECORD_STATUS = POINTER(NET_DVR_RECORD_STATUS)


class NET_DVR_MANUAL_CURRICULUM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byRecUUID", BYTE * MAX_UUID_LEN), # 手动课表UUID
        ("byCourseName", BYTE * COURSE_NAME_LEN_128), # 课程名称
        ("byInstructorName", BYTE * INSTRUCTOR_NAME_LEN_64), # 授课老师
        ("byCourseDescription", BYTE * COURSE_DESCRIPTION_LEN),
        ("byCmdType", BYTE), # 命令，0-开始录像 1-结束 2-暂停 3-继续,4-开始屏蔽，5-结束屏蔽
        ("byRes", BYTE * 303), # 保留字节
    ]


LPNET_DVR_MANUAL_CURRICULUM_CFG = POINTER(NET_DVR_MANUAL_CURRICULUM_CFG)


class NET_DVR_IMAGE_DIFF_DETECTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struRegion", NET_VCA_POLYGON), # 区域范围
        ("byEnabled", BYTE), # 是否启用，0-不启用，1-启用
        ("byThreshold", BYTE), # 阈值[0,100]
        ("bySensitivity", BYTE), # 灵敏度 [0,100]
        ("byVideoInputType", BYTE), # 视频输入口类型，0-自动，1-HDMI，2-VGA
        ("byRes", BYTE * 300), # 保留字节
    ]


LPNET_DVR_IMAGE_DIFF_DETECTION_CFG = POINTER(NET_DVR_IMAGE_DIFF_DETECTION_CFG)


class NET_DVR_RECORDING_PUBLISH_FILE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD),
        ("byFileID", BYTE * MAX_ID_LEN_128), # 发布文件ID
        ("byRes", BYTE * 300),
    ]


LPNET_DVR_RECORDING_PUBLISH_FILE_COND = POINTER(NET_DVR_RECORDING_PUBLISH_FILE_COND)


class NET_DVR_RECORDING_PUBLISH_FILE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartTime", NET_DVR_TIME_V30), # 课程开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 课程开始时间
        ("byCourseName", BYTE * COURSE_NAME_LEN_128),
        ("byInstructorName", BYTE * INSTRUCTOR_NAME_LEN_64),
        ("byCourseDescription", BYTE * COURSE_DESCRIPTION_LEN),
        ("byRes", BYTE * 300), # 保留字节
    ]


LPNET_DVR_RECORDING_PUBLISH_FILE_INFO = POINTER(NET_DVR_RECORDING_PUBLISH_FILE_INFO)


# 屏幕控制
class NET_DVR_SCREEN_POINT(Structure):
    _fields_ = [
        ("wX", WORD), # X坐标
        ("wY", WORD), # Y坐标
    ]


LPNET_DVR_SCREEN_POINT = POINTER(NET_DVR_SCREEN_POINT)


class NET_DVR_MOUSE_PARAM(Structure):
    _fields_ = [
        ("byMouseEvent", BYTE), # 鼠标事件，1-鼠标左键按下，2-鼠标左键松开，3-鼠标右键按下，4-鼠标右键松开，
        # 5-鼠标移动，6-鼠标左键单击，7-鼠标左键双击，8-鼠标右键单击，9-滚轮按下，
        # 10-滚轮松开，11-滚轮向下，12-滚轮向上
        ("byRes1", BYTE * 3),
        ("struMousePoint", NET_DVR_SCREEN_POINT), # 鼠标坐标信息
        ("byRes2", BYTE * 8),
    ]


LPNET_DVR_MOUSE_PARAM = POINTER(NET_DVR_MOUSE_PARAM)


class NET_DVR_MARK_PARAM(Structure):
    _fields_ = [
        ("byMarkEvent", BYTE), # 标注事件，1-正常标注，2-标注结束，3-更新标注工具状态
        ("byMarkTool", BYTE), # 标注工具，0-无效，1-画笔，2-橡皮擦，标注事件为1时有效
        ("byLineWidth", BYTE), # 线条粗细，0-无效，1-细，2-中，3-粗，标注事件为1时有效
        ("byMouseEvent", BYTE), # 鼠标事件，标注事件为1时有效，0-无效，1-鼠标左键按下，2-鼠标左键松开，3-鼠标移动
        ("struColor", NET_DVR_RGB_COLOR), # 标注颜色，标注工具为画笔时有效
        ("struPoint", NET_DVR_SCREEN_POINT), # 标注坐标信息
        ("byRes", BYTE * 4),
    ]


LPNET_DVR_MARK_PARAM = POINTER(NET_DVR_MARK_PARAM)


class NET_DVR_KEYBOARD_PARAM(Structure):
    _fields_ = [
        ("dwKeyValue", DWORD), # 符号使用ASCII表中的值，特殊按键待确定
        ("byRes", BYTE * 12),
    ]


LPNET_DVR_KEYBOARD_PARAM = POINTER(NET_DVR_KEYBOARD_PARAM)


class NET_DVR_PPT_PARAM(Structure):
    _fields_ = [
        ("byPPTAction", BYTE), # PPT动作，1-打开放映，2-停止放映，3-上一个动画，4-下一个动画，
        # 5-上一页，6-下一页，7-跳到X页，8-激光笔开，9-激光笔关，10-激光笔移动
        ("byRes1", BYTE * 3),
        ("struPoint", NET_DVR_SCREEN_POINT), # 激光笔坐标信息，PPT动作为10时有效
        ("dwPPTNo", DWORD), # PPT页码数，PPT动作为7时有效
        ("byRes2", BYTE * 4),
    ]


LPNET_DVR_PPT_PARAM = POINTER(NET_DVR_PPT_PARAM)


class NET_DVR_REMOTE_CTRL_PARAM(Structure):
    _fields_ = [
        ("byRemoteCtrlCmd", BYTE), # 远程控制命令，1-切换置顶窗口，2-关闭屏幕当前窗口，3-打开文件，4-关闭文件，5-删除文件，6-关机，7-显示桌面，8-表扬
        ("byRes1", BYTE * 3),
        ("dwCtrlParam", DWORD), # 操作参数，当byRemoteCtrlCmd为3、4、5时，表示操作的文件索引；当byRemoteCtrlCmd为8时表示表扬类型，0-无效，1-表扬
        ("byRes2", BYTE * 8),
    ]


LPNET_DVR_REMOTE_CTRL_PARAM = POINTER(NET_DVR_REMOTE_CTRL_PARAM)


class NET_DVR_SPOTLIGHT_PARAM(Structure):
    _fields_ = [
        ("byCmd", BYTE), # 聚光灯命令，0-关闭聚光灯，1-开启聚光灯，2-聚光灯位置移动
        ("byRes1", BYTE * 3),
        ("struPoint", NET_DVR_SCREEN_POINT), # 聚光灯中心点坐标，聚光灯位置移动时有效
        ("dwRadius", DWORD), # 聚光灯半径
        ("byRes2", BYTE * 4),
    ]


LPNET_DVR_SPOTLIGHT_PARAM = POINTER(NET_DVR_SPOTLIGHT_PARAM)


class NET_DVR_TOUCHPAD_PARAM(Structure):
    _fields_ = [
        ("byMouseEvent", BYTE), # 鼠标事件，1-鼠标左键按下，2-鼠标左键松开，3-鼠标右键按下，4-鼠标右键松开，
        # 5-鼠标移动，6-鼠标左键单击，7-鼠标左键双击，8-鼠标右键单击，9-滚轮按下，
        # 10-滚轮松开，11-滚轮向下，12-滚轮向上
        ("byRes1", BYTE * 3),
        ("iXDisplacement", int), # X轴位移，正数表示向右移动，负数表示向左移动，鼠标移动时有效
        ("iYDisplacement", int), # Y轴位移，正数表示向上移动，负数表示向下移动，鼠标移动时有效
        ("byRes2", BYTE * 4),
    ]


LPNET_DVR_TOUCHPAD_PARAM = POINTER(NET_DVR_TOUCHPAD_PARAM)


class NET_DVR_MEDIA_LIST_PARAM(Structure):
    _fields_ = [
        ("byOperateCmd", BYTE), # 操作命令，1-显示图片素材，2-显示视频素材，3-显示ppt素材，4-关闭多媒体文件夹
        ("byRes", BYTE * 15),
    ]


LPNET_DVR_MEDIA_LIST_PARAM = POINTER(NET_DVR_MEDIA_LIST_PARAM)


class NET_DVR_SCREEN_CTRL_PARAM(Union):
    _fields_ = [
        ("struMouseParam", NET_DVR_MOUSE_PARAM), # 鼠标参数，命令类型为1时有效
        ("struMarkParam", NET_DVR_MARK_PARAM), # 标注参数，命令类型为2时有效
        ("struKeyboardInfo", NET_DVR_KEYBOARD_PARAM), # 键盘参数，命令类型为3时有效
        ("struPPTParam", NET_DVR_PPT_PARAM), # PPT参数，命令类型为4时有效
        ("struRemoteCtrlParam", NET_DVR_REMOTE_CTRL_PARAM), # 远程操作参数，命令类型为5时有效
        ("struSpotLight", NET_DVR_SPOTLIGHT_PARAM), # 聚光灯参数，命令类型为6时有效
        ("struTouchPadParam", NET_DVR_TOUCHPAD_PARAM), # 触摸板参数，命令参数为7时有效
        ("struMediaListParam", NET_DVR_MEDIA_LIST_PARAM), # 多媒体参数，命令类型为8时有效
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_SCREEN_CTRL_PARAM = POINTER(NET_DVR_SCREEN_CTRL_PARAM)


class NET_DVR_SCREEN_CTRL_CMD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCmdType", BYTE), # 命令类型，1-鼠标，2-标注，3-键盘，4-PPT，5-远程操作，6-聚光灯，7-触控板，8-显示多媒体材料
        ("byRes1", BYTE * 3),
        ("struScreenCtrlParam", NET_DVR_SCREEN_CTRL_PARAM), # 屏幕控制参数
    ]


LPNET_DVR_SCREEN_CTRL_CMD = POINTER(NET_DVR_SCREEN_CTRL_CMD)


class NET_DVR_FILE_RESPONSE_PARAM(Structure):
    _fields_ = [
        ("byFileState", BYTE), # 文件操作状态，1-文件不存在，2-打开文件失败，3-打开文件成功
        ("byRes1", BYTE * 3),
        ("dwErrorFileIndex", DWORD), # 文件操作的文件索引值
        ("byRes2", BYTE * 24),
    ]


LPNET_DVR_FILE_RESPONSE_PARAM = POINTER(NET_DVR_FILE_RESPONSE_PARAM)


class NET_DVR_PPT_RESPONSE_PARAM(Structure):
    _fields_ = [
        ("byCurrentState", BYTE), # 当前PPT状态，1 - 正在放映，2 - 放映停止，3 - PPT已关闭，4 - ppt受保护或生产预览图失败，5 - 打开放映成功，6 - 打开放映失败，7 - ppt内容为空，8 - 缩略图生成失败，9 - 缩略图生成成功
        ("byRes1", BYTE * 3),
        ("dwCurrentPage", DWORD), # PPT的页数，PPT状态为1,7,8时有效
        ("dwFileIndex", DWORD), # PPT文件索引值
        ("dwTotalPageNum", DWORD), # PPT总页数，PPT状态为5时有效
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_PPT_RESPONSE_PARAM = POINTER(NET_DVR_PPT_RESPONSE_PARAM)


class NET_DVR_SCREEN_RESPONSE_PARAM(Union):
    _fields_ = [
        ("byRes", BYTE * 32),
        ("struPPTParam", NET_DVR_PPT_RESPONSE_PARAM), # PPT参数
        ("struFileParam", NET_DVR_FILE_RESPONSE_PARAM), # 文件操作响应参数
    ]


LPNET_DVR_SCREEN_RESPONSE_PARAM = POINTER(NET_DVR_SCREEN_RESPONSE_PARAM)


class NET_DVR_SCREEN_RESPONSE_CMD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byResponseCmd", BYTE), # 屏幕响应命令类型，1-PPT，2-文件操作
        ("byRes1", BYTE * 3),
        ("struResonseParam", NET_DVR_SCREEN_RESPONSE_PARAM), # 屏幕响应参数
        ("byRes2", BYTE * 16),
    ]


LPNET_DVR_SCREEN_RESPONSE_CMD = POINTER(NET_DVR_SCREEN_RESPONSE_CMD)


class NET_DVR_SCREEN_FILE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFileType", BYTE), # 文件类型，1-图片，2-视频，3-文档，0xff-所有文件类型
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_SCREEN_FILE_COND = POINTER(NET_DVR_SCREEN_FILE_COND)


class NET_DVR_SCREEN_FILE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileIndex", DWORD), # 文件索引，全局唯一
        ("byFileType", BYTE), # 文件类型，1-图片，2-视频，3-文档，4-其他
        ("byPictureFormat", BYTE), # 图片格式，文件类型为图片时有效，1-bmp,2-jpeg,3-png,4-swf,5-gif
        ("byVideoFormat", BYTE), # 视频格式，文件类型为视频时有效，1-avi,2-wmv,3-mp4,4-flv,5-vod,6-mkv,7-rmvb
        ("byDocumentFormat", BYTE), # 文档格式，0-ppt，1-txt，2-doc，3-xls，文件类型为3时有效
        ("byFileName", BYTE * NET_SDK_MAX_FILE_PATH), # 屏幕文件名
        ("dwFileSize", DWORD), # 文件大小，单位：字节
        ("dwPPTPage", DWORD), # ppt页码值，仅当获取已打开的PPT文件信息时有效
        ("byOtherFileFormat", BYTE * 8), # 其他类型的文件的格式（例如.dat、.dll等），文件类型为4时有效
        ("byRes1", BYTE * 56),
    ]


LPNET_DVR_SCREEN_FILE_INFO = POINTER(NET_DVR_SCREEN_FILE_INFO)


class NET_DVR_SCREEN_CONFIG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byVolume", BYTE), # 音量，0-100
        ("byContrast", BYTE), # 对比度，0-100
        ("byBrightness", BYTE), # 亮度，0-100
        ("byScreenShowEnabled", BYTE), # 开启屏幕显示，0-关，非0-开
        ("byScreenLocked", BYTE), # 锁定屏幕，0-解锁，非0-锁定
        ("byBlackScreenEnabled", BYTE), # 屏幕黑屏，0-取消黑屏，非0-黑屏
        ("byRes", BYTE * 30),
    ]


LPNET_DVR_SCREEN_CONFIG = POINTER(NET_DVR_SCREEN_CONFIG)


class NET_DVR_SCREEM_FILE_UPLOAD_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFileType", BYTE), # 文件类型，1-图片，2-视频，3-文档，4-其他
        ("byPictureFormat", BYTE), # 图片格式，1-BMP，2-JPEG，3-PNG，4-SWF，5-GIF，文件类型为1时有效
        ("byVideoFormat", BYTE), # 视频格式，1-AVI，2-WMV，3-MP4，4-FLV，5-VOD，6-MKV，7-RMVB，文件类型为2时有效
        ("byDocumentFormat", BYTE), # 文档格式，0-ppt，1-txt，2-doc，3-xls，文件类型为3时有效
        ("byFileName", BYTE * NET_SDK_MAX_FILE_PATH), # 文件名称
        ("byOtherFileFormat", BYTE * 8), # 其他类型的文件的格式（例如.dat、.dll等），文件类型为4时有效
        ("byRes1", BYTE * 56),
    ]


LPNET_DVR_SCREEM_FILE_UPLOAD_PARAM = POINTER(NET_DVR_SCREEM_FILE_UPLOAD_PARAM)


class NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileIndex", DWORD), # 文件索引
        ("dwPPTPageNo", DWORD), # 下载PPT页面图片时有效，为0表示下载PPT本身，其他值表示PPT页码值
        ("byRes2", BYTE * 64),
    ]


LPNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM = POINTER(NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM)


class NET_DVR_TV_SCREEN_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwChannel", DWORD), # 通道号
        ("wTVScreenNo", WORD), # 导播屏编号 0-全部导播屏
        ("byRes", BYTE * 62), # 保留
    ]


LPNET_DVR_TV_SCREEN_COND = POINTER(NET_DVR_TV_SCREEN_COND)


class NET_DVR_TV_SCREEN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwPicStayTime", DWORD), # 画面停留时间 （0~255s）
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_TV_SCREEN_CFG = POINTER(NET_DVR_TV_SCREEN_CFG)


# 获取设备抓取图片和附加信息结构体
class NET_DVR_BV_CALIB_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwChannels", DWORD), # 通道号
        ("byRes", BYTE * 300), # 保留
    ]


LPNET_DVR_BV_CALIB_COND = POINTER(NET_DVR_BV_CALIB_COND)


class NET_DVR_BV_CALIB_PIC(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwPicID", DWORD),
        ("dwPicLen1", DWORD), # 图片1长度
        ("dwPicLen2", DWORD), # 图片2长度
        ("pPicBuffer1", CHARP), # 图片缓存
        ("pPicBuffer2", CHARP), # 图片缓存
        ("byRes", BYTE * 600), # 保留
    ]


LPNET_DVR_BV_CALIB_PIC = POINTER(NET_DVR_BV_CALIB_PIC)


# 获取双目外参标定结果
class NET_DVR_BV_CALIB_PARAM(Structure):
    _fields_ = [
        ("dwPicID", DWORD),
        ("struPoint", NET_VCA_POINT), # 眉心坐标
        ("byRes", BYTE * 32), # 保留
    ]


LPNET_DVR_BV_CALIB_PARAM = POINTER(NET_DVR_BV_CALIB_PARAM)


class NET_DVR_BV_CALIB_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwBVCalibNumber", DWORD), # 样本个数
        ("struBVCalibParam", NET_DVR_BV_CALIB_PARAM * 12),
        ("dwHumanHeight", DWORD), # 人体真实身高，单位cm
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 300), # 保留
    ]


LPNET_DVR_BV_CALIB_INFO = POINTER(NET_DVR_BV_CALIB_INFO)


class NET_DVR_BV_CALIB_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwCameraHeight", DWORD), # 摄像机高度，单位cm
        ("fPitchAngle", float), # 摄像机俯视角度[0°, 60°], （浮点数 + 360）* 1000
        ("fInclineAngle", float), # 摄像机斜角度[-20°,20°]，（浮点数 + 360） * 1000
        ("byRes", BYTE * 300), # 保留
    ]


LPNET_DVR_BV_CALIB_RESULT = POINTER(NET_DVR_BV_CALIB_RESULT)


# 获取双目高度矫正数据
class NET_DVR_BV_HCORRECTION_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwChannels", DWORD), # 通道号
        ("dwPicID", DWORD),
        ("byRes", BYTE * 300), # 保留
    ]


LPNET_DVR_BV_HCORRECTION_COND = POINTER(NET_DVR_BV_HCORRECTION_COND)


class NET_DVR_BV_HCORRECTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构长度
        ("dwHumanHeight", DWORD), # 人体真实身高，单位cm
        ("byRes", BYTE * 300), # 保留
    ]


LPNET_DVR_BV_HCORRECTION_CFG = POINTER(NET_DVR_BV_HCORRECTION_CFG)


# 语音参数配置
class NET_DVR_TMEVOICE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byVoiceSpeed", BYTE), # 语速 0~100
        ("byVoicePitch", BYTE), # 语调 0~100
        ("byVoiceVolum", BYTE), # 音量0~100
        ("byVoicePlateEnable", BYTE), # 车牌语音播报使能 ,0~关闭，1~启用
        # 声音种类；
        # 3  = Xiaoyan (female, Chinese)
        # 51 = Jiu Xu (male, Chinese)
        # 52 = Duo Xu (male, Chinese)
        # 53 = Xiaoping (female, Chinese)
        # 54 = Donald Duck (male, Chinese)
        # 55 = Baby Xu (child, Chinese)
        #
        ("dwVoiceRole", DWORD), # 声音种类
        ("sInfo", CHAR * MAX_TMEVOICE_LEN), # 语音播报内容（出入口压线圈播报的语音内容）
        ("sFileName", CHAR * MAX_TMEVOICE_LEN), # 语音文件名
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_TMEVOICE_CFG = POINTER(NET_DVR_TMEVOICE_CFG)


# 输入板参数配置
class NET_DVR_INPUT_BOARD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSlotNo", DWORD), # 输入板槽位号
        ("byFullFrameEnable", BYTE), # 是否开启全帧率畅显，0-不开启，1-开启
        ("byRes", BYTE * 3), # 四字节对齐
        ("byRes1", BYTE * 64), # 保留
    ]


LPNET_DVR_INPUT_BOARD_CFG = POINTER(NET_DVR_INPUT_BOARD_CFG)


class NET_DVR_INPUT_BOARD_CFG_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struBoardList", NET_DVR_INPUT_BOARD_CFG * MAX_NUM_INPUT_BOARD), # 输入板配置信息列表
    ]


LPNET_DVR_INPUT_BOARD_CFG_LIST = POINTER(NET_DVR_INPUT_BOARD_CFG_LIST)


# *****************************安全防范视频监控联网信息安全 begin*****************************************
# 获取加密设备信息条件结构体
# 获取加密设备信息结构体
# 加密证书参数结构体
# *****************************安全防范视频监控联网信息安全 end*****************************************
MAX_RING_NAME_LEN_128 = 128 # 铃音名称长度
class NET_DVR_RING_UPLOAD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRingID", DWORD), # 铃音序号，[1,8]
        ("byRingName", BYTE * MAX_RING_NAME_LEN_128), # 铃音名称
        ("dwRingSize", DWORD), # 文件大小
        ("byRingType", BYTE), # 铃音类型，0-wav
        ("byRes", BYTE * 363),
    ]


LPNET_DVR_RING_UPLOAD_CFG = POINTER(NET_DVR_RING_UPLOAD_CFG)


class NET_DVR_RING_SEARCH_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRingID", DWORD), # 铃音序号，傻瓜式查找，不设置此参数（设为0）表示无视序号查找
        ("byRes", BYTE * 300),
    ]


LPNET_DVR_RING_SEARCH_COND = POINTER(NET_DVR_RING_SEARCH_COND)


class NET_DVR_RING_SEARCH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRingID", DWORD), # 铃音序号，[1,8]
        ("byRingName", BYTE * MAX_RING_NAME_LEN_128), # 铃音名称
        ("dwRingSize", DWORD), # 文件大小
        ("byRingType", BYTE), # 铃音类型，0-wav
        ("byRes", BYTE * 303),
    ]


LPNET_DVR_RING_SEARCH_CFG = POINTER(NET_DVR_RING_SEARCH_CFG)


# 报警控制
class NET_DVR_ALARMCTRL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byListenPicUploadEnabled", BYTE), # 监听图片上传使能
        ("byRes", BYTE),
    ]


LPNET_DVR_ALARMCTRL_CFG = POINTER(NET_DVR_ALARMCTRL_CFG)


class NET_DVR_VEHICLEFLOW_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byLane", BYTE), # 车道号，1~6车道,0为所有车道。
        ("byRes1", BYTE * 3),
        ("struStartTime", NET_DVR_TIME_V30), # 开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 结束时间
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_VEHICLEFLOW_COND = POINTER(NET_DVR_VEHICLEFLOW_COND)


class NET_DVR_VEHICLEFLOW_INFO(Structure):
    _fields_ = [
        ("dwVehicleFlowValue", DWORD), # 为一个时间段内的流量
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_VEHICLEFLOW_INFO = POINTER(NET_DVR_VEHICLEFLOW_INFO)


class NET_DVR_VEHICLEFLOW_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struVehFlow", NET_DVR_VEHICLEFLOW_INFO * MAX_VEHICLEFLOW_INFO),
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_VEHICLEFLOW_CFG = POINTER(NET_DVR_VEHICLEFLOW_CFG)


# 条件结构体
class NET_DVR_IPADDR_FILTER_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_IPADDR_FILTER_COND = POINTER(NET_DVR_IPADDR_FILTER_COND)


class NET_DVR_TEMPHUMSENSOR(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("byEnable", BYTE), # 使能 0-关，1-开
        ("byCtrlMode", BYTE), # 控制模式 0-温度阈值控制，1-湿度阈值控制，2-温湿度阈值控制
        ("byTemperatureValue", BYTE), # 温度阈值，0~100摄氏度,当控制模式为0或者2时生效
        ("byHumidityValue", BYTE), # 湿度阈值，0~100，当控制模式为1或者2时生效
        ("byFanSwitch", BYTE), # 风扇开关，0-关，1-开
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)。
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_TEMPHUMSENSOR = POINTER(NET_DVR_TEMPHUMSENSOR)


# 雷达测速配置
class NET_DVR_POSTRADARSPEED_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byLaneType", BYTE), # 道路类型；0~未配置,1~高速公路,2~城市快速路,0xff~其他道路
        ("byRes1", BYTE * 3),
        ("dwInterval", DWORD), # 超速抓拍间隔，单位：ms
        ("dwSignSpeed", DWORD), # 标志限速(小车)，单位km/h
        ("dwSpeedLimit", DWORD), # 限速值(小车)，单位km/h
        ("dwBigCarSignSpeed", DWORD), # 标志限速(大车)，单位km/h
        ("dwBigCarSpeedLimit", DWORD), # 限速值（大车），单位km/h
        ("dwLowSpeedLimit", DWORD), #  小车限低速，单位km/h
        ("dwBigCarLowSpeedLimit", DWORD), #  大车限低速，单位km/h
        ("byCheckPostEnabled", BYTE), # 启用卡口抓拍
        ("byOverSpeedEnabled", BYTE), # 启用超速抓拍
        ("byRes", BYTE * 246),
    ]


LPNET_DVR_POSTRADARSPEED_CFG = POINTER(NET_DVR_POSTRADARSPEED_CFG)


# 雷达参数配置
class NET_DVR_POSTRADARPARAM_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("bySoftWareVersion", BYTE * 32), # 软件版本号 只读参数
        ("byID", BYTE), # 串口号
        ("byWorkMode", BYTE), # 工作模式，0~持续,1~触头,2~触尾,3~巡逻车触尾,4~双触,0xff~其他
        ("bySpeedType", BYTE), # 速度格式，0~单字节,1~双字节,2~四字节,0xff~其他
        ("byDirectionFilter", BYTE), # 方向过滤，0~不过滤,1~输出来向,2~输出去向
        ("dwAngleCorrect", DWORD), # 角度修正[0,70]
        ("dwSensitivity", DWORD), #  灵敏度[11,240]
        ("dwSpeedLowLimit", DWORD), #  测速下限[1,150km/h]
        ("dwTrigDistance", DWORD), #  触发距离[0,40m]
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_POSTRADARPARAM_CFG = POINTER(NET_DVR_POSTRADARPARAM_CFG)


class NET_DVR_CLOUD_URL_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byType", BYTE), # 云类型0-保留，1- OneDrive  2-GoogleDrive 3-DropBox
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_CLOUD_URL_COND = POINTER(NET_DVR_CLOUD_URL_COND)


class NET_DVR_CLOUD_URL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szURL", CHAR * 256), # 云存储URL
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_CLOUD_URL = POINTER(NET_DVR_CLOUD_URL)


class NET_DVR_CLOUD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 0-不开启，1-开启
        ("byType", BYTE), # 云类型0-保留，1- OneDrive  2-GoogleDrive 3-DropBox
        ("byStatus", BYTE), # 状态，只读 0-保留 1-在线 2-不在线
        ("byRes1", BYTE),
        ("szAuthCode", CHAR * CODE_LEN), # 授权码
        ("szAlias", CHAR * ALIAS_LEN), # 别名，只读
        ("i64TotalCapability", INT64), # 总容量，只读，单位：MB
        ("i64UsedSpace", INT64), # 已用容量，只读，单位：MB
        ("byRes2", BYTE * 256),
    ]


LPNET_DVR_CLOUD_CFG = POINTER(NET_DVR_CLOUD_CFG)


class NET_DVR_CLOUD_UPLOADSTRATEGY_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRes", BYTE * 254), # 为将来使用流ID做保留
    ]


LPNET_DVR_CLOUD_UPLOADSTRATEGY_COND = POINTER(NET_DVR_CLOUD_UPLOADSTRATEGY_COND)


class NET_DVR_CLOUD_UPLOADSTRATEGY(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byStrategyType", BYTE), # 策略类型0-无意义，1-录像，2-图片
        ("byRes1", BYTE * 3),
        ("dwRecordType", DWORD), # 策略类型byStrategyType 为1时有效，按位表示
        # 0x00: 无意义
        # 0x01: 全部事件
        # 0x02: 移动侦测
        # 0x04: 信号量报警类型
        # 0x08: 智能类型
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_CLOUD_UPLOADSTRATEGY = POINTER(NET_DVR_CLOUD_UPLOADSTRATEGY)


# 录像完整性检查条件参数
class NET_DVR_RECORD_CHECK_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamInfo", NET_DVR_STREAM_INFO),
        ("byCheckType", BYTE), # 检测方式,0--录像是否完整,1--录像是否完整&缺失录像的起止时间
        ("byRes1", BYTE * 3),
        ("struBeginTime", NET_DVR_TIME_EX), # 检测录像的开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 检测录像的结束时间
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_RECORD_CHECK_COND = POINTER(NET_DVR_RECORD_CHECK_COND)


# 录像完整性检查结果
class NET_DVR_RECORD_CHECK_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRecordNotComplete", BYTE), # 录像是否完整，0--完整,1--不完整
        ("byRes1", BYTE * 3),
        ("struBeginTime", NET_DVR_TIME_EX), # 缺失录像的开始时间，byCheckType、byRecordNotComplete值都为1时有效
        ("struEndTime", NET_DVR_TIME_EX), # 缺失录像的结束时间，byCheckType、byRecordNotComplete值都为1时有效
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_RECORD_CHECK_RET = POINTER(NET_DVR_RECORD_CHECK_RET)


# 添加手动回传任务条件
class NET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamInfo", NET_DVR_STREAM_INFO),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND = POINTER(NET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND)


# 添加手动回传任务参数
class NET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struBeginTime", NET_DVR_TIME_EX), # 回传的录像开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 回传的录像结束时间
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG = POINTER(NET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG)


# 回传任务参数
class NET_DVR_RECORD_PASSBACK_TASK_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTaskID", DWORD), # 任务ID
        ("byRes", BYTE * 160),
    ]


LPNET_DVR_RECORD_PASSBACK_TASK_CFG = POINTER(NET_DVR_RECORD_PASSBACK_TASK_CFG)


# 获取所有手动回传任务条件参数
class NET_DVR_RECORD_PASSBACK_MANUAL_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byType", BYTE), # 获取方式,0--获取全部剩余任务，1--根据流ID获取剩余任务, 2--获取全部任务，3--根据流ID获取任务，4—根据任务ID获取任务
        ("byTimeSegmentQuety", BYTE), # 是否启用时间范围查询，0-不启用，1-启用
        ("byRes1", BYTE * 2), # 保留
        ("struStreamInfo", NET_DVR_STREAM_INFO), # 流id信息（72字节），根据流ID获取剩余任务时有效
        ("struBeginTime", NET_DVR_TIME_EX), # 查询开始时间，byTimeSegmentQuety启用时有效
        ("struEndTime", NET_DVR_TIME_EX), # 查询结束时间，byTimeSegmentQuety启用时有效
        ("dwTaskID", DWORD), # 任务ID, byType等于4时有效
        ("byRes", BYTE * 108), # 保留
    ]


LPNET_DVR_RECORD_PASSBACK_MANUAL_COND = POINTER(NET_DVR_RECORD_PASSBACK_MANUAL_COND)


# 获取所有手动回传任务参数
class NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamInfo", NET_DVR_STREAM_INFO), # 流id信息（72字节），根据流ID获取剩余任务时有效
        ("dwTaskID", DWORD), # 任务ID
        ("struStartTime", NET_DVR_TIME_EX), # 回传的录像开始时间
        ("struStopTime", NET_DVR_TIME_EX), # 回传的录像结束时间
        ("byTaskStatus", BYTE), # 任务状态，0--未执行，1--暂停中，2--已执行, 3--回传中, 4--回传失败
        ("byRes1", BYTE * 3),
        ("struExecuteStartTime", NET_DVR_TIME_EX), # 任务实际执行开始时间，byTaskStatus为1和2有效
        ("struExecuteStopTime", NET_DVR_TIME_EX), # 任务实际执行结束时间，byTaskStatus为2有效
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET = POINTER(NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET)


# 控制手动回传任务参数
class NET_DVR_RECORD_PASSBACK_MANUAL_CTRL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byControlType", BYTE), # 控制方式,0--暂停所有手动任务，1--恢复所有手动任务
        ("byRes", BYTE * 131), # 保留
    ]


LPNET_DVR_RECORD_PASSBACK_MANUAL_CTRL = POINTER(NET_DVR_RECORD_PASSBACK_MANUAL_CTRL)


# 删除手动回传任务条件
class NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDelType", BYTE), # 删除方式,0--根据任务ID删除，1--根据流ID删除任务，2--删除全部任务
        ("byRes", BYTE * 131), # 保留
    ]


LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND = POINTER(NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND)


# 删除手动回传任务参数
class NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTaskID", DWORD), # 手动回传任务ID，根据任务ID删除任务时有效
        ("struStreamInfo", NET_DVR_STREAM_INFO), # 流id信息（72字节），根据流ID删除任务时有效
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG = POINTER(NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG)


class NET_DVR_PASSBACK_DAY(Structure):
    _fields_ = [
        ("byAllDay", BYTE), # 是否启用全天回传
        ("byRes", BYTE * 3), # 保留
    ]


LPNET_DVR_PASSBACK_DAY = POINTER(NET_DVR_PASSBACK_DAY)


class NET_DVR_PASSBACK_SCHED(Structure):
    _fields_ = [
        ("struPassBackTime", NET_DVR_SCHEDTIME), # 回传任务时间段，开始时间-结束时间
        ("byRes", BYTE * 4), # 保留
    ]


LPNET_DVR_PASSBACK_SCHED = POINTER(NET_DVR_PASSBACK_SCHED)


# 录像回传计划参数
class NET_DVR_RECORD_PASSBACK_SCH_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 是否启用，0--不启用，1--启用
        ("byPassBackWeek", BYTE), # 是否按周回传，0--否，1--是，值为1时struPassBackDay、struPassBackSched无效
        ("byRes1", BYTE * 2), # 保留
        ("struPassBackDay", NET_DVR_PASSBACK_DAY * MAX_DAYS), # 全天回传计划
        ("struPassBackSched", NET_DVR_PASSBACK_SCHED * MAX_DAYS), # 时间段回传计划
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_RECORD_PASSBACK_SCH_CFG = POINTER(NET_DVR_RECORD_PASSBACK_SCH_CFG)


# 回传历史录像计划参数
class NET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 版本头
        ("byEnable", BYTE), # 是否启用，0--不启用，1--启用
        ("byRes1", BYTE * 3), # 保留
        ("struPassBackDay", NET_DVR_PASSBACK_DAY * MAX_DAYS), # 全天回传计划
        ("struPassBackSched", NET_DVR_PASSBACK_SCHED * MAX_DAYS), # 时间段回传计划
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG = POINTER(NET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG)


# 录像卷参数
class NET_DVR_DEV_STORAGE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwCapacityTotal", DWORD), # 设备存储(CVR表示录像卷)总容量(只读)，单位MB
        ("dwFreeSpaceTotal", DWORD), # 设备存储(CVR表示录像卷)剩余总空间(只读)，单位MB
        ("dwLockedRecordSpace", DWORD), # 设备已加锁录像存储(CVR表示录像卷)总容量(只读)，单位MB
        ("dwUnLockedSpace", DWORD), # 设备未加锁存储(CVR表示录像卷)总容量(只读),包含未加锁录像和剩余存储空间，单位MB
        ("byRes", BYTE * 512), # 保留
    ]


LPNET_DVR_DEV_STORAGE_CFG = POINTER(NET_DVR_DEV_STORAGE_CFG)


# 一键配置CVR（V50）
class NET_DVR_ONE_KEY_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byRaidType", BYTE), # RAID类型：0-raid5,1-raid6,2-raid95（Vraid）,3-单盘模式，即不创建raid
        ("bySpareRaidProportion", BYTE), # 热备盘：raid（阵列）的比例,0--（0:1）,1--（1:1）,2--（1:2）,3--（1:3）,4--（1:4）,5--（1:5）,6--（1:6）,7--（6:1）,8--（5:1）,9--（4:1）,10--（3:1）,11--（2:1）
        ("byPicQuota", BYTE), # 图片卷比例：范围0~100
        ("byRes", BYTE * 257),
    ]


LPNET_DVR_ONE_KEY_CFG_V50 = POINTER(NET_DVR_ONE_KEY_CFG_V50)


class NET_DVR_ONE_KEY_RESULT_V51(Structure):
    _fields_ = [
        ("dwState", DWORD), # 状态值，详见备注的状态值
        ("byProgress", BYTE), # 操作进度，0~100
        ("byRes", BYTE * 259),
    ]


LPNET_DVR_ONE_KEY_RESULT_V51 = POINTER(NET_DVR_ONE_KEY_RESULT_V51)


class NET_DVR_ONE_KEY_CFG_SAN_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byRaidType", BYTE), # RAID类型：0-raid5,1-raid6
        ("bySpareRaidProportion", BYTE), # 热备盘：raid（阵列）的比例,0--（0:1）,1--（1:1）,2--（1:2）,3--（1:3）,4--（1:4）,5--（1:5）,6--（1:6）,7--（6:1）,8--（5:1）,9--（4:1）,10--（3:1）,11--（2:1）
        ("byRes", BYTE * 254),
    ]


LPNET_DVR_ONE_KEY_CFG_SAN_V50 = POINTER(NET_DVR_ONE_KEY_CFG_SAN_V50)


class NET_DVR_REC_PASSBACK_BASIC_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwStartTime", DWORD), # 检测窗口开始时间（单位：分钟）
        ("dwStopTime", DWORD), # 检测窗口结束时间（单位：分钟）
        ("wMaxTotalConcurrenceNum", WORD), # 并发回传路数上限,针对的是编码器路数，不是回传任务条数
        ("wMaxDvrConcurrenceNum", WORD), # 单台DVR并发回传通道数上限
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_REC_PASSBACK_BASIC_CFG = POINTER(NET_DVR_REC_PASSBACK_BASIC_CFG)


# 设备连接的用户参数
class NET_DVR_ONLINE_USER_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("wOnlineUserCount", WORD), # 登录设备的用户数
        ("byRes", BYTE * 514), # 保留
    ]


LPNET_DVR_ONLINE_USER_INFO = POINTER(NET_DVR_ONLINE_USER_INFO)


# 查询录像总大小条件参数
class NET_DVR_RECORD_SEGMENT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreanInfo", NET_DVR_STREAM_INFO),
        ("struStartTime", NET_DVR_TIME_EX), # 开始时间
        ("struStopTime", NET_DVR_TIME_EX), # 结束时间
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_RECORD_SEGMENT_COND = POINTER(NET_DVR_RECORD_SEGMENT_COND)


# 查询录像总大小返回参数
class NET_DVR_RECORD_SEGMENT_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRecordTotalSize", DWORD), # 录像总大小，单位MB
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_RECORD_SEGMENT_RET = POINTER(NET_DVR_RECORD_SEGMENT_RET)


class NET_DVR_ACCESSORY_CARD_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szAccessoryCardInfo", BYTE * MAX_ACCESSORY_CARD), # 配件板(智能板和拼控板)型号信息
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_ACCESSORY_CARD_INFO = POINTER(NET_DVR_ACCESSORY_CARD_INFO)


# 查询信息条件结构体
class NET_DVR_SEARCH_INFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCommand", BYTE), # 查询条件，0-个人，1-所有
        ("byRes1", BYTE * 3),
        ("dwEmployeeNo", DWORD), # 工号（查询条件配置为0-个人时有效）
        ("byName", BYTE * NAME_LEN), # 姓名（查询条件配置为0-个人时有效）
        ("struStartTime", NET_DVR_TIME_V30), # 开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 结束时间
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_SEARCH_INFO_COND = POINTER(NET_DVR_SEARCH_INFO_COND)


# 获取排班信息
class NET_DVR_SCHEDULE_CHOICE(Structure):
    _fields_ = [
        ("byScheduleType", BYTE), # 班次类型，0-不排班、1-普通班、2-工时班
        ("byScheduleNo", BYTE), # 班次编号
        ("byRes", BYTE * 14), # 保留
    ]


LPNET_DVR_SCHEDULE_CHOICE = POINTER(NET_DVR_SCHEDULE_CHOICE)


#   B20 V1.5
class NET_DVR_DISPINPUT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDispInputNo", DWORD), # 显示输入号
        ("dwEDIDFileNo", DWORD), # 关联的EDID文件编号
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DISPINPUT_CFG = POINTER(NET_DVR_DISPINPUT_CFG)


# 排班计划结构体
class NET_DVR_SCHEDULE_PLAN(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("bySchedulePlanNo", BYTE), # 排班计划编号,起始范围根据能力集返回
        ("bySchedulePlanType", BYTE), # 排班计划类型，0-个人、1-部门
        ("byEnable", BYTE), # 使能
        ("byRes1", BYTE),
        ("struScheduleChoice", NET_DVR_SCHEDULE_CHOICE * DAYS_A_WEEK), # 班次选择
        ("struStartTime", NET_DVR_TIME_V30), # 开始时间
        ("struEndTime", NET_DVR_TIME_V30), # 结束时间
        ("byHolidayNo", BYTE), # 假日组编号
        ("byRes", BYTE * 63), # 保留
    ]


LPNET_DVR_SCHEDULE_PLAN = POINTER(NET_DVR_SCHEDULE_PLAN)


class NET_DVR_DISPINPUT_CFG_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDispInputNum", DWORD), # 返回的NET_DVR_DISPINPUT_CFG结构的个数
        ("lpstruBuffer", LPNET_DVR_DISPINPUT_CFG), # 缓冲区指针
        ("dwBufferSize", DWORD), # 缓冲区大小
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DISPINPUT_CFG_LIST = POINTER(NET_DVR_DISPINPUT_CFG_LIST)


# 获取排班信息
class NET_DVR_SCHEDULE_INFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEmployeeNo", DWORD), # 工号
        ("byName", BYTE * NAME_LEN), # 姓名
        ("byDepartmentName", BYTE * NAME_LEN), # 部门名称
        ("struSchedulePlan", NET_DVR_SCHEDULE_PLAN), # 排班计划
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_SCHEDULE_INFO_CFG = POINTER(NET_DVR_SCHEDULE_INFO_CFG)


# 获取考勤汇总信息
class NET_DVR_ATTENDANCE_SUMMARY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEmployeeNo", DWORD), # 工号
        ("byName", BYTE * NAME_LEN), # 姓名
        ("byDepartmentName", BYTE * NAME_LEN), # 部门名称
        ("dwWorkStandard", DWORD), # 标准工作时间（分钟）
        ("dwWorkActual", DWORD), # 实际工作时间（分钟）
        ("dwLateTimes", DWORD), # 迟到次数
        ("dwLateMinutes", DWORD), # 迟到累计时间（分钟）
        ("dwLeaveEarlyTimes", DWORD), # 早退次数
        ("dwLeaveEarlyMinutes", DWORD), # 早退累计时间（分钟）
        ("dwOvertimeStandard", DWORD), # 标准加班时间（分钟）
        ("dwOvertimeActual", DWORD), # 实际加班时间（分钟）
        ("dwAttendanceStandard", DWORD), # 标准出勤天数（天）
        ("dwAttendanceActual", DWORD), # 实际出勤天数（天）
        ("dwAbsentDays", DWORD), # 旷工天数（天）
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_ATTENDANCE_SUMMARY_CFG = POINTER(NET_DVR_ATTENDANCE_SUMMARY_CFG)


# 获取考勤记录信息
class NET_DVR_ATTENDANCE_RECORD_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEmployeeNo", DWORD), # 工号
        ("byName", BYTE * NAME_LEN), # 姓名
        ("byDepartmentName", BYTE * NAME_LEN), # 部门名称
        ("struAttendanceTime", NET_DVR_TIME_V30), # 考勤时间
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_ATTENDANCE_RECORD_CFG = POINTER(NET_DVR_ATTENDANCE_RECORD_CFG)


# 考勤时间段信息
class NET_DVR_ATTENDANCE_TIME(Structure):
    _fields_ = [
        ("struOnDutyTime", NET_DVR_TIME_V30), # 上班时间
        ("struOffDutyTime", NET_DVR_TIME_V30), # 下班时间
    ]


LPNET_DVR_ATTENDANCE_TIME = POINTER(NET_DVR_ATTENDANCE_TIME)


# 获取异常统计信息
class NET_DVR_ABNORMAL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEmployeeNo", DWORD), # 工号
        ("byName", BYTE * NAME_LEN), # 姓名
        ("byDepartmentName", BYTE * NAME_LEN), # 部门名称
        ("struAttendanceTime", NET_DVR_ATTENDANCE_TIME * ABNORMAL_INFO_NUM), # 异常时间段
        ("dwLateMinutes", DWORD), # 迟到时间（分钟）
        ("dwLeaveEarlyMinutes", DWORD), # 早退时间（分钟）
        ("dwAbsenceMinutes", DWORD), # 缺勤时间（分钟）
        ("dwTotalMinutes", DWORD), # 合计时间（分钟）
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_ABNORMAL_CFG = POINTER(NET_DVR_ABNORMAL_CFG)


class NET_DVR_CARD_CFG_V50(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwModifyParamType", DWORD),
        # 需要修改的卡参数，设置卡参数时有效，按位表示，每位代表一种参数，1为需要修改，0为不修改
        # #define CARD_PARAM_CARD_VALID       0x00000001 卡是否有效参数
        # #define CARD_PARAM_VALID            0x00000002  有效期参数
        # #define CARD_PARAM_CARD_TYPE        0x00000004  卡类型参数
        # #define CARD_PARAM_DOOR_RIGHT       0x00000008  门权限参数
        # #define CARD_PARAM_LEADER_CARD      0x00000010  首卡参数
        # #define CARD_PARAM_SWIPE_NUM        0x00000020  最大刷卡次数参数
        # #define CARD_PARAM_GROUP            0x00000040  所属群组参数
        # #define CARD_PARAM_PASSWORD         0x00000080  卡密码参数
        # #define CARD_PARAM_RIGHT_PLAN       0x00000100  卡权限计划参数
        # #define CARD_PARAM_SWIPED_NUM       0x00000200  已刷卡次数
        # #define CARD_PARAM_EMPLOYEE_NO      0x00000400  工号
        # #define CARD_PARAM_NAME             0x00000800  姓名
        # #define CARD_PARAM_DEPARTMENT_NO    0x00001000  部门编号
        # #define CARD_SCHEDULE_PLAN_NO       0x00002000  排班计划编号
        # #define CARD_SCHEDULE_PLAN_TYPE     0x00004000  排班计划类型
        # #define CARD_ROOM_NUMBER            0x00008000  房间号
        # #define CARD_SIM_NO                 0x00010000  SIM卡号（手机号）
        # #define CARD_FLOOR_NUMBER           0x00020000  楼层号
        # #define CARD_USER_TYPE              0x00040000  用户类型
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("byCardValid", BYTE), # 卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
        ("byCardType", BYTE), # 卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，9-员工卡，10-应急卡，11-应急管理卡（用于授权临时卡权限，本身不能开门），默认普通卡
        ("byLeaderCard", BYTE), # 是否为首卡，1-是，0-否
        ("byUserType", BYTE), #  0 – 普通用户1 - 管理员用户
        ("byDoorRight", BYTE * MAX_DOOR_NUM_256), # 门权限(楼层权限、锁权限)，按位表示，1为有权限，0为无权限，从低位到高位表示对门（锁）1-N是否有权限
        ("struValid", NET_DVR_VALID_PERIOD_CFG), # 有效期参数
        ("byBelongGroup", BYTE * MAX_GROUP_NUM_128), # 所属群组，按字节表示，1-属于，0-不属于
        ("byCardPassword", BYTE * CARD_PASSWORD_LEN), # 卡密码
        ("wCardRightPlan", WORD * MAX_DOOR_NUM_256), # 卡权限计划，取值为计划模板编号，同个门（锁）不同计划模板采用权限或的方式处理
        ("dwMaxSwipeTime", DWORD), # 最大刷卡次数，0为无次数限制（开锁次数）
        ("dwSwipeTime", DWORD), # 已刷卡次数
        ("wRoomNumber", WORD), # 房间号
        ("wFloorNumber", SHORT), # 层号
        ("dwEmployeeNo", DWORD), # 工号（用户ID）
        ("byName", BYTE * NAME_LEN), # 姓名
        ("wDepartmentNo", WORD), # 部门编号
        ("wSchedulePlanNo", WORD), # 排班计划编号
        ("bySchedulePlanType", BYTE), # 排班计划类型：0-无意义、1-个人、2-部门
        ("byRightType", BYTE), # 下发权限类型：0-普通发卡权限、1-二维码权限、2-蓝牙权限（可视对讲设备二维码权限配置项：房间号、卡号（虚拟卡号）、最大刷卡次数（开锁次数）、有效期参数；蓝牙权限：卡号（萤石APP账号）、其他参数配置与普通发卡权限一致）
        ("byRes2", BYTE * 2),
        ("dwLockID", DWORD), # 锁ID
        ("byLockCode", BYTE * MAX_LOCK_CODE_LEN), # 锁代码
        ("byRoomCode", BYTE * MAX_DOOR_CODE_LEN), # 房间代码
        # 按位表示，0-无权限，1-有权限
        # 第0位表示：弱电报警
        # 第1位表示：开门提示音
        # 第2位表示：限制客卡
        # 第3位表示：通道
        # 第4位表示：反锁开门
        # 第5位表示：巡更功能
        ("dwCardRight", DWORD), # 卡权限
        ("dwPlanTemplate", DWORD), # 计划模板(每天)各时间段是否启用，按位表示，0--不启用，1-启用
        ("dwCardUserId", DWORD), # 持卡人ID
        ("byCardModelType", BYTE), # 0-空，1- MIFARE S50，2- MIFARE S70，3- FM1208 CPU卡，4- FM1216 CPU卡，5-国密CPU卡，6-身份证，7- NFC
        ("byRes3", BYTE * 51),
        ("bySIMNum", BYTE * NAME_LEN), # SIM卡号（手机号）
    ]


LPNET_DVR_CARD_CFG_V50 = POINTER(NET_DVR_CARD_CFG_V50)


class NET_DVR_CAPTURE_FINGERPRINT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byFingerPrintPicType", BYTE), # 图片类型：0-无意义
        ("byFingerNo", BYTE), # 手指编号，范围1-10
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_CAPTURE_FINGERPRINT_COND = POINTER(NET_DVR_CAPTURE_FINGERPRINT_COND)


class NET_DVR_CAPTURE_FINGERPRINT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFingerPrintDataSize", DWORD), # 指纹数据大小
        ("byFingerData", BYTE * MAX_FINGER_PRINT_LEN), # 指纹数据内容
        ("dwFingerPrintPicSize", DWORD), # 指纹图片大小，等于0时，代表无指纹图片数据
        ("pFingerPrintPicBuffer", CHARP), # 指纹图片缓存
        ("byFingerNo", BYTE), # 手指编号，范围1-10
        ("byFingerPrintQuality", BYTE), # 指纹质量，范围1-100
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_CAPTURE_FINGERPRINT_CFG = POINTER(NET_DVR_CAPTURE_FINGERPRINT_CFG)


class NET_DVR_CAPTURE_FACE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CAPTURE_FACE_COND = POINTER(NET_DVR_CAPTURE_FACE_COND)


class NET_DVR_FACE_FEATURE(Structure):
    _fields_ = [
        ("struFace", NET_VCA_RECT), # 人脸子图区域
        ("struLeftEye", NET_VCA_POINT), #  左眼坐标
        ("struRightEye", NET_VCA_POINT), #  右眼坐标
        ("struLeftMouth", NET_VCA_POINT), #  嘴左边坐标
        ("struRightMouth", NET_VCA_POINT), #  嘴右边坐标
        ("struNoseTip", NET_VCA_POINT), #  鼻子坐标
    ]


LPNET_DVR_FACE_FEATURE = POINTER(NET_DVR_FACE_FEATURE)


class NET_DVR_CAPTURE_FACE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFaceTemplate1Size", DWORD), # 人脸模板1数据大小，等于0时，代表无人脸模板1数据
        ("pFaceTemplate1Buffer", CHARP), # 人脸模板1数据缓存（不大于2.5k）
        ("dwFaceTemplate2Size", DWORD), # 人脸模板2数据大小，等于0时，代表无人脸模板2数据
        ("pFaceTemplate2Buffer", CHARP), # 人脸模板2数据缓存（不大于2.5K）
        ("dwFacePicSize", DWORD), # 人脸图片数据大小，等于0时，代表无人脸图片数据
        ("pFacePicBuffer", CHARP), # 人脸图片数据缓存
        ("byFaceQuality1", BYTE), # 人脸质量，范围1-100
        ("byFaceQuality2", BYTE), # 人脸质量，范围1-100
        ("byCaptureProgress", BYTE), # 采集进度，目前只有两种进度值：0-未采集到人脸，100-采集到人脸（只有在进度为100时，才解析人脸信息）
        ("byFacePicQuality", BYTE), # 人脸图片中人脸质量
        ("dwInfraredFacePicSize", DWORD), # 红外人脸图片数据大小，等于0时，代表无人脸图片数据
        ("pInfraredFacePicBuffer", CHARP), # 红外人脸图片数据缓存
        ("byInfraredFacePicQuality", BYTE), # 红外人脸图片中人脸质量
        ("byRes1", BYTE * 3),
        ("struFeature", NET_DVR_FACE_FEATURE), # 人脸抠图特征信息
        ("byRes", BYTE * 56),
    ]


LPNET_DVR_CAPTURE_FACE_CFG = POINTER(NET_DVR_CAPTURE_FACE_CFG)


# 查询手动回传任务可执行性条件参数
class NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamInfo", NET_DVR_STREAM_INFO), # 流id信息（72字节）
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND = POINTER(NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND)


# 查询手动回传任务可执行性条件参数
class NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStreamInfo", NET_DVR_STREAM_INFO), # 流id信息（72字节）
        ("byExecutable", BYTE), # 0-不可立即回传，1-可立即执行回传
        ("byUnexecutableReason", BYTE), # 不可立即回传原因, 0-需要排队，1-编码器无连接，2-流ID不存在，3-CVR异常，4-无输入视频, 5-编码器用户名或密码错, 6-前端设备不兼容, 7-其他原因
        ("byRes", BYTE * 254), # 保留
    ]


LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET = POINTER(NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET)


class NET_DVR_STREAM_MEDIA_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sUrl", BYTE * MAX_URL_LEN),
        ("struDMSIP", NET_DVR_IPADDR), #  dms IP地址
        ("wDMSPort", WORD), # dms 端口号
        ("byRes", BYTE * 366), # 保留
    ]


LPNET_DVR_STREAM_MEDIA_CFG = POINTER(NET_DVR_STREAM_MEDIA_CFG)


# 船只检测单个区域配置
class NET_DVR_SHIPSDETECTION_REGION_CFG(Structure):
    _fields_ = [
        #
        ("byRuleID", BYTE),
        ("byEnable", BYTE), # 使能
        ("bySensitivity", BYTE), # 灵敏度参数，范围[1,100]
        ("byFrameOverlayEnabled", BYTE), # 视频是否叠加检测框
        ("byRes", BYTE * 36),
        ("struPolygon", NET_ITC_POLYGON), # 触发区域
        ("struTriggerLine", NET_VCA_LINE), # 触发线
    ]


LPNET_DVR_SHIPSDETECTION_REGION_CFG = POINTER(NET_DVR_SHIPSDETECTION_REGION_CFG)


class NET_DVR_SHIPSDETECTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("byRes1", BYTE * 3),
        ("fLookDownUpAngle", float), # 设备俯仰角度，精确到小数点后一位
        ("fHorizontalHeight", float), # 设备水平高度，精确到小数点后一位
        ("struShipsDetectionRegion", NET_DVR_SHIPSDETECTION_REGION_CFG * MAX_SHIPSDETE_REGION_NUM), # 船只检测单个区域配置
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_SHIPSDETECTION_CFG = POINTER(NET_DVR_SHIPSDETECTION_CFG)


class NET_DVR_TEMPERATURE_COLOR(Structure):
    _fields_ = [
        #
        # 选择0~高温报警类型时，<highTemperature>字段生效,当高于该温度值时，会有进行颜色标注，
        # 选择1~低温报警类型时, <lowTemperature>字段生效,当低于该温度值时，会有进行颜色标注。
        # 选择2~区间报警类型时，<highTemperature>、<lowTemperature>字段生效，当在温度在该温度区间时，会有进行颜色标注。
        # 选择3~保温报警类型时，<highTemperature>、<lowTemperature>字段生效，当温度不在该温度区间时，会有进行颜色标注。
        # 选择4~为无报警类型，<nullAlarm>字段生效，关闭报警，
        ("byType", BYTE), # 测温报警颜色控制类型，0~无报警类型（关闭），1~高温报警类型，2~低温报警类型，3~区间报警类型，4~保温报警类型
        ("byRes1", BYTE * 3),
        ("iHighTemperature", int), # 高温值，-273~10000
        ("iLowTemperature", int), # 低温值，-273~10000
        ("byRes", BYTE * 8),
    ]


LPNET_DVR_TEMPERATURE_COLOR = POINTER(NET_DVR_TEMPERATURE_COLOR)


class NET_DVR_THERMOMETRY_BASICPARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byStreamOverlay", BYTE), # 码流叠加温度信息：0- 否，1- 是
        ("byPictureOverlay", BYTE), # 抓图叠加温度信息：0- 否，1- 是
        ("byThermometryRange", BYTE), # 测温范围: 0-默认值,1-(-20~150),2-(0~550)（这里以摄氏度为单位计算）,3-(摄氏度:0-650℃；华氏温度:32-1200℉),4-（摄氏度: -40-150℃）,5-(摄氏度: 0~1200℃)（这里以摄氏度为单位计算，根据测温单位设定不同测温范围的显示），6-(摄氏度: -20-120℃,7-(摄氏度:20~350℃), 8-(摄氏度:20~45),9-(摄氏度:30~45),0xff-自动
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)。
        ("byThermometryCurve", BYTE), # 测温曲线模式显示方式，0-关闭，1-模式1（横向温度趋势线模式），2-模式2（纵向温度趋势线模式）
        ("byFireImageModea", BYTE), # 消防图像模式，0-保留，1-黑白模式，2-热探测模式，3-火场模式(字段0目前保留，避免与之前接口不兼容)
        ("byShowTempStripEnable", BYTE), # 显示温度条使能：0- 否，1- 是
        ("fEmissivity", float), # 发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
        ("byDistanceUnit", BYTE), # 距离单位: 0-米（m），1-英尺（feet）,2-厘米(centimeter)
        ("byEnviroHumidity", BYTE), # 环境相对湿度，取值范围：0~100%
        ("byRes2", BYTE * 2),
        ("struTempColor", NET_DVR_TEMPERATURE_COLOR), # 测温报警颜色
        ("iEnviroTemperature", int), # 环境温度，取值范围：-273~10000摄氏度
        ("iCorrectionVolume", int), # 测温修正量，取值范围：-100~100
        # bit0-中心点测温：0-不显示，1-显示；
        # bit1-最高点测温：0-不显示，1-显示；
        # bit2-最低点测温：0-不显示，1-显示；
        #
        ("bySpecialPointThermType", BYTE), #  特殊测温点显示
        ("byReflectiveEnabled", BYTE), # 反射温度使能：0- 否，1- 是
        ("wDistance", WORD), # 距离(m)[0, 10000]
        ("fReflectiveTemperature", float), # 反射温度 精确到小数后一位
        ("fAlert", float), # 预警温度阈值，-100.0-1000.0度（精确到小数点后一位）
        ("fAlarm", float), # 报警温度阈值，-100.0-1000.0度（精确到小数点后一位）
        ("fThermalOpticalTransmittance", float), #  光学透过率, 精确到小数点后3位，范围0.001-1.000，默认1.000
        ("fExternalOpticsWindowCorrection", float), # 外部光学温度，默认值20℃，范围为-40.0~80.0℃，实际显示单位以界面显示为准
        ("byDisplayMaxTemperatureEnabled", BYTE), #  显示最高温 0-不显示 1-显示
        ("byDisplayMinTemperatureEnabled", BYTE), #  显示最低温 0-不显示 1-显示
        ("byDisplayAverageTemperatureEnabled", BYTE), #  显示平均温 0-不显示 1-显示
        ("byThermometryInfoDisplayposition", BYTE), #  测温信息显示位置 0-保留 1-跟随规则 2-屏幕左上角
        ("dwAlertFilteringTime", DWORD), # 温度预警等待时间,单位秒
        ("dwAlarmFilteringTime", DWORD), # 温度报警等待时间,单位秒
        ("byemissivityMode", BYTE), # 发射率配置类型 1-粗糙，2-较粗糙，3-较光滑, 4-光滑, 0xff-自定义
        ("bydisplayTemperatureInOpticalChannelEnabled", BYTE), # 可见光显示温度信息使能，0-不启用，1启用
        ("byDisplayCentreTemperatureEnabled", BYTE), #  显示中心点温度 0-不显示 1-显示
        ("byRes", BYTE * 49),
    ]


LPNET_DVR_THERMOMETRY_BASICPARAM = POINTER(NET_DVR_THERMOMETRY_BASICPARAM)


class NET_DVR_THERMOMETRY_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChannel", DWORD),
        ("wPresetNo", WORD), # 0-保留
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_THERMOMETRY_COND = POINTER(NET_DVR_THERMOMETRY_COND)


class NET_DVR_THERMOMETRY_PRESETINFO_PARAM(Structure):
    _fields_ = [
        ("byEnabled", BYTE), # 是否使能：0- 否，1- 是
        ("byRuleID", BYTE), # 规则ID 0-表示无效，从1开始 （list内部判断数据有效性）
        ("wDistance", WORD), # 距离(m)[0, 10000]
        ("fEmissivity", float), # 发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
        ("byDistanceUnit", BYTE), # 距离单位: 0-米（m），1-英尺（feet）,2-厘米(centimeter)
        ("byRes", BYTE * 2),
        ("byReflectiveEnabled", BYTE), # 反射温度使能：0- 否，1- 是
        ("fReflectiveTemperature", float), # 反射温度 精确到小数后2位
        ("szRuleName", CHAR * NAME_LEN), # 规则名称
        ("byemissivityMode", BYTE), # 发射率配置类型 1-粗糙，2-较粗糙，3-较光滑, 4-光滑, 0xff-自定义
        ("byRes1", BYTE * 62),
        ("byRuleCalibType", BYTE), # 规则标定类型 0-点，1-框，2-线
        ("struPoint", NET_VCA_POINT), # 点测温坐标（当规则标定类型为"点"的时候生效）
        ("struRegion", NET_VCA_POLYGON), # 区域、线（当规则标定类型为"框"或者"线"的时候生效）
    ]


LPNET_DVR_THERMOMETRY_PRESETINFO_PARAM = POINTER(NET_DVR_THERMOMETRY_PRESETINFO_PARAM)


class NET_DVR_THERMOMETRY_PRESETINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("wPresetNo", WORD), # 0-保留
        ("byRes", BYTE * 2),
        ("struPresetInfo", NET_DVR_THERMOMETRY_PRESETINFO_PARAM * MAX_THERMOMETRY_REGION_NUM),
    ]


LPNET_DVR_THERMOMETRY_PRESETINFO = POINTER(NET_DVR_THERMOMETRY_PRESETINFO)


class NET_DVR_BASE_STATION_INFO_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("sNetBarWaCode", CHAR * 16), # 场所编号
        ("sCollectionEquipmentID", CHAR * 24), # 采集设备编号
        ("sMCC", CHAR * 4), # 移动国家码
        ("sMNC", CHAR * 4), # 移动网络码
        ("sLAC", CHAR * 36), # 位置区码
        ("sCI", CHAR * 36), # 小区识别码
        ("sBSCI", CHAR * 36), # 基站识别码
        ("sBCCH", CHAR * 36), # 公共广播信道
        ("sLEV", CHAR * 36), # 接收报告电平
        ("sCollectionEquipmentLongitude", CHAR * 12), # 采集设备经度
        ("sCollectionEquipmentLatitude", CHAR * 12), # 采集设备纬度
        ("sCaptureTime", CHAR * 20), # 采集时间 时间格式yyyy-MM-dd hh:mm:ss
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_BASE_STATION_INFO_ALARM = POINTER(NET_DVR_BASE_STATION_INFO_ALARM)


class NET_DVR_THERMOMETRY_ALARMRULE_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byRuleID", BYTE), # 规则ID
        ("byRule", BYTE), # 报警温度比较方式 0-高温大于,1-高温小于,2-低温大于,3-低温小于,4-平均温大于,5-平均温小于,6-温差大于,7-温差小于
        ("byRes", BYTE),
        ("szRuleName", CHAR * NAME_LEN), # 规则名称
        ("fAlert", float), # 预警温度
        ("fAlarm", float), # 报警温度
        ("fThreshold", float), # 门限温度
        ("dwAlertFilteringTime", DWORD), # 温度预警等待时间,单位秒
        ("dwAlarmFilteringTime", DWORD), # 温度报警等待时间,单位秒
        ("byRes1", BYTE * 56),
    ]


LPNET_DVR_THERMOMETRY_ALARMRULE_PARAM = POINTER(NET_DVR_THERMOMETRY_ALARMRULE_PARAM)


class NET_DVR_THERMOMETRY_ALARMRULE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struThermometryAlarmRuleParam", NET_DVR_THERMOMETRY_ALARMRULE_PARAM * THERMOMETRY_ALARMRULE_NUM),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_THERMOMETRY_ALARMRULE = POINTER(NET_DVR_THERMOMETRY_ALARMRULE)


class NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM(Structure):
    _fields_ = [
        ("byEnable", BYTE),
        ("byRuleID", BYTE), # 规则ID,0-表示无效，范围值从1开始
        ("byAlarmID1", BYTE),
        ("byAlarmID2", BYTE),
        ("byRule", BYTE), # 报警温度比较方式0-高温大于,1-高温小于,2-低温大于,3-低温小于,4-平均温大于,5-平均温小于,6-温差大于,7-温差小于
        ("byRes", BYTE * 3),
        ("fTemperatureDiff", float), # 温差值
        ("dwAlarmFilteringTime", DWORD), # 温度报警等待时间,单位秒
        ("byRes1", BYTE * 28),
    ]


LPNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM = POINTER(NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM)


class NET_DVR_THERMOMETRY_DIFFCOMPARISON(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("struDiffComparison", NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM * MAX_THERMOMETRY_DIFFCOMPARISON_NUM),
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_THERMOMETRY_DIFFCOMPARISON = POINTER(NET_DVR_THERMOMETRY_DIFFCOMPARISON)


# 实时温度检测条件结构
class NET_DVR_REALTIME_THERMOMETRY_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChan", DWORD), # 通道号，从1开始，0xffffffff代表获取全部通道
        ("byRuleID", BYTE), # 规则ID 0-代表获取全部规则，具体规则ID从1开始
        #
        # 1-定时模式：设备每隔一秒上传各个规则测温数据的最高温、最低温和平均温度值、温差
        # 2-温差模式：若上一秒与下一秒的最高温或者最低温或者平均温或者温差值的温差大于等于2摄氏度，则上传最高温、最低温和平均温度值。若大于等于一个小时温差值均小于2摄氏度，则上传最高温、最低温、平均温和温差值
        #
        ("byMode", BYTE), # 长连接模式， 0-保留（为兼容老设备），1-定时模式，2-温差模式
        ("wInterval", WORD), # 上传间隔，仅温差模式支持，1~3600S，填0则默认3600S上传一次
        ("byRes", BYTE * 60), # 保留
    ]


LPNET_DVR_REALTIME_THERMOMETRY_COND = POINTER(NET_DVR_REALTIME_THERMOMETRY_COND)


class NET_DVR_POINT_THERM_CFG(Structure):
    _fields_ = [
        ("fTemperature", float), # 当前温度
        ("struPoint", NET_VCA_POINT), # 点测温坐标（当规则标定类型为点的时候生效）
        ("byRes", BYTE * 120),
    ]


LPNET_DVR_POINT_THERM_CFG = POINTER(NET_DVR_POINT_THERM_CFG)


class NET_DVR_LINEPOLYGON_THERM_CFG(Structure):
    _fields_ = [
        ("fMaxTemperature", float), # 最高温
        ("fMinTemperature", float), # 最低温
        ("fAverageTemperature", float), # 平均温
        ("fTemperatureDiff", float), # 温差
        ("struRegion", NET_VCA_POLYGON), # 区域（当规则标定类型为框/线的时候生效）
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LINEPOLYGON_THERM_CFG = POINTER(NET_DVR_LINEPOLYGON_THERM_CFG)


class NET_DVR_THERMOMETRY_UPLOAD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwRelativeTime", DWORD), #  相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("szRuleName", CHAR * NAME_LEN), # 规则名称
        ("byRuleID", BYTE), # 规则ID号
        ("byRuleCalibType", BYTE), # 规则标定类型 0-点，1-框，2-线
        ("wPresetNo", WORD), # 预置点号
        ("struPointThermCfg", NET_DVR_POINT_THERM_CFG),
        ("struLinePolygonThermCfg", NET_DVR_LINEPOLYGON_THERM_CFG),
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
        ("byDataType", BYTE), # 数据状态类型:0-检测中，1-开始，2-结束
        ("byRes1", BYTE),
        #
        # bit0-中心点测温：0-不支持，1-支持；
        # bit1-最高点测温：0-不支持，1-支持；
        # bit2-最低点测温：0-不支持，1-支持；
        #
        ("bySpecialPointThermType", BYTE), #  是否支持特殊点测温
        ("fCenterPointTemperature", float), # 中心点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10 （由bySpecialPointThermType判断是否支持中心点）
        ("fHighestPointTemperature", float), # 最高点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10（由bySpecialPointThermType判断是否支持最高点）
        ("fLowestPointTemperature", float), # 最低点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10（由bySpecialPointThermType判断是否支持最低点）
        ("struHighestPoint", NET_VCA_POINT), # 线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
        ("struLowestPoint", NET_VCA_POINT), # 线、框测温最低温度位置坐标（当规则标定类型为线、框的时候生效）
        ("byIsFreezedata", BYTE), # 是否数据冻结 0-否 1-是
        ("byRes2", BYTE * 3),
        ("dwChan", DWORD), # 通道号，查询条件中通道号为0xffffffff时该字段生效
        ("byRes", BYTE * 88),
    ]


LPNET_DVR_THERMOMETRY_UPLOAD = POINTER(NET_DVR_THERMOMETRY_UPLOAD)


# 温度报警（检测温度和配置温度比较报警）
class NET_DVR_THERMOMETRY_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRuleID", BYTE), # 规则ID
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
        ("wPresetNo", WORD), # 预置点号
        ("struPtzInfo", NET_PTZ_INFO), # ptz坐标信息
        ("byAlarmLevel", BYTE), # 0-预警 1-报警
        ("byAlarmType", BYTE), # 报警类型 0-最高温度 1-最低温度 2-平均温度 3-温差 4-温度突升 5-温度突降
        ("byAlarmRule", BYTE), # 0-大于，1-小于
        ("byRuleCalibType", BYTE), # 规则标定类型 0-点，1-框，2线
        ("struPoint", NET_VCA_POINT), # 点测温坐标（当规则标定类型为点的时候生效）
        ("struRegion", NET_VCA_POLYGON), # 区域（当规则标定类型为框的时候生效）
        ("fRuleTemperature", float), # 配置规则温度,精确到小数点后一位(-40-1000),（浮点数+100）
        ("fCurrTemperature", float), # 当前温度,精确到小数点后一位(-40-1000),（浮点数+100）
        ("dwPicLen", DWORD), # 可见光图片长度
        ("dwThermalPicLen", DWORD), # 热成像图片长度
        ("dwThermalInfoLen", DWORD), # 热成像附加信息长度
        ("pPicBuff", CHARP), # /可见光图片指针
        ("pThermalPicBuff", CHARP), #  热成像图片指针
        ("pThermalInfoBuff", CHARP), # 热成像附加信息指针
        ("struHighestPoint", NET_VCA_POINT), # 线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
        ("fToleranceTemperature", float), #  容差温度,精确到小数点后一位(-40-1000),（浮点数+100）
        ("dwAlertFilteringTime", DWORD), # 温度预警等待时间 单位秒 范围为0-200秒，默认为0秒
        ("dwAlarmFilteringTime", DWORD), # 温度报警等待时间 单位秒 范围为0-200秒，默认为0秒
        ("dwTemperatureSuddenChangeCycle", DWORD), # 温度突变记录周期，单位秒
        ("fTemperatureSuddenChangeValue", float), # 温度突变值,精确到小数点后一位(大于0)
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("byRes", BYTE * 39),
    ]


LPNET_DVR_THERMOMETRY_ALARM = POINTER(NET_DVR_THERMOMETRY_ALARM)


# 温差报警
class NET_DVR_THERMOMETRY_DIFF_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byAlarmID1", BYTE), # 规则AlarmID1
        ("byAlarmID2", BYTE), # 规则AlarmID2
        ("wPresetNo", WORD), # 预置点号
        ("byAlarmLevel", BYTE), # 0-预警 1-报警
        ("byAlarmType", BYTE), # 报警类型 0-最高温度 1-最低温度 2-平均温度
        ("byAlarmRule", BYTE), # 0-大于，1-小于
        ("byRuleCalibType", BYTE), # 规则标定类型 0-点，1-框，2线
        ("struPoint", NET_VCA_POINT * 2), # 点测温坐标（当规则标定类型为点的时候生效）数组下标0代表着AlarmID1，数组下标1代表着AlarmID2.
        ("struRegion", NET_VCA_POLYGON * 2), # 区域（当规则标定类型为框的时候生效）数组下标0代表着AlarmID1，数组下标1代表着AlarmID2.
        ("fRuleTemperatureDiff", float), # 配置规则温差,精确到小数点后一位(-40-1000)）
        ("fCurTemperatureDiff", float), # 当前温差,精确到小数点后一位(-40-1000),（浮点数+100）
        ("struPtzInfo", NET_PTZ_INFO), # ptz坐标信息
        ("dwPicLen", DWORD), # 可见光图片长度
        ("dwThermalPicLen", DWORD), # 热成像图片长度
        ("dwThermalInfoLen", DWORD), # 热成像附加信息长度
        ("pPicBuff", CHARP), # /可见光图片指针
        ("pThermalPicBuff", CHARP), #  热成像图片指针
        ("pThermalInfoBuff", CHARP), # 热成像附加信息指针
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("byRes1", BYTE * 2),
        ("fToleranceTemperature", float), # 容差温度,精确到小数点后一位(-40-1000),（浮点数+100）
        ("dwAlarmFilteringTime", DWORD), # 温度报警等待时间 单位秒 范围为0-200秒，默认为0秒
        ("byRes", BYTE * 52),
    ]


LPNET_DVR_THERMOMETRY_DIFF_ALARM = POINTER(NET_DVR_THERMOMETRY_DIFF_ALARM)


# 获取船只计数信息结构
class NET_DVR_SHIPSCOUNT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwUpShipsCount", DWORD), # 上行船只数
        ("dwDownShipsCount", DWORD), # 下行船只数
        ("dwLeftShipsCount", DWORD), # 左行船只数
        ("dwRightShipsCount", DWORD), # 右行船只数
        ("dwTotalCount", DWORD), # 船只总计数
        ("dwRelativeTime", DWORD), # 设备侧计数开始计数的相对时标
        ("dwAbsTime", DWORD), # 设备侧计数开始计数的绝对时标
        ("byDataType", BYTE), # 数据状态类型:0-检测中，1-开始，2-结束
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_SHIPSCOUNT_CFG = POINTER(NET_DVR_SHIPSCOUNT_CFG)


# 船只信息
class NET_DVR_SHIPSINFO(Structure):
    _fields_ = [
        ("fShipsLength", float), # 船只长度；1~1000.0m，精确到小数点后一位
        ("fShipsHeight", float), # 船只高度；1~1000.0m，精确到小数点后一位
        ("fShipsWidth", float), # 船只宽度；1~1000.0m，精确到小数点后一位
        ("fShipsSpeed", float), # 船只速度；1~1000.0m/s，精确到小数点后一位
        ("byShipsDirection", BYTE), # 船只方向；0~up,1~down,2~left,3~right
        ("byShipsDetState", BYTE), # 船只检测状态；0~正跨越检测线，1~船头检测，2~船尾检测
        ("byTriggerLineID", BYTE), # 检测线ID
        ("byRes", BYTE * 61),
        ("struShipsRect", NET_VCA_POLYGON), # 船只区域，归一化值，相对于大图（可见光图、热成像图)的分辨率
    ]


LPNET_DVR_SHIPSINFO = POINTER(NET_DVR_SHIPSINFO)


# 船只检测报警上传
class NET_DVR_SHIPSDETECTION_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struDevInfo", NET_VCA_DEV_INFO), # 设备信息
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("byShipsNum", BYTE), # 船只数；(正跨越检测线的船只数)
        ("byShipsNumHead", BYTE), # 船只数；(船头检测船只数)
        ("byShipsNumEnd", BYTE), # 船只数；(船尾检测船只数)
        ("byPicTransType", BYTE), # 图片数据传输方式: 0-二进制；1-url
        ("struShipInfo", NET_DVR_SHIPSINFO * MAX_SHIPS_NUM), # 船只信息；最大支持20艘
        ("dwPicLen", DWORD), # 可见光图片长度
        ("dwThermalPicLen", DWORD), # 热成像图片长度
        ("pPicBuffer", BYTE*), # 可见光图片数据指针
        ("pThermalPicBuffer", BYTE*), # 热成像图片数据指针
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byTimeDiffFlag", BYTE), # 时差字段是否有效  0-时差无效， 1-时差有效
        ("cTimeDifferenceH", CHAR), # 与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
        ("cTimeDifferenceM", CHAR), # 与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
        ("bySID", BYTE), # 场景ID
        ("byRes1", BYTE * 2),
        ("szSceneName", CHAR * NAME_LEN), # 场景名称，不超过32字符
        ("byRes", BYTE * 216),
    ]


LPNET_DVR_SHIPSDETECTION_ALARM = POINTER(NET_DVR_SHIPSDETECTION_ALARM)


class NET_DVR_THERMAL_PIP(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用
        ("byPipMode", BYTE), #  画中画模式，0~叠加模式，1~融合模式，2-普通模式
        ("byOverlapType", BYTE), # 叠加类型，选择画中画叠加模式后生效。0~可见光叠加热成像图片，1~热成像叠加可见光图片
        ("byTransparency", BYTE), # 透明度 0~100
        ("struPipRegion", NET_VCA_POLYGON), # 画中画区域位置
        ("byImageFusionRatio", BYTE), # 图像融合比例,融合模式下生效 0-100 默认75
        ("byBorderFusionRatio", BYTE), # 边缘融合比例,融合模式下生效 0-100 默认100
        ("byRes1", BYTE * 2),
        ("fDistance", float), # 融合距离,融合模式下生效,范围0.1-4.0米
        ("byRes", BYTE * 632),
    ]


LPNET_DVR_THERMAL_PIP = POINTER(NET_DVR_THERMAL_PIP)


class NET_DVR_RULESLINE_CFG(Structure):
    _fields_ = [
        ("struRGB", NET_DVR_RGB_COLOR), #  RGB参数：R（红色），G（绿色），B（蓝色） 范围0-255
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_RULESLINE_CFG = POINTER(NET_DVR_RULESLINE_CFG)


class NET_DVR_THERMAL_INTELRULE_DISPLAY(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        #
        # fontSizeType:为字体大小倍率索引，播放库会根据该倍率以及预览窗口的宽度动态改变字体的大小。公式为：具体倍率值/8*(0.01*预览窗口宽度)
        # 倍率索引对应如下：
        # 0~8倍率（小）
        # 1~12倍率（标准）
        # 2~16倍率（大）
        # 3~20倍率（超大）
        # 4~24倍率（特大）
        #
        ("byFontSizeType", BYTE),
        ("byRes1", BYTE * 3),
        ("struNormalRulesLineCfg", NET_DVR_RULESLINE_CFG), # 正常规则线相关属性参数
        ("struAlertRulesLineCfg", NET_DVR_RULESLINE_CFG), # 预警规则线相关属性参数
        ("struAlarmRulesLineCfg", NET_DVR_RULESLINE_CFG), # 报警规则线相关属性参数
        ("byRes", BYTE * 640),
    ]


LPNET_DVR_THERMAL_INTELRULE_DISPLAY = POINTER(NET_DVR_THERMAL_INTELRULE_DISPLAY)


class NET_DVR_BAREDATAOVERLAY_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byEnable", BYTE), # 使能
        ("byIntervalTime", BYTE), #  上传的时间间隔可配置：1 2 3 4 5.单位为秒，默认为3秒
        ("byRes", BYTE * 258),
    ]


LPNET_DVR_BAREDATAOVERLAY_CFG = POINTER(NET_DVR_BAREDATAOVERLAY_CFG)


# 测温联动条件结构
class NET_DVR_THERMOMETRY_TRIGGER_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("dwChan", DWORD), # 通道号
        ("dwPreset", DWORD), # 预置点号（目前不支持,无需赋值）
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_THERMOMETRY_TRIGGER_COND = POINTER(NET_DVR_THERMOMETRY_TRIGGER_COND)


# 手动除冰
class NET_DVR_MANUALDEICING_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnabled", BYTE), # 是否启用手动除冰 ，0~关闭，1~启用
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_MANUALDEICING_CFG = POINTER(NET_DVR_MANUALDEICING_CFG)


# 小间距LED控制器
class NET_DVR_INPUT_SOURCE_TEXT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwInputSourceNo", DWORD), # 输入源编号
        ("dwTextNo", DWORD), # 文本编号
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_INPUT_SOURCE_TEXT_COND = POINTER(NET_DVR_INPUT_SOURCE_TEXT_COND)


class NET_DVR_INPUT_SOURCE_TEXT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwTextNo", DWORD), # 文本编号
        ("byEnable", BYTE), # 是否使能，0-不使能，1-使能
        ("byFontSize", BYTE), # 字体大小
        ("byBkGroudMode", BYTE), # 背景模式，1-透明，2-覆盖
        ("byRes", BYTE * 1),
        ("dwXPosition", DWORD), # 字符显示位置的左上角X坐标，输入源相对坐标
        ("dwYPosition", DWORD), # 字符显示位置的左上角Y坐标，输入源相对坐标
        ("struForegroudColor", NET_DVR_RGB_COLOR), # 字符前景色
        ("struBackgroudColor", NET_DVR_RGB_COLOR), # 字符背景色
        ("byTextContent", BYTE * MAX_LEN_TEXT_CONTENT), # 字符内容
        ("byRes1", BYTE * 64),
    ]


LPNET_DVR_INPUT_SOURCE_TEXT = POINTER(NET_DVR_INPUT_SOURCE_TEXT)


class NET_DVR_INPUT_SOURCE_TEXT_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTextList", NET_DVR_INPUT_SOURCE_TEXT * MAX_NUM_INPUT_SOURCE_TEXT), # 文本列表
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_INPUT_SOURCE_TEXT_LIST = POINTER(NET_DVR_INPUT_SOURCE_TEXT_LIST)


class NET_DVR_INPUT_SOURCE_RESOLUTION(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwInputSignalNo", DWORD), # 输入源编号
        ("byEnabled", BYTE), # 自定义分辨率是否使能
        ("byRes", BYTE),
        ("wImageWidth", WORD), # 图像宽度
        ("wImageHeight", WORD), # 图像高度
        ("wRefreshRate", WORD), # 刷新频率
        ("byColorDepth", BYTE), # 颜色深度，32位、16位、8位三种可选
        ("byScanType", BYTE), # 扫描类型，1-逐行扫描，2-间隔扫描
        ("byRes1", BYTE * 62),
    ]


LPNET_DVR_INPUT_SOURCE_RESOLUTION = POINTER(NET_DVR_INPUT_SOURCE_RESOLUTION)


class NET_DVR_INPUT_SOURCE_RESOLUTION_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwInputSignalCnt", DWORD), # 设备输入信号源数量
        ("lpstruBuffer", LPNET_DVR_INPUT_SOURCE_RESOLUTION), # 缓冲区指针
        ("dwBufferSize", DWORD), # 缓冲区大小
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_INPUT_SOURCE_RESOLUTION_LIST = POINTER(NET_DVR_INPUT_SOURCE_RESOLUTION_LIST)


class NET_DVR_LED_AREA_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwVideoWallNo", DWORD), # 电视墙编号
        ("dwLEDAreaNo", DWORD), # LED区域编号
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LED_AREA_COND = POINTER(NET_DVR_LED_AREA_COND)


class NET_DVR_LED_AREA_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwLEDAreaNo", DWORD), # LED区域编号
        ("struRect", NET_DVR_RECTCFG_EX), # 矩形区域
        ("dwaOutputNo", DWORD * MAX_NUM_OUTPUT_CHANNEL), # 输出口列表
        ("byAreaType", BYTE), # 区域类型，0-LED区域，1-LCD区域
        ("byRes", BYTE * 31),
    ]


LPNET_DVR_LED_AREA_INFO = POINTER(NET_DVR_LED_AREA_INFO)


class NET_DVR_LED_AREA_INFO_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwLEDAreaNum", DWORD), # LED区域数量
        ("lpstruBuffer", LPNET_DVR_LED_AREA_INFO), # 缓冲区指针
        ("dwBufferSize", DWORD), # 缓冲区大小
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_LED_AREA_INFO_LIST = POINTER(NET_DVR_LED_AREA_INFO_LIST)


# 呼叫等待参数
class NET_DVR_CALL_WAITTING_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用呼叫等待, 0--不启用，1--启用
        ("byRes1", BYTE),
        ("wWaitTime", WORD), # 呼叫等待时间，单位秒
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_CALL_WAITTING_CFG = POINTER(NET_DVR_CALL_WAITTING_CFG)


# 警灯参数
class NET_DVR_ALARM_LAMP_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用警灯定时闪烁, 0--不启用，1--启用
        ("byRes1", BYTE),
        ("wFlashDuration", WORD), # 警灯定时闪烁持续时间，单位秒
        ("wFlashIntervalTime", WORD), # 警灯闪烁间隔时间，单位秒
        ("byRes", BYTE * 510),
    ]


LPNET_DVR_ALARM_LAMP_CFG = POINTER(NET_DVR_ALARM_LAMP_CFG)


# 语音提示参数
class NET_DVR_VOICE_PROMPTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byEnable", BYTE), # 是否启用语音提示, 0--不启用，1--启用
        ("byRes1", BYTE * 3),
        ("byCenterBusyFile", BYTE * NAME_LEN), # 中心繁忙提示语音文件名
        ("byRefusedFile", BYTE * NAME_LEN), # 拒绝提示语音文件名
        ("byHangUpFile", BYTE * NAME_LEN), # 对讲结束提示语音文件名
        ("byCallWaittingFile", BYTE * NAME_LEN), # 呼叫等候音文件名
        ("byConsultWaittingFile", BYTE * NAME_LEN), # 业务咨询等候音文件名
        ("byRes", BYTE * 480),
    ]


LPNET_DVR_VOICE_PROMPTION_CFG = POINTER(NET_DVR_VOICE_PROMPTION_CFG)


# 紧急报警处理
class NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byCommand", BYTE), # 控制命令，0--centerbusy，1--refuse
        ("byType", BYTE), # 处理类型，0—紧急报警，1—业务咨询
        ("byRes", BYTE * 510),
    ]


LPNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG = POINTER(NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG)


# # # # # # 网络参数配置_V50# # # # # # /
# 目标封装格式类型
STREAM_3GPP = 0x2


NET_SDK_INIT_CFG_TYPE_CHECK_MODULE_COM = 0
NET_SDK_INIT_CFG_ABILITY = 1
NET_SDK_INIT_CFG_SDK_PATH = 2
NET_SDK_INIT_CFG_LIBEAY_PATH = 3
NET_SDK_INIT_CFG_SSLEAY_PATH = 4


class NET_DVR_INIT_CHECK_MODULE_COM(Structure):
    _fields_ = [
        ("byEnable", BYTE), # 启用必须库检查机制 0-不启用，1-启用
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_INIT_CHECK_MODULE_COM = POINTER(NET_DVR_INIT_CHECK_MODULE_COM)


# SDK支持的最大路数能力集
INIT_CFG_NUM_2048 = 2048
INIT_CFG_NUM_5120 = 5120
INIT_CFG_NUM_10240 = 10240
INIT_CFG_NUM_15360 = 15360
INIT_CFG_NUM_20480 = 20480


class NET_DVR_INIT_CFG_ABILITY(Structure):
    _fields_ = [
        ("enumMaxLoginUsersNum", INIT_CFG_MAX_NUM), # 最多允许的注册用户个数。
        ("enumMaxAlarmNum", INIT_CFG_MAX_NUM), # 最大的告警路数
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_INIT_CFG_ABILITY = POINTER(NET_DVR_INIT_CFG_ABILITY)


class NET_DVR_LOCAL_SDK_PATH(Structure):
    _fields_ = [
        ("sPath", CHAR * NET_SDK_MAX_FILE_PATH), # 组件库地址
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_LOCAL_SDK_PATH = POINTER(NET_DVR_LOCAL_SDK_PATH)


class NET_DVR_SDKMEMPOOL_CFG(Structure):
    _fields_ = [
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_SDKMEMPOOL_CFG = POINTER(NET_DVR_SDKMEMPOOL_CFG)


class NET_DVR_RES_INFO(Structure):
    _fields_ = [
        ("dwImageWidth", DWORD), # 图像宽度
        ("dwImageHeight", DWORD), # 图像高度
    ]


LPNET_DVR_RES_INFO = POINTER(NET_DVR_RES_INFO)


class NET_DVR_VS_INPUT_CHAN_INIT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwVSInputChan", DWORD), # 虚拟屏输入通道号
        ("dwResNums", DWORD), # 分辨率的个数
        ("struResList", NET_DVR_RES_INFO * MAX_RES_NUM_ONE_VS_INPUT_CHAN), # 分辨率列表
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_VS_INPUT_CHAN_INIT = POINTER(NET_DVR_VS_INPUT_CHAN_INIT)


class NET_DVR_VS_INPUT_CHAN_INIT_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struChanList", NET_DVR_VS_INPUT_CHAN_INIT * MAX_VS_INPUT_CHAN_NUM), # 通道列表
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_VS_INPUT_CHAN_INIT_LIST = POINTER(NET_DVR_VS_INPUT_CHAN_INIT_LIST)


class NET_DVR_VS_INPUT_CHAN_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwVSInputChan", DWORD), # 虚拟屏输入通道号
        ("struResolutin", NET_DVR_RES_INFO), # 分辨率
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_VS_INPUT_CHAN_CFG = POINTER(NET_DVR_VS_INPUT_CHAN_CFG)


class NET_DVR_VS_NETSRC_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwVSInputChan", DWORD), # 虚拟屏输入通道号
        ("byDispUrl", BYTE * MAX_URL_LEN), # 显示URL
        ("byEnabled", BYTE), # 是否启用URL
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_VS_NETSRC_CFG = POINTER(NET_DVR_VS_NETSRC_CFG)


class NET_DVR_EDID_FILE_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEDIDFileNo", DWORD), # EDID文件编号，从1开始
        ("byFileName", BYTE * FILE_NAME_LEN), # EDID文件名称
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_EDID_FILE_INFO = POINTER(NET_DVR_EDID_FILE_INFO)


class NET_DVR_EDID_FILE_INFO_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwEDIDFileNum", DWORD), # 返回的NET_DVR_EDID_FILE_INFO个数
        ("lpstruBuffer", LPNET_DVR_EDID_FILE_INFO), # 缓冲区指针
        ("dwBufferSize", DWORD), # 缓冲区大小
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_EDID_FILE_INFO_LIST = POINTER(NET_DVR_EDID_FILE_INFO_LIST)


# 子窗口解码OSD
class NET_DVR_OSD_INFO(Structure):
    _fields_ = [
        ("byEnabled", BYTE), # 是否使能，零-不使能，非零-使能
        ("byEnabledFlash", BYTE), # 是否闪烁，零-不闪烁，非零-闪烁
        ("byFontSize", BYTE), # 字体大小，1-大，2-中，3-小
        ("byTransparent", BYTE), # 透明度，取值范围0-100
        ("struColor", NET_DVR_RGB_COLOR), # 字体颜色
        ("wCoordinateX", WORD), # OSD左上角X坐标
        ("wCoordinateY", WORD), # OSD左上角Y坐标
        ("byContent", BYTE * MAX_LEN_OSD_CONTENT), # OSD信息
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_OSD_INFO = POINTER(NET_DVR_OSD_INFO)


class NET_DVR_SUBWND_DECODE_OSD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwSubWndNo", DWORD), # 子窗口号（4字节组合方式）
        ("dwOSDNums", DWORD), # 该子窗口配置的OSD信息的个数
        ("struOSDList", NET_DVR_OSD_INFO * MAX_NUM_OSD_ONE_SUBWND), # OSD信息列表
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_SUBWND_DECODE_OSD = POINTER(NET_DVR_SUBWND_DECODE_OSD)


class NET_DVR_SUBWND_DECODE_OSD_LIST(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSubWndList", NET_DVR_SUBWND_DECODE_OSD * MAX_NUM_SPLIT_WND), # 所有子窗口的解码OSD
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_SUBWND_DECODE_OSD_LIST = POINTER(NET_DVR_SUBWND_DECODE_OSD_LIST)


class NET_DVR_DECODE_CHANNEL_OSD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struOSDInfo", NET_DVR_OSD_INFO * MAX_NUM_OSD), # OSD信息列表
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_DECODE_CHANNEL_OSD = POINTER(NET_DVR_DECODE_CHANNEL_OSD)


# 热成像智能互斥配置参数
class NET_DVR_THERMINTELL_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byIntellType", BYTE), # 智能功能资源配置类型,0~测温+行为分析(默认)，1~船只检测，2~火点检测,3~画中画功能, 4~人脸测温，5-测温+烟火检测，6-测温+火点检测 7-行为分析 8-测温
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_THERMINTELL_PARAM = POINTER(NET_DVR_THERMINTELL_PARAM)


class NET_DVR_FACE_THERMOMETRY_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("byRuleID", BYTE), # 人脸测温规则ID:1-40
        ("byRes1", BYTE * 3),
        ("byRuleName", BYTE * NAME_LEN), # 规则名称
        ("dwRelativeTime", DWORD), # 相对时标
        ("dwAbsTime", DWORD), # 绝对时标
        ("byFaceDetectionState", BYTE), # 人脸检测状态；0~未检测到人脸，1~已检测到人脸
        ("byThermometryUnit", BYTE), # 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
        ("byAlarmRule", BYTE), # 报警规则；0-最高温大于，1-最高温小于
        ("byRes2", BYTE * 1),
        ("fAlarmTemperature", float), # 触发报警温度（-20.0~120.0℃，精确到小数点后1位）
        ("fRuleTemperature", float), #  规则配置报警温度（-20.0~60.0℃，精确到小数点后1位）
        ("dwVisibleLightImageLen", DWORD), #  可见光图片长度
        ("*pVisibleLightImage", BYTE), # 可见光图片指针
        ("dwFaceImageLen", DWORD), #  人脸子图长度
        ("*pFaceImage", BYTE), # 人脸子图指针
        ("struFaceRegion", NET_VCA_RECT), # 人脸目标边界框，设备识别抓拍图片中，人脸子图坐标
        ("fMinTemperature", float), #  最低温度（-20.0~120.0℃，精确到小数点后1位）
        ("fAverageTemperature", float), # 平均温（-20.0~120.0℃，精确到小数点后1位）
        ("struMinTemperaturePoint", NET_VCA_POINT), # 最低温度位置坐标
        ("struMaxTemperaturePoint", NET_VCA_POINT), # 最高温度位置坐标
        ("byRes", BYTE * 720),
    ]


LPNET_DVR_FACE_THERMOMETRY_ALARM = POINTER(NET_DVR_FACE_THERMOMETRY_ALARM)


# 导出GUID文件
class NET_DVR_GUID_FILE_EXPORT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sLoginPassWord", CHAR * NET_SDK_MAX_LOGIN_PASSWORD_LEN), # 用户登录密码
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_GUID_FILE_EXPORT = POINTER(NET_DVR_GUID_FILE_EXPORT)


# 用户登录密码校验
class NET_DVR_LOGIN_PASSWORDCFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("sLoginPassWord", CHAR * NET_SDK_MAX_LOGIN_PASSWORD_LEN), # 用户登录密码
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_LOGIN_PASSWORDCFG = POINTER(NET_DVR_LOGIN_PASSWORDCFG)


# 单个安全问题配置
class NET_DVR_SINGLE_SECURITY_QUESTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwId", DWORD), # 序号（安全问题序号，只读）
        ("sAnswer", CHAR * NET_SDK_MAX_ANSWER_LEN), # 答案（获取时只读）
        ("byMark", BYTE), # 标记  0-未设置 1-已设置
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_SINGLE_SECURITY_QUESTION_CFG = POINTER(NET_DVR_SINGLE_SECURITY_QUESTION_CFG)


# 安全问题配置
class NET_DVR_SECURITY_QUESTION_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struSecurityQuestion", NET_DVR_SINGLE_SECURITY_QUESTION_CFG * NET_SDK_MAX_QUESTION_LIST_LEN), # 安全问题列表
        ("sLoginPassWord", CHAR * NET_SDK_MAX_LOGIN_PASSWORD_LEN), # admin用户登录密码
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_SECURITY_QUESTION_CFG = POINTER(NET_DVR_SECURITY_QUESTION_CFG)


class NET_DVR_ALARMIN_TRIGGER_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号，从1开始
        ("dwAlarmInNo", DWORD), # 防区号，从0开始
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_ALARMIN_TRIGGER_COND = POINTER(NET_DVR_ALARMIN_TRIGGER_COND)


class NET_DVR_FACELIB_GUARD_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwChannel", DWORD), # 通道号
        ("szFDID", CHAR * 68), # 人脸库的ID
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_FACELIB_GUARD_COND = POINTER(NET_DVR_FACELIB_GUARD_COND)


class NET_DVR_GUID_FILE_STATUS_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byLockStatus", BYTE), # 0：未锁定，1：锁定
        ("byPasswd", BYTE), # 0:密码错误，1：密码正确。注:该值未锁定时有效。
        ("byRetryNum", BYTE), # 剩余尝试次数。注:该值未锁定时有效
        ("byRes1", BYTE),
        ("dwLockTime", DWORD), # 剩余锁定时间：单位秒。注:该值锁定时有效
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_GUID_FILE_STATUS_INFO = POINTER(NET_DVR_GUID_FILE_STATUS_INFO)


# 测温模式配置
class NET_DVR_THERMOMETRY_MODE(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byMode", BYTE), # 测温模式，0~普通模式，1~专家模式
        ("byThermometryROIEnabled", BYTE), # 测温ROI使能 0-保留 1-不开启 2-开启（基于互斥兼容考虑）
        ("byRes", BYTE * 62),
    ]


LPNET_DVR_THERMOMETRY_MODE = POINTER(NET_DVR_THERMOMETRY_MODE)


# 热成像相关算法库版本获取
class NET_DVR_THERMAL_ALGINFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sThermometryAlgName", CHAR * NET_SDK_MAX_THERMOMETRYALGNAME), # 测温算法库版本名称
        ("sShipsAlgName", CHAR * NET_SDK_MAX_SHIPSALGNAME), # 船只算法库版本名称
        ("sFireAlgName", CHAR * NET_SDK_MAX_FIRESALGNAME), # 火点检测算法库版本名称
        ("byRes", BYTE * 768),
    ]


LPNET_DVR_THERMAL_ALGINFO = POINTER(NET_DVR_THERMAL_ALGINFO)


# 电流锁定配置
class NET_DVR_CURRENT_LOCK(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("byCurrentLock", BYTE), # 云台垂直电机锁定电流，0~不锁定，1~全流锁定，2~3/4流锁定，3~半流锁定
        ("byRes", BYTE * 255),
    ]


LPNET_DVR_CURRENT_LOCK = POINTER(NET_DVR_CURRENT_LOCK)


# 脸比对报警（数据透传方式）
class NET_VCA_FACESNAP_RAWDATA_ALARM(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构大小
        ("dwRelativeTime", DWORD), #  相对时标
        ("dwAbsTime", DWORD), #  绝对时标
        ("struDevInfo", NET_VCA_DEV_INFO), # 前端设备信息
        ("dwJsonDataLen", DWORD), # json数据定义信息，0-没有数据，非0表示有数据（即结构体后跟着的json数据长度）
        ("pJsonBuff", BYTE*), #  json数据指针
        ("byRes", BYTE * 256), #  保留字节
    ]


LPNET_VCA_FACESNAP_RAWDATA_ALARM = POINTER(NET_VCA_FACESNAP_RAWDATA_ALARM)


# LED屏幕校正参数
class NET_SDK_LED_SCREEN_CHECK_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byOperateType", BYTE), # 操作类型，1-写入校正数据，2-校正预览，3-删除校正数据
        ("byIsRGBSynChk", BYTE), # RGB是否同步调整，0-不支持，!0-支持，byOperateType为1、2时有效
        ("byRes1", BYTE * 2),
        ("wRgbPermil", WORD), # RGB同步调整的千分比，byOperateType为1、2且byIsRGBSynChk非零时有效
        ("wRedPermil", WORD), # 红色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
        ("wGreenPermil", WORD), # 绿色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
        ("wBluePermil", WORD), # 蓝色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
        ("dwRectCount", DWORD), # 矩形区域的数量
        ("struRectList", NET_DVR_RECTCFG_EX * MAX_SCREEN_AREA_NUM), # 矩形区域列表，顺序存放
        ("byRes2", BYTE * 64),
    ]


LPNET_SDK_LED_SCREEN_CHECK_PARAM = POINTER(NET_SDK_LED_SCREEN_CHECK_PARAM)


# LED屏幕校正响应数据
class NET_SDK_SCREEN_CHECK_RESPONSE_DATA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byDataType", BYTE), # 数据类型，1-进度（整体进度），2-状态
        ("byOperateType", BYTE), # 操作类型，1-写入校正数据，2-校正预览，3-删除校正数据
        ("byProgress", BYTE), # 进度，byDataType为1时有效，0-100
        ("byStatus", BYTE), # 状态，byDataType为2时有效，1-LED屏幕区域校正失败，2-LED屏幕区域对应的接收卡不存在，3-加载校正数据失败（原始数据异常）
        # 4-该屏幕型号不支持校正，5-设备忙（正在校正），6-设备内存不足
        ("struRect", NET_DVR_RECTCFG_EX), # LED屏幕区域，byDataType为2时有效
        ("byRes", BYTE * 64),
    ]


LPNET_SDK_SCREEN_CHECK_RESPONSE_DATA = POINTER(NET_SDK_SCREEN_CHECK_RESPONSE_DATA)


class NET_DVR_PLAY_BY_NAME_PARA(Structure):
    _fields_ = [
        ("szFileName", CHAR * 100), # 回放文件名
        ("byDownload", BYTE), # 是否下载 0-否，1-是
        ("byRes1", BYTE * 127),
        ("hWnd", HWND), # 回放的窗口句柄，若置为空，SDK仍能收到码流数据，但不解码显示
        ("struAddr", NET_DVR_ADDRESS), # 文件所在集群中CS地址信息，该信息文件查找时会返回
        # 如果为空表示本登录地址
        ("byRes2", BYTE * 256),
    ]


LPNET_DVR_PLAY_BY_NAME_PARA = POINTER(NET_DVR_PLAY_BY_NAME_PARA)


class NET_DVR_PLAYBCK_BYTIME_COND_PCNVR(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIpAddr", NET_DVR_IPADDR),
        ("wIpPort", WORD),
        ("byRes", BYTE * 2),
        ("sDomainName", CHAR * MAX_DOMAIN_NAME),
        ("sSerial", CHAR * SERIALNO_LEN),
        ("iChannel", LONG),
        ("struStartTime", NET_DVR_TIME),
        ("struStopTime", NET_DVR_TIME),
        ("hWnd", HWND),
    ]


LPNET_DVR_PLAYBCK_BYTIME_COND_PCNVR = POINTER(NET_DVR_PLAYBCK_BYTIME_COND_PCNVR)


# 按文件名下载集群录像文件
class NET_DVR_DOWNLOAD_BY_NAME_COND(Structure):
    _fields_ = [
        ("*pFileName", CHAR), # 回放文件名，包含\0，最大100字节
        ("*pSavedFileName", CHAR), # 文件保存位置
        ("struAddr", NET_DVR_ADDRESS), # 文件所在集群中CS地址信息，该信息文件查找时会返回
        # 如果为空表示本登录地址
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_DOWNLOAD_BY_NAME_COND = POINTER(NET_DVR_DOWNLOAD_BY_NAME_COND)


class NET_DVR_PIC_PARAM(Structure):
    _fields_ = [
        ("*pDVRFileName", CHAR), # 图片名，包含\0，最大64字节
        ("*pSavedFileBuf", CHAR), # 保存图片的缓冲区，内存外部申请释放
        ("dwBufLen", DWORD), # 缓冲区大小
        ("*lpdwRetLen", DWORD), # 实际收到的数据长度指针，不能为NULL
        ("struAddr", NET_DVR_ADDRESS), # 图片所在的地址信息，图片查找时会返回
        ("byRes", BYTE * 256), # 保留字节
    ]


LPNET_DVR_PIC_PARAM = POINTER(NET_DVR_PIC_PARAM)


NET_SDK_MAX_INDENTITY_KEY_LEN = 64 # 交互操作口令长度
# 导入人脸数据条件
class NET_DVR_FACELIB_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szFDID", CHAR * NET_SDK_MAX_FDID_LEN), # 人脸库ID
        ("byConcurrent", BYTE), # 设备并发处理 0-不开启，1-开始
        ("byCover", BYTE), # 是否覆盖式导入 0-否，1-是
        ("byCustomFaceLibID", BYTE), # FDID是否是自定义，0-不是，1-是；
        # 当”/ISAPI/Intelligent/channels/<ID>/faceContrast/capabilities”能力中返回isSupportNoSaveUploadPicture能力节点时，
        # 代表非并发处理模式下，支持不保存上传原图的操作:当上传成功图片并设备建模成功后，会将上传的原图进行删除。
        # 注：该操作无法与并发处理同时进行。
        ("byPictureSaveMode", BYTE), # 上传原图保存模式，0-保存，1-不保存
        ("byIdentityKey", BYTE * NET_SDK_MAX_INDENTITY_KEY_LEN), # 交互操作口令
        ("byRes", BYTE * 60),
    ]


LPNET_DVR_FACELIB_COND = POINTER(NET_DVR_FACELIB_COND)


class NET_DVR_EXPORT_PUBLISH_SCHEDULE(Structure):
    _fields_ = [
        ("dwScheduleID", DWORD), #  日程索引
        ("fnDownloadFileCallBack", DOWNLOAD_DATA_CB), # 数据回调函数
        ("pUser", VOIDP), # 用户数据指针
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_EXPORT_PUBLISH_SCHEDULE = POINTER(NET_DVR_EXPORT_PUBLISH_SCHEDULE)


class NET_DVR_GBT28181_AUDIO_OUTPUT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwAudioChannel", DWORD), # 语音对讲通道号
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_GBT28181_AUDIO_OUTPUT_COND = POINTER(NET_DVR_GBT28181_AUDIO_OUTPUT_COND)


# GBT28181协议的语音输出通道配置 配置结构
class NET_DVR_GBT28181_AUDIO_OUTPUT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szAudioOutNumID", CHAR * MAX_COMPRESSIONID_LEN), # 设备语音输出编码ID
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_GBT28181_AUDIO_OUTPUT_CFG = POINTER(NET_DVR_GBT28181_AUDIO_OUTPUT_CFG)


class NET_DVR_NOTICE_VIDEO_DATA(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileSize", DWORD), # 文件大小，单位：字节
        ("byNoticeNumber", BYTE * MAX_NOTICE_NUMBER_LEN), # 公告编号
        ("byRes", BYTE * 2016),
    ]


LPNET_DVR_NOTICE_VIDEO_DATA = POINTER(NET_DVR_NOTICE_VIDEO_DATA)


class NET_DVR_NOTICE_VIDEO_DATA_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byRes", BYTE * 256), # 保留
    ]


LPNET_DVR_NOTICE_VIDEO_DATA_COND = POINTER(NET_DVR_NOTICE_VIDEO_DATA_COND)


class NET_DVR_NOTICE_VIDEO_DATA_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDataLen", DWORD), # 数据长度
        ("pDataBuffer", CHARP), # 数据指针
        ("byDataType", BYTE), # 数据类型：0-无效，1-结构体数据（NET_DVR_NOTICE_VIDEO_DATA），2-视频数据
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_NOTICE_VIDEO_DATA_CFG = POINTER(NET_DVR_NOTICE_VIDEO_DATA_CFG)


class NET_DVR_UPGRADE_FIRMWARE_INFO(Structure):
    _fields_ = [
        ("dwMagicNumber", DWORD), #  魔术字段，固定值0x484b5753
        ("dwCheckSum", DWORD), #  文件头校验和
        ("dwHeadLen", DWORD), #  文件头长度
        ("dwFileNums", DWORD), #  文件个数
        ("dwLanguage", DWORD), #  语言，1-英文或多语言，2-中文
        ("dwDeviceClassID", DWORD), #  1 – DS9000 DVR
        ("dwOemCode", DWORD), #  1 – hikvision
        ("byUpgradeVersion", BYTE), #  升级版本: 0xFE - 需判断flash, ram, DSP ram 的容量
        ("byResFeature", BYTE * 15), #  保留字段
        ("byFlashSize", BYTE), #  0 - do not need check 1 - 16M 2 - 32M 3 - 64M
        ("byRamSize", BYTE), #  0 - do not need check 1 - 128M 2 - 256M 3 - 512M 4 - 1024M
        ("byDspRamSize", BYTE), #  0 - do not need check 1 - 64M 2 - 128M 3 - 256M
        ("byRes", BYTE * 17), #  保留
    ]


LPNET_DVR_UPGRADE_FIRMWARE_INFO = POINTER(NET_DVR_UPGRADE_FIRMWARE_INFO)


class NET_DVR_SCHEDULE_FILE_RET(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szFileName", CHAR * 32), # 文件名
        ("dwFileLen", DWORD), # 文件长度
        ("byRes", BYTE * 64),
    ]


LPNET_DVR_SCHEDULE_FILE_RET = POINTER(NET_DVR_SCHEDULE_FILE_RET)


NET_SDK_MAX_EXAM_ROUND_NO = 64 # 考试场次编号最大长度
NET_SDK_MAX_EXAM_NO = 64 # 考试编号最大长度
NET_SDK_MAX_EXAM_SUBJECT = 64 # 考试科目最大长度
NET_SDK_MAX_TEACHER_NO = 64 # 监考老师编号最大长度
NET_SDK_MAX_TEACHER_NAME = 64 # 监考老师姓名最大长度
NET_SDK_MAX_EXAMINEE_NO = 64 # 考生编号最大长度
NET_SDK_MAX_ADMISSION_TICKET = 64 # 准考证号最大长度
class NET_DVR_EXAM_INFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwExamNumber", DWORD), # 考试信息数目
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_EXAM_INFO_COND = POINTER(NET_DVR_EXAM_INFO_COND)


class NET_DVR_EXAM_INFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byExamRoundNo", BYTE * NET_SDK_MAX_EXAM_ROUND_NO), # 考试场次编号（某堂具体考试）
        ("byExamNo", BYTE * NET_SDK_MAX_EXAM_NO), # 考试编号（某次考试，包含多场考试）
        ("byExamSubject", BYTE * NET_SDK_MAX_EXAM_SUBJECT), # 考试科目
        ("byTeacherNo", BYTE * NET_SDK_MAX_TEACHER_NO), # 监考老师编号
        ("byTeacherName", BYTE * NET_SDK_MAX_TEACHER_NAME), # 监考老师姓名
        ("struStartTime", NET_DVR_TIME), # 考试开始时间
        ("struEndTime", NET_DVR_TIME), # 考试结束时间
        ("byExamInfoValid", BYTE), # 考试信息是否有效：0-无效，1-有效（用于考试场次编号删除考试信息，该字段为0时代表删除）
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_EXAM_INFO_CFG = POINTER(NET_DVR_EXAM_INFO_CFG)


class NET_DVR_EXAM_INFO_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byExamRoundNo", BYTE * NET_SDK_MAX_EXAM_ROUND_NO), # 考试场次编号（某堂具体考试）
        ("byStatus", BYTE), # 下发状态：0-无效，1-失败，2-成功（代表该考试场次下发是否成功）
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_EXAM_INFO_STATUS = POINTER(NET_DVR_EXAM_INFO_STATUS)


class NET_DVR_EXAMINEE_INFO_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwExamineeNumber", DWORD), # 考生信息数目
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_EXAMINEE_INFO_COND = POINTER(NET_DVR_EXAMINEE_INFO_COND)


class NET_DVR_EXAMINEE_INFO_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byExamineeNo", BYTE * NET_SDK_MAX_EXAMINEE_NO), # 考生编号
        ("byAdmissionTicket", BYTE * NET_SDK_MAX_ADMISSION_TICKET), # 准考证号
        ("byExamRoundNo", BYTE * NET_SDK_MAX_EXAM_ROUND_NO), # 考试场次编号（某堂具体考试）
        ("byName", BYTE * NAME_LEN), # 姓名
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 考生关联的卡号
        ("bySex", BYTE), # 性别：0-无效，1-男，2-女
        ("byExamineeInfoValid", BYTE), # 考生信息是否有效：0-无效，1-有效（用于考生编号和考试场次编号删除考生信息，该字段为0时代表删除）
        ("byRes", BYTE * 126),
    ]


LPNET_DVR_EXAMINEE_INFO_CFG = POINTER(NET_DVR_EXAMINEE_INFO_CFG)


class NET_DVR_EXAMINEE_INFO_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byExamineeNo", BYTE * NET_SDK_MAX_EXAMINEE_NO), # 考生编号
        ("byExamRoundNo", BYTE * NET_SDK_MAX_EXAM_ROUND_NO), # 考试场次编号（某堂具体考试）
        ("byStatus", BYTE), # 下发状态：0-无效，1-失败，2-成功（代表该考生信息下发是否成功）
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_EXAMINEE_INFO_STATUS = POINTER(NET_DVR_EXAMINEE_INFO_STATUS)


class NET_DVR_EXAM_COMPARE_RESULT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byExamRoundNo", BYTE * NET_SDK_MAX_EXAM_ROUND_NO), # 考试场次编号（某堂具体考试）
        ("byExamNo", BYTE * NET_SDK_MAX_EXAM_NO), # 考试编号（某次考试，包含多场考试）
        ("struStartTime", NET_DVR_TIME), # 开始时间
        ("struEndTime", NET_DVR_TIME), # 结束时间
        ("byRes", BYTE * 512),
    ]


LPNET_DVR_EXAM_COMPARE_RESULT_COND = POINTER(NET_DVR_EXAM_COMPARE_RESULT_COND)


class NET_DVR_EXAM_COMPARE_RESULT_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struTime", NET_DVR_TIME), # 时间
        ("byExamineeNo", BYTE * NET_SDK_MAX_EXAMINEE_NO), # 考生编号
        ("byAdmissionTicket", BYTE * NET_SDK_MAX_ADMISSION_TICKET), # 准考证号
        ("byExamNo", BYTE * NET_SDK_MAX_EXAM_NO), # 考试编号（某次考试，包含多场考试）
        ("byExamRoundNo", BYTE * NET_SDK_MAX_EXAM_ROUND_NO), # 考试场次编号（某堂具体考试）
        ("byName", BYTE * NAME_LEN), # 姓名
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 考生关联的卡号
        ("dwPicDataLen", DWORD), # 比对抓拍图片数据大小，不为0是表示后面带数据
        ("*pPicData", CHAR), # 比对抓拍图片指针
        ("byRes", BYTE * 256),
    ]


LPNET_DVR_EXAM_COMPARE_RESULT_CFG = POINTER(NET_DVR_EXAM_COMPARE_RESULT_CFG)


class NET_DVR_BLACK_LIST_PICTURE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPictureNum", DWORD), # 图片数量
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_BLACK_LIST_PICTURE_COND = POINTER(NET_DVR_BLACK_LIST_PICTURE_COND)


class NET_DVR_BLACK_LIST_PICTURE_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("byStatus", BYTE), # 状态：0-无效，，1-处理中，2-上传失败，3-成功
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_BLACK_LIST_PICTURE_STATUS = POINTER(NET_DVR_BLACK_LIST_PICTURE_STATUS)


class NET_DVR_BLACK_LIST_PICTURE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 卡号
        ("byName", BYTE * NAME_LEN), # 姓名
        ("bySex", BYTE), # 性别：0-无效，1-男，2-女
        ("byPictureValid", BYTE), # 黑名单图片是否有效：0-无效，1-有效（用于按卡号删除黑名单图片，该字段为0时代表删除，删除时不传递黑名单图片）
        ("byRes1", BYTE * 2),
        ("dwPictureLen", DWORD), # 黑名单图片长度（图片大小不超过1M）
        ("pPictureBuffer", CHARP), # 黑名单图片指针
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_BLACK_LIST_PICTURE_CFG = POINTER(NET_DVR_BLACK_LIST_PICTURE_CFG)


class NET_DVR_UPLOAD_ID_BLACK_LIST_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwBlackListNum", DWORD), # 黑名单数量
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_UPLOAD_ID_BLACK_LIST_COND = POINTER(NET_DVR_UPLOAD_ID_BLACK_LIST_COND)


class NET_DVR_UPLOAD_ID_BLACK_LIST_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struIDCardCfg", NET_DVR_ID_CARD_INFO), # 身份证信息（该结构体中姓名和身份证号码为必填项，其他字段为选填项）
        ("byBlackListValid", BYTE), # 身份证黑名单是否有效：0-无效，1-有效（用于按身份证号码删除身份证黑名单，该字段为0时代表删除）
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_UPLOAD_ID_BLACK_LIST_CFG = POINTER(NET_DVR_UPLOAD_ID_BLACK_LIST_CFG)


class NET_DVR_UPLOAD_ID_BLACK_LIST_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byIDNum", BYTE * MAX_ID_NUM_LEN), # 身份证号码
        ("byStatus", BYTE), # 状态：0-无效，1-处理中，2-上传失败，3-成功
        ("byRes", BYTE * 63),
    ]


LPNET_DVR_UPLOAD_ID_BLACK_LIST_STATUS = POINTER(NET_DVR_UPLOAD_ID_BLACK_LIST_STATUS)


class NET_DVR_ALARM_ISAPI_INFO(Structure):
    _fields_ = [
        ("*", CHAR), #  报警数据
        ("dwAlarmDataLen", DWORD), #  报警数据长度
        ("byDataType", BYTE), #  0-invalid,1-xml,2-json
        ("byPicturesNumber", BYTE), #  图片数量
        ("byRes", BYTE * 2),
        ("*", void), #  图片变长部分
        ("byRes1", BYTE * 32),
    ]


LPNET_DVR_ALARM_ISAPI_INFO = POINTER(NET_DVR_ALARM_ISAPI_INFO)


class NET_DVR_ALARM_ISAPI_PICDATA(Structure):
    _fields_ = [
        ("dwPicLen", DWORD),
        ("byPicType", BYTE), # 图片格式: 1- jpg
        ("byRes", BYTE * 3),
        ("szFilename", CHAR * MAX_FILE_PATH_LEN),
        ("*pPicData", BYTE),
    ]


LPNET_DVR_ALARM_ISAPI_PICDATA = POINTER(NET_DVR_ALARM_ISAPI_PICDATA)


class NET_DVR_FORMAT_HDD(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体长度
        ("dwDiskNo", DWORD), # 硬盘号，从0开始，0xff表示对所有硬盘有效（不包括只读硬盘）
        ("struLocateIP", NET_DVR_IPADDR), # 该硬盘所在设备的IP（对应硬盘管理参数V50中获取到的szHDLocateIP信息）
        ("byRes", BYTE * 16),
    ]


LPNET_DVR_FORMAT_HDD = POINTER(NET_DVR_FORMAT_HDD)


class NET_DVR_CHECK_FACE_PICTURE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPictureNum", DWORD), # 图片数量
        ("byCheckTemplate", BYTE), # 0-校验图片是否合法（默认），1-校验图片和建模数据是否匹配
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_CHECK_FACE_PICTURE_COND = POINTER(NET_DVR_CHECK_FACE_PICTURE_COND)


class NET_DVR_CHECK_FACE_PICTURE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPictureNo", DWORD), # 图片编号
        ("dwPictureLen", DWORD), # 图片长度（图片大小不超过200k）
        ("pPictureBuffer", CHARP), # 图片指针
        ("dwFaceTemplateLen", DWORD), # 人脸建模数据长度
        ("pFaceTemplateBuffer", CHARP), # 人脸建模数据指针
        ("byRes", BYTE * 248),
    ]


LPNET_DVR_CHECK_FACE_PICTURE_CFG = POINTER(NET_DVR_CHECK_FACE_PICTURE_CFG)


class NET_DVR_CHECK_FACE_PICTURE_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwPictureNo", DWORD), # 图片编号
        ("byCheckStatus", BYTE), # 校验结果：0-无效，1-建模成功，2-建模失败，3-人脸模块通讯异常，4-图像无人脸，5-人脸朝上，6-人脸朝下，7-人脸偏左，8-人脸偏右，9-人脸顺时旋转，
        # 10 - 人脸逆时旋转，11-人眼间距小，12-人脸和模板匹配，13-人脸和模板不匹配,14-传输数据有误
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_CHECK_FACE_PICTURE_STATUS = POINTER(NET_DVR_CHECK_FACE_PICTURE_STATUS)


class NET_SDK_NPQ_STATE_SINGLE(Structure):
    _fields_ = [
        ("dwRttUs", DWORD), # rtt，单位us
        ("dwRealRttUs", DWORD), # 实时rtt，单位us
        ("dwBitRate", DWORD), # 码率，单位bps
        ("byLossFraction", BYTE), # 丢包率，单位1/256
        ("byLossFraction2", BYTE), # 经过恢复之后的丢包率，只能在接收端获取，单位1/256
        ("byRes", BYTE * 126),
    ]


LPNET_SDK_NPQ_STATE_SINGLE = POINTER(NET_SDK_NPQ_STATE_SINGLE)


class NET_SDK_NPQ_STATE(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struAudioState", NET_SDK_NPQ_STATE_SINGLE), # 音频传输状态
        ("struVideoState", NET_SDK_NPQ_STATE_SINGLE), # 视频传输状态
        ("byRes", BYTE * 256),
    ]


LPNET_SDK_NPQ_STATE = POINTER(NET_SDK_NPQ_STATE)


class NET_SDK_NPQ_NOTIFY_PARAM(Structure):
    _fields_ = [
        ("iVersion", LONG), # 结构体版本，用于以后兼容
        ("dwBitRate", DWORD), # 码率 单位bps
        ("bHaveBitrate", BOOL), # 码率字段是否有效标志
        ("bHaveForceIframe", BOOL), # 强制I帧字段是否有效标志
        ("bForceIframe", BOOL), # 强制I帧
        ("bHaveScale", BOOL), # scale字段是否有效标志,回放时此字段无效,请通过SDK快放接口实现
        ("fScale", float), # scale信息  1、2、4、8,回放时此字段无效,请通过SDK快放接口实现
        ("res", BYTE * 240),
    ]


LPNET_SDK_NPQ_NOTIFY_PARAM = POINTER(NET_SDK_NPQ_NOTIFY_PARAM)


# 报警信息查询条件结构体
class NET_DVR_ALARM_SEARCH_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("strStartTime", NET_DVR_TIME_SEARCH_COND), # 开始时间,时间为空则代表不通过时间筛选。
        ("strStopTime", NET_DVR_TIME_SEARCH_COND), # 结束时间, 时间为空则代表不通过时间筛选。
        #
        # 报警命令，该字段值与报警布防类型相同，目前支持：
        # COMM_VCA_ALARM 	0x4993  智能检测报警
        # COMM_UPLOAD_FACESNAP_RESULT    0x1112  人脸识别结果上传
        # COMM_SNAP_MATCH_ALAR    0x2902  人脸比对结果上传
        #
        ("dwAlarmComm", DWORD), # 若该命令为空这代表不进行报警命令过滤。
        ("sAlarmUID", CHAR * 64), # UID标识（上传报警时设备返回的UID标识，64字节的长度，可以使用时间（精确到毫秒）加上随即数的方式组成）,为空则代表不区分UID
        ("wEventType", WORD), # 事件类型，仅dwAlarmComm为COMM_VCA_ALARM 0x4993  智能检测报警有效，0-表示所有事件,1-混合目标检测（mixedTargetDetection）,2-雷视目标检测（radarVideoDetection）
        ("wSubEventType", WORD), # 子事件类型，0-表示所有子事件，其余值根据wEventType的取值变化而变化，具体参见能力集。
        ("bySupport", BYTE), # 保留
        ("byRes", BYTE * 123),
    ]


LPNET_DVR_ALARM_SEARCH_COND = POINTER(NET_DVR_ALARM_SEARCH_COND)


# 报警信息查询结果结构体
class NET_DVR_ALARM_SEARCH_RESULT(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        #
        # 报警命令，该字段值与报警布防类型相同，目前支持：
        # COMM_VCA_ALARM 	0x4993    智能检测报警
        # COMM_UPLOAD_FACESNAP_RESULT    0x1112  人脸识别结果上传
        # COMM_SNAP_MATCH_ALARM   0x2902 人脸比对结果上传
        #
        ("dwAlarmComm", DWORD),
        #
        # 报警信息，该字段值与报警信息相同，目前支持：
        # 当COMM_VCA_ALARM时，该报警信息为JSON报文
        # 当COMM_UPLOAD_FACESNAP_RESULT时，该报警信息为NET_VCA_FACESNAP_RESULT
        # 当COMM_SNAP_MATCH_ALARM时，该报警信息为NET_VCA_FACESNAP_MATCH_ALARM
        #
        ("dwAlarmLen", DWORD), # 报警信息，即pAlarmInfo指针指向的数据长度
        ("*pAlarmInfo", CHAR),
        ("struAlarmer", NET_DVR_ALARMER),
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_ALARM_SEARCH_RESULT = POINTER(NET_DVR_ALARM_SEARCH_RESULT)


class NET_DVR_FACE_AND_TEMPLATE_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号（设置时该参数不设置）
        ("dwFaceNum", DWORD), # 设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
        ("byRes", BYTE * 128), # 保留
    ]


LPNET_DVR_FACE_AND_TEMPLATE_COND = POINTER(NET_DVR_FACE_AND_TEMPLATE_COND)


class NET_DVR_FACE_AND_TEMPLATE_CFG(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号
        ("dwFaceLen", DWORD), # 人脸图片长度（图片大小不超过200k）
        ("pFaceBuffer", CHARP), # 人脸图片指针
        ("dwFaceTemplateLen", DWORD), # 人脸建模数据长度
        ("pFaceTemplateBuffer", CHARP), # 人脸建模数据指针
        ("byRes", BYTE * 116),
    ]


LPNET_DVR_FACE_AND_TEMPLATE_CFG = POINTER(NET_DVR_FACE_AND_TEMPLATE_CFG)


class NET_DVR_FACE_AND_TEMPLATE_STATUS(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN), # 人脸关联的卡号
        ("byRecvStatus", BYTE), # 人脸下发状态，按字节表示，0-失败，1-成功，2-内存已满（人脸数据满）
        ("byRes", BYTE * 131),
    ]


LPNET_DVR_FACE_AND_TEMPLATE_STATUS = POINTER(NET_DVR_FACE_AND_TEMPLATE_STATUS)


class NET_DVR_SINGLE_HEATMAP_RESULT_PDC(Structure):
    _fields_ = [
        ("dwMaxHeatMapValue", DWORD), # 最大热度值
        ("dwMinHeatMapValue", DWORD), # 最小热度值
        ("dwTimeHeatMapValue", DWORD), #  (时间热度值)平均热度值
        ("wArrayLine", WORD), # 图片像素点行值
        ("wArrayColumn", WORD), # 图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）
        ("pBuffer", BYTE*), # 热度图片像素点数据信息
        ("byRes", BYTE * 32),
    ]


LPNET_DVR_SINGLE_HEATMAP_RESULT_PDC = POINTER(NET_DVR_SINGLE_HEATMAP_RESULT_PDC)


# 热度图报警上传
class NET_DVR_HEATMAP_RESULT_PDC(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("struStartTime", NET_DVR_TIME_EX), # 开始时间
        ("struEndTime", NET_DVR_TIME_EX), # 结束时间
        ("struDevInfo", NET_VCA_DEV_INFO), # 设备信息
        ("wDevInfoIvmsChannelEx", WORD), # 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
        ("byBrokenNetHttp", BYTE), # 断网续传标志位，0-不是重传数据，1-重传数据
        ("byArrayUnitType", BYTE), # 矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型）,1-byte, 2-short,4- int
        #
        # struSingleHeatMap[0]:表示按人数统计中的画面中停留人数的热度值；
        # struSingleHeatMap[1]:表示按人数统计中的画面中离开人数的热度值；
        #
        ("struSingleHeatMap", NET_DVR_SINGLE_HEATMAP_RESULT_PDC * 2),
        ("wCurNumber", WORD), # 当前人数
        ("wLeaveNumber", WORD), # 离开人数
        ("byRes1", BYTE * 60),
    ]


LPNET_DVR_HEATMAP_RESULT_PDC = POINTER(NET_DVR_HEATMAP_RESULT_PDC)


# 设备支持AI开放平台接入，上传视频检测数据
# 设备支持AI开放平台接入，上传图片检测数据
MAX_FILE_NAME_LEN		100 =  # 最大文件名长
class NET_DVR_DOOR_FILE_UPLOAD_PARAM(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFileSize", DWORD), # 文件大小，单位：字节
        ("byFileName", BYTE * MAX_FILE_NAME_LEN), # 文件名称
        ("byRes1", BYTE * 256),
    ]


LPNET_DVR_DOOR_FILE_UPLOAD_PARAM = POINTER(NET_DVR_DOOR_FILE_UPLOAD_PARAM)


AUDIO_FILE_NAME_LEN = 32 # 音频文件名称长度
# 上传音频控制文件
class NET_DVR_TRANS_AUDIO_INFO(Structure):
    _fields_ = [
        ("dwSize", DWORD), # 结构体大小
        ("sAudioName", CHAR * AUDIO_FILE_NAME_LEN), # 音频文件名称
        ("byAudioFormat", BYTE), # 音频数据格式：0-wav
        ("byRes", BYTE * 127),
    ]


LPNET_DVR_TRANS_AUDIO_INFO = POINTER(NET_DVR_TRANS_AUDIO_INFO)


class NET_DVR_AI_ALGORITHM_MODEL(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwDescribeLength", DWORD), # AlgorithmModel 文件长度
        ("pDescribeBuffer", CHARP), # AlgorithmModel文件
        ("byRes1", BYTE * 3), # 保留字节，使四字节对齐
        ("dwLicenseKeyLength", DWORD), # licenseKey文件长度
        ("pLicenseKeyBuffer", CHARP), # licenseKey文件
        ("byRes", BYTE * 120),
    ]


LPNET_DVR_AI_ALGORITHM_MODEL = POINTER(NET_DVR_AI_ALGORITHM_MODEL)


class NET_DVR_AI_PICTUR_UPLOAD(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szTaskID", CHAR * 64), # 任务id，strlen.max = 64,业务平台统一维护管理
        ("szPID", CHAR * 64), # 图片id，strlen.max = 64，业务平台统一维护管理
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_AI_PICTUR_UPLOAD = POINTER(NET_DVR_AI_PICTUR_UPLOAD)


class NET_DVR_FINGERPRINT_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("dwFingerprintNum", DWORD),
        ("byCardNo", BYTE * ACS_CARD_NO_LEN),
        ("dwEnableReaderNo", DWORD),
        ("byFingerPrintID", BYTE),
        ("byRes", BYTE * 131),
    ]


LPNET_DVR_FINGERPRINT_COND = POINTER(NET_DVR_FINGERPRINT_COND)


class NET_DVR_CAPTURE_DATA_COND(Structure):
    _fields_ = [
        ("dwSize", DWORD),
        ("szPassword", CHAR * 128), # 秘钥，字符串
        ("byRes", BYTE * 128),
    ]


LPNET_DVR_CAPTURE_DATA_COND = POINTER(NET_DVR_CAPTURE_DATA_COND)


EZVIZ_CLASSSESSION_LEN = 64
EZVIZ_DEVICEID_LEN = 32
class NET_DVR_EZVIZ_USER_LOGIN_INFO(Structure):
    _fields_ = [
        ("sEzvizServerAddress", CHAR * NET_DVR_DEV_ADDRESS_MAX_LEN), # 云服务器地址
        ("wPort", WORD), # 云服务器端口
        ("byLogin", BYTE),
        ("byRes1", BYTE * 1),
        ("sClassSession", CHAR * EZVIZ_CLASSSESSION_LEN), # ClassSession, 服务器分配的一个字符串，每次通信时需要发送给服务器
        ("sDeviceID", CHAR * EZVIZ_DEVICEID_LEN), # 设备ID， 由服务器分配的
        ("byRes2", BYTE * 128),
    ]


LPNET_DVR_EZVIZ_USER_LOGIN_INFO = POINTER(NET_DVR_EZVIZ_USER_LOGIN_INFO)


EZVIZ_REQURL_LEN = 64
EZVIZ_ACCESSTOKEN_LEN = 128
EZVIZ_CLIENTTYPE_LEN = 32
EZVIZ_FEATURECODE_LEN = 64
EZVIZ_OSVERSION_LEN = 32
EZVIZ_NETTYPE_LEN = 32
EZVIZ_SDKVERSION_LEN = 32
EZVIZ_APPID_LEN = 64
class NET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO(Structure):
    _fields_ = [
        ("sEzvizServerAddress", CHAR * NET_DVR_DEV_ADDRESS_MAX_LEN), # 云服务器地址
        ("byRes1", BYTE * 3),
        ("wPort", WORD), # 云服务器端口
        ("byRes2", BYTE * 2),
        ("sUrl", CHAR * EZVIZ_REQURL_LEN),
        ("sAccessToken", CHAR * EZVIZ_ACCESSTOKEN_LEN), # accessToken, 服务器分配的一个字符串，每次通信时需要发送给服务器
        ("sDeviceID", CHAR * EZVIZ_DEVICEID_LEN), # 设备ID， 由服务器分配的
        ("sClientType", CHAR * EZVIZ_CLIENTTYPE_LEN), # 客户端类型: 0: PC-控件 1: ios 2: android
        ("sFeatureCode", CHAR * EZVIZ_FEATURECODE_LEN), # 硬件特征码
        ("sOsVersion", CHAR * EZVIZ_OSVERSION_LEN), # 终端系统版本, 例如: IOS 7.0.4, Android 2.3.
        ("sNetType", CHAR * EZVIZ_NETTYPE_LEN), # 网络类型, UNKNOWN GPRS EDGE UMTS HSDPA HSUPA HSPA CDMAEVDO_0 EVDO_A EVDO_B 1xRTT IDEN WIFI
        ("sSdkVersion", CHAR * EZVIZ_SDKVERSION_LEN), # Sdk版本号, v.1.0.20140720.45xx
        ("sAppID", CHAR * EZVIZ_APPID_LEN), # AppID，ios上报BundleID，Android上报包名
        ("byRes3", BYTE * 512),
    ]


LPNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO = POINTER(NET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO)


PLAYCTRL = 0
DSSDK = 1
STREAMCONVERT = 2
STREAMTRANS = 3
QOSSDK = 4
DLL_PATH_AUDIO = 5
EZVIZ_SSL_SDK = 6
ANALYZE_DATA_LIB = 7
DLL_LIBICONV = 8
SSLEAY32_SDK = 9
LIBEAY32_SDK = 10
HCNETUTILS_SDK = 11
NPQ_LIB = 12
LOAD_DLL_COUNT = 13

























